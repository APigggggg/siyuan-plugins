(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode("#option[data-v-6911afe5] {\r\n    display: grid;\r\n    align-items: center;\r\n    min-height: 30px;\n}\n#content[data-v-6911afe5] {\r\n    display: flex;\r\n    justify-content: space-between;\n}\r\n\n#option[data-v-465f3d4a] {\r\n    display: grid;\r\n    align-items: center;\r\n    min-height: 30px;\n}\n#content[data-v-465f3d4a] {\r\n    display: flex;\r\n    justify-content: space-between;\n}\r\n\n.option[data-v-1c0ece5c] {\n  font-size: 1.1em;\n  font-weight: 600;\n  margin: 5px 0px 0px;\n}\n.menu[data-v-1c0ece5c] {\n  color: var(--b3-theme-on-background);\n  background-color: var(--b3-menu-background);\n  margin: 1px;\n  padding: 10px 20px;\n  /* 添加边框 */\n  border: 1px solid var(--b3-theme-surface-lighter);;\n  border-radius: 3px;\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const siyuan = require("siyuan");
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const EMPTY_OBJ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
const EMPTY_ARR = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$1(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn$1(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = process.env.NODE_ENV !== "production" ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (process.env.NODE_ENV !== "production" && activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = process.env.NODE_ENV !== "production" ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (process.env.NODE_ENV !== "production" && effect.onTrigger) {
      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow$1(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = process.env.NODE_ENV !== "production" ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (process.env.NODE_ENV !== "production") {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ]);
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow$1(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (process.env.NODE_ENV !== "production") {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow$1(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[
      "__v_isReadonly"
      /* ReactiveFlags.IS_READONLY */
    ] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = process.env.NODE_ENV !== "production" ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (process.env.NODE_ENV !== "production" && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn(msg, ...args) {
  if (!(process.env.NODE_ENV !== "production"))
    return;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  [
    "sp"
    /* LifecycleHooks.SERVER_PREFETCH */
  ]: "serverPrefetch hook",
  [
    "bc"
    /* LifecycleHooks.BEFORE_CREATE */
  ]: "beforeCreate hook",
  [
    "c"
    /* LifecycleHooks.CREATED */
  ]: "created hook",
  [
    "bm"
    /* LifecycleHooks.BEFORE_MOUNT */
  ]: "beforeMount hook",
  [
    "m"
    /* LifecycleHooks.MOUNTED */
  ]: "mounted hook",
  [
    "bu"
    /* LifecycleHooks.BEFORE_UPDATE */
  ]: "beforeUpdate hook",
  [
    "u"
    /* LifecycleHooks.UPDATED */
  ]: "updated",
  [
    "bum"
    /* LifecycleHooks.BEFORE_UNMOUNT */
  ]: "beforeUnmount hook",
  [
    "um"
    /* LifecycleHooks.UNMOUNTED */
  ]: "unmounted hook",
  [
    "a"
    /* LifecycleHooks.ACTIVATED */
  ]: "activated hook",
  [
    "da"
    /* LifecycleHooks.DEACTIVATED */
  ]: "deactivated hook",
  [
    "ec"
    /* LifecycleHooks.ERROR_CAPTURED */
  ]: "errorCaptured hook",
  [
    "rtc"
    /* LifecycleHooks.RENDER_TRACKED */
  ]: "renderTracked hook",
  [
    "rtg"
    /* LifecycleHooks.RENDER_TRIGGERED */
  ]: "renderTriggered hook",
  [
    0
    /* ErrorCodes.SETUP_FUNCTION */
  ]: "setup function",
  [
    1
    /* ErrorCodes.RENDER_FUNCTION */
  ]: "render function",
  [
    2
    /* ErrorCodes.WATCH_GETTER */
  ]: "watcher getter",
  [
    3
    /* ErrorCodes.WATCH_CALLBACK */
  ]: "watcher callback",
  [
    4
    /* ErrorCodes.WATCH_CLEANUP */
  ]: "watcher cleanup function",
  [
    5
    /* ErrorCodes.NATIVE_EVENT_HANDLER */
  ]: "native event handler",
  [
    6
    /* ErrorCodes.COMPONENT_EVENT_HANDLER */
  ]: "component event handler",
  [
    7
    /* ErrorCodes.VNODE_HOOK */
  ]: "vnode hook",
  [
    8
    /* ErrorCodes.DIRECTIVE_HOOK */
  ]: "directive hook",
  [
    9
    /* ErrorCodes.TRANSITION_HOOK */
  ]: "transition hook",
  [
    10
    /* ErrorCodes.APP_ERROR_HANDLER */
  ]: "app errorHandler",
  [
    11
    /* ErrorCodes.APP_WARN_HANDLER */
  ]: "app warnHandler",
  [
    12
    /* ErrorCodes.FUNCTION_REF */
  ]: "ref function",
  [
    13
    /* ErrorCodes.ASYNC_COMPONENT_LOADER */
  ]: "async component loader",
  [
    14
    /* ErrorCodes.SCHEDULER */
  ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = process.env.NODE_ENV !== "production" ? ErrorTypeStrings[type] : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (process.env.NODE_ENV !== "production") {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (process.env.NODE_ENV !== "production") {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = process.env.NODE_ENV !== "production" ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (process.env.NODE_ENV !== "production" && check(job)) {
          continue;
        }
        callWithErrorHandling(
          job,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (process.env.NODE_ENV !== "production") {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount", app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* DevtoolsHooks.COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* DevtoolsHooks.COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* DevtoolsHooks.COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* DevtoolsHooks.PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* DevtoolsHooks.PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1("component:emit", component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (process.env.NODE_ENV !== "production") {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (process.env.NODE_ENV !== "production") {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (process.env.NODE_ENV !== "production" && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render2.length > 1 ? render2(props, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render2(
        props,
        null
        /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    handleError(
      err,
      instance,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (process.env.NODE_ENV !== "production" && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (process.env.NODE_ENV !== "production" && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root.transition = vnode.transition;
  }
  if (process.env.NODE_ENV !== "production" && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    if (process.env.NODE_ENV !== "production") {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else if (process.env.NODE_ENV !== "production") {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (process.env.NODE_ENV !== "production" && !isFunction(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  if (process.env.NODE_ENV !== "production" && !cb) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow$1(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(
          s,
          instance,
          2
          /* ErrorCodes.WATCH_GETTER */
        );
      } else {
        process.env.NODE_ENV !== "production" && warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(
        source,
        instance,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    process.env.NODE_ENV !== "production" && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(
        fn,
        instance,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (process.env.NODE_ENV !== "production") {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (process.env.NODE_ENV !== "production") {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
);
const onMounted = createHook(
  "m"
  /* LifecycleHooks.MOUNTED */
);
const onBeforeUpdate = createHook(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
);
const onUpdated = createHook(
  "u"
  /* LifecycleHooks.UPDATED */
);
const onBeforeUnmount = createHook(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
const onUnmounted = createHook(
  "um"
  /* LifecycleHooks.UNMOUNTED */
);
const onServerPrefetch = createHook(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
);
const onRenderTriggered = createHook(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
);
const onRenderTracked = createHook(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const NULL_DYNAMIC_COMPONENT = Symbol();
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (process.env.NODE_ENV !== "production" && key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
        process.env.NODE_ENV !== "production" && markAttrsAccessed();
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (process.env.NODE_ENV !== "production" && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (process.env.NODE_ENV !== "production" && setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
      return false;
    } else {
      if (process.env.NODE_ENV !== "production" && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (process.env.NODE_ENV !== "production" && true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(
      options.beforeCreate,
      instance,
      "bc"
      /* LifecycleHooks.BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = process.env.NODE_ENV !== "production" ? createDuplicateChecker() : null;
  if (process.env.NODE_ENV !== "production") {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (process.env.NODE_ENV !== "production") {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (process.env.NODE_ENV !== "production") {
          checkDuplicateProperties("Methods", key);
        }
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (process.env.NODE_ENV !== "production" && !isFunction(dataOptions)) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (process.env.NODE_ENV !== "production" && isPromise(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject(data)) {
      process.env.NODE_ENV !== "production" && warn(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      if (process.env.NODE_ENV !== "production") {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (process.env.NODE_ENV !== "production" && get2 === NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : process.env.NODE_ENV !== "production" ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (process.env.NODE_ENV !== "production") {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(
      created,
      instance,
      "c"
      /* LifecycleHooks.CREATED */
    );
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        if (process.env.NODE_ENV !== "production") {
          warn(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    if (process.env.NODE_ENV !== "production") {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (process.env.NODE_ENV !== "production") {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      process.env.NODE_ENV !== "production" && warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* BooleanFlags.shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* BooleanFlags.shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (process.env.NODE_ENV !== "production" && !isString(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (process.env.NODE_ENV !== "production" && !isObject(raw)) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* BooleanFlags.shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (process.env.NODE_ENV !== "production" && currentInstance) {
      warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (process.env.NODE_ENV !== "production" && true) {
        warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (process.env.NODE_ENV !== "production" && !isKeepAlive(instance.vnode) && true) {
    warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
        extend(slots, children);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      process.env.NODE_ENV !== "production" && warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (process.env.NODE_ENV !== "production") {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
          process.env.NODE_ENV !== "production" && warn(`Plugin has already been applied to target app.`);
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (process.env.NODE_ENV !== "production") {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (process.env.NODE_ENV !== "production") {
            warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        if (process.env.NODE_ENV !== "production") {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (process.env.NODE_ENV !== "production" && context.components[name]) {
          warn(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (process.env.NODE_ENV !== "production") {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (process.env.NODE_ENV !== "production" && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (process.env.NODE_ENV !== "production" && rootContainer.__vue_app__) {
            warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (process.env.NODE_ENV !== "production") {
            context.reload = () => {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (process.env.NODE_ENV !== "production" || false) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          if (process.env.NODE_ENV !== "production" || false) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (process.env.NODE_ENV !== "production" && key in context.provides) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (process.env.NODE_ENV !== "production" && !owner) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (process.env.NODE_ENV !== "production" && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (process.env.NODE_ENV !== "production" || false) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = process.env.NODE_ENV !== "production" && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (process.env.NODE_ENV !== "production") {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (process.env.NODE_ENV !== "production" && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (process.env.NODE_ENV !== "production") {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (process.env.NODE_ENV !== "production") {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (process.env.NODE_ENV !== "production") {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    if (process.env.NODE_ENV !== "production") {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `render`);
            }
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `render`);
          }
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentUpdated(instance);
        }
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (process.env.NODE_ENV !== "production") {
      effect.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update.ownerInstance = instance;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (process.env.NODE_ENV !== "production" && keyToNewIndexMap.has(nextChild.key)) {
            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(
              nextChild,
              container,
              anchor,
              2
              /* MoveType.REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (process.env.NODE_ENV !== "production" && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (process.env.NODE_ENV !== "production" && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0);
const Text = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0);
const Comment = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0);
const Static = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0);
let currentBlock = null;
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (process.env.NODE_ENV !== "production" && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (process.env.NODE_ENV !== "production" && vnode.key !== vnode.key) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = process.env.NODE_ENV !== "production" ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (process.env.NODE_ENV !== "production" && !type) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (process.env.NODE_ENV !== "production" && shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (process.env.NODE_ENV !== "production") {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (process.env.NODE_ENV !== "production") {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (process.env.NODE_ENV !== "production") {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [process.env.NODE_ENV !== "production" ? shallowReadonly(instance.props) : instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(
            e,
            instance,
            0
            /* ErrorCodes.SETUP_FUNCTION */
          );
        });
      } else {
        instance.asyncDep = setupResult;
        if (process.env.NODE_ENV !== "production" && !instance.suspense) {
          const name = (_a = Component.name) !== null && _a !== void 0 ? _a : "Anonymous";
          warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (process.env.NODE_ENV !== "production" && isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    if (process.env.NODE_ENV !== "production" || false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (process.env.NODE_ENV !== "production") {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (process.env.NODE_ENV !== "production" && setupResult !== void 0) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (process.env.NODE_ENV !== "production" && !Component.render && instance.render === NOOP && !isSSR) {
    if (Component.template) {
      warn(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        /* should not happen */
      );
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, process.env.NODE_ENV !== "production" ? {
    get(target, key) {
      markAttrsAccessed();
      track(instance, "get", "$attrs");
      return target[key];
    },
    set() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (process.env.NODE_ENV !== "production") {
      if (instance.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
      }
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  if (process.env.NODE_ENV !== "production") {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol(process.env.NODE_ENV !== "production" ? `ssrContext` : ``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      process.env.NODE_ENV !== "production" && warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function initCustomFormatter() {
  if (!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
const version = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (process.env.NODE_ENV !== "production") {
      if (semicolonRE.test(val)) {
        warn(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
  !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (process.env.NODE_ENV !== "production" && !needRemove) {
      warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (process.env.NODE_ENV !== "production") {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (process.env.NODE_ENV !== "production" && !res) {
      warn(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (process.env.NODE_ENV !== "production" && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
function initDev() {
  {
    initCustomFormatter();
  }
}
if (process.env.NODE_ENV !== "production") {
  initDev();
}
const Option_vue_vue_type_style_index_0_scoped_6911afe5_lang = "";
const MyButton_vue_vue_type_style_index_0_scoped_465f3d4a_lang = "";
const App_vue_vue_type_style_index_0_scoped_1c0ece5c_lang = "";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "sheet",
  props: {
    beautifulFeature: Array,
    labFeature: Array,
    dangerousFeature: Array
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return null;
    };
  }
});
const labFeatureList = [
  "原生替换"
];
class SettingList {
  constructor() {
    __publicField(this, "setList");
    __publicField(this, "SetDict");
    this.setList = [];
    this.SetDict = {};
  }
  setting(init, name) {
    this.setList.push(init);
    this.SetDict[name] = init;
    return init;
  }
  //返回读取结果后的dict字典，方便保存
  getSetting() {
    let settingKey = Object.keys(this.SetDict);
    let returnDict = {};
    for (let item of settingKey) {
      returnDict[item] = this.SetDict[item].value;
    }
    return returnDict;
  }
}
let settingList = new SettingList();
function addSetting(settingKey, setDict) {
  return {
    content: settingKey,
    status: settingList.setting(
      ref(setDict[settingKey]),
      settingKey
    )
  };
}
function loadSetting(settingDict) {
  let labFeature = [];
  for (let item of labFeatureList) {
    labFeature.push(addSetting(item, settingDict));
  }
  let settingConfig = {
    labFeature
  };
  return settingConfig;
}
function initSetting() {
  let setDict = {};
  for (let item of labFeatureList) {
    setDict[item] = false;
  }
  let settingConfig = loadSetting(setDict);
  return settingConfig;
}
async function getSetting(localConfig) {
  if (!localConfig) {
    return initSetting();
  }
  let setDictText = localConfig;
  let setDict = JSON.parse(setDictText);
  return loadSetting(setDict);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var jqueryExports = {};
var jquery = {
  get exports() {
    return jqueryExports;
  },
  set exports(v) {
    jqueryExports = v;
  }
};
/*!
 * jQuery JavaScript Library v3.6.4
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-03-08T15:28Z
 */
(function(module2) {
  (function(global2, factory) {
    {
      module2.exports = global2.document ? factory(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto2 = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn2 = class2type.hasOwnProperty;
    var fnToString = hasOwn2.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction2 = function isFunction3(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow2(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc2) {
      doc2 = doc2 || document2;
      var i, val, script = doc2.createElement("script");
      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {
          val = node[i] || node.getAttribute && node.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc2.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    var version2 = "3.6.4", jQuery = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version2,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        if (num == null) {
          return slice.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return i % 2;
        }));
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction2(target)) {
        target = {};
      }
      if (i === length) {
        target = this;
        i--;
      }
      for (; i < length; i++) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            copy = options[name];
            if (name === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name];
              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }
              copyIsArray = false;
              target[name] = jQuery.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto2(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(code, options, doc2) {
        DOMEval(code, { nonce: options && options.nonce }, doc2);
      },
      each: function(obj, callback) {
        var length, i = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // results is for internal usage only
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike(Object(arr2))) {
            jQuery.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i) {
        return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function(first, second) {
        var len = +second.length, j = 0, i = first.length;
        for (; j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i < length; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      }
    );
    function isArrayLike(obj) {
      var length = !!obj && "length" in obj && obj.length, type = toType(obj);
      if (isFunction2(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = (
      /*!
       * Sizzle CSS Selector Engine v2.3.10
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://js.foundation/
       *
       * Date: 2023-02-14
       */
      function(window3) {
        var i, support2, Expr, getText, isXML, tokenize, compile2, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, hasOwn3 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
          var i2 = 0, len = list.length;
          for (; i2 < len; i2++) {
            if (list[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 65536;
          return nonHex ? (
            // Strip the backslash prefix from a non-hex escape sequence
            nonHex
          ) : (
            // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
          );
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "�";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
          },
          { dir: "parentNode", next: "legend" }
        );
        try {
          push2.apply(
            arr2 = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: arr2.length ? (
              // Leverage slice if possible
              function(target, els) {
                pushNative.apply(target, slice2.call(els));
              }
            ) : (
              // Support: IE<9
              // Otherwise append directly
              function(target, els) {
                var j = target.length, i2 = 0;
                while (target[j++] = els[i2++]) {
                }
                target.length = j - 1;
              }
            )
          };
        }
        function Sizzle2(selector, context, results, seed) {
          var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
              // Exclude object elements
              (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext !== context || !support2.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = nid.replace(rcssescape, fcssescape);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim2, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr3 = attrs.split("|"), i2 = arr3.length;
          while (i2--) {
            Expr.attrHandle[arr3[i2]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
          if (diff) {
            return diff;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                /* jshint -W018 */
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j = matchIndexes[i2]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support2 = Sizzle2.support = {};
        isXML = Sizzle2.isXML = function(elem) {
          var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
        };
        setDocument = Sizzle2.setDocument = function(node) {
          var hasCompare, subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
          if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
            return document3;
          }
          document3 = doc2;
          docElem = document3.documentElement;
          documentIsHTML = !isXML(document3);
          if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            if (subWindow.addEventListener) {
              subWindow.addEventListener("unload", unloadHandler, false);
            } else if (subWindow.attachEvent) {
              subWindow.attachEvent("onunload", unloadHandler);
            }
          }
          support2.scope = assert(function(el) {
            docElem.appendChild(el).appendChild(document3.createElement("div"));
            return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
          });
          support2.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          });
          support2.attributes = assert(function(el) {
            el.className = "i";
            return !el.getAttribute("className");
          });
          support2.getElementsByTagName = assert(function(el) {
            el.appendChild(document3.createComment(""));
            return !el.getElementsByTagName("*").length;
          });
          support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
          support2.getById = assert(function(el) {
            docElem.appendChild(el).id = expando;
            return !document3.getElementsByName || !document3.getElementsByName(expando).length;
          });
          if (support2.getById) {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i2, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support2.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if (support2.qsa = rnative.test(document3.querySelectorAll)) {
            assert(function(el) {
              var input;
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
              if (el.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              el.querySelectorAll("\\\f");
              rbuggyQSA.push("[\\r\\n\\f]");
            });
            assert(function(el) {
              el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              if (el.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
              }
              if (el.querySelectorAll(":enabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              docElem.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              el.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function(el) {
              support2.disconnectedMatch = matches.call(el, "*");
              matches.call(el, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          if (!support2.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
            if (!aup || !bup) {
              return a == document3 ? -1 : b == document3 ? 1 : (
                /* eslint-enable eqeqeq */
                aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0
              );
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? (
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck(ap[i2], bp[i2])
            ) : (
              // Otherwise nodes in our document sort first
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              /* eslint-disable eqeqeq */
              ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : (
                /* eslint-enable eqeqeq */
                0
              )
            );
          };
          return document3;
        };
        Sizzle2.matches = function(expr, elements) {
          return Sizzle2(expr, null, null, elements);
        };
        Sizzle2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return Sizzle2(expr, document3, null, [elem]).length > 0;
        };
        Sizzle2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle2.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn3.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle2.escape = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support2.detectDuplicates;
          sortInput = !support2.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle2.getText = function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle2.selectors = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                Sizzle2.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(
                className,
                function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                }
              );
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle2.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf2(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function(selector) {
              var input = [], results = [], matcher = compile2(selector.replace(rtrim2, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle2(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || getText(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            "target": function(elem) {
              var hash = window3.location && window3.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            "enabled": createDisabledPseudo(false),
            "disabled": createDisabledPseudo(true),
            "checked": function(elem) {
              var nodeName2 = elem.nodeName.toLowerCase();
              return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            // Element/input types
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrim2, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle2(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
              postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              )
            ) : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf2(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i2 > 1 && elementMatcher(matchers),
                  i2 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                  ).replace(rtrim2, "$1"),
                  matcher,
                  i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                  j < len && matcherFromTokens(tokens = tokens.slice(j)),
                  j < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile2 = Sizzle2.compile = function(selector, match) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i2 = match.length;
            while (i2--) {
              cached = matcherFromTokens(match[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle2.select = function(selector, context, results, seed) {
          var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find = Expr.find[type]) {
                if (seed = find(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile2(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        };
        support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support2.detectDuplicates = !!hasDuplicate;
        setDocument();
        support2.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        if (!assert(function(el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML2) {
            if (!isXML2) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support2.attributes || !assert(function(el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, _name, isXML2) {
            if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(el) {
          return el.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML2) {
            var val;
            if (!isXML2) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle2;
      }(window2)
    );
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction2(qualifier)) {
        return jQuery.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function(elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery.fn.extend({
      find: function(selector) {
        var i, ret, len = this.length, self2 = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self2[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery.find(selector, self2[i], ret);
        }
        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root = root || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document2,
              true
            ));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (isFunction2(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction2(selector)) {
        return root.ready !== void 0 ? root.ready(selector) : (
          // Execute immediately if ready is not present
          selector(jQuery)
        );
      }
      return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function(target) {
        var targets = jQuery(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
              ))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        }
        return indexOf.call(
          this,
          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem
        );
      },
      add: function(selector, context) {
        return this.pushStack(
          jQuery.uniqueSort(
            jQuery.merge(this.get(), jQuery(selector, context))
          )
        );
      },
      addBack: function(selector) {
        return this.add(
          selector == null ? this.prevObject : this.prevObject.filter(selector)
        );
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery.each({
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto2(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery.merge([], elem.childNodes);
      }
    }, function(name, fn) {
      jQuery.fn[name] = function(until, selector) {
        var matched = jQuery.map(this, fn, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          }
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
      var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue2.length; firingIndex = -1) {
          memory = queue2.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue2.push(memory);
            }
            (function add2(args) {
              jQuery.each(args, function(_, arg) {
                if (isFunction2(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add2(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          jQuery.each(arguments, function(_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue2 = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue2 = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue2.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
      var method;
      try {
        if (value && isFunction2(method = value.promise)) {
          method.call(value).done(resolve).fail(reject);
        } else if (value && isFunction2(method = value.then)) {
          method.call(value, resolve, reject);
        } else {
          resolve.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject.apply(void 0, [value2]);
      }
    }
    jQuery.extend({
      Deferred: function(func) {
        var tuples = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(_i, tuple) {
                var fn = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction2(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](
                      this,
                      fn ? [returned] : arguments
                    );
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred2, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction2(then)) {
                    if (special) {
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special)
                      );
                    } else {
                      maxDepth++;
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special),
                        resolve(
                          maxDepth,
                          deferred2,
                          Identity,
                          deferred2.notifyWith
                        )
                      );
                    }
                  } else {
                    if (handler !== Identity) {
                      that = void 0;
                      args = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args);
                  }
                }, process2 = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(
                        e,
                        process2.stackTrace
                      );
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = void 0;
                        args = [e];
                      }
                      deferred2.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process2();
                } else {
                  if (jQuery.Deferred.getStackHook) {
                    process2.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window2.setTimeout(process2);
                }
              };
            }
            return jQuery.Deferred(function(newDefer) {
              tuples[0][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onProgress) ? onProgress : Identity,
                  newDefer.notifyWith
                )
              );
              tuples[1][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onFulfilled) ? onFulfilled : Identity
                )
              );
              tuples[2][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onRejected) ? onRejected : Thrower
                )
              );
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery.each(tuples, function(i, tuple) {
          var list = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(
              function() {
                state = stateString;
              },
              // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable,
              // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable,
              // progress_callbacks.lock
              tuples[0][2].lock,
              // progress_handlers.lock
              tuples[0][3].lock
            );
          }
          list.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      // Deferred helper
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
          return function(value) {
            resolveContexts[i2] = this;
            resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(
            singleValue,
            primary.done(updateFunc(i)).resolve,
            primary.reject,
            !remaining
          );
          if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack2) {
      if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
        window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack2);
      }
    };
    jQuery.readyException = function(error) {
      window2.setTimeout(function() {
        throw error;
      });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error) {
        jQuery.readyException(error);
      });
      return this;
    };
    jQuery.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function(wait) {
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }
        jQuery.isReady = true;
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction2(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, _key, value2) {
              return bulk.call(jQuery(elem), value2);
            };
          }
        }
        if (fn) {
          for (; i < len; i++) {
            fn(
              elems[i],
              key,
              raw ? value : value.call(elems[i], i, fn(elems[i], key))
            );
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data, value) {
        var prop, cache = this.cache(owner);
        if (typeof data === "string") {
          cache[camelCase(data)] = value;
        } else {
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === void 0 ? this.cache(owner) : (
          // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)]
        );
      },
      access: function(owner, key, value) {
        if (key === void 0 || key && typeof key === "string" && value === void 0) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== void 0 ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key !== void 0) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === void 0 || jQuery.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
      if (data === "true") {
        return true;
      }
      if (data === "false") {
        return false;
      }
      if (data === "null") {
        return null;
      }
      if (data === +data + "") {
        return +data;
      }
      if (rbrace.test(data)) {
        return JSON.parse(data);
      }
      return data;
    }
    function dataAttr(elem, key, data) {
      var name;
      if (data === void 0 && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);
        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {
          }
          dataUser.set(elem, key, data);
        } else {
          data = void 0;
        }
      }
      return data;
    }
    jQuery.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function(elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function(elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function(elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function(key, value) {
        var i, name, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name = attrs[i].name;
                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value2) {
          var data2;
          if (elem && value2 === void 0) {
            data2 = dataUser.get(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            data2 = dataAttr(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function(elem, type, data) {
        var queue2;
        if (elem) {
          type = (type || "fx") + "queue";
          queue2 = dataPriv.get(elem, type);
          if (data) {
            if (!queue2 || Array.isArray(data)) {
              queue2 = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue2.push(data);
            }
          }
          return queue2 || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue2 = jQuery.queue(elem, type), startLength = queue2.length, fn = queue2.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
          jQuery.dequeue(elem, type);
        };
        if (fn === "inprogress") {
          fn = queue2.shift();
          startLength--;
        }
        if (fn) {
          if (type === "fx") {
            queue2.unshift("inprogress");
          }
          delete hooks.stop;
          fn.call(elem, next, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }
        return data === void 0 ? this : this.each(function() {
          var queue2 = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" && queue2[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(type, obj) {
        var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached = function(elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc2.body.appendChild(doc2.createElement(nodeName2));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values = [], index = 0, length = elements.length;
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;
            if (!values[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }
      return elements;
    }
    jQuery.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (; i < l; i++) {
        dataPriv.set(
          elems[i],
          "globalEval",
          !refElements || dataPriv.get(refElements[i], "globalEval")
        );
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function expectSync(elem, type) {
      return elem === safeActiveElement() === (type === "focus");
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on(elem, types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = void 0;
        }
        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }
        return elem;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = void 0;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = void 0;
        } else {
          fn = data;
          data = selector;
          selector = void 0;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    jQuery.event = {
      global: {},
      add: function(elem, types, handler, data, selector) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        }
        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery.event.special[type] || {};
          handleObj = jQuery.extend({
            type,
            origType,
            data,
            handler,
            guid: handler.guid,
            selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction2(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", returnTrue);
            }
            return false;
          },
          trigger: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function(event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type, expectSync2) {
      if (!expectSync2) {
        if (dataPriv.get(el, type) === void 0) {
          jQuery.event.add(el, type, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type, false);
      jQuery.event.add(el, type, {
        namespace: false,
        handler: function(event) {
          var notAsync, result, saved = dataPriv.get(this, type);
          if (event.isTrigger & 1 && this[type]) {
            if (!saved.length) {
              saved = slice.call(arguments);
              dataPriv.set(this, type, saved);
              notAsync = expectSync2(this, type);
              this[type]();
              result = dataPriv.get(this, type);
              if (saved !== result || notAsync) {
                dataPriv.set(this, type, false);
              } else {
                result = {};
              }
              if (saved !== result) {
                event.stopImmediatePropagation();
                event.preventDefault();
                return result && result.value;
              }
            } else if ((jQuery.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }
          } else if (saved.length) {
            dataPriv.set(this, type, {
              value: jQuery.event.trigger(
                // Support: IE <=9 - 11+
                // Extend with the prototype to reset the above stopImmediatePropagation()
                jQuery.extend(saved[0], jQuery.Event.prototype),
                saved.slice(1),
                this
              )
            });
            event.stopImmediatePropagation();
          }
        }
      });
    }
    jQuery.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery.Event = function(src, props) {
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
      jQuery.event.special[type] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function() {
          leverageNative(this, type, expectSync);
          return false;
        },
        trigger: function() {
          leverageNative(this, type);
          return true;
        },
        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function(event) {
          return dataPriv.get(event.target, type);
        },
        delegateType
      };
    });
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function(types, selector, fn) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(
            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn = selector;
          selector = void 0;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;
        if (events) {
          dataPriv.remove(dest, "handle events");
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = flat(args);
      var fragment, first, scripts, hasScripts, node, doc2, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction2(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self2 = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i], node, i);
          }
          if (hasScripts) {
            doc2 = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc2, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery._evalUrl && !node.noModule) {
                    jQuery._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc2);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove2(elem, selector, keepData) {
      var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          destElements = getAll(clone);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        }
        destElements = getAll(clone, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone;
      },
      cleanData: function(elems) {
        var data, elem, type, special = jQuery.event.special, i = 0;
        for (; (elem = elems[i]) !== void 0; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type);
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function(selector) {
        return remove2(this, selector, true);
      },
      remove: function(selector) {
        return remove2(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery.htmlPrefilter(value2);
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent = this.parentNode;
          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name, original) {
      jQuery.fn[name] = function(selector) {
        var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.call(elem);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name, computed2) {
      var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
      computed2 = computed2 || getStyles(elem);
      if (computed2) {
        ret = computed2.getPropertyValue(name) || computed2[name];
        if (isCustomProp && ret) {
          ret = ret.replace(rtrimCSS, "$1") || void 0;
        }
        if (ret === "" && !isAttached(elem)) {
          ret = jQuery.style(elem, name);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed2.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== void 0 ? (
        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + ""
      ) : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name) {
      var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
      while (i--) {
        name = cssPrefixes[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }
    function finalPropName(name) {
      var final = jQuery.cssProps[name] || vendorProps[name];
      if (final) {
        return final;
      }
      if (name in emptyStyle) {
        return name;
      }
      return vendorProps[name] = vendorPropName(name) || name;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
      var matches = rcssNum.exec(value);
      return matches ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
      ) : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i < 4; i += 2) {
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
        }
        if (!isBorderBox) {
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          }
          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }
      return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
      elem.getClientRects().length) {
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(
        elem,
        dimension,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles,
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
      ) + "px";
    }
    jQuery.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(elem, computed2) {
            if (computed2) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function(elem, name, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name];
        }
      },
      css: function(elem, name, extra, styles) {
        var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name, styles);
        }
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery.each(["height", "width"], function(_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function(elem, computed2, extra) {
          if (computed2) {
            return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles
          ) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
            );
          }
          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(
      support.reliableMarginLeft,
      function(elem, computed2) {
        if (computed2) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }
    );
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function(name, value) {
        return access(this, function(elem, name2, value2) {
          var styles, len, map2 = {}, i = 0;
          if (Array.isArray(name2)) {
            styles = getStyles(elem);
            len = name2.length;
            for (; i < len; i++) {
              map2[name2[i]] = jQuery.css(elem, name2[i], false, styles);
            }
            return map2;
          }
          return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
        }, name, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](
            percent,
            this.options.duration * percent,
            0,
            1,
            this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function(p2) {
        return p2;
      },
      swing: function(p2) {
        return 0.5 - Math.cos(p2 * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery.fx.interval);
        }
        jQuery.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = { height: type };
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }
      propTween = !jQuery.isEmptyObject(props);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks;
      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }
        if (index !== name) {
          props[name] = value;
          delete props[index];
        }
        hooks = jQuery.cssHooks[name];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name];
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
        for (; index2 < length2; index2++) {
          animation.tweens[index2].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        }
        if (!length2) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction2(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery.map(props, createTween, animation);
      if (isFunction2(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(
        jQuery.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );
      return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props, callback) {
        if (isFunction2(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index = 0, length = props.length;
        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery.speed = function(speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction2(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction2(easing) && easing
      };
      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction2(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue2 ? queue2.length : 0;
          data.finish = true;
          jQuery.queue(this, type, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue2[index] && queue2[index].finish) {
              queue2[index].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function(_i, name) {
      var cssFn = jQuery.fn[name];
      jQuery.fn[name] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    });
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name, props) {
      jQuery.fn[name] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
      var timer, i = 0, timers = jQuery.timers;
      fxNow = Date.now();
      for (; i < timers.length; i++) {
        timer = timers[i];
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery.fx.timer = function(timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery.fx.stop = function() {
      inProgress = null;
    };
    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    };
    jQuery.fn.delay = function(time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks) {
        var timeout = window2.setTimeout(next, time);
        hooks.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function(name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function(name) {
        return this.each(function() {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        ret = jQuery.find.attr(elem, name);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name) {
        if (value === false) {
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }
        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;
      attrHandle[name] = function(elem, name2, isXML) {
        var ret, handle, lowercaseName = name2.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function(name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function(name) {
        return this.each(function() {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }
        if (value !== void 0) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          return elem[name] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function(elem) {
          var parent = elem.parentNode;
          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery.fn.extend({
      addClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      removeClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (isFunction2(value)) {
          return this.each(function(i2) {
            jQuery(this).toggleClass(
              value.call(this, i2, getClass(this), stateVal),
              stateVal
            );
          });
        }
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        classNames = classesToArray(value);
        return this.each(function() {
          if (isValidValue) {
            self2 = jQuery(this);
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute(
                "class",
                className || value === false ? "" : dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i = 0;
        className = " " + selector + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function(value) {
        var hooks, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction2(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : (
              // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem))
            );
          }
        },
        select: {
          get: function(elem) {
            var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            }
            for (; i < max; i++) {
              option = options[i];
              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                value = jQuery(option).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
            while (i--) {
              option = options[i];
              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });
    jQuery.each(["radio", "checkbox"], function() {
      jQuery.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window2;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
      trigger: function(event, data, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn2.call(event, "type") ? event.type : event, namespaces = hasOwn2.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [event] : jQuery.makeArray(data, [event]);
        special = jQuery.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function(type, elem, event) {
        var e = jQuery.extend(
          new jQuery.Event(),
          event,
          {
            type,
            isSimulated: true
          }
        );
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function(type, data) {
        return this.each(function() {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
        var handler = function(event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
          setup: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix);
            if (!attaches) {
              doc2.addEventListener(orig, handler, true);
            }
            dataPriv.access(doc2, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix) - 1;
            if (!attaches) {
              doc2.removeEventListener(orig, handler, true);
              dataPriv.remove(doc2, fix);
            } else {
              dataPriv.access(doc2, fix, attaches);
            }
          }
        };
      });
    }
    var location = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery.parseXML = function(data) {
      var xml, parserErrorElem;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        xml = new window2.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
      }
      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data));
      }
      return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add2) {
      var name;
      if (Array.isArray(obj)) {
        jQuery.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix)) {
            add2(prefix, v);
          } else {
            buildParams(
              prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
              v,
              traditional,
              add2
            );
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
        }
      } else {
        add2(prefix, obj);
      }
    }
    jQuery.param = function(a, traditional) {
      var prefix, s = [], add2 = function(key, valueOrFunction) {
        var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a == null) {
        return "";
      }
      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        jQuery.each(a, function() {
          add2(this.name, this.value);
        });
      } else {
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add2);
        }
      }
      return s.join("&");
    };
    jQuery.fn.extend({
      serialize: function() {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(_i, elem) {
          var val = jQuery(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction2(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(target, settings) {
        return settings ? (
          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
        ) : (
          // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target)
        );
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function(url, options) {
        if (typeof url === "object") {
          options = url;
          url = void 0;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                }
              }
              match = responseHeaders[key.toLowerCase() + " "];
            }
            return match == null ? null : match.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function(name, value) {
            if (completed2 == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (completed2 == null) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function(map2) {
            var code;
            if (map2) {
              if (completed2) {
                jqXHR.always(map2[jqXHR.status]);
              } else {
                for (code in map2) {
                  statusCode[code] = [statusCode[code], map2[code]];
                }
              }
            }
            return this;
          },
          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery.event && s.global;
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader(
          "Accept",
          s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
        );
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed2 = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (completed2) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(
              isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s, isSuccess ? success : error]
            );
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery.get(url, void 0, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function(_i, method) {
      jQuery[method] = function(url, data, callback, type) {
        if (isFunction2(data)) {
          type = type || callback;
          callback = data;
          data = void 0;
        }
        return jQuery.ajax(jQuery.extend({
          url,
          type: method,
          dataType: type,
          data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });
    jQuery.ajaxPrefilter(function(s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });
    jQuery._evalUrl = function(url, options, doc2) {
      return jQuery.ajax({
        url,
        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery.globalEval(response, options, doc2);
        }
      });
    };
    jQuery.fn.extend({
      wrapAll: function(html) {
        var wrap;
        if (this[0]) {
          if (isFunction2(html)) {
            html = html.call(this[0]);
          }
          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction2(html)) {
          return this.each(function(i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self2 = jQuery(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction2(html);
        return this.each(function(i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    };
    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(
                        // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status,
                        xhr.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr.status] || xhr.status,
                      xhr.statusText,
                      // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                      xhr.getAllResponseHeaders()
                    );
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== void 0) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });
    jQuery.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery.ajaxTransport("script", function(s) {
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function(_, complete) {
            script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction2(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction2(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function(data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document2.implementation.createHTMLDocument("");
          base = context.createElement("base");
          base.href = document2.location.href;
          context.head.appendChild(base);
        } else {
          context = document2;
        }
      }
      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data], context, scripts);
      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function(url, params, callback) {
      var selector, type, response, self2 = this, off = url.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }
      if (isFunction2(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery.ajax({
          url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? (
            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
          ) : (
            // Otherwise use the full result
            responseText
          ));
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
      return jQuery.grep(jQuery.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction2(options)) {
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery.css(elem, "position") === "fixed") {
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset();
          doc2 = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc2.documentElement;
          while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
      var top = "pageYOffset" === prop;
      jQuery.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method2];
          }
          if (win) {
            win.scrollTo(
              !top ? val2 : win.pageXOffset,
              top ? val2 : win.pageYOffset
            );
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery.each(["top", "left"], function(_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(
        support.pixelPosition,
        function(elem, computed2) {
          if (computed2) {
            computed2 = curCSS(elem, prop);
            return rnumnonpx.test(computed2) ? jQuery(elem).position()[prop] + "px" : computed2;
          }
        }
      );
    });
    jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function(defaultExtra, funcName) {
        jQuery.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc2;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            }
            if (elem.nodeType === 9) {
              doc2 = elem.documentElement;
              return Math.max(
                elem.body["scroll" + name],
                doc2["scroll" + name],
                elem.body["offset" + name],
                doc2["offset" + name],
                doc2["client" + name]
              );
            }
            return value2 === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery.css(elem, type2, extra)
            ) : (
              // Set width or height on the element
              jQuery.style(elem, type2, value2, extra)
            );
          }, type, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type) {
      jQuery.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    });
    jQuery.fn.extend({
      bind: function(types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function(types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function(selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function(selector, types, fn) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(_i, name) {
        jQuery.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      }
    );
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    jQuery.proxy = function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!isFunction2(fn)) {
        return void 0;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };
    jQuery.holdReady = function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction2;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "$1");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery.noConflict = function(deep) {
      if (window2.$ === jQuery) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery) {
        window2.jQuery = _jQuery;
      }
      return jQuery;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery;
    }
    return jQuery;
  });
})(jquery);
const $ = jqueryExports;
const currentLayout = $("body");
function renderMathLive(naiveDom, originMathBlock, debug = false) {
  initVitrualKeyboard();
  var textBlock = document.querySelector(".block__popover--move");
  var latexBlock = document.querySelector(".block__popover--move > textarea");
  if (!textBlock || !latexBlock) {
    console.log("renderMathLive 初始化获得输入框元素错误！");
    console.log(`textBlock ${textBlock} ||  latexBlock ${latexBlock} `);
    return;
  }
  if (debug === true) {
    console.log("renderMathLive 初始化获得输入框元素成功！");
    console.log(`textBlock ${textBlock} ||  latexBlock ${latexBlock} `);
  }
  var dyBlock = document.createElement("div");
  dyBlock.id = "mathEnhanceDyBlock";
  var keyboardBlock = initkeyboardBlock();
  var MathLiveBlock = initMathLiveBlock(latexBlock);
  if (naiveDom === true) {
    console.log("启动原生渲染！");
    dyBlock.appendChild(MathLiveBlock);
  } else {
    dyBlock.appendChild(MathLiveBlock);
  }
  textBlock.appendChild(dyBlock);
  textBlock.appendChild(keyboardBlock);
  addMathLiveListener(latexBlock, MathLiveBlock);
}
function addMathLiveListener(latexBlock, MathLiveBlock) {
  var tempLatex = MathLiveBlock.value;
  var liveCall = false;
  let evt = new Event("input", {
    bubbles: true,
    cancelable: true
  });
  MathLiveBlock.addEventListener("input", () => {
    var expendLatex = MathLiveBlock.getValue("latex-expanded");
    latexBlock.value = expendLatex.replace(/\{\\textcolor\{#6495ed\}\{(.+?)\}\}/g, "\\mark{$1}").replace(/\\textcolor\{#6495ed\}\{(.+?)\}/g, "\\mark{$1}");
    if (tempLatex === MathLiveBlock.value) {
      tempLatex = MathLiveBlock.value;
      return;
    }
    tempLatex = MathLiveBlock.value;
    liveCall = true;
    latexBlock.dispatchEvent(evt);
  });
  latexBlock.addEventListener(
    "input",
    (ev) => {
      if (liveCall === true) {
        liveCall = false;
        return;
      }
      MathLiveBlock.setValue(latexBlock.value, { suppressChangeNotifications: true });
    }
  );
}
function initMathLiveBlock(latexBlock) {
  var mathLiveBlock = document.createElement("math-field");
  mathLiveBlock.style.width = "-webkit-fill-available";
  mathLiveBlock.value = latexBlock.value;
  mathLiveBlock.macros = {
    ...mathLiveBlock.macros,
    mark: {
      args: 1,
      def: "{\\color{#6495ed}#1}",
      captureSelection: false
    }
  };
  return mathLiveBlock;
}
function initkeyboardBlock() {
  var keyboardBlock = document.createElement("div");
  keyboardBlock.style.height = "auto";
  mathVirtualKeyboard.container = keyboardBlock;
  return keyboardBlock;
}
function initStyle() {
  var mathlive_css = document.createElement("style");
  mathlive_css.innerHTML = `
#mathlive-popover-panel{
    z-index: 200;
}
.ML__keyboard.is-visible{
    height: calc(var(--keyboard-height) + 10px);
}
`;
  document.body.appendChild(mathlive_css);
  document.body.style.setProperty("--keycap-height", "3em");
  document.body.style.setProperty("--keycap-font-size", "1.2em");
}
function initMathLive() {
  initStyle();
  currentLayout.on("mouseup", '[data-subtype="math"]', initMathLiveRender);
}
function initMathLiveRender(event) {
  event.target;
  setTimeout(() => {
    renderMathLive(false);
  }, 10);
}
function initVitrualKeyboard() {
  mathVirtualKeyboard.layouts[0].layers[0].markup = `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='x-var'><i>x</i></li>
    <li class='MLK__keycap MLK__tex' data-variants='n-var'><i>n</i></li>
    <li class='separator w5'></li>
    <row name='numpad-1'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='exponentialE' data-variants='ee'>e</li>
    <li class='MLK__keycap MLK__tex' data-latex='imaginaryI' data-variants='ii'>i</li>
    <li class='MLK__keycap MLK__tex' data-latex='pi' data-variants='numeric-pi'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-key='<' data-variants='<'>&lt;</li>
    <li class='MLK__keycap MLK__tex' data-key='>' data-variants='>'>&gt;</li>
    <li class='separator w5'></li>
    <row name='numpad-2'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='#@^{2}' data-latex='x^2'></li>
    <li class='MLK__keycap MLK__tex' data-variants='^' data-insert='#@^{#?}' data-latex='x^placeholder'></li>
    <li class='MLK__keycap MLK__tex small' data-insert='sqrt{#0}' data-latex='sqrt{#0}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='(' >(</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' >)</li>
    <li class='separator w5'></li>
    <row name='numpad-3'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap small' data-variants='int' data-latex='int_0^infty'></li>
    <li class='MLK__keycap' data-latex='\forall' data-variants='logic' ></li>
    <li class='action font-glyph bottom right' data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  </ul>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"#6495ed"}]'><span style='color:#6495ed'>[...]</span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>
    <li class='separator w5'></li>
    <row name='numpad-4'/>
    <li class='separator w5'></li>
    <arrows/>
  </ul>
</div>
    `;
}
function removeMathLive() {
  currentLayout.off("mouseup", '[data-subtype="math"]', initMathLiveRender);
  var dyBlock = document.querySelector("#mathEnhanceDyBlock");
  dyBlock == null ? void 0 : dyBlock.remove();
}
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.MathLive = {}));
})(globalThis, function(exports2) {
  var MathLive = (() => {
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp2(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp2(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
    var mathlive_exports = {};
    __export(mathlive_exports, {
      MathfieldElement: () => MathfieldElement,
      autoRenderMathInElement: () => autoRenderMathInElement,
      convertAsciiMathToLatex: () => convertAsciiMathToLatex,
      convertLatexToAsciiMath: () => convertLatexToAsciiMath,
      convertLatexToMarkup: () => convertLatexToMarkup,
      convertLatexToMathMl: () => convertLatexToMathMl,
      convertLatexToSpeakableText: () => convertLatexToSpeakableText,
      debug: () => debug,
      globalMathLive: () => globalMathLive,
      makeSharedVirtualKeyboard: () => makeSharedVirtualKeyboard,
      renderMathInDocument: () => renderMathInDocument,
      renderMathInElement: () => renderMathInElement,
      serializeMathJsonToLatex: () => serializeMathJsonToLatex,
      validateLatex: () => validateLatex2,
      version: () => version3
    });
    function isArray2(x) {
      return Array.isArray(x);
    }
    var STRINGS = {
      en: {
        "keyboard.tooltip.functions": "Functions",
        "keyboard.tooltip.symbols": "Symbols",
        "keyboard.tooltip.greek": "Greek Letters",
        "keyboard.tooltip.command": "LaTeX Command Mode",
        "keyboard.tooltip.numeric": "Numeric",
        "keyboard.tooltip.alphabetic": "Roman Letters",
        "tooltip.copy to clipboard": "Copy to Clipboard",
        "tooltip.cut to clipboard": "Cut to Clipboard",
        "tooltip.paste from clipboard": "Paste from Clipboard",
        "tooltip.redo": "Redo",
        "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard",
        "tooltip.undo": "Undo",
        "menu.insert matrix": "Insert Matrix",
        "menu.insert vector": "Insert Vector",
        "submenu.array.matrix delimiters": "Matrix Delimiters",
        "menu.array.add row above": "Add Row After",
        "menu.array.add row below": "Add Row Before",
        "menu.array.add column after": "Add Column After",
        "menu.array.add column before": "Add Column Before",
        "menu.array.delete row": "Delete Row",
        "menu.array.delete rows": "Delete Selected Rows",
        "menu.array.delete column": "Delete Column",
        "menu.array.delete columns": "Delete Selected Columns",
        "submenu.array.insert separator": "Insert Separator",
        "menu.insert table": "Insert Table",
        "submenu.table style": "Table Style"
      },
      // Arabic
      ar: {
        "keyboard.tooltip.functions": "مهام",
        "keyboard.tooltip.symbols": "حرف او رمز",
        "keyboard.tooltip.greek": "حروف يونانية",
        "keyboard.tooltip.command": "حالة تلقي الأوامر اللاتك",
        "keyboard.tooltip.numeric": "الرقمية",
        "keyboard.tooltip.alphabetic": "رموز الاحرف الرومانية",
        "tooltip.copy to clipboard": "نسخ إلى الحافظة",
        "tooltip.redo": "الإعادة",
        "tooltip.toggle virtual keyboard": "تبديل لوحة المفاتيح الإفتراضية",
        "tooltip.undo": "إلغاء",
        "menu.insert matrix": "أدخل المصفوفة",
        "menu.insert vector": "أدخل متجه",
        "submenu.array.matrix delimiters": "محددات المصفوفة",
        "menu.array.add row above": "أضف صفًا بعد ذلك",
        "menu.array.add row below": "أضف الصف قبل",
        "menu.array.add column after": "أضف العمود بعد ذلك",
        "menu.array.add column before": "أضف العمود قبل",
        "menu.array.delete row": "احذف صف",
        "menu.array.delete rows": "حذف الصفوف المحددة",
        "menu.array.delete column": "حذف العمود",
        "menu.array.delete columns": "حذف الأعمدة المحددة",
        "submenu.array.insert separator": "أدخل فاصل",
        "menu.insert table": "إدراج جدول",
        "submenu.table style": "نمط الجدول"
      },
      //Bulgarian
      bg: {
        "keyboard.tooltip.functions": "Функции",
        "keyboard.tooltip.symbols": "Символи",
        "keyboard.tooltip.greek": "Гръцки букви",
        "keyboard.tooltip.command": "Команден режим на латекс",
        "keyboard.tooltip.numeric": "Числови",
        "keyboard.tooltip.alphabetic": "Римски букви",
        "tooltip.copy to clipboard": "Копиране в клипборда",
        "tooltip.redo": "Повторно",
        "tooltip.toggle virtual keyboard": "Превключване на виртуална клавиатура",
        "tooltip.undo": "Отмяна",
        "menu.insert matrix": "Вмъкване на матрица",
        "menu.insert vector": "Вмъкване на вектор",
        "submenu.array.matrix delimiters": "Матрични разделители",
        "menu.array.add row above": "Добавяне на ред след",
        "menu.array.add row below": "Добавяне на ред преди",
        "menu.array.add column after": "Добавяне на колона след",
        "menu.array.add column before": "Добавяне на колона преди",
        "menu.array.delete row": "Изтриване на реда",
        "menu.array.delete rows": "Изтриване на избраните редове",
        "menu.array.delete column": "Изтриване на колона",
        "menu.array.delete columns": "Изтриване на избраните колони",
        "submenu.array.insert separator": "Поставете разделител",
        "menu.insert table": "Вмъкване на таблица",
        "submenu.table style": "Табличен стил"
      },
      // Bosnian
      bs: {
        "keyboard.tooltip.functions": "Funkcije",
        "keyboard.tooltip.symbols": "Simboli",
        "keyboard.tooltip.greek": "Grčka slova",
        "keyboard.tooltip.command": "LaTeX naredbeni način",
        "keyboard.tooltip.numeric": "Numerički",
        "keyboard.tooltip.alphabetic": "Rimska slova",
        "tooltip.copy to clipboard": "Kopirati u clipboard",
        "tooltip.redo": "Ponovi",
        "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
        "tooltip.undo": "Poništi",
        "menu.insert matrix": "Umetni matricu",
        "menu.insert vector": "Umetni vektor",
        "submenu.array.matrix delimiters": "Matrični razdjelnici",
        "menu.array.add row above": "Dodaj redak nakon",
        "menu.array.add row below": "Dodaj red prije",
        "menu.array.add column after": "Dodaj stupac nakon",
        "menu.array.add column before": "Dodaj stupac prije",
        "menu.array.delete row": "Izbriši red",
        "menu.array.delete rows": "Izbriši odabrane redove",
        "menu.array.delete column": "Izbriši stupac",
        "menu.array.delete columns": "Izbriši odabrane stupce",
        "submenu.array.insert separator": "Umetni separator",
        "menu.insert table": "Ubaci tabelu",
        "submenu.table style": "Stil tabele"
      },
      // Czech
      cs: {
        "keyboard.tooltip.functions": "Funkce",
        "keyboard.tooltip.symbols": "Symboly",
        "keyboard.tooltip.greek": "Řecké dopisy",
        "keyboard.tooltip.command": "Příkazový režim LaTeX",
        "keyboard.tooltip.numeric": "Číselné",
        "keyboard.tooltip.alphabetic": "Římské dopisy",
        "tooltip.copy to clipboard": "Zkopírovat do schránky",
        "tooltip.redo": "Předělat",
        "tooltip.toggle virtual keyboard": "Přepnout virtuální klávesnici",
        "tooltip.undo": "Vrátit",
        "menu.insert matrix": "Vložte matici",
        "menu.insert vector": "Vložit vektor",
        "submenu.array.matrix delimiters": "Oddělovače matic",
        "menu.array.add row above": "Přidat řádek za",
        "menu.array.add row below": "Přidat řádek před",
        "menu.array.add column after": "Přidat sloupec za",
        "menu.array.add column before": "Přidat sloupec dříve",
        "menu.array.delete row": "Odstranit řádek",
        "menu.array.delete rows": "Odstranit vybrané řádky",
        "menu.array.delete column": "Odstranit sloupec",
        "menu.array.delete columns": "Odstranit vybrané sloupce",
        "submenu.array.insert separator": "Vložte oddělovač",
        "menu.insert table": "Vložit tabulku",
        "submenu.table style": "Styl tabulky"
      },
      // Dannish
      da: {
        "keyboard.tooltip.functions": "Funktioner",
        "keyboard.tooltip.symbols": "Symboler",
        "keyboard.tooltip.greek": "Græske bogstaver",
        "keyboard.tooltip.command": "LaTeX kommandotilstand",
        "keyboard.tooltip.numeric": "Numerisk",
        "keyboard.tooltip.alphabetic": "Romerske breve",
        "tooltip.copy to clipboard": "Kopier til udklipsholder",
        "tooltip.redo": "Gentag igen",
        "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur",
        "tooltip.undo": "Fortryd",
        "menu.insert matrix": "Indsæt matrix",
        "menu.insert vector": "Indsæt vektor",
        "submenu.array.matrix delimiters": "Matrixafgrænsere",
        "menu.array.add row above": "Tilføj række efter",
        "menu.array.add row below": "Tilføj række før",
        "menu.array.add column after": "Tilføj kolonne efter",
        "menu.array.add column before": "Tilføj kolonne før",
        "menu.array.delete row": "Slet række",
        "menu.array.delete rows": "Slet valgte rækker",
        "menu.array.delete column": "Slet kolonne",
        "menu.array.delete columns": "Slet valgte kolonner",
        "submenu.array.insert separator": "Indsæt separator",
        "menu.insert table": "Indsæt tabel",
        "submenu.table style": "Tabelstil"
      },
      // German
      de: {
        "keyboard.tooltip.functions": "Funktionen",
        "keyboard.tooltip.symbols": "Symbole",
        "keyboard.tooltip.greek": "Griechische Buchstaben",
        "keyboard.tooltip.command": "LaTeX-Befehlsmodus",
        "keyboard.tooltip.numeric": "Numerisch",
        "keyboard.tooltip.alphabetic": "Römische Buchstaben",
        "tooltip.copy to clipboard": "In die Zwischenablage kopieren",
        "tooltip.redo": "Wiederholen",
        "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten",
        "tooltip.undo": "Widerrufen",
        "menu.insert matrix": "Matrix einfügen",
        "menu.insert vector": "Vektor einfügen",
        "submenu.array.matrix delimiters": "Matrixtrennzeichen",
        "menu.array.add row above": "Zeile hinzufügen nach",
        "menu.array.add row below": "Zeile hinzufügen vor",
        "menu.array.add column after": "Spalte hinzufügen nach",
        "menu.array.add column before": "Spalte hinzufügen vor",
        "menu.array.delete row": "Zeile löschen",
        "menu.array.delete rows": "Ausgewählte Zeilen löschen",
        "menu.array.delete column": "Spalte löschen",
        "menu.array.delete columns": "Ausgewählte Spalten löschen",
        "submenu.array.insert separator": "Trennzeichen einfügen",
        "menu.insert table": "Tabelle einfügen",
        "submenu.table style": "Tabellenstil"
      },
      // Greek
      el: {
        "keyboard.tooltip.functions": "συναρτήσεις",
        "keyboard.tooltip.symbols": "σύμβολα",
        "keyboard.tooltip.greek": "ελληνικά γράμματα",
        "keyboard.tooltip.command": "Λειτουργία εντολών LaTeX",
        "keyboard.tooltip.numeric": "Αριθμητικός",
        "keyboard.tooltip.alphabetic": "Ρωμαϊκά γράμματα",
        "tooltip.copy to clipboard": "Αντιγραφή στο πρόχειρο",
        "tooltip.redo": "Ξανακάνω",
        "tooltip.toggle virtual keyboard": "Εναλλαγή εικονικού πληκτρολογίου",
        "tooltip.undo": "Ξεκάνω",
        "menu.insert matrix": "Εισαγωγή Matrix",
        "menu.insert vector": "Εισαγωγή διανύσματος",
        "submenu.array.matrix delimiters": "Οριοθέτες Matrix",
        "menu.array.add row above": "Προσθήκη σειράς μετά",
        "menu.array.add row below": "Προσθήκη σειράς πριν",
        "menu.array.add column after": "Προσθήκη στήλης μετά",
        "menu.array.add column before": "Προσθήκη στήλης πριν",
        "menu.array.delete row": "Διαγραφή σειράς",
        "menu.array.delete rows": "Διαγραφή επιλεγμένων σειρών",
        "menu.array.delete column": "Διαγραφή στήλης",
        "menu.array.delete columns": "Διαγραφή επιλεγμένων στηλών",
        "submenu.array.insert separator": "Εισαγωγή διαχωριστικού",
        "menu.insert table": "Εισαγωγή πίνακα",
        "submenu.table style": "Στυλ πίνακα"
      },
      // Spanish
      es: {
        "keyboard.tooltip.functions": "Funciones",
        "keyboard.tooltip.symbols": "Símbolos",
        "keyboard.tooltip.greek": "Letras griegas",
        "keyboard.tooltip.command": "Modo Comando LaTeX",
        "keyboard.tooltip.numeric": "Numérico",
        "keyboard.tooltip.alphabetic": "Letras romanas",
        "tooltip.copy to clipboard": "Copiar al portapapeles",
        "tooltip.redo": "Rehacer",
        "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
        "tooltip.undo": "Deshacer",
        "menu.insert matrix": "Añadir Matriz",
        "menu.insert vector": "Añadir vector",
        "submenu.array.matrix delimiters": "Delimitadores de Matriz",
        "menu.array.add row above": "Añadir Línea Antes",
        "menu.array.add row below": "Añadir Línea Despues",
        "menu.array.add column after": "Añadir Columna Despues",
        "menu.array.add column before": "Añadir Columna Antes",
        "menu.array.delete row": "Borrar Línea",
        "menu.array.delete rows": "Borrar Líneas Seleccionadas",
        "menu.array.delete column": "Borrar Columna",
        "menu.array.delete columns": "Borrar Columnas Seleccionadas",
        "submenu.array.insert separator": "Insertar un Separador",
        "menu.insert table": "Insertar Tabla",
        "submenu.table style": "Estilo de Tabla"
      },
      // Estonian
      et: {
        "keyboard.tooltip.functions": "Funktsioonid",
        "keyboard.tooltip.symbols": "Sümbolid",
        "keyboard.tooltip.greek": "Kreeka kirjad",
        "keyboard.tooltip.command": "LaTeXi käsurežiim",
        "keyboard.tooltip.numeric": "Numbriline",
        "keyboard.tooltip.alphabetic": "Rooma kirjad",
        "tooltip.copy to clipboard": "Kopeerida lõikelauale",
        "tooltip.redo": "Tee uuesti",
        "tooltip.toggle virtual keyboard": "Lülitage sisse virtuaalne klaviatuur",
        "tooltip.undo": "Võta tagasi",
        "menu.insert matrix": "Sisesta maatriks",
        "menu.insert vector": "Sisesta vektor",
        "submenu.array.matrix delimiters": "Maatriksi eraldajad",
        "menu.array.add row above": "Lisa rida pärast",
        "menu.array.add row below": "Lisa rida enne",
        "menu.array.add column after": "Lisa veerg pärast",
        "menu.array.add column before": "Lisa veerg enne",
        "menu.array.delete row": "Kustuta rida",
        "menu.array.delete rows": "Kustuta valitud read",
        "menu.array.delete column": "Kustuta veerg",
        "menu.array.delete columns": "Kustuta valitud veerud",
        "submenu.array.insert separator": "Sisestage eraldaja",
        "menu.insert table": "Sisesta tabeli",
        "submenu.table style": "Tabeli stiilis"
      },
      // Farsi
      fa: {
        "keyboard.tooltip.functions": "توابع",
        "keyboard.tooltip.symbols": "نمادها",
        "keyboard.tooltip.greek": "حروف یونانی",
        "keyboard.tooltip.command": "حالت دستور لاتک",
        "keyboard.tooltip.numeric": "عددی",
        "keyboard.tooltip.alphabetic": "حروف رومی",
        "tooltip.copy to clipboard": "کپی به کلیپبورد",
        "tooltip.redo": "بازگشت به بعد",
        "tooltip.toggle virtual keyboard": "نمایش/نهفتن کیبورد مجازی",
        "tooltip.undo": "بازگشت به قبل",
        "menu.insert matrix": "ماتریس را وارد کنید",
        "menu.insert vector": "درج بردار",
        "submenu.array.matrix delimiters": "مرزهای ماتریس",
        "menu.array.add row above": "بعد از آن ردیف اضافه کنید",
        "menu.array.add row below": "ردیف را قبل اضافه کنید",
        "menu.array.add column after": "اضافه کردن ستون بعد",
        "menu.array.add column before": "ستون قبل را اضافه کنید",
        "menu.array.delete row": "ردیف را حذف کنید",
        "menu.array.delete rows": "ردیف های انتخاب شده را حذف کنید",
        "menu.array.delete column": "حذف ستون",
        "menu.array.delete columns": "ستون های انتخاب شده را حذف کنید",
        "submenu.array.insert separator": "درج جدا کننده",
        "menu.insert table": "قرار دادن جدول",
        "submenu.table style": "سبک میز"
      },
      // Finnish
      fi: {
        "keyboard.tooltip.functions": "Toiminnot",
        "keyboard.tooltip.symbols": "Symbolit",
        "keyboard.tooltip.greek": "Kreikkalaiset kirjeet",
        "keyboard.tooltip.command": "LaTeX-komentotila",
        "keyboard.tooltip.numeric": "Numeerinen",
        "keyboard.tooltip.alphabetic": "Roomalaiset kirjeet",
        "tooltip.copy to clipboard": "Kopioi leikepöydälle",
        "tooltip.redo": "Tee uudelleen",
        "tooltip.toggle virtual keyboard": "Vaihda virtuaalinäppäimistö",
        "tooltip.undo": "Kumoa",
        "menu.insert matrix": "Lisää matriisi",
        "menu.insert vector": "Lisää vektori",
        "submenu.array.matrix delimiters": "Matriisin erottimet",
        "menu.array.add row above": "Lisää rivi jälkeen",
        "menu.array.add row below": "Lisää rivi ennen",
        "menu.array.add column after": "Lisää sarake jälkeen",
        "menu.array.add column before": "Lisää sarake ennen",
        "menu.array.delete row": "Poista rivi",
        "menu.array.delete rows": "Poista valitut rivit",
        "menu.array.delete column": "Poista sarake",
        "menu.array.delete columns": "Poista valitut sarakkeet",
        "submenu.array.insert separator": "Aseta erotin",
        "menu.insert table": "Lisää taulukko",
        "submenu.table style": "Taulukon tyyli"
      },
      // French
      fr: {
        "keyboard.tooltip.functions": "Fonctions",
        "keyboard.tooltip.symbols": "Symboles",
        "keyboard.tooltip.greek": "Lettres grecques",
        "keyboard.tooltip.command": "Mode de commandes LaTeX",
        "keyboard.tooltip.numeric": "Numérique",
        "keyboard.tooltip.alphabetic": "Lettres romaines",
        "tooltip.copy to clipboard": "Copier dans le presse-papiers",
        "tooltip.redo": "Rétablir",
        "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel",
        "tooltip.undo": "Annuler",
        "menu.insert matrix": "Insérer une Matrice",
        "menu.insert vector": "Insérer un Vecteur",
        "submenu.array.matrix delimiters": "Délimiteurs de la Matrice",
        "menu.array.add row above": "Ajouter une Ligne Avant",
        "menu.array.add row below": "Ajouter une Ligne Après",
        "menu.array.add column before": "Ajouter une Colonne Avant",
        "menu.array.add column after": "Ajouter une Colonne Après",
        "menu.array.delete row": "Enlever une Ligne",
        "menu.array.delete rows": "Enlever les Lignes Sélectionées",
        "menu.array.delete column": "Enlever une Colone",
        "menu.array.delete columns": "Enlever les Colonnes Sélectionées",
        "submenu.array.insert separator": "Insérer un Séparateur",
        "menu.insert table": "Insérer une Table",
        "submenu.table style": "Style de la  Table"
      },
      // Irish
      ga: {
        "keyboard.tooltip.functions": "Feidhmeanna",
        "keyboard.tooltip.symbols": "Siombailí",
        "keyboard.tooltip.greek": "Litreacha na Gréige",
        "keyboard.tooltip.command": "Mód Ordú LaTeX",
        "keyboard.tooltip.numeric": "Uimhriúil",
        "keyboard.tooltip.alphabetic": "Litreacha Rómhánacha",
        "tooltip.copy to clipboard": "Cóipeáil chuig an Ghearrthaisce",
        "tooltip.redo": "Athdhéan",
        "tooltip.toggle virtual keyboard": "Méarchláir Fíorúil a Fháil",
        "tooltip.undo": "Cealaigh",
        "menu.insert matrix": "Cuir isteach Maitrís",
        "menu.insert vector": "Cuir isteach Veicteoir",
        "submenu.array.matrix delimiters": "Delimiters Maitrís",
        "menu.array.add row above": "Cuir Rae Tar éis",
        "menu.array.add row below": "Cuir Rae Roimh",
        "menu.array.add column after": "Cuir Colún Tar éis",
        "menu.array.add column before": "Cuir Colún Roimh",
        "menu.array.delete row": "Scrios Rae",
        "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe",
        "menu.array.delete column": "Scrios Colún",
        "menu.array.delete columns": "Scrios Colúin Roghnaithe",
        "submenu.array.insert separator": "Cuir Deighilteoir isteach",
        "menu.insert table": "Ionsáigh Tábla",
        "submenu.table style": "Stíl Tábla"
      },
      // Hebrew (Israel)
      he: {
        "keyboard.tooltip.functions": "פונקציות",
        "keyboard.tooltip.symbols": "סמלים",
        "keyboard.tooltip.greek": "אותיות יווניות",
        "keyboard.tooltip.command": "מצב פקודה לטקס",
        "keyboard.tooltip.numeric": "מספרי",
        "keyboard.tooltip.alphabetic": "מכתבים רומיים",
        "tooltip.copy to clipboard": "העתק ללוח",
        "tooltip.redo": "לַעֲשׂוֹת שׁוּב",
        "tooltip.toggle virtual keyboard": "החלף את המקלדת הווירטואלית",
        "tooltip.undo": "לבטל",
        "menu.insert matrix": "הכנס מטריקס",
        "menu.insert vector": "הכנס וקטור",
        "submenu.array.matrix delimiters": "מפרידי מטריקס",
        "menu.array.add row above": "הוסף שורה אחרי",
        "menu.array.add row below": "הוסף שורה לפני",
        "menu.array.add column after": "הוסף עמודה אחרי",
        "menu.array.add column before": "הוסף עמודה לפני",
        "menu.array.delete row": "מחק שורה",
        "menu.array.delete rows": "מחק שורות שנבחרו",
        "menu.array.delete column": "מחק עמודה",
        "menu.array.delete columns": "מחק עמודות שנבחרו",
        "submenu.array.insert separator": "הכנס מפריד",
        "menu.insert table": "הכנס טבלה",
        "submenu.table style": "טבלה סִגְנוֹן"
      },
      // Croatian
      hr: {
        "keyboard.tooltip.functions": "Funkcije",
        "keyboard.tooltip.symbols": "Simboli",
        "keyboard.tooltip.greek": "Grčka slova",
        "keyboard.tooltip.command": "LaTeX naredbeni način",
        "keyboard.tooltip.numeric": "Numerički",
        "keyboard.tooltip.alphabetic": "Rimska slova",
        "tooltip.copy to clipboard": "Kopirati u međuspremnik",
        "tooltip.redo": "Ponovi",
        "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu",
        "tooltip.undo": "Poništi",
        "menu.insert matrix": "Umetni matricu",
        "menu.insert vector": "Umetni vektor",
        "submenu.array.matrix delimiters": "Matrični razdjelnici",
        "menu.array.add row above": "Dodaj redak nakon",
        "menu.array.add row below": "Dodaj redak prije",
        "menu.array.add column after": "Dodaj stupac nakon",
        "menu.array.add column before": "Dodaj stupac prije",
        "menu.array.delete row": "Izbriši redak",
        "menu.array.delete rows": "Izbriši odabrane retke",
        "menu.array.delete column": "Izbriši stupac",
        "menu.array.delete columns": "Izbriši odabrane stupce",
        "submenu.array.insert separator": "Umetni separator",
        "menu.insert table": "Umetni tablicu",
        "submenu.table style": "Stil tabele"
      },
      /// Indonesian
      id: {
        "keyboard.tooltip.functions": "Fungsi",
        "keyboard.tooltip.symbols": "Simbol",
        "keyboard.tooltip.greek": "Huruf Yunani",
        "keyboard.tooltip.command": "Mode Perintah LaTeX",
        "keyboard.tooltip.numeric": "Numerik",
        "keyboard.tooltip.alphabetic": "Surat Romawi",
        "tooltip.copy to clipboard": "Menyalin ke clipboard",
        "tooltip.redo": "Mengulangi",
        "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual",
        "tooltip.undo": "Membuka",
        "menu.insert matrix": "Sisipkan Matriks",
        "menu.insert vector": "Sisipkan Vektor",
        "submenu.array.matrix delimiters": "Pembatas Matriks",
        "menu.array.add row above": "Tambahkan Baris Setelah",
        "menu.array.add row below": "Tambahkan Baris Sebelumnya",
        "menu.array.add column after": "Tambahkan Kolom Setelah",
        "menu.array.add column before": "Tambahkan Kolom Sebelumnya",
        "menu.array.delete row": "Hapus Baris",
        "menu.array.delete rows": "Hapus Baris yang Dipilih",
        "menu.array.delete column": "Hapus Kolom",
        "menu.array.delete columns": "Hapus Kolom yang Dipilih",
        "submenu.array.insert separator": "Sisipkan Pemisah",
        "menu.insert table": "Sisipkan Tabel",
        "submenu.table style": "Gaya Tabel"
      },
      // Hindi (India)
      hi: {
        "keyboard.tooltip.functions": "कार्यों",
        "keyboard.tooltip.symbols": "प्रतीक",
        "keyboard.tooltip.greek": "ग्रीक अक्षर",
        "keyboard.tooltip.command": "लाटेक्स कमांड मोड",
        "keyboard.tooltip.numeric": "संख्यात्मक",
        "keyboard.tooltip.alphabetic": "रोमन पत्र",
        "tooltip.copy to clipboard": "क्लिपबोर्ड पर कॉपी करें",
        "tooltip.redo": "फिर से करें",
        "tooltip.toggle virtual keyboard": "वर्चुअल कीबोर्ड टॉगल करें",
        "tooltip.undo": "पूर्ववत",
        "menu.insert matrix": "मैट्रिक्स डालें",
        "menu.insert vector": "वेक्टर डालें",
        "submenu.array.matrix delimiters": "मैट्रिक्स सीमांकक",
        "menu.array.add row above": "बाद में पंक्ति जोड़ें",
        "menu.array.add row below": "पहले पंक्ति जोड़ें",
        "menu.array.add column after": "बाद में कॉलम जोड़ें",
        "menu.array.add column before": "पहले कॉलम जोड़ें",
        "menu.array.delete row": "पंक्ति को हटाएं",
        "menu.array.delete rows": "चयनित पंक्तियों को हटाएं",
        "menu.array.delete column": "कॉलम हटाएं",
        "menu.array.delete columns": "चयनित कॉलम हटाएं",
        "submenu.array.insert separator": "विभाजक डालें",
        "menu.insert table": "टेबल इंसर्ट करें",
        "submenu.table style": "टेबल स्टाइल"
      },
      // Hungarian
      hu: {
        "keyboard.tooltip.functions": "Funkciók",
        "keyboard.tooltip.symbols": "Szimbólumok",
        "keyboard.tooltip.greek": "Görög levelek",
        "keyboard.tooltip.command": "LaTeX Parancs mód",
        "keyboard.tooltip.numeric": "Numerikus",
        "keyboard.tooltip.alphabetic": "Római levelek",
        "tooltip.copy to clipboard": "Másolja a vágólapra",
        "tooltip.redo": "Újra",
        "tooltip.toggle virtual keyboard": "Váltás a virtuális billentyűzetre",
        "tooltip.undo": "Visszavonás",
        "menu.insert matrix": "Helyezze be a Mátrixot",
        "menu.insert vector": "Vektor beszúrása",
        "submenu.array.matrix delimiters": "Mátrixhatárolók",
        "menu.array.add row above": "Sor hozzáadása után",
        "menu.array.add row below": "Add Add Sor előtt",
        "menu.array.add column after": "Oszlop hozzáadása után",
        "menu.array.add column before": "Add oszlop előtt",
        "menu.array.delete row": "Sor törlése",
        "menu.array.delete rows": "Kijelölt sorok törlése",
        "menu.array.delete column": "Oszlop törlése",
        "menu.array.delete columns": "A kijelölt oszlopok törlése",
        "submenu.array.insert separator": "Helyezze be az elválasztót",
        "menu.insert table": "Helyezze be a táblázatot",
        "submenu.table style": "Táblázatos stílus"
      },
      // Italian
      it: {
        "keyboard.tooltip.functions": "Funzioni",
        "keyboard.tooltip.symbols": "Simboli",
        "keyboard.tooltip.greek": "Lettere greche",
        "keyboard.tooltip.command": "Modalità di comando LaTeX",
        "keyboard.tooltip.numeric": "Numerico",
        "keyboard.tooltip.alphabetic": "Lettere romane",
        "tooltip.copy to clipboard": "Copia negli appunti",
        "tooltip.redo": "Rifare",
        "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale",
        "tooltip.undo": "Disfare",
        "menu.insert matrix": "Inserisci una Matrice",
        "menu.insert vector": "Inserisci Vettore",
        "submenu.array.matrix delimiters": "Delimitatori di Matrice",
        "menu.array.add row above": "Aggiungi una Riga Prima",
        "menu.array.add row below": "Aggiungi una Riga Dopo",
        "menu.array.add column before": "Aggiungi una Colonna Prima",
        "menu.array.add column after": "Aggiungi una Colonna Dopo",
        "menu.array.delete row": "Rimuovi una Riga",
        "menu.array.delete rows": "Rimuovi le Righe Selezionate",
        "menu.array.delete column": "Rimuovi una Colonna",
        "menu.array.delete columns": "Rimuovi le Colonne Selezionate",
        "submenu.array.insert separator": "Inserisci un Separatore",
        "menu.insert table": "Inserisci Tabella",
        "submenu.table style": "Stile tabella"
      },
      // Icelandic
      is: {
        "keyboard.tooltip.functions": "Aðgerðir",
        "keyboard.tooltip.symbols": "Tákn",
        "keyboard.tooltip.greek": "Grísk bréf",
        "keyboard.tooltip.command": "LaTeX stjórnunarstilling",
        "keyboard.tooltip.numeric": "Tölulegt",
        "keyboard.tooltip.alphabetic": "Rómversk bréf",
        "tooltip.copy to clipboard": "Afritaðu á klemmuspjald",
        "tooltip.redo": "Endurtaka",
        "tooltip.toggle virtual keyboard": "Skiptu um sýndarlyklaborð",
        "tooltip.undo": "Afturkalla",
        "menu.insert matrix": "Settu fylki inn",
        "menu.insert vector": "Settu inn Vector",
        "submenu.array.matrix delimiters": "Matrix afmörkun",
        "menu.array.add row above": "Bæta við röð á eftir",
        "menu.array.add row below": "Bæta við röð áður",
        "menu.array.add column after": "Bæta við dálki á eftir",
        "menu.array.add column before": "Bæta við dálki áður",
        "menu.array.delete row": "Eyða röð",
        "menu.array.delete rows": "Eyða völdum línum",
        "menu.array.delete column": "Eyða dálki",
        "menu.array.delete columns": "Eyða völdum dálkum",
        "submenu.array.insert separator": "Settu skiljuna í",
        "menu.insert table": "Settu inn töflu",
        "submenu.table style": "Töflu stíl"
      },
      // Japanese
      ja: {
        "keyboard.tooltip.functions": "関数",
        "keyboard.tooltip.symbols": "シンボル",
        "keyboard.tooltip.greek": "ギリシャ文字",
        "keyboard.tooltip.command": "ラテックスコマンドモード",
        "keyboard.tooltip.numeric": "数値",
        "keyboard.tooltip.alphabetic": "ローマ字",
        "tooltip.copy to clipboard": "クリップボードにコピー",
        "tooltip.redo": "やり直し",
        "tooltip.toggle virtual keyboard": "仮想キーボードの切り替え",
        "tooltip.undo": "元に戻す",
        "menu.insert matrix": "マトリックスを挿入",
        "menu.insert vector": "ベクトルを挿入",
        "submenu.array.matrix delimiters": "行列区切り文字",
        "menu.array.add row above": "後に行を追加",
        "menu.array.add row below": "前に行を追加",
        "menu.array.add column after": "後に列を追加",
        "menu.array.add column before": "前に列を追加",
        "menu.array.delete row": "行を削除",
        "menu.array.delete rows": "選択した行を削除する",
        "menu.array.delete column": "列を削除",
        "menu.array.delete columns": "選択した列を削除する",
        "submenu.array.insert separator": "セパレーターを挿入",
        "menu.insert table": "テーブルを挿入",
        "submenu.table style": "テーブルスタイル"
      },
      // Korean
      ko: {
        "keyboard.tooltip.functions": "기능",
        "keyboard.tooltip.symbols": "기호",
        "keyboard.tooltip.greek": "그리스 문자",
        "keyboard.tooltip.command": "유액 명령 모드",
        "keyboard.tooltip.numeric": "숫자",
        "keyboard.tooltip.alphabetic": "로마 문자",
        "tooltip.copy to clipboard": "클립 보드에 복사",
        "tooltip.redo": "다시 하다",
        "tooltip.toggle virtual keyboard": "가상 키보드 전환",
        "tooltip.undo": "실행 취소",
        "menu.insert matrix": "매트릭스 삽입",
        "menu.insert vector": "벡터 삽입",
        "submenu.array.matrix delimiters": "행렬 구분 기호",
        "menu.array.add row above": "뒤에 행 추가",
        "menu.array.add row below": "앞에 행 추가",
        "menu.array.add column after": "뒤에 열 추가",
        "menu.array.add column before": "앞에 열 추가",
        "menu.array.delete row": "행 삭제",
        "menu.array.delete rows": "선택한 행 삭제",
        "menu.array.delete column": "열 삭제",
        "menu.array.delete columns": "선택한 열 삭제",
        "submenu.array.insert separator": "구분자 삽입",
        "menu.insert table": "표 삽입",
        "submenu.table style": "테이블 스타일"
      },
      // Lettish
      lv: {
        "keyboard.tooltip.functions": "Funkcijas",
        "keyboard.tooltip.symbols": "Simboli",
        "keyboard.tooltip.greek": "Grieķu burti",
        "keyboard.tooltip.command": "LaTeX komandu režīms",
        "keyboard.tooltip.numeric": "Ciparu skaitlis",
        "keyboard.tooltip.alphabetic": "Romiešu vēstules",
        "tooltip.copy to clipboard": "Kopēt starpliktuvē",
        "tooltip.redo": "Pārtaisīt",
        "tooltip.toggle virtual keyboard": "Pārslēgt virtuālo tastatūru",
        "tooltip.undo": "Atsaukt",
        "menu.insert matrix": "Ievietojiet matricu",
        "menu.insert vector": "Ievietot vektoru",
        "submenu.array.matrix delimiters": "Matricas norobežotāji",
        "menu.array.add row above": "Pievienot rindu pēc",
        "menu.array.add row below": "Pievienot rindu pirms",
        "menu.array.add column after": "Pievienot kolonnu pēc",
        "menu.array.add column before": "Pievienot kolonnu pirms",
        "menu.array.delete row": "Dzēst rindu",
        "menu.array.delete rows": "Dzēst atlasītās rindas",
        "menu.array.delete column": "Dzēst kolonnu",
        "menu.array.delete columns": "Dzēst atlasītās kolonnas",
        "submenu.array.insert separator": "Ievietojiet atdalītāju",
        "menu.insert table": "Ievietojiet tabulu",
        "submenu.table style": "Galda stils"
      },
      // Lithuanian
      lt: {
        "keyboard.tooltip.functions": "Funkcijos",
        "keyboard.tooltip.symbols": "Simboliai",
        "keyboard.tooltip.greek": "Graikiškos raidės",
        "keyboard.tooltip.command": "LaTeX komandų režimas",
        "keyboard.tooltip.numeric": "Skaitmeninis",
        "keyboard.tooltip.alphabetic": "Romos laiškai",
        "tooltip.copy to clipboard": "Nukopijuoti į iškarpinę",
        "tooltip.redo": "Perdaryti",
        "tooltip.toggle virtual keyboard": "Perjungti virtualiąją klaviatūrą",
        "tooltip.undo": "Atšaukti",
        "menu.insert matrix": "Ievietojiet matricu",
        "menu.insert vector": "Ievietot vektoru",
        "submenu.array.matrix delimiters": "Matricas norobežotāji",
        "menu.array.add row above": "Pievienot rindu pēc",
        "menu.array.add row below": "Pievienot rindu pirms",
        "menu.array.add column after": "Pievienot kolonnu pēc",
        "menu.array.add column before": "Pievienot kolonnu pirms",
        "menu.array.delete row": "Dzēst rindu",
        "menu.array.delete rows": "Dzēst atlasītās rindas",
        "menu.array.delete column": "Dzēst kolonnu",
        "menu.array.delete columns": "Dzēst atlasītās kolonnas",
        "submenu.array.insert separator": "Ievietojiet atdalītāju",
        "menu.insert table": "Ievietojiet tabulu",
        "submenu.table style": "Tabulas stili"
      },
      /// Luxembourgish
      lu: {
        "keyboard.tooltip.functions": "Funktiounen",
        "keyboard.tooltip.symbols": "Symboler",
        "keyboard.tooltip.greek": "Griichesch Bréiwer",
        "keyboard.tooltip.command": "LaTeX Kommando Modus",
        "keyboard.tooltip.numeric": "Numeresch",
        "keyboard.tooltip.alphabetic": "Réimesch Bréiwer",
        "tooltip.copy to clipboard": "Kopéiert op Clipboard",
        "tooltip.redo": "Nees nei maachen",
        "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur",
        "tooltip.undo": "Undoen",
        "menu.insert matrix": "Matrix asetzen",
        "menu.insert vector": "Insert Vector",
        "submenu.array.matrix delimiters": "Matrix Ofgrenzer",
        "menu.array.add row above": "Dobäizemaachen Rei No",
        "menu.array.add row below": "Füügt Rei vir",
        "menu.array.add column after": "Dobäizemaachen Kolonn No",
        "menu.array.add column before": "Kolonn derbäi Virun",
        "menu.array.delete row": "Rad läschen",
        "menu.array.delete rows": "Läscht Ausgewielte Reien",
        "menu.array.delete column": "Läscht Kolonn",
        "menu.array.delete columns": "Läscht Ausgewielte Kolonnen",
        "submenu.array.insert separator": "Insert Separator",
        "menu.insert table": "Dësch anzeginn",
        "submenu.table style": "Dësch Style"
      },
      // Dutch
      nl: {
        "keyboard.tooltip.functions": "Functies",
        "keyboard.tooltip.symbols": "Symbolen",
        "keyboard.tooltip.greek": "Griekse letters",
        "keyboard.tooltip.command": "LaTeX commando mode",
        "keyboard.tooltip.numeric": "Numeriek",
        "keyboard.tooltip.alphabetic": "Romeinse letters",
        "tooltip.copy to clipboard": "Kopiëren naar klembord",
        "tooltip.redo": "Opnieuw",
        "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord",
        "tooltip.undo": "Ongedaan maken",
        "menu.insert matrix": "Matrix invoegen",
        "menu.insert vector": "Vector invoegen",
        "submenu.array.matrix delimiters": "Matrixscheidingstekens",
        "menu.array.add row above": "Rij toevoegen na",
        "menu.array.add row below": "Rij toevoegen eerder",
        "menu.array.add column after": "Kolom toevoegen na",
        "menu.array.add column before": "Kolom toevoegen voor",
        "menu.array.delete row": "Verwijder rij",
        "menu.array.delete rows": "Geselecteerde rijen verwijderen",
        "menu.array.delete column": "Kolom verwijderen",
        "menu.array.delete columns": "Geselecteerde kolommen verwijderen",
        "submenu.array.insert separator": "Scheidingsteken invoegen",
        "menu.insert table": "Tabel invoegen",
        "submenu.table style": "Tabelstijl"
      },
      // Norwegian
      no: {
        "keyboard.tooltip.functions": "Funksjoner",
        "keyboard.tooltip.symbols": "Symboler",
        "keyboard.tooltip.greek": "Greske bokstaver",
        "keyboard.tooltip.command": "LaTeX kommandomodus",
        "keyboard.tooltip.numeric": "Numerisk",
        "keyboard.tooltip.alphabetic": "Romerske bokstaver",
        "tooltip.copy to clipboard": "Kopiere til utklippstavle",
        "tooltip.redo": "Gjøre om",
        "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur",
        "tooltip.undo": "Angre",
        "menu.insert matrix": "Sett inn matrise",
        "menu.insert vector": "Sett inn vektor",
        "submenu.array.matrix delimiters": "Matrix avgrensere",
        "menu.array.add row above": "Legg til rad etter",
        "menu.array.add row below": "Legg til rad før",
        "menu.array.add column after": "Legg til kolonne etter",
        "menu.array.add column before": "Legg til kolonne før",
        "menu.array.delete row": "Slett rad",
        "menu.array.delete rows": "Slett valgte rader",
        "menu.array.delete column": "Slett kolonne",
        "menu.array.delete columns": "Slett valgte kolonner",
        "submenu.array.insert separator": "Sett inn skilletegn",
        "menu.insert table": "Sett inn tabell",
        "submenu.table style": "Tabellstil"
      },
      // Macedonian
      mk: {
        "keyboard.tooltip.functions": "Функции",
        "keyboard.tooltip.symbols": "Симболи",
        "keyboard.tooltip.greek": "Грчки букви",
        "keyboard.tooltip.command": "Режим на команда во латекс",
        "keyboard.tooltip.numeric": "Нумерички",
        "keyboard.tooltip.alphabetic": "Римски писма",
        "tooltip.copy to clipboard": "Копирајте во клипборд",
        "tooltip.redo": "Повторно",
        "tooltip.toggle virtual keyboard": "Вклучете ја виртуелната тастатура",
        "tooltip.undo": "Врати",
        "menu.insert matrix": "Вметнете матрица",
        "menu.insert vector": "Вметни вектор",
        "submenu.array.matrix delimiters": "Разграничувачи на матрица",
        "menu.array.add row above": "Додадете ред после",
        "menu.array.add row below": "Додади ред пред тоа",
        "menu.array.add column after": "Додадете колона после",
        "menu.array.add column before": "Додадете колона пред тоа",
        "menu.array.delete row": "Избриши го редот",
        "menu.array.delete rows": "Избришете ги избраните редови",
        "menu.array.delete column": "Избриши ја колоната",
        "menu.array.delete columns": "Избриши ја колоната",
        "submenu.array.insert separator": "Вметнете сепаратор",
        "menu.insert table": "Вметни табела",
        "submenu.table style": "Табела стил"
      },
      // Polish
      pl: {
        "keyboard.tooltip.functions": "Funkcje",
        "keyboard.tooltip.symbols": "Symbolika",
        "keyboard.tooltip.greek": "Litery greckie",
        "keyboard.tooltip.command": "Tryb poleceń LaTeX",
        "keyboard.tooltip.numeric": "Numeryczne",
        "keyboard.tooltip.alphabetic": "Litery rzymskie",
        "tooltip.copy to clipboard": "Kopiuj do Schowka",
        "tooltip.redo": "Przywróć",
        "tooltip.toggle virtual keyboard": "Przełącz wirtualną klawiaturę",
        "tooltip.undo": "Cofnij",
        "menu.insert matrix": "Wstaw macierz",
        "menu.insert vector": "Wstaw wektor",
        "submenu.array.matrix delimiters": "Ograniczniki macierzy",
        "menu.array.add row above": "Dodaj wiersz po",
        "menu.array.add row below": "Dodaj wiersz przed",
        "menu.array.add column after": "Dodaj kolumnę po",
        "menu.array.add column before": "Dodaj kolumnę przed",
        "menu.array.delete row": "Usuń wiersz",
        "menu.array.delete rows": "Usuń wybrane wiersze",
        "menu.array.delete column": "Usuń kolumnę",
        "menu.array.delete columns": "Usuń wybrane kolumny",
        "submenu.array.insert separator": "Wstaw separator",
        "menu.insert table": "Wypełnij tabelę",
        "submenu.table style": "Styl tabelę"
      },
      // Portuguese
      pt: {
        "keyboard.tooltip.functions": "Functions",
        "keyboard.tooltip.symbols": "Símbolos",
        "keyboard.tooltip.greek": "Letras gregas",
        "keyboard.tooltip.command": "Modo de Comando LaTeX",
        "keyboard.tooltip.numeric": "Numérico",
        "keyboard.tooltip.alphabetic": "Letras romanas",
        "tooltip.copy to clipboard": "Copiar para área de transferência",
        "tooltip.redo": "Refazer",
        "tooltip.toggle virtual keyboard": "Alternar teclado virtual",
        "tooltip.undo": "Desfazer",
        "menu.insert matrix": "Inserir Matriz",
        "menu.insert vector": "Inserir vetor",
        "submenu.array.matrix delimiters": "Delimitadores de matriz",
        "menu.array.add row above": "Adicionar linha depois",
        "menu.array.add row below": "Adicionar linha antes",
        "menu.array.add column after": "Adicionar coluna depois",
        "menu.array.add column before": "Adicionar coluna antes",
        "menu.array.delete row": "Excluir linha",
        "menu.array.delete rows": "Excluir linhas selecionadas",
        "menu.array.delete column": "Apagar Coluna",
        "menu.array.delete columns": "Excluir Colunas Selecionadas",
        "submenu.array.insert separator": "Inserir Separador",
        "menu.insert table": "Insira a tabela",
        "submenu.table style": "Estilo tabela"
      },
      //Romaninan
      ro: {
        "keyboard.tooltip.functions": "Funcții",
        "keyboard.tooltip.symbols": "Simboluri",
        "keyboard.tooltip.greek": "Scrisori grecești",
        "keyboard.tooltip.command": "Modul de comandă latex",
        "keyboard.tooltip.numeric": "Numeric",
        "keyboard.tooltip.alphabetic": "Scrisori romane",
        "tooltip.copy to clipboard": "Copiați în clipboard",
        "tooltip.redo": "A reface",
        "tooltip.toggle virtual keyboard": "Comutați tastatura virtuală",
        "tooltip.undo": "Anula",
        "menu.insert matrix": "Introduceți Matrix",
        "menu.insert vector": "Inserați Vector",
        "submenu.array.matrix delimiters": "Delimitatori de matrice",
        "menu.array.add row above": "Adăugați rândul după",
        "menu.array.add row below": "Adăugați rândul înainte",
        "menu.array.add column after": "Adăugați o coloană după",
        "menu.array.add column before": "Adăugați o coloană înainte",
        "menu.array.delete row": "Ștergeți rândul",
        "menu.array.delete rows": "Ștergeți rândurile selectate",
        "menu.array.delete column": "Ștergeți coloana",
        "menu.array.delete columns": "Ștergeți coloanele selectate",
        "submenu.array.insert separator": "Introduceți separatorul",
        "menu.insert table": "Introduceți tabelul",
        "submenu.table style": "Table style"
      },
      // Russian
      ru: {
        "keyboard.tooltip.functions": "Функции",
        "keyboard.tooltip.symbols": "Символы",
        "keyboard.tooltip.greek": "Греческие буквы",
        "keyboard.tooltip.command": "Режим командной строки Латекс",
        "keyboard.tooltip.numeric": "числовой",
        "keyboard.tooltip.alphabetic": "Латинские буквы",
        "tooltip.copy to clipboard": "Скопировать в буфер обмена",
        "tooltip.redo": "переделывать",
        "tooltip.toggle virtual keyboard": "Переключить виртуальную клавиатуру",
        "tooltip.undo": "расстегивать",
        "menu.insert matrix": "Вставить матрицу",
        "menu.insert vector": "Вставить вектор",
        "submenu.array.matrix delimiters": "Матричные разделители",
        "menu.array.add row above": "Добавить строку после",
        "menu.array.add row below": "Добавить строку перед",
        "menu.array.add column after": "Добавить столбец после",
        "menu.array.add column before": "Добавить столбец перед",
        "menu.array.delete row": "Удалить строку",
        "menu.array.delete rows": "Удалить выбранные строки",
        "menu.array.delete column": "Удалить столбец",
        "menu.array.delete columns": "Удалить выбранные столбцы",
        "submenu.array.insert separator": "Вставить разделитель",
        "menu.insert table": "Вставить таблицу",
        "submenu.table style": "Табличный стиль"
      },
      // Slovak
      sk: {
        "keyboard.tooltip.functions": "Functions",
        "keyboard.tooltip.symbols": "Symboly",
        "keyboard.tooltip.greek": "Grécke listy",
        "keyboard.tooltip.command": "Príkazový režim LaTeX",
        "keyboard.tooltip.numeric": "Numerické",
        "keyboard.tooltip.alphabetic": "Rímske listy",
        "tooltip.copy to clipboard": "Skopírovať do schránky",
        "tooltip.redo": "Znova",
        "tooltip.toggle virtual keyboard": "Prepnúť virtuálnu klávesnicu",
        "tooltip.undo": "Vrátenie späť",
        "menu.insert matrix": "Vložte maticu",
        "menu.insert vector": "Vložte vektor",
        "submenu.array.matrix delimiters": "Oddeľovače matíc",
        "menu.array.add row above": "Pridajte riadok za",
        "menu.array.add row below": "Pridajte riadok pred",
        "menu.array.add column after": "Pridať stĺpec za",
        "menu.array.add column before": "Pridajte stĺpec predtým",
        "menu.array.delete row": "Odstrániť riadok",
        "menu.array.delete rows": "Odstrániť vybraté riadky",
        "menu.array.delete column": "Odstrániť stĺpec",
        "menu.array.delete columns": "Odstrániť vybraté stĺpce",
        "submenu.array.insert separator": "Vložte oddeľovač",
        "menu.insert table": "Vložte tabuľku",
        "submenu.table style": "Štýl tabuľky"
      },
      // Slovenian
      sl: {
        "keyboard.tooltip.functions": "Funkcije",
        "keyboard.tooltip.symbols": "Simboli",
        "keyboard.tooltip.greek": "Grška pisma",
        "keyboard.tooltip.command": "Ukazni način LaTeX",
        "keyboard.tooltip.numeric": "Številsko",
        "keyboard.tooltip.alphabetic": "Rimska pisma",
        "tooltip.copy to clipboard": "Kopirati v odložišče",
        "tooltip.redo": "Ponovi",
        "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice",
        "tooltip.undo": "Razveljavi",
        "menu.insert matrix": "Vstavi matrico",
        "menu.insert vector": "Vstavi vektor",
        "submenu.array.matrix delimiters": "Matrični ločevalniki",
        "menu.array.add row above": "Dodaj vrstico po",
        "menu.array.add row below": "Dodaj vrstico prej",
        "menu.array.add column after": "Dodaj stolpec po",
        "menu.array.add column before": "Dodaj stolpec prej",
        "menu.array.delete row": "Izbriši vrstico",
        "menu.array.delete rows": "Izbriši izbrane vrstice",
        "menu.array.delete column": "Izbriši stolpec",
        "menu.array.delete columns": "Izbriši izbrane stolpce",
        "submenu.array.insert separator": "Vstavi ločilo",
        "menu.insert table": "Vstavi tabelo",
        "submenu.table style": "Tabela slog"
      },
      /// Albanian
      sq: {
        "keyboard.tooltip.functions": "Funksione",
        "keyboard.tooltip.symbols": "Simbolet",
        "keyboard.tooltip.greek": "Letrat Greke",
        "keyboard.tooltip.command": "Modaliteti i komandës latex",
        "keyboard.tooltip.numeric": "Numerike",
        "keyboard.tooltip.alphabetic": "Letrat romake",
        "tooltip.copy to clipboard": "Kopjoni në Clipboard",
        "tooltip.redo": "Riparo",
        "tooltip.toggle virtual keyboard": "Aktivizo tastierën virtuale",
        "tooltip.undo": "Zhbëj",
        "menu.insert matrix": "Vendosni Matricën",
        "menu.insert vector": "Vendos vektorin",
        "submenu.array.matrix delimiters": "Përcaktuesit e matricës",
        "menu.array.add row above": "Shto Rreshtin Pas",
        "menu.array.add row below": "Shto Rreshtin Para",
        "menu.array.add column after": "Shto kolonën pas",
        "menu.array.add column before": "Shto kolonën para",
        "menu.array.delete row": "Fshi Rreshtin",
        "menu.array.delete rows": "Fshi rreshtat e zgjedhur",
        "menu.array.delete column": "Fshi kolonën",
        "menu.array.delete columns": "Fshi kolonat e zgjedhura",
        "submenu.array.insert separator": "Vendos Ndarësin",
        "menu.insert table": "Vendos tabelën",
        "submenu.table style": "Stili tabelën"
      },
      // Serbian
      sr: {
        "keyboard.tooltip.functions": "Функције",
        "keyboard.tooltip.symbols": "Симболи",
        "keyboard.tooltip.greek": "Греек Леттерс",
        "keyboard.tooltip.command": "ЛаТеКс командни режим",
        "keyboard.tooltip.numeric": "Нумерички",
        "keyboard.tooltip.alphabetic": "Римска писма",
        "tooltip.copy to clipboard": "Копирајте у међуспремник",
        "tooltip.redo": "Понови",
        "tooltip.toggle virtual keyboard": "Укључи / искључи виртуелну тастатуру",
        "tooltip.undo": "Опозови",
        "menu.insert matrix": "Уметни матрицу",
        "menu.insert vector": "Уметни вектор",
        "submenu.array.matrix delimiters": "Матрик Делимитерс",
        "menu.array.add row above": "Додај ред после",
        "menu.array.add row below": "Додај ред пре",
        "menu.array.add column after": "Додај колону после",
        "menu.array.add column before": "Додај колону пре",
        "menu.array.delete row": "Избриши ред",
        "menu.array.delete rows": "Избриши изабране редове",
        "menu.array.delete column": "Избриши колону",
        "menu.array.delete columns": "Избриши изабране колоне",
        "submenu.array.insert separator": "Уметни сепаратор",
        "menu.insert table": "Убаци табелу",
        "submenu.table style": "Табеларни стил"
      },
      // Swedish
      sv: {
        "keyboard.tooltip.functions": "Funktioner",
        "keyboard.tooltip.symbols": "Symboler",
        "keyboard.tooltip.greek": "Grekiska bokstäver",
        "keyboard.tooltip.command": "LaTeX kommandoläge",
        "keyboard.tooltip.numeric": "Numerisk",
        "keyboard.tooltip.alphabetic": "Romerska bokstäver",
        "tooltip.copy to clipboard": "Kopiera till Urklipp",
        "tooltip.redo": "Göra om",
        "tooltip.toggle virtual keyboard": "Växla virtuellt tangentbord",
        "tooltip.undo": "Ångra",
        "menu.insert matrix": "Sätt in matris",
        "menu.insert vector": "Infoga vektor",
        "submenu.array.matrix delimiters": "Matrisavgränsare",
        "menu.array.add row above": "Lägg till rad efter",
        "menu.array.add row below": "Lägg till rad före",
        "menu.array.add column after": "Lägg till kolumn efter",
        "menu.array.add column before": "Lägg till kolumn före",
        "menu.array.delete row": "Radera rad",
        "menu.array.delete rows": "Ta bort valda rader",
        "menu.array.delete column": "Ta bort kolumn",
        "menu.array.delete columns": "Ta bort valda kolumner",
        "submenu.array.insert separator": "Sätt i separator",
        "menu.insert table": "Infoga tabell",
        "submenu.table style": "Tabellstil"
      },
      // Thai
      th: {
        "keyboard.tooltip.functions": "ฟังก์ชั่น",
        "keyboard.tooltip.symbols": "สัญลักษณ์",
        "keyboard.tooltip.greek": "อักษรกรีก",
        "keyboard.tooltip.command": "โหมดคำสั่ง น้ำยาง",
        "keyboard.tooltip.numeric": "ตัวเลข",
        "keyboard.tooltip.alphabetic": "อักษรโรมัน",
        "tooltip.copy to clipboard": "คัดลอกไปที่คลิปบอร์ด",
        "tooltip.redo": "ทำซ้ำ",
        "tooltip.toggle virtual keyboard": "สลับแป้นพิมพ์เสมือน",
        "tooltip.undo": "เลิกทำ",
        "menu.insert matrix": "แทรกเมทริกซ์",
        "menu.insert vector": "แทรกเวกเตอร์",
        "submenu.array.matrix delimiters": "ตัวคั่นเมทริกซ์",
        "menu.array.add row above": "เพิ่มแถวหลัง",
        "menu.array.add row below": "เพิ่มแถวก่อน",
        "menu.array.add column after": "เพิ่มคอลัมน์หลัง",
        "menu.array.add column before": "เพิ่มคอลัมน์ก่อน",
        "menu.array.delete row": "ลบแถว",
        "menu.array.delete rows": "ลบแถวที่เลือก",
        "menu.array.delete column": "ลบคอลัมน์",
        "menu.array.delete columns": "ลบคอลัมน์ที่เลือก",
        "submenu.array.insert separator": "ตัวคั่นแทรก",
        "menu.insert table": "แทรกตาราง",
        "submenu.table style": "สไตล์ตาราง"
      },
      // Turkish
      tr: {
        "keyboard.tooltip.functions": "Fonksiyonlar",
        "keyboard.tooltip.symbols": "Semboller",
        "keyboard.tooltip.greek": "Yunan harfleri",
        "keyboard.tooltip.command": "LaTeX Komut Modu",
        "keyboard.tooltip.numeric": "Sayısal",
        "keyboard.tooltip.alphabetic": "Roma Harfleri",
        "tooltip.copy to clipboard": "Panoya kopyala",
        "tooltip.redo": "Yeniden yap",
        "tooltip.toggle virtual keyboard": "Sanal Klavyeyi Aç/Kapat",
        "tooltip.undo": "Geri alma",
        "menu.insert matrix": "Matris Ekle",
        "menu.insert vector": "Vektör Ekle",
        "submenu.array.matrix delimiters": "Matris Sınırlayıcılar",
        "menu.array.add row above": "Satırdan Sonra Ekle",
        "menu.array.add row below": "Önce Satır Ekle",
        "menu.array.add column after": "Sonra Sütun Ekle",
        "menu.array.add column before": "Önce Sütun Ekle",
        "menu.array.delete row": "Sırayı sil",
        "menu.array.delete rows": "Seçili Satırları Sil",
        "menu.array.delete column": "Sütunu Sil",
        "menu.array.delete columns": "Seçili Sütunları Sil",
        "submenu.array.insert separator": "Ayırıcı Ekle",
        "menu.insert table": "Tablo Ekle",
        "submenu.table style": "Tablo Stili"
      },
      //Ukrainian
      uk: {
        "keyboard.tooltip.functions": "Функції",
        "keyboard.tooltip.symbols": "Символи",
        "keyboard.tooltip.greek": "Грецькі літери",
        "keyboard.tooltip.command": "Командний режим латексу",
        "keyboard.tooltip.numeric": "Числовий",
        "keyboard.tooltip.alphabetic": "Римські літери",
        "tooltip.copy to clipboard": "Копіювати в буфер обміну",
        "tooltip.redo": "Повторити",
        "tooltip.toggle virtual keyboard": "Переключити віртуальну клавіатуру",
        "tooltip.undo": "Скасувати",
        "menu.insert matrix": "Вставити матрицю",
        "menu.insert vector": "Вставити вектор",
        "submenu.array.matrix delimiters": "Матричні роздільники",
        "menu.array.add row above": "Додати рядок після",
        "menu.array.add row below": "Додати рядок до",
        "menu.array.add column after": "Додати стовпець після",
        "menu.array.add column before": "Додати стовпець перед",
        "menu.array.delete row": "Видалити рядок",
        "menu.array.delete rows": "Видалити вибрані рядки",
        "menu.array.delete column": "Видалити стовпець",
        "menu.array.delete columns": "Видалити вибрані стовпці",
        "submenu.array.insert separator": "Вставте роздільник",
        "menu.insert table": "Вставити таблицю",
        "submenu.table style": "Стиль таблиці"
      },
      //Vietnamese
      vi: {
        "keyboard.tooltip.functions": "Chức năng",
        "keyboard.tooltip.symbols": "Ký hiệu",
        "keyboard.tooltip.greek": "Chữ Hy Lạp",
        "keyboard.tooltip.command": "Chế độ lệnh LaTeX",
        "keyboard.tooltip.numeric": "Số",
        "keyboard.tooltip.alphabetic": "Chữ cái La mã",
        "tooltip.copy to clipboard": "Sao chép vào clipboard",
        "tooltip.redo": "Làm lại",
        "tooltip.toggle virtual keyboard": "Chuyển đổi bàn phím ảo",
        "tooltip.undo": "Hoàn tác",
        "menu.insert matrix": "Chèn ma trận",
        "menu.insert vector": "Insert Vector",
        "submenu.array.matrix delimiters": "Dấu phân cách ma trận",
        "menu.array.add row above": "Thêm hàng sau",
        "menu.array.add row below": "Thêm hàng trước",
        "menu.array.add column after": "Thêm cột sau",
        "menu.array.add column before": "Thêm cột trước",
        "menu.array.delete row": "Xóa hàng",
        "menu.array.delete rows": "Xóa hàng đã chọn",
        "menu.array.delete column": "Xóa cột",
        "menu.array.delete columns": "Xóa các cột đã chọn",
        "submenu.array.insert separator": "Chèn dấu phân cách",
        "menu.insert table": "Chèn bảng",
        "submenu.table style": "Kiểu bảng"
      },
      // Simplified Chinese
      zh_cn: {
        "keyboard.tooltip.functions": "职能",
        "keyboard.tooltip.symbols": "符号",
        "keyboard.tooltip.greek": "希腊字母",
        "keyboard.tooltip.command": "乳胶 命令模式",
        "keyboard.tooltip.numeric": "数字",
        "keyboard.tooltip.alphabetic": "罗马字母",
        "tooltip.copy to clipboard": "复制到剪贴板",
        "tooltip.redo": "重做",
        "tooltip.toggle virtual keyboard": "切换虚拟键盘",
        "tooltip.undo": "撤消",
        "menu.insert matrix": "插入矩阵",
        "menu.insert vector": "插入向量",
        "submenu.array.matrix delimiters": "矩阵分隔符",
        "menu.array.add row above": "在后面添加行",
        "menu.array.add row below": "在前面添加行",
        "menu.array.add column after": "在后面添加列r",
        "menu.array.add column before": "在前面添加列",
        "menu.array.delete row": "删除行",
        "menu.array.delete rows": "删除选定行",
        "menu.array.delete column": "删除列",
        "menu.array.delete columns": "删除选定的列",
        "submenu.array.insert separator": "插入分隔符",
        "menu.insert table": "插入表格",
        "submenu.table style": "表格样式"
      },
      // Traditional Chinese
      zh_tw: {
        "keyboard.tooltip.functions": "職能",
        "keyboard.tooltip.symbols": "符號",
        "keyboard.tooltip.greek": "希臘字母",
        "keyboard.tooltip.command": "乳膠命令模式",
        "keyboard.tooltip.numeric": "數字",
        "keyboard.tooltip.alphabetic": "羅馬字母",
        "tooltip.copy to clipboard": "複製到剪貼板",
        "tooltip.redo": "重做",
        "tooltip.toggle virtual keyboard": "切換虛擬鍵盤",
        "tooltip.undo": "撤消",
        "menu.insert matrix": "插入矩陣",
        "menu.insert vector": "插入向量",
        "submenu.array.matrix delimiters": "矩陣分隔符",
        "menu.array.add row above": "在後面添加行",
        "menu.array.add row below": "在前面添加行",
        "menu.array.add column after": "在後面添加列",
        "menu.array.add column before": "在前面添加列",
        "menu.array.delete row": "刪除行",
        "menu.array.delete rows": "刪除選定行",
        "menu.array.delete column": "刪除列",
        "menu.array.delete columns": "刪除選定的列",
        "submenu.array.insert separator": "插入分隔符",
        "menu.insert table": "插入表格",
        "submenu.table style": "表格樣式"
      }
    };
    function isBrowser() {
      return "window" in globalThis && "document" in globalThis;
    }
    function throwIfNotInBrowser() {
      if (!isBrowser()) {
        throw new Error(
          "<math-field> is an interactive component that needs to run in a browser environment\nIf you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr"
        );
      }
    }
    function isTouchCapable() {
      if ("matchMedia" in window)
        return window.matchMedia("(any-pointer: coarse)").matches;
      return "ontouchstart" in window || navigator.maxTouchPoints > 0;
    }
    function canVibrate() {
      return typeof navigator.vibrate === "function";
    }
    function osPlatform() {
      var _a3, _b3;
      if (!isBrowser())
        return "other";
      const platform2 = (_b3 = (_a3 = navigator["userAgentData"]) == null ? void 0 : _a3.platform) != null ? _b3 : navigator.platform;
      if (/^mac/i.test(platform2)) {
        if (navigator.maxTouchPoints === 5)
          return "ios";
        return "macos";
      }
      if (/^win/i.test(platform2))
        return "windows";
      if (/android/i.test(navigator.userAgent))
        return "android";
      if (/iphone|ipod|ipad/i.test(navigator.userAgent))
        return "ios";
      if (/\bcros\b/i.test(navigator.userAgent))
        return "chromeos";
      return "other";
    }
    function supportRegexPropertyEscape() {
      if (!isBrowser())
        return true;
      if (/firefox/i.test(navigator.userAgent)) {
        const m = navigator.userAgent.match(/firefox\/(\d+)/i);
        if (!m)
          return false;
        const version4 = parseInt(m[1]);
        return version4 >= 78;
      }
      if (/trident/i.test(navigator.userAgent))
        return false;
      if (/edge/i.test(navigator.userAgent)) {
        const m = navigator.userAgent.match(/edg\/(\d+)/i);
        if (!m)
          return false;
        const version4 = parseInt(m[1]);
        return version4 >= 79;
      }
      return true;
    }
    var l10n = {
      strings: STRINGS,
      _locale: "",
      //  Important! Set the locale to empty so it can be determined at runtime
      // Add getter and setter for the _locale property of l10n
      get locale() {
        if (!l10n._locale)
          l10n._locale = isBrowser() ? navigator.language.slice(0, 5) : "en";
        return l10n._locale;
      },
      set locale(value) {
        l10n._locale = value;
      },
      /*
       * Two forms for this function:
       * - merge(locale, strings)
       * Merge a dictionary of keys -> values for the specified locale
       * - merge(strings)
       * Merge a dictionary of locale code -> dictionary of keys -> values
       *
       */
      merge(locale, strings) {
        if (locale && strings) {
          const savedLocale = l10n._locale;
          l10n.locale = locale;
          l10n.strings[locale] = __spreadValues(__spreadValues({}, l10n.strings[locale]), strings);
          l10n.locale = savedLocale;
        } else if (locale && !strings) {
          for (const l of Object.keys(
            locale
          ))
            l10n.merge(l, locale[l]);
        }
      }
    };
    function localize(key) {
      if (key === void 0)
        return void 0;
      const language = l10n.locale.slice(0, 2);
      let result = "";
      if (l10n.strings[l10n.locale])
        result = l10n.strings[l10n.locale][key];
      if (!result && l10n.strings[language])
        result = l10n.strings[language][key];
      if (!result)
        result = l10n.strings.en[key];
      if (!result)
        return void 0;
      return result;
    }
    var MATHEMATICA_COLORS = {
      m0: "#3F3D99",
      // Strong blue
      m1: "#993D71",
      // Strong cerise
      m2: "#998B3D",
      // Strong gold
      m3: "#3D9956",
      // Malachite green
      m4: "#3D5A99",
      // Strong cobalt blue
      m5: "#993D90",
      // Strong orchid
      m6: "#996D3D",
      // Strong orange
      m7: "#43993D",
      // Strong sap green
      m8: "#3D7999",
      // Cornflower blue
      m9: "#843D99"
      // Mulberry
    };
    var MATLAB_COLORS = {
      blue: "#0072BD",
      // [0, 0.4470, 0.7410]             blue
      orange: "#D95319",
      // [0.8500, 0.3250, 0.0980]        orange
      yellow: "#EDB120",
      // [0.9290, 0.6940, 0.1250]       yellow
      purple: "#7E2F8E",
      // [0.4940, 0.1840, 0.5560]       purple
      green: "#77AC30",
      // [0.4660, 0.6740, 0.1880]       green
      cyan: "#4DBEEE",
      // [0.3010, 0.7450, 0.9330]       cyan
      red: "#A2142F"
      // [0.6350, 0.0780, 0.1840]	    dark red
    };
    var BACKGROUND_COLORS = {
      "red": "#fbbbb6",
      "orange": "#ffe0c2",
      "yellow": "#fff1c2",
      "lime": "#d0e8b9",
      "green": "#bceac4",
      "teal": "#b9f1f1",
      "blue": "#b6d9fb",
      "indigo": "#d1c2f0",
      "purple": "#e3baf8",
      "magenta": "#f9c8e0",
      "black": "#353535",
      "dark-grey": "#8C8C8C",
      "grey": "#D0D0D0",
      "light-grey": "#F0F0F0",
      "white": "#ffffff"
    };
    var FOREGROUND_COLORS = {
      "red": "#d7170b",
      //<- 700, 500 ->'#f21c0d'
      "orange": "#fe8a2b",
      "yellow": "#ffc02b",
      // <- 600, 500 -> '#ffcf33',
      "lime": "#63b215",
      "green": "#21ba3a",
      "teal": "#17cfcf",
      "blue": "#0d80f2",
      "indigo": "#63c",
      "purple": "#a219e6",
      "magenta": "#eb4799",
      "black": "#000",
      "dark-grey": "#666",
      "grey": "#A6A6A6",
      "light-grey": "#d4d5d2",
      "white": "#ffffff"
    };
    var DVIPS_TO_CHROMATIC = {
      Red: "red",
      Orange: "orange",
      Yellow: "yellow",
      LimeGreen: "lime",
      Green: "green",
      TealBlue: "teal",
      Blue: "blue",
      Violet: "indigo",
      Purple: "purple",
      Magenta: "magenta",
      Black: "black",
      Gray: "grey",
      White: "white"
    };
    var DVIPS_COLORS = {
      Apricot: "#FBB982",
      Aquamarine: "#00B5BE",
      Bittersweet: "#C04F17",
      Black: "#221E1F",
      // Indeed.
      Blue: "#2D2F92",
      BlueGreen: "#00B3B8",
      BlueViolet: "#473992",
      BrickRed: "#B6321C",
      Brown: "#792500",
      BurntOrange: "#F7921D",
      CadetBlue: "#74729A",
      CarnationPink: "#F282B4",
      Cerulean: "#00A2E3",
      CornflowerBlue: "#41B0E4",
      Cyan: "#00AEEF",
      Dandelion: "#FDBC42",
      DarkOrchid: "#A4538A",
      Emerald: "#00A99D",
      ForestGreen: "#009B55",
      Fuchsia: "#8C368C",
      Goldenrod: "#FFDF42",
      Gray: "#949698",
      Green: "#00A64F",
      GreenYellow: "#DFE674",
      JungleGreen: "#00A99A",
      Lavender: "#F49EC4",
      Limegreen: "#8DC73E",
      Magenta: "#EC008C",
      Mahogany: "#A9341F",
      Maroon: "#AF3235",
      Melon: "#F89E7B",
      MidnightBlue: "#006795",
      Mulberry: "#A93C93",
      NavyBlue: "#006EB8",
      OliveGreen: "#3C8031",
      Orange: "#F58137",
      OrangeRed: "#ED135A",
      Orchid: "#AF72B0",
      Peach: "#F7965A",
      Periwinkle: "#7977B8",
      PineGreen: "#008B72",
      Plum: "#92268F",
      ProcessBlue: "#00B0F0",
      Purple: "#99479B",
      RawSienna: "#974006",
      Red: "#ED1B23",
      RedOrange: "#F26035",
      RedViolet: "#A1246B",
      Rhodamine: "#EF559F",
      RoyalBlue: "#0071BC",
      RoyalPurple: "#613F99",
      RubineRed: "#ED017D",
      Salmon: "#F69289",
      SeaGreen: "#3FBC9D",
      Sepia: "#671800",
      SkyBlue: "#46C5DD",
      SpringGreen: "#C6DC67",
      Tan: "#DA9D76",
      TealBlue: "#00AEB3",
      Thistle: "#D883B7",
      Turquoise: "#00B4CE",
      Violet: "#58429B",
      VioletRed: "#EF58A0",
      White: "#FFFFFF",
      WildStrawberry: "#EE2967",
      Yellow: "#FFF200",
      YellowGreen: "#98CC70",
      YellowOrange: "#FAA21A"
    };
    function defaultColorMap(s) {
      var _a3, _b3, _c2, _d2, _e, _f;
      const colorSpec = s.split("!");
      let baseRed;
      let baseGreen;
      let baseBlue;
      let red = 255;
      let green = 255;
      let blue = 255;
      let mix = -1;
      const complementary = colorSpec.length > 0 && colorSpec[0].startsWith("-");
      if (complementary)
        colorSpec[0] = colorSpec[0].slice(1);
      for (let i = 0; i < colorSpec.length; i++) {
        baseRed = red;
        baseGreen = green;
        baseBlue = blue;
        const colorName = (_a3 = colorSpec[i].trim().match(/^([A-Za-z\d]+)/)) == null ? void 0 : _a3[1];
        const lcColorName = colorName == null ? void 0 : colorName.toLowerCase();
        const color = !colorName ? colorSpec[i].trim() : (_f = (_e = (_d2 = (_c2 = (_b3 = FOREGROUND_COLORS[lcColorName]) != null ? _b3 : FOREGROUND_COLORS[DVIPS_TO_CHROMATIC[colorName]]) != null ? _c2 : MATLAB_COLORS[colorName]) != null ? _d2 : DVIPS_COLORS[colorName]) != null ? _e : MATHEMATICA_COLORS[colorName]) != null ? _f : colorSpec[i].trim();
        let m = color.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
        if ((m == null ? void 0 : m[1]) && m[2] && m[3]) {
          red = Math.max(0, Math.min(255, Number.parseInt(m[1], 16)));
          green = Math.max(0, Math.min(255, Number.parseInt(m[2], 16)));
          blue = Math.max(0, Math.min(255, Number.parseInt(m[3], 16)));
        } else {
          m = color.match(/^#([\da-f]{3})$/i);
          if (m == null ? void 0 : m[1]) {
            const r1 = Number.parseInt(m[1][0], 16);
            const g1 = Number.parseInt(m[1][1], 16);
            const b1 = Number.parseInt(m[1][2], 16);
            red = Math.max(0, Math.min(255, r1 * 16 + r1));
            green = Math.max(0, Math.min(255, g1 * 16 + g1));
            blue = Math.max(0, Math.min(255, b1 * 16 + b1));
          } else {
            m = color.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if ((m == null ? void 0 : m[1]) && m[2] && m[3]) {
              red = Math.max(0, Math.min(255, Number.parseInt(m[1])));
              green = Math.max(0, Math.min(255, Number.parseInt(m[2])));
              blue = Math.max(0, Math.min(255, Number.parseInt(m[3])));
            } else
              return void 0;
          }
        }
        if (mix >= 0) {
          red = (1 - mix) * red + mix * baseRed;
          green = (1 - mix) * green + mix * baseGreen;
          blue = (1 - mix) * blue + mix * baseBlue;
          mix = -1;
        }
        if (i + 1 < colorSpec.length)
          mix = Math.max(0, Math.min(100, Number.parseInt(colorSpec[++i]))) / 100;
      }
      if (mix >= 0) {
        red = mix * red + (1 - mix) * baseRed;
        green = mix * green + (1 - mix) * baseGreen;
        blue = mix * blue + (1 - mix) * baseBlue;
      }
      if (complementary) {
        red = 255 - red;
        green = 255 - green;
        blue = 255 - blue;
      }
      return "#" + ("00" + Math.round(red).toString(16)).slice(-2) + ("00" + Math.round(green).toString(16)).slice(-2) + ("00" + Math.round(blue).toString(16)).slice(-2);
    }
    function defaultBackgroundColorMap(s) {
      var _a3, _b3;
      s = s.trim();
      return (_b3 = (_a3 = BACKGROUND_COLORS[s.toLowerCase()]) != null ? _a3 : BACKGROUND_COLORS[DVIPS_TO_CHROMATIC[s]]) != null ? _b3 : defaultColorMap(s);
    }
    function parseHex(hex) {
      if (!hex)
        return void 0;
      if (hex[0] !== "#")
        return void 0;
      hex = hex.slice(1);
      let result;
      if (hex.length <= 4) {
        result = {
          r: parseInt(hex[0] + hex[0], 16),
          g: parseInt(hex[1] + hex[1], 16),
          b: parseInt(hex[2] + hex[2], 16)
        };
        if (hex.length === 4)
          result.a = parseInt(hex[3] + hex[3], 16) / 255;
      } else {
        result = {
          r: parseInt(hex[0] + hex[1], 16),
          g: parseInt(hex[2] + hex[3], 16),
          b: parseInt(hex[4] + hex[5], 16)
        };
        if (hex.length === 8)
          result.a = parseInt(hex[6] + hex[7], 16) / 255;
      }
      if (result && result.a === void 0)
        result.a = 1;
      return result;
    }
    function hueToRgbChannel(t1, t2, hue) {
      if (hue < 0)
        hue += 6;
      if (hue >= 6)
        hue -= 6;
      if (hue < 1)
        return (t2 - t1) * hue + t1;
      else if (hue < 3)
        return t2;
      else if (hue < 4)
        return (t2 - t1) * (4 - hue) + t1;
      return t1;
    }
    function hslToRgb(hsl) {
      let [hue, sat, light] = [hsl.h, hsl.s, hsl.l];
      hue = (hue + 360) % 360 / 60;
      light = Math.max(0, Math.min(light, 1));
      sat = Math.max(0, Math.min(sat, 1));
      const t2 = light <= 0.5 ? light * (sat + 1) : light + sat - light * sat;
      const t1 = light * 2 - t2;
      return {
        r: Math.round(255 * hueToRgbChannel(t1, t2, hue + 2)),
        g: Math.round(255 * hueToRgbChannel(t1, t2, hue)),
        b: Math.round(255 * hueToRgbChannel(t1, t2, hue - 2))
      };
    }
    function clampByte(v) {
      if (v < 0)
        return 0;
      if (v > 255)
        return 255;
      return Math.round(v);
    }
    function rgbToHexstring(rgb) {
      const { r, g, b } = rgb;
      let hexString = ((1 << 24) + (clampByte(r) << 16) + (clampByte(g) << 8) + clampByte(b)).toString(16).slice(1);
      if (hexString[0] === hexString[1] && hexString[2] === hexString[3] && hexString[4] === hexString[5] && hexString[6] === hexString[7])
        hexString = hexString[0] + hexString[2] + hexString[4];
      return "#" + hexString;
    }
    function rgbToHsl(rgb) {
      let { r, g, b } = rgb;
      r = r / 255;
      g = g / 255;
      b = b / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min)
        h = 0;
      else if (r === max)
        h = (g - b) / delta;
      else if (g === max)
        h = 2 + (b - r) / delta;
      else if (b === max)
        h = 4 + (r - g) / delta;
      h = Math.min(h * 60, 360);
      if (h < 0)
        h += 360;
      const l = (min + max) / 2;
      if (max === min)
        s = 0;
      else if (l <= 0.5)
        s = delta / (max + min);
      else
        s = delta / (2 - max - min);
      return { h, s, l };
    }
    function highlight(color) {
      let rgb = parseHex(color);
      if (!rgb)
        return color;
      let { h, s, l } = rgbToHsl(rgb);
      s += 0.1;
      l -= 0.1;
      return rgbToHexstring(hslToRgb({ h, s, l }));
    }
    var M6 = [0, 0.69444, 0, 0];
    var M11 = [0, 0.61111, 0, 0];
    var M15 = [0.25, 0.75, 0, 0];
    var M7 = [0, 0.44444, 0, 0];
    var M4 = [0, 0.68611, 0, 0];
    var M16 = [0.19444, 0.69444, 0, 0];
    var M9 = [0, 0.68333, 0, 0];
    var M1 = [0, 0.68889, 0, 0];
    var M21 = [0, 0.69141, 0, 0];
    var M0 = [0, 0, 0, 0];
    var M5 = [0, 0.64444, 0, 0];
    var M3 = [0, 0.69224, 0, 0];
    var M8 = [0.19444, 0.44444, 0, 0];
    var M19 = [0.65002, 1.15, 0, 0];
    var M20 = [0, 0.55556, 0, 0];
    var M10 = [0.35001, 0.85, 0, 0];
    var M12 = [1.25003, 1.75, 0, 0];
    var M13 = [0.95003, 1.45, 0, 0];
    var M14 = [0, 0.75, 0, 0];
    var M22 = [0, 0.47534, 0, 0];
    var M17 = [0.25001, 0.75, 0, 0];
    var M18 = [0.55001, 1.05, 0, 0];
    var M2 = [0.16667, 0.68889, 0, 0];
    var M23 = [0.08167, 0.58167, 0, 0];
    var font_metrics_data_default = {
      "AMS-Regular": {
        "32": M0,
        "65": M1,
        "66": M1,
        "67": M1,
        "68": M1,
        "69": M1,
        "70": M1,
        "71": M1,
        "72": M1,
        "73": M1,
        "74": M2,
        "75": M1,
        "76": M1,
        "77": M1,
        "78": M1,
        "79": M2,
        "80": M1,
        "81": M2,
        "82": M1,
        "83": M1,
        "84": M1,
        "85": M1,
        "86": M1,
        "87": M1,
        "88": M1,
        "89": M1,
        "90": M1,
        "107": M1,
        "160": M0,
        "165": [0, 0.675, 0.025, 0],
        "174": [0.15559, 0.69224, 0, 0],
        "240": M1,
        "295": M1,
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.9, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.9, 0, 0],
        "989": M23,
        "1008": [0, 0.43056, 0.04028, 0],
        "8245": [0, 0.54986, 0, 0],
        "8463": M1,
        "8487": M1,
        "8498": M1,
        "8502": M1,
        "8503": M1,
        "8504": M1,
        "8513": M1,
        "8592": [-0.03598, 0.46402, 0, 0],
        "8594": [-0.03598, 0.46402, 0, 0],
        "8602": [-0.13313, 0.36687, 0, 0],
        "8603": [-0.13313, 0.36687, 0, 0],
        "8606": [0.01354, 0.52239, 0, 0],
        "8608": [0.01354, 0.52239, 0, 0],
        "8610": [0.01354, 0.52239, 0, 0],
        "8611": [0.01354, 0.52239, 0, 0],
        "8619": [0, 0.54986, 0, 0],
        "8620": [0, 0.54986, 0, 0],
        "8621": [-0.13313, 0.37788, 0, 0],
        "8622": [-0.13313, 0.36687, 0, 0],
        "8624": M3,
        "8625": M3,
        "8630": [0, 0.43056, 0, 0],
        "8631": [0, 0.43056, 0, 0],
        "8634": [0.08198, 0.58198, 0, 0],
        "8635": [0.08198, 0.58198, 0, 0],
        "8638": [0.19444, 0.69224, 0, 0],
        "8639": [0.19444, 0.69224, 0, 0],
        "8642": [0.19444, 0.69224, 0, 0],
        "8643": [0.19444, 0.69224, 0, 0],
        "8644": [0.1808, 0.675, 0, 0],
        "8646": [0.1808, 0.675, 0, 0],
        "8647": [0.1808, 0.675, 0, 0],
        "8648": [0.19444, 0.69224, 0, 0],
        "8649": [0.1808, 0.675, 0, 0],
        "8650": [0.19444, 0.69224, 0, 0],
        "8651": [0.01354, 0.52239, 0, 0],
        "8652": [0.01354, 0.52239, 0, 0],
        "8653": [-0.13313, 0.36687, 0, 0],
        "8654": [-0.13313, 0.36687, 0, 0],
        "8655": [-0.13313, 0.36687, 0, 0],
        "8666": [0.13667, 0.63667, 0, 0],
        "8667": [0.13667, 0.63667, 0, 0],
        "8669": [-0.13313, 0.37788, 0, 0],
        "8672": [-0.064, 0.437, 0, 0],
        "8674": [-0.064, 0.437, 0, 0],
        "8705": [0, 0.825, 0, 0],
        "8708": M1,
        "8709": M23,
        "8717": [0, 0.43056, 0, 0],
        "8722": [-0.03598, 0.46402, 0, 0],
        "8724": [0.08198, 0.69224, 0, 0],
        "8726": M23,
        "8733": M3,
        "8736": M3,
        "8737": M3,
        "8738": [0.03517, 0.52239, 0, 0],
        "8739": M23,
        "8740": [0.25142, 0.74111, 0, 0],
        "8741": M23,
        "8742": [0.25142, 0.74111, 0, 0],
        "8756": M3,
        "8757": M3,
        "8764": [-0.13313, 0.36687, 0, 0],
        "8765": [-0.13313, 0.37788, 0, 0],
        "8769": [-0.13313, 0.36687, 0, 0],
        "8770": [-0.03625, 0.46375, 0, 0],
        "8774": [0.30274, 0.79383, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8778": M23,
        "8782": [0.06062, 0.54986, 0, 0],
        "8783": [0.06062, 0.54986, 0, 0],
        "8785": [0.08198, 0.58198, 0, 0],
        "8786": [0.08198, 0.58198, 0, 0],
        "8787": [0.08198, 0.58198, 0, 0],
        "8790": M3,
        "8791": [0.22958, 0.72958, 0, 0],
        "8796": [0.08198, 0.91667, 0, 0],
        "8806": [0.25583, 0.75583, 0, 0],
        "8807": [0.25583, 0.75583, 0, 0],
        "8808": [0.25142, 0.75726, 0, 0],
        "8809": [0.25142, 0.75726, 0, 0],
        "8812": [0.25583, 0.75583, 0, 0],
        "8814": [0.20576, 0.70576, 0, 0],
        "8815": [0.20576, 0.70576, 0, 0],
        "8816": [0.30274, 0.79383, 0, 0],
        "8817": [0.30274, 0.79383, 0, 0],
        "8818": [0.22958, 0.72958, 0, 0],
        "8819": [0.22958, 0.72958, 0, 0],
        "8822": [0.1808, 0.675, 0, 0],
        "8823": [0.1808, 0.675, 0, 0],
        "8828": [0.13667, 0.63667, 0, 0],
        "8829": [0.13667, 0.63667, 0, 0],
        "8830": [0.22958, 0.72958, 0, 0],
        "8831": [0.22958, 0.72958, 0, 0],
        "8832": [0.20576, 0.70576, 0, 0],
        "8833": [0.20576, 0.70576, 0, 0],
        "8840": [0.30274, 0.79383, 0, 0],
        "8841": [0.30274, 0.79383, 0, 0],
        "8842": [0.13597, 0.63597, 0, 0],
        "8843": [0.13597, 0.63597, 0, 0],
        "8847": [0.03517, 0.54986, 0, 0],
        "8848": [0.03517, 0.54986, 0, 0],
        "8858": [0.08198, 0.58198, 0, 0],
        "8859": [0.08198, 0.58198, 0, 0],
        "8861": [0.08198, 0.58198, 0, 0],
        "8862": [0, 0.675, 0, 0],
        "8863": [0, 0.675, 0, 0],
        "8864": [0, 0.675, 0, 0],
        "8865": [0, 0.675, 0, 0],
        "8872": M3,
        "8873": M3,
        "8874": M3,
        "8876": M1,
        "8877": M1,
        "8878": M1,
        "8879": M1,
        "8882": [0.03517, 0.54986, 0, 0],
        "8883": [0.03517, 0.54986, 0, 0],
        "8884": [0.13667, 0.63667, 0, 0],
        "8885": [0.13667, 0.63667, 0, 0],
        "8888": [0, 0.54986, 0, 0],
        "8890": [0.19444, 0.43056, 0, 0],
        "8891": [0.19444, 0.69224, 0, 0],
        "8892": [0.19444, 0.69224, 0, 0],
        "8901": [0, 0.54986, 0, 0],
        "8903": M23,
        "8905": M23,
        "8906": M23,
        "8907": M3,
        "8908": M3,
        "8909": [-0.03598, 0.46402, 0, 0],
        "8910": [0, 0.54986, 0, 0],
        "8911": [0, 0.54986, 0, 0],
        "8912": [0.03517, 0.54986, 0, 0],
        "8913": [0.03517, 0.54986, 0, 0],
        "8914": [0, 0.54986, 0, 0],
        "8915": [0, 0.54986, 0, 0],
        "8916": M3,
        "8918": [0.0391, 0.5391, 0, 0],
        "8919": [0.0391, 0.5391, 0, 0],
        "8920": [0.03517, 0.54986, 0, 0],
        "8921": [0.03517, 0.54986, 0, 0],
        "8922": [0.38569, 0.88569, 0, 0],
        "8923": [0.38569, 0.88569, 0, 0],
        "8926": [0.13667, 0.63667, 0, 0],
        "8927": [0.13667, 0.63667, 0, 0],
        "8928": [0.30274, 0.79383, 0, 0],
        "8929": [0.30274, 0.79383, 0, 0],
        "8934": [0.23222, 0.74111, 0, 0],
        "8935": [0.23222, 0.74111, 0, 0],
        "8936": [0.23222, 0.74111, 0, 0],
        "8937": [0.23222, 0.74111, 0, 0],
        "8938": [0.20576, 0.70576, 0, 0],
        "8939": [0.20576, 0.70576, 0, 0],
        "8940": [0.30274, 0.79383, 0, 0],
        "8941": [0.30274, 0.79383, 0, 0],
        "8994": [0.19444, 0.69224, 0, 0],
        "8995": [0.19444, 0.69224, 0, 0],
        "9416": [0.15559, 0.69224, 0, 0],
        "9484": M3,
        "9488": M3,
        "9492": [0, 0.37788, 0, 0],
        "9496": [0, 0.37788, 0, 0],
        "9585": [0.19444, 0.68889, 0, 0],
        "9586": [0.19444, 0.74111, 0, 0],
        "9632": [0, 0.675, 0, 0],
        "9633": [0, 0.675, 0, 0],
        "9650": [0, 0.54986, 0, 0],
        "9651": [0, 0.54986, 0, 0],
        "9654": [0.03517, 0.54986, 0, 0],
        "9660": [0, 0.54986, 0, 0],
        "9661": [0, 0.54986, 0, 0],
        "9664": [0.03517, 0.54986, 0, 0],
        "9674": [0.11111, 0.69224, 0, 0],
        "9733": [0.19444, 0.69224, 0, 0],
        "10003": M3,
        "10016": M3,
        "10731": [0.11111, 0.69224, 0, 0],
        "10846": [0.19444, 0.75583, 0, 0],
        "10877": [0.13667, 0.63667, 0, 0],
        "10878": [0.13667, 0.63667, 0, 0],
        "10885": [0.25583, 0.75583, 0, 0],
        "10886": [0.25583, 0.75583, 0, 0],
        "10887": [0.13597, 0.63597, 0, 0],
        "10888": [0.13597, 0.63597, 0, 0],
        "10889": [0.26167, 0.75726, 0, 0],
        "10890": [0.26167, 0.75726, 0, 0],
        "10891": [0.48256, 0.98256, 0, 0],
        "10892": [0.48256, 0.98256, 0, 0],
        "10901": [0.13667, 0.63667, 0, 0],
        "10902": [0.13667, 0.63667, 0, 0],
        "10933": [0.25142, 0.75726, 0, 0],
        "10934": [0.25142, 0.75726, 0, 0],
        "10935": [0.26167, 0.75726, 0, 0],
        "10936": [0.26167, 0.75726, 0, 0],
        "10937": [0.26167, 0.75726, 0, 0],
        "10938": [0.26167, 0.75726, 0, 0],
        "10949": [0.25583, 0.75583, 0, 0],
        "10950": [0.25583, 0.75583, 0, 0],
        "10955": [0.28481, 0.79383, 0, 0],
        "10956": [0.28481, 0.79383, 0, 0],
        "57350": M23,
        "57351": M23,
        "57352": M23,
        "57353": [0, 0.43056, 0.04028, 0],
        "57356": [0.25142, 0.75726, 0, 0],
        "57357": [0.25142, 0.75726, 0, 0],
        "57358": [0.41951, 0.91951, 0, 0],
        "57359": [0.30274, 0.79383, 0, 0],
        "57360": [0.30274, 0.79383, 0, 0],
        "57361": [0.41951, 0.91951, 0, 0],
        "57366": [0.25142, 0.75726, 0, 0],
        "57367": [0.25142, 0.75726, 0, 0],
        "57368": [0.25142, 0.75726, 0, 0],
        "57369": [0.25142, 0.75726, 0, 0],
        "57370": [0.13597, 0.63597, 0, 0],
        "57371": [0.13597, 0.63597, 0, 0]
      },
      "Caligraphic-Regular": {
        "32": M0,
        "65": [0, 0.68333, 0, 0.19445],
        "66": [0, 0.68333, 0.03041, 0.13889],
        "67": [0, 0.68333, 0.05834, 0.13889],
        "68": [0, 0.68333, 0.02778, 0.08334],
        "69": [0, 0.68333, 0.08944, 0.11111],
        "70": [0, 0.68333, 0.09931, 0.11111],
        "71": [0.09722, 0.68333, 0.0593, 0.11111],
        "72": [0, 0.68333, 965e-5, 0.11111],
        "73": [0, 0.68333, 0.07382, 0],
        "74": [0.09722, 0.68333, 0.18472, 0.16667],
        "75": [0, 0.68333, 0.01445, 0.05556],
        "76": [0, 0.68333, 0, 0.13889],
        "77": [0, 0.68333, 0, 0.13889],
        "78": [0, 0.68333, 0.14736, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.11111],
        "80": [0, 0.68333, 0.08222, 0.08334],
        "81": [0.09722, 0.68333, 0, 0.11111],
        "82": [0, 0.68333, 0, 0.08334],
        "83": [0, 0.68333, 0.075, 0.13889],
        "84": [0, 0.68333, 0.25417, 0],
        "85": [0, 0.68333, 0.09931, 0.08334],
        "86": [0, 0.68333, 0.08222, 0],
        "87": [0, 0.68333, 0.08222, 0.08334],
        "88": [0, 0.68333, 0.14643, 0.13889],
        "89": [0.09722, 0.68333, 0.08222, 0.08334],
        "90": [0, 0.68333, 0.07944, 0.13889],
        "160": M0
      },
      "Fraktur-Regular": {
        "32": M0,
        "33": M21,
        "34": M21,
        "38": M21,
        "39": M21,
        "40": [0.24982, 0.74947, 0, 0],
        "41": [0.24982, 0.74947, 0, 0],
        "42": [0, 0.62119, 0, 0],
        "43": [0.08319, 0.58283, 0, 0],
        "44": [0, 0.10803, 0, 0],
        "45": [0.08319, 0.58283, 0, 0],
        "46": [0, 0.10803, 0, 0],
        "47": [0.24982, 0.74947, 0, 0],
        "48": M22,
        "49": M22,
        "50": M22,
        "51": [0.18906, 0.47534, 0, 0],
        "52": [0.18906, 0.47534, 0, 0],
        "53": [0.18906, 0.47534, 0, 0],
        "54": M21,
        "55": [0.18906, 0.47534, 0, 0],
        "56": M21,
        "57": [0.18906, 0.47534, 0, 0],
        "58": M22,
        "59": [0.12604, 0.47534, 0, 0],
        "61": [-0.13099, 0.36866, 0, 0],
        "63": M21,
        "65": M21,
        "66": M21,
        "67": M21,
        "68": M21,
        "69": M21,
        "70": [0.12604, 0.69141, 0, 0],
        "71": M21,
        "72": [0.06302, 0.69141, 0, 0],
        "73": M21,
        "74": [0.12604, 0.69141, 0, 0],
        "75": M21,
        "76": M21,
        "77": M21,
        "78": M21,
        "79": M21,
        "80": [0.18906, 0.69141, 0, 0],
        "81": [0.03781, 0.69141, 0, 0],
        "82": M21,
        "83": M21,
        "84": M21,
        "85": M21,
        "86": M21,
        "87": M21,
        "88": M21,
        "89": [0.18906, 0.69141, 0, 0],
        "90": [0.12604, 0.69141, 0, 0],
        "91": [0.24982, 0.74947, 0, 0],
        "93": [0.24982, 0.74947, 0, 0],
        "94": M21,
        "97": M22,
        "98": M21,
        "99": M22,
        "100": [0, 0.62119, 0, 0],
        "101": M22,
        "102": [0.18906, 0.69141, 0, 0],
        "103": [0.18906, 0.47534, 0, 0],
        "104": [0.18906, 0.69141, 0, 0],
        "105": M21,
        "106": M21,
        "107": M21,
        "108": M21,
        "109": M22,
        "110": M22,
        "111": M22,
        "112": [0.18906, 0.52396, 0, 0],
        "113": [0.18906, 0.47534, 0, 0],
        "114": M22,
        "115": M22,
        "116": [0, 0.62119, 0, 0],
        "117": M22,
        "118": [0, 0.52396, 0, 0],
        "119": [0, 0.52396, 0, 0],
        "120": [0.18906, 0.47534, 0, 0],
        "121": [0.18906, 0.47534, 0, 0],
        "122": [0.18906, 0.47534, 0, 0],
        "160": M0,
        "8216": M21,
        "8217": M21,
        "58112": [0, 0.62119, 0, 0],
        "58113": [0, 0.62119, 0, 0],
        "58114": [0.18906, 0.69141, 0, 0],
        "58115": [0.18906, 0.69141, 0, 0],
        "58116": [0.18906, 0.47534, 0, 0],
        "58117": M21,
        "58118": [0, 0.62119, 0, 0],
        "58119": M22
      },
      "Main-Bold": {
        "32": M0,
        "33": M6,
        "34": M6,
        "35": M16,
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": M6,
        "39": M6,
        "40": M15,
        "41": M15,
        "42": M14,
        "43": [0.13333, 0.63333, 0, 0],
        "44": [0.19444, 0.15556, 0, 0],
        "45": M7,
        "46": [0, 0.15556, 0, 0],
        "47": M15,
        "48": M5,
        "49": M5,
        "50": M5,
        "51": M5,
        "52": M5,
        "53": M5,
        "54": M5,
        "55": M5,
        "56": M5,
        "57": M5,
        "58": M7,
        "59": M8,
        "60": [0.08556, 0.58556, 0, 0],
        "61": [-0.10889, 0.39111, 0, 0],
        "62": [0.08556, 0.58556, 0, 0],
        "63": M6,
        "64": M6,
        "65": M4,
        "66": M4,
        "67": M4,
        "68": M4,
        "69": M4,
        "70": M4,
        "71": M4,
        "72": M4,
        "73": M4,
        "74": M4,
        "75": M4,
        "76": M4,
        "77": M4,
        "78": M4,
        "79": M4,
        "80": M4,
        "81": [0.19444, 0.68611, 0, 0],
        "82": M4,
        "83": M4,
        "84": M4,
        "85": M4,
        "86": [0, 0.68611, 0.01597, 0],
        "87": [0, 0.68611, 0.01597, 0],
        "88": M4,
        "89": [0, 0.68611, 0.02875, 0],
        "90": M4,
        "91": M15,
        "92": M15,
        "93": M15,
        "94": M6,
        "95": [0.31, 0.13444, 0.03194, 0],
        "97": M7,
        "98": M6,
        "99": M7,
        "100": M6,
        "101": M7,
        "102": [0, 0.69444, 0.10903, 0],
        "103": [0.19444, 0.44444, 0.01597, 0],
        "104": M6,
        "105": M6,
        "106": M16,
        "107": M6,
        "108": M6,
        "109": M7,
        "110": M7,
        "111": M7,
        "112": M8,
        "113": M8,
        "114": M7,
        "115": M7,
        "116": [0, 0.63492, 0, 0],
        "117": M7,
        "118": [0, 0.44444, 0.01597, 0],
        "119": [0, 0.44444, 0.01597, 0],
        "120": M7,
        "121": [0.19444, 0.44444, 0.01597, 0],
        "122": M7,
        "123": M15,
        "124": M15,
        "125": M15,
        "126": [0.35, 0.34444, 0, 0],
        "160": M0,
        "163": M6,
        "168": M6,
        "172": M7,
        "176": M6,
        "177": [0.13333, 0.63333, 0, 0],
        "184": [0.17014, 0, 0, 0],
        "198": M4,
        "215": [0.13333, 0.63333, 0, 0],
        "216": [0.04861, 0.73472, 0, 0],
        "223": M6,
        "230": M7,
        "247": [0.13333, 0.63333, 0, 0],
        "248": [0.09722, 0.54167, 0, 0],
        "305": M7,
        "338": M4,
        "339": M7,
        "567": M8,
        "710": M6,
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.59611, 0, 0],
        "714": M6,
        "715": M6,
        "728": M6,
        "729": M6,
        "730": M6,
        "732": M6,
        "733": M6,
        "915": M4,
        "916": M4,
        "920": M4,
        "923": M4,
        "926": M4,
        "928": M4,
        "931": M4,
        "933": M4,
        "934": M4,
        "936": M4,
        "937": M4,
        "8211": [0, 0.44444, 0.03194, 0],
        "8212": [0, 0.44444, 0.03194, 0],
        "8216": M6,
        "8217": M6,
        "8220": M6,
        "8221": M6,
        "8224": M16,
        "8225": M16,
        "8242": M20,
        "8407": [0, 0.72444, 0.15486, 0],
        "8463": M6,
        "8465": M6,
        "8467": M6,
        "8472": M8,
        "8476": M6,
        "8501": M6,
        "8592": [-0.10889, 0.39111, 0, 0],
        "8593": M16,
        "8594": [-0.10889, 0.39111, 0, 0],
        "8595": M16,
        "8596": [-0.10889, 0.39111, 0, 0],
        "8597": M15,
        "8598": M16,
        "8599": M16,
        "8600": M16,
        "8601": M16,
        "8636": [-0.10889, 0.39111, 0, 0],
        "8637": [-0.10889, 0.39111, 0, 0],
        "8640": [-0.10889, 0.39111, 0, 0],
        "8641": [-0.10889, 0.39111, 0, 0],
        "8656": [-0.10889, 0.39111, 0, 0],
        "8657": M16,
        "8658": [-0.10889, 0.39111, 0, 0],
        "8659": M16,
        "8660": [-0.10889, 0.39111, 0, 0],
        "8661": M15,
        "8704": M6,
        "8706": [0, 0.69444, 0.06389, 0],
        "8707": M6,
        "8709": [0.05556, 0.75, 0, 0],
        "8711": M4,
        "8712": [0.08556, 0.58556, 0, 0],
        "8715": [0.08556, 0.58556, 0, 0],
        "8722": [0.13333, 0.63333, 0, 0],
        "8723": [0.13333, 0.63333, 0, 0],
        "8725": M15,
        "8726": M15,
        "8727": [-0.02778, 0.47222, 0, 0],
        "8728": [-0.02639, 0.47361, 0, 0],
        "8729": [-0.02639, 0.47361, 0, 0],
        "8730": [0.18, 0.82, 0, 0],
        "8733": M7,
        "8734": M7,
        "8736": M3,
        "8739": M15,
        "8741": M15,
        "8743": M20,
        "8744": M20,
        "8745": M20,
        "8746": M20,
        "8747": [0.19444, 0.69444, 0.12778, 0],
        "8764": [-0.10889, 0.39111, 0, 0],
        "8768": M16,
        "8771": [222e-5, 0.50222, 0, 0],
        "8776": [0.02444, 0.52444, 0, 0],
        "8781": [222e-5, 0.50222, 0, 0],
        "8801": [222e-5, 0.50222, 0, 0],
        "8804": [0.19667, 0.69667, 0, 0],
        "8805": [0.19667, 0.69667, 0, 0],
        "8810": [0.08556, 0.58556, 0, 0],
        "8811": [0.08556, 0.58556, 0, 0],
        "8826": [0.08556, 0.58556, 0, 0],
        "8827": [0.08556, 0.58556, 0, 0],
        "8834": [0.08556, 0.58556, 0, 0],
        "8835": [0.08556, 0.58556, 0, 0],
        "8838": [0.19667, 0.69667, 0, 0],
        "8839": [0.19667, 0.69667, 0, 0],
        "8846": M20,
        "8849": [0.19667, 0.69667, 0, 0],
        "8850": [0.19667, 0.69667, 0, 0],
        "8851": M20,
        "8852": M20,
        "8853": [0.13333, 0.63333, 0, 0],
        "8854": [0.13333, 0.63333, 0, 0],
        "8855": [0.13333, 0.63333, 0, 0],
        "8856": [0.13333, 0.63333, 0, 0],
        "8857": [0.13333, 0.63333, 0, 0],
        "8866": M6,
        "8867": M6,
        "8868": M6,
        "8869": M6,
        "8900": [-0.02639, 0.47361, 0, 0],
        "8901": [-0.02639, 0.47361, 0, 0],
        "8902": [-0.02778, 0.47222, 0, 0],
        "8968": M15,
        "8969": M15,
        "8970": M15,
        "8971": M15,
        "8994": [-0.13889, 0.36111, 0, 0],
        "8995": [-0.13889, 0.36111, 0, 0],
        "9651": M16,
        "9657": [-0.02778, 0.47222, 0, 0],
        "9661": M16,
        "9667": [-0.02778, 0.47222, 0, 0],
        "9711": M16,
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": M14,
        "9838": M16,
        "9839": M16,
        "10216": M15,
        "10217": M15,
        "10815": M4,
        "10927": [0.19667, 0.69667, 0, 0],
        "10928": [0.19667, 0.69667, 0, 0],
        "57376": M16
      },
      "Main-BoldItalic": {
        "32": M0,
        "33": [0, 0.69444, 0.11417, 0],
        "34": [0, 0.69444, 0.07939, 0],
        "35": [0.19444, 0.69444, 0.06833, 0],
        "37": [0.05556, 0.75, 0.12861, 0],
        "38": [0, 0.69444, 0.08528, 0],
        "39": [0, 0.69444, 0.12945, 0],
        "40": [0.25, 0.75, 0.15806, 0],
        "41": [0.25, 0.75, 0.03306, 0],
        "42": [0, 0.75, 0.14333, 0],
        "43": [0.10333, 0.60333, 0.03306, 0],
        "44": [0.19444, 0.14722, 0, 0],
        "45": [0, 0.44444, 0.02611, 0],
        "46": [0, 0.14722, 0, 0],
        "47": [0.25, 0.75, 0.15806, 0],
        "48": [0, 0.64444, 0.13167, 0],
        "49": [0, 0.64444, 0.13167, 0],
        "50": [0, 0.64444, 0.13167, 0],
        "51": [0, 0.64444, 0.13167, 0],
        "52": [0.19444, 0.64444, 0.13167, 0],
        "53": [0, 0.64444, 0.13167, 0],
        "54": [0, 0.64444, 0.13167, 0],
        "55": [0.19444, 0.64444, 0.13167, 0],
        "56": [0, 0.64444, 0.13167, 0],
        "57": [0, 0.64444, 0.13167, 0],
        "58": [0, 0.44444, 0.06695, 0],
        "59": [0.19444, 0.44444, 0.06695, 0],
        "61": [-0.10889, 0.39111, 0.06833, 0],
        "63": [0, 0.69444, 0.11472, 0],
        "64": [0, 0.69444, 0.09208, 0],
        "65": M4,
        "66": [0, 0.68611, 0.0992, 0],
        "67": [0, 0.68611, 0.14208, 0],
        "68": [0, 0.68611, 0.09062, 0],
        "69": [0, 0.68611, 0.11431, 0],
        "70": [0, 0.68611, 0.12903, 0],
        "71": [0, 0.68611, 0.07347, 0],
        "72": [0, 0.68611, 0.17208, 0],
        "73": [0, 0.68611, 0.15681, 0],
        "74": [0, 0.68611, 0.145, 0],
        "75": [0, 0.68611, 0.14208, 0],
        "76": M4,
        "77": [0, 0.68611, 0.17208, 0],
        "78": [0, 0.68611, 0.17208, 0],
        "79": [0, 0.68611, 0.09062, 0],
        "80": [0, 0.68611, 0.0992, 0],
        "81": [0.19444, 0.68611, 0.09062, 0],
        "82": [0, 0.68611, 0.02559, 0],
        "83": [0, 0.68611, 0.11264, 0],
        "84": [0, 0.68611, 0.12903, 0],
        "85": [0, 0.68611, 0.17208, 0],
        "86": [0, 0.68611, 0.18625, 0],
        "87": [0, 0.68611, 0.18625, 0],
        "88": [0, 0.68611, 0.15681, 0],
        "89": [0, 0.68611, 0.19803, 0],
        "90": [0, 0.68611, 0.14208, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.09972, 0],
        "94": [0, 0.69444, 0.06709, 0],
        "95": [0.31, 0.13444, 0.09811, 0],
        "97": [0, 0.44444, 0.09426, 0],
        "98": [0, 0.69444, 0.07861, 0],
        "99": [0, 0.44444, 0.05222, 0],
        "100": [0, 0.69444, 0.10861, 0],
        "101": [0, 0.44444, 0.085, 0],
        "102": [0.19444, 0.69444, 0.21778, 0],
        "103": [0.19444, 0.44444, 0.105, 0],
        "104": [0, 0.69444, 0.09426, 0],
        "105": [0, 0.69326, 0.11387, 0],
        "106": [0.19444, 0.69326, 0.1672, 0],
        "107": [0, 0.69444, 0.11111, 0],
        "108": [0, 0.69444, 0.10861, 0],
        "109": [0, 0.44444, 0.09426, 0],
        "110": [0, 0.44444, 0.09426, 0],
        "111": [0, 0.44444, 0.07861, 0],
        "112": [0.19444, 0.44444, 0.07861, 0],
        "113": [0.19444, 0.44444, 0.105, 0],
        "114": [0, 0.44444, 0.11111, 0],
        "115": [0, 0.44444, 0.08167, 0],
        "116": [0, 0.63492, 0.09639, 0],
        "117": [0, 0.44444, 0.09426, 0],
        "118": [0, 0.44444, 0.11111, 0],
        "119": [0, 0.44444, 0.11111, 0],
        "120": [0, 0.44444, 0.12583, 0],
        "121": [0.19444, 0.44444, 0.105, 0],
        "122": [0, 0.44444, 0.13889, 0],
        "126": [0.35, 0.34444, 0.11472, 0],
        "160": M0,
        "168": [0, 0.69444, 0.11473, 0],
        "176": M6,
        "184": [0.17014, 0, 0, 0],
        "198": [0, 0.68611, 0.11431, 0],
        "216": [0.04861, 0.73472, 0.09062, 0],
        "223": [0.19444, 0.69444, 0.09736, 0],
        "230": [0, 0.44444, 0.085, 0],
        "248": [0.09722, 0.54167, 0.09458, 0],
        "305": [0, 0.44444, 0.09426, 0],
        "338": [0, 0.68611, 0.11431, 0],
        "339": [0, 0.44444, 0.085, 0],
        "567": [0.19444, 0.44444, 0.04611, 0],
        "710": [0, 0.69444, 0.06709, 0],
        "711": [0, 0.63194, 0.08271, 0],
        "713": [0, 0.59444, 0.10444, 0],
        "714": [0, 0.69444, 0.08528, 0],
        "715": M6,
        "728": [0, 0.69444, 0.10333, 0],
        "729": [0, 0.69444, 0.12945, 0],
        "730": M6,
        "732": [0, 0.69444, 0.11472, 0],
        "733": [0, 0.69444, 0.11472, 0],
        "915": [0, 0.68611, 0.12903, 0],
        "916": M4,
        "920": [0, 0.68611, 0.09062, 0],
        "923": M4,
        "926": [0, 0.68611, 0.15092, 0],
        "928": [0, 0.68611, 0.17208, 0],
        "931": [0, 0.68611, 0.11431, 0],
        "933": [0, 0.68611, 0.10778, 0],
        "934": [0, 0.68611, 0.05632, 0],
        "936": [0, 0.68611, 0.10778, 0],
        "937": [0, 0.68611, 0.0992, 0],
        "8211": [0, 0.44444, 0.09811, 0],
        "8212": [0, 0.44444, 0.09811, 0],
        "8216": [0, 0.69444, 0.12945, 0],
        "8217": [0, 0.69444, 0.12945, 0],
        "8220": [0, 0.69444, 0.16772, 0],
        "8221": [0, 0.69444, 0.07939, 0]
      },
      "Main-Italic": {
        "32": M0,
        "33": [0, 0.69444, 0.12417, 0],
        "34": [0, 0.69444, 0.06961, 0],
        "35": [0.19444, 0.69444, 0.06616, 0],
        "37": [0.05556, 0.75, 0.13639, 0],
        "38": [0, 0.69444, 0.09694, 0],
        "39": [0, 0.69444, 0.12417, 0],
        "40": [0.25, 0.75, 0.16194, 0],
        "41": [0.25, 0.75, 0.03694, 0],
        "42": [0, 0.75, 0.14917, 0],
        "43": [0.05667, 0.56167, 0.03694, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0.02826, 0],
        "46": [0, 0.10556, 0, 0],
        "47": [0.25, 0.75, 0.16194, 0],
        "48": [0, 0.64444, 0.13556, 0],
        "49": [0, 0.64444, 0.13556, 0],
        "50": [0, 0.64444, 0.13556, 0],
        "51": [0, 0.64444, 0.13556, 0],
        "52": [0.19444, 0.64444, 0.13556, 0],
        "53": [0, 0.64444, 0.13556, 0],
        "54": [0, 0.64444, 0.13556, 0],
        "55": [0.19444, 0.64444, 0.13556, 0],
        "56": [0, 0.64444, 0.13556, 0],
        "57": [0, 0.64444, 0.13556, 0],
        "58": [0, 0.43056, 0.0582, 0],
        "59": [0.19444, 0.43056, 0.0582, 0],
        "61": [-0.13313, 0.36687, 0.06616, 0],
        "63": [0, 0.69444, 0.1225, 0],
        "64": [0, 0.69444, 0.09597, 0],
        "65": M9,
        "66": [0, 0.68333, 0.10257, 0],
        "67": [0, 0.68333, 0.14528, 0],
        "68": [0, 0.68333, 0.09403, 0],
        "69": [0, 0.68333, 0.12028, 0],
        "70": [0, 0.68333, 0.13305, 0],
        "71": [0, 0.68333, 0.08722, 0],
        "72": [0, 0.68333, 0.16389, 0],
        "73": [0, 0.68333, 0.15806, 0],
        "74": [0, 0.68333, 0.14028, 0],
        "75": [0, 0.68333, 0.14528, 0],
        "76": M9,
        "77": [0, 0.68333, 0.16389, 0],
        "78": [0, 0.68333, 0.16389, 0],
        "79": [0, 0.68333, 0.09403, 0],
        "80": [0, 0.68333, 0.10257, 0],
        "81": [0.19444, 0.68333, 0.09403, 0],
        "82": [0, 0.68333, 0.03868, 0],
        "83": [0, 0.68333, 0.11972, 0],
        "84": [0, 0.68333, 0.13305, 0],
        "85": [0, 0.68333, 0.16389, 0],
        "86": [0, 0.68333, 0.18361, 0],
        "87": [0, 0.68333, 0.18361, 0],
        "88": [0, 0.68333, 0.15806, 0],
        "89": [0, 0.68333, 0.19383, 0],
        "90": [0, 0.68333, 0.14528, 0],
        "91": [0.25, 0.75, 0.1875, 0],
        "93": [0.25, 0.75, 0.10528, 0],
        "94": [0, 0.69444, 0.06646, 0],
        "95": [0.31, 0.12056, 0.09208, 0],
        "97": [0, 0.43056, 0.07671, 0],
        "98": [0, 0.69444, 0.06312, 0],
        "99": [0, 0.43056, 0.05653, 0],
        "100": [0, 0.69444, 0.10333, 0],
        "101": [0, 0.43056, 0.07514, 0],
        "102": [0.19444, 0.69444, 0.21194, 0],
        "103": [0.19444, 0.43056, 0.08847, 0],
        "104": [0, 0.69444, 0.07671, 0],
        "105": [0, 0.65536, 0.1019, 0],
        "106": [0.19444, 0.65536, 0.14467, 0],
        "107": [0, 0.69444, 0.10764, 0],
        "108": [0, 0.69444, 0.10333, 0],
        "109": [0, 0.43056, 0.07671, 0],
        "110": [0, 0.43056, 0.07671, 0],
        "111": [0, 0.43056, 0.06312, 0],
        "112": [0.19444, 0.43056, 0.06312, 0],
        "113": [0.19444, 0.43056, 0.08847, 0],
        "114": [0, 0.43056, 0.10764, 0],
        "115": [0, 0.43056, 0.08208, 0],
        "116": [0, 0.61508, 0.09486, 0],
        "117": [0, 0.43056, 0.07671, 0],
        "118": [0, 0.43056, 0.10764, 0],
        "119": [0, 0.43056, 0.10764, 0],
        "120": [0, 0.43056, 0.12042, 0],
        "121": [0.19444, 0.43056, 0.08847, 0],
        "122": [0, 0.43056, 0.12292, 0],
        "126": [0.35, 0.31786, 0.11585, 0],
        "160": M0,
        "168": [0, 0.66786, 0.10474, 0],
        "176": M6,
        "184": [0.17014, 0, 0, 0],
        "198": [0, 0.68333, 0.12028, 0],
        "216": [0.04861, 0.73194, 0.09403, 0],
        "223": [0.19444, 0.69444, 0.10514, 0],
        "230": [0, 0.43056, 0.07514, 0],
        "248": [0.09722, 0.52778, 0.09194, 0],
        "338": [0, 0.68333, 0.12028, 0],
        "339": [0, 0.43056, 0.07514, 0],
        "710": [0, 0.69444, 0.06646, 0],
        "711": [0, 0.62847, 0.08295, 0],
        "713": [0, 0.56167, 0.10333, 0],
        "714": [0, 0.69444, 0.09694, 0],
        "715": M6,
        "728": [0, 0.69444, 0.10806, 0],
        "729": [0, 0.66786, 0.11752, 0],
        "730": M6,
        "732": [0, 0.66786, 0.11585, 0],
        "733": [0, 0.69444, 0.1225, 0],
        "915": [0, 0.68333, 0.13305, 0],
        "916": M9,
        "920": [0, 0.68333, 0.09403, 0],
        "923": M9,
        "926": [0, 0.68333, 0.15294, 0],
        "928": [0, 0.68333, 0.16389, 0],
        "931": [0, 0.68333, 0.12028, 0],
        "933": [0, 0.68333, 0.11111, 0],
        "934": [0, 0.68333, 0.05986, 0],
        "936": [0, 0.68333, 0.11111, 0],
        "937": [0, 0.68333, 0.10257, 0],
        "8211": [0, 0.43056, 0.09208, 0],
        "8212": [0, 0.43056, 0.09208, 0],
        "8216": [0, 0.69444, 0.12417, 0],
        "8217": [0, 0.69444, 0.12417, 0],
        "8220": [0, 0.69444, 0.1685, 0],
        "8221": [0, 0.69444, 0.06961, 0],
        "8463": M1
      },
      "Main-Regular": {
        "32": M0,
        "33": M6,
        "34": M6,
        "35": M16,
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": M6,
        "39": M6,
        "40": M15,
        "41": M15,
        "42": M14,
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.19444, 0.10556, 0, 0],
        "45": [0, 0.43056, 0, 0],
        "46": [0, 0.10556, 0, 0],
        "47": M15,
        "48": M5,
        "49": M5,
        "50": M5,
        "51": M5,
        "52": M5,
        "53": M5,
        "54": M5,
        "55": M5,
        "56": M5,
        "57": M5,
        "58": [0, 0.43056, 0, 0],
        "59": [0.19444, 0.43056, 0, 0],
        "60": [0.0391, 0.5391, 0, 0],
        "61": [-0.13313, 0.36687, 0, 0],
        "62": [0.0391, 0.5391, 0, 0],
        "63": M6,
        "64": M6,
        "65": M9,
        "66": M9,
        "67": M9,
        "68": M9,
        "69": M9,
        "70": M9,
        "71": M9,
        "72": M9,
        "73": M9,
        "74": M9,
        "75": M9,
        "76": M9,
        "77": M9,
        "78": M9,
        "79": M9,
        "80": M9,
        "81": [0.19444, 0.68333, 0, 0],
        "82": M9,
        "83": M9,
        "84": M9,
        "85": M9,
        "86": [0, 0.68333, 0.01389, 0],
        "87": [0, 0.68333, 0.01389, 0],
        "88": M9,
        "89": [0, 0.68333, 0.025, 0],
        "90": M9,
        "91": M15,
        "92": M15,
        "93": M15,
        "94": M6,
        "95": [0.31, 0.12056, 0.02778, 0],
        "97": [0, 0.43056, 0, 0],
        "98": M6,
        "99": [0, 0.43056, 0, 0],
        "100": M6,
        "101": [0, 0.43056, 0, 0],
        "102": [0, 0.69444, 0.07778, 0],
        "103": [0.19444, 0.43056, 0.01389, 0],
        "104": M6,
        "105": [0, 0.66786, 0, 0],
        "106": [0.19444, 0.66786, 0, 0],
        "107": M6,
        "108": M6,
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.19444, 0.43056, 0, 0],
        "113": [0.19444, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.61508, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0.01389, 0],
        "119": [0, 0.43056, 0.01389, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.19444, 0.43056, 0.01389, 0],
        "122": [0, 0.43056, 0, 0],
        "123": M15,
        "124": M15,
        "125": M15,
        "126": [0.35, 0.31786, 0, 0],
        "160": M0,
        "163": M6,
        "167": M16,
        "168": [0, 0.66786, 0, 0],
        "172": [0, 0.43056, 0, 0],
        "176": M6,
        "177": [0.08333, 0.58333, 0, 0],
        "182": M16,
        "184": [0.17014, 0, 0, 0],
        "198": M9,
        "215": [0.08333, 0.58333, 0, 0],
        "216": [0.04861, 0.73194, 0, 0],
        "223": M6,
        "230": [0, 0.43056, 0, 0],
        "247": [0.08333, 0.58333, 0, 0],
        "248": [0.09722, 0.52778, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "338": M9,
        "339": [0, 0.43056, 0, 0],
        "567": [0.19444, 0.43056, 0, 0],
        "710": M6,
        "711": [0, 0.62847, 0, 0],
        "713": [0, 0.56778, 0, 0],
        "714": M6,
        "715": M6,
        "728": M6,
        "729": [0, 0.66786, 0, 0],
        "730": M6,
        "732": [0, 0.66786, 0, 0],
        "733": M6,
        "915": M9,
        "916": M9,
        "920": M9,
        "923": M9,
        "926": M9,
        "928": M9,
        "931": M9,
        "933": M9,
        "934": M9,
        "936": M9,
        "937": M9,
        "8211": [0, 0.43056, 0.02778, 0],
        "8212": [0, 0.43056, 0.02778, 0],
        "8216": M6,
        "8217": M6,
        "8220": M6,
        "8221": M6,
        "8224": M16,
        "8225": M16,
        "8230": [0, 0.12, 0, 0],
        "8242": M20,
        "8407": [0, 0.71444, 0.15382, 0],
        "8463": M1,
        "8465": M6,
        "8467": [0, 0.69444, 0, 0.11111],
        "8472": [0.19444, 0.43056, 0, 0.11111],
        "8476": M6,
        "8501": M6,
        "8592": [-0.13313, 0.36687, 0, 0],
        "8593": M16,
        "8594": [-0.13313, 0.36687, 0, 0],
        "8595": M16,
        "8596": [-0.13313, 0.36687, 0, 0],
        "8597": M15,
        "8598": M16,
        "8599": M16,
        "8600": M16,
        "8601": M16,
        "8614": [0.011, 0.511, 0, 0],
        "8617": [0.011, 0.511, 0, 0],
        "8618": [0.011, 0.511, 0, 0],
        "8636": [-0.13313, 0.36687, 0, 0],
        "8637": [-0.13313, 0.36687, 0, 0],
        "8640": [-0.13313, 0.36687, 0, 0],
        "8641": [-0.13313, 0.36687, 0, 0],
        "8652": [0.011, 0.671, 0, 0],
        "8656": [-0.13313, 0.36687, 0, 0],
        "8657": M16,
        "8658": [-0.13313, 0.36687, 0, 0],
        "8659": M16,
        "8660": [-0.13313, 0.36687, 0, 0],
        "8661": M15,
        "8704": M6,
        "8706": [0, 0.69444, 0.05556, 0.08334],
        "8707": M6,
        "8709": [0.05556, 0.75, 0, 0],
        "8711": M9,
        "8712": [0.0391, 0.5391, 0, 0],
        "8715": [0.0391, 0.5391, 0, 0],
        "8722": [0.08333, 0.58333, 0, 0],
        "8723": [0.08333, 0.58333, 0, 0],
        "8725": M15,
        "8726": M15,
        "8727": [-0.03472, 0.46528, 0, 0],
        "8728": [-0.05555, 0.44445, 0, 0],
        "8729": [-0.05555, 0.44445, 0, 0],
        "8730": [0.2, 0.8, 0, 0],
        "8733": [0, 0.43056, 0, 0],
        "8734": [0, 0.43056, 0, 0],
        "8736": M3,
        "8739": M15,
        "8741": M15,
        "8743": M20,
        "8744": M20,
        "8745": M20,
        "8746": M20,
        "8747": [0.19444, 0.69444, 0.11111, 0],
        "8764": [-0.13313, 0.36687, 0, 0],
        "8768": M16,
        "8771": [-0.03625, 0.46375, 0, 0],
        "8773": [-0.022, 0.589, 0, 0],
        "8776": [-0.01688, 0.48312, 0, 0],
        "8781": [-0.03625, 0.46375, 0, 0],
        "8784": [-0.133, 0.67, 0, 0],
        "8801": [-0.03625, 0.46375, 0, 0],
        "8804": [0.13597, 0.63597, 0, 0],
        "8805": [0.13597, 0.63597, 0, 0],
        "8810": [0.0391, 0.5391, 0, 0],
        "8811": [0.0391, 0.5391, 0, 0],
        "8826": [0.0391, 0.5391, 0, 0],
        "8827": [0.0391, 0.5391, 0, 0],
        "8834": [0.0391, 0.5391, 0, 0],
        "8835": [0.0391, 0.5391, 0, 0],
        "8838": [0.13597, 0.63597, 0, 0],
        "8839": [0.13597, 0.63597, 0, 0],
        "8846": M20,
        "8849": [0.13597, 0.63597, 0, 0],
        "8850": [0.13597, 0.63597, 0, 0],
        "8851": M20,
        "8852": M20,
        "8853": [0.08333, 0.58333, 0, 0],
        "8854": [0.08333, 0.58333, 0, 0],
        "8855": [0.08333, 0.58333, 0, 0],
        "8856": [0.08333, 0.58333, 0, 0],
        "8857": [0.08333, 0.58333, 0, 0],
        "8866": M6,
        "8867": M6,
        "8868": M6,
        "8869": M6,
        "8872": [0.249, 0.75, 0, 0],
        "8900": [-0.05555, 0.44445, 0, 0],
        "8901": [-0.05555, 0.44445, 0, 0],
        "8902": [-0.03472, 0.46528, 0, 0],
        "8904": [5e-3, 0.505, 0, 0],
        "8942": [0.03, 0.9, 0, 0],
        "8943": [-0.19, 0.31, 0, 0],
        "8945": [-0.1, 0.82, 0, 0],
        "8968": M15,
        "8969": M15,
        "8970": M15,
        "8971": M15,
        "8994": [-0.14236, 0.35764, 0, 0],
        "8995": [-0.14236, 0.35764, 0, 0],
        "9136": [0.244, 0.744, 0, 0],
        "9137": [0.244, 0.744, 0, 0],
        "9651": M16,
        "9657": [-0.03472, 0.46528, 0, 0],
        "9661": M16,
        "9667": [-0.03472, 0.46528, 0, 0],
        "9711": M16,
        "9824": [0.12963, 0.69444, 0, 0],
        "9825": [0.12963, 0.69444, 0, 0],
        "9826": [0.12963, 0.69444, 0, 0],
        "9827": [0.12963, 0.69444, 0, 0],
        "9837": M14,
        "9838": M16,
        "9839": M16,
        "10216": M15,
        "10217": M15,
        "10222": [0.244, 0.744, 0, 0],
        "10223": [0.244, 0.744, 0, 0],
        "10229": [0.011, 0.511, 0, 0],
        "10230": [0.011, 0.511, 0, 0],
        "10231": [0.011, 0.511, 0, 0],
        "10232": [0.024, 0.525, 0, 0],
        "10233": [0.024, 0.525, 0, 0],
        "10234": [0.024, 0.525, 0, 0],
        "10236": [0.011, 0.511, 0, 0],
        "10815": M9,
        "10927": [0.13597, 0.63597, 0, 0],
        "10928": [0.13597, 0.63597, 0, 0],
        "57376": M16
      },
      "Math-BoldItalic": {
        "32": M0,
        "48": M7,
        "49": M7,
        "50": M7,
        "51": M8,
        "52": M8,
        "53": M8,
        "54": M5,
        "55": M8,
        "56": M5,
        "57": M8,
        "65": M4,
        "66": [0, 0.68611, 0.04835, 0],
        "67": [0, 0.68611, 0.06979, 0],
        "68": [0, 0.68611, 0.03194, 0],
        "69": [0, 0.68611, 0.05451, 0],
        "70": [0, 0.68611, 0.15972, 0],
        "71": M4,
        "72": [0, 0.68611, 0.08229, 0],
        "73": [0, 0.68611, 0.07778, 0],
        "74": [0, 0.68611, 0.10069, 0],
        "75": [0, 0.68611, 0.06979, 0],
        "76": M4,
        "77": [0, 0.68611, 0.11424, 0],
        "78": [0, 0.68611, 0.11424, 0],
        "79": [0, 0.68611, 0.03194, 0],
        "80": [0, 0.68611, 0.15972, 0],
        "81": [0.19444, 0.68611, 0, 0],
        "82": [0, 0.68611, 421e-5, 0],
        "83": [0, 0.68611, 0.05382, 0],
        "84": [0, 0.68611, 0.15972, 0],
        "85": [0, 0.68611, 0.11424, 0],
        "86": [0, 0.68611, 0.25555, 0],
        "87": [0, 0.68611, 0.15972, 0],
        "88": [0, 0.68611, 0.07778, 0],
        "89": [0, 0.68611, 0.25555, 0],
        "90": [0, 0.68611, 0.06979, 0],
        "97": M7,
        "98": M6,
        "99": M7,
        "100": M6,
        "101": M7,
        "102": [0.19444, 0.69444, 0.11042, 0],
        "103": [0.19444, 0.44444, 0.03704, 0],
        "104": M6,
        "105": [0, 0.69326, 0, 0],
        "106": [0.19444, 0.69326, 0.0622, 0],
        "107": [0, 0.69444, 0.01852, 0],
        "108": [0, 0.69444, 88e-4, 0],
        "109": M7,
        "110": M7,
        "111": M7,
        "112": M8,
        "113": [0.19444, 0.44444, 0.03704, 0],
        "114": [0, 0.44444, 0.03194, 0],
        "115": M7,
        "116": [0, 0.63492, 0, 0],
        "117": M7,
        "118": [0, 0.44444, 0.03704, 0],
        "119": [0, 0.44444, 0.02778, 0],
        "120": M7,
        "121": [0.19444, 0.44444, 0.03704, 0],
        "122": [0, 0.44444, 0.04213, 0],
        "160": M0,
        "915": [0, 0.68611, 0.15972, 0],
        "916": M4,
        "920": [0, 0.68611, 0.03194, 0],
        "923": M4,
        "926": [0, 0.68611, 0.07458, 0],
        "928": [0, 0.68611, 0.08229, 0],
        "931": [0, 0.68611, 0.05451, 0],
        "933": [0, 0.68611, 0.15972, 0],
        "934": M4,
        "936": [0, 0.68611, 0.11653, 0],
        "937": [0, 0.68611, 0.04835, 0],
        "945": M7,
        "946": [0.19444, 0.69444, 0.03403, 0],
        "947": [0.19444, 0.44444, 0.06389, 0],
        "948": [0, 0.69444, 0.03819, 0],
        "949": M7,
        "950": [0.19444, 0.69444, 0.06215, 0],
        "951": [0.19444, 0.44444, 0.03704, 0],
        "952": [0, 0.69444, 0.03194, 0],
        "953": M7,
        "954": M7,
        "955": M6,
        "956": M8,
        "957": [0, 0.44444, 0.06898, 0],
        "958": [0.19444, 0.69444, 0.03021, 0],
        "959": M7,
        "960": [0, 0.44444, 0.03704, 0],
        "961": M8,
        "962": [0.09722, 0.44444, 0.07917, 0],
        "963": [0, 0.44444, 0.03704, 0],
        "964": [0, 0.44444, 0.13472, 0],
        "965": [0, 0.44444, 0.03704, 0],
        "966": M8,
        "967": M8,
        "968": [0.19444, 0.69444, 0.03704, 0],
        "969": [0, 0.44444, 0.03704, 0],
        "977": M6,
        "981": M16,
        "982": [0, 0.44444, 0.03194, 0],
        "1009": M8,
        "1013": M7,
        "57649": M7,
        "57911": M8
      },
      "Math-Italic": {
        "32": M0,
        "48": [0, 0.43056, 0, 0],
        "49": [0, 0.43056, 0, 0],
        "50": [0, 0.43056, 0, 0],
        "51": [0.19444, 0.43056, 0, 0],
        "52": [0.19444, 0.43056, 0, 0],
        "53": [0.19444, 0.43056, 0, 0],
        "54": M5,
        "55": [0.19444, 0.43056, 0, 0],
        "56": M5,
        "57": [0.19444, 0.43056, 0, 0],
        "65": [0, 0.68333, 0, 0.13889],
        "66": [0, 0.68333, 0.05017, 0.08334],
        "67": [0, 0.68333, 0.07153, 0.08334],
        "68": [0, 0.68333, 0.02778, 0.05556],
        "69": [0, 0.68333, 0.05764, 0.08334],
        "70": [0, 0.68333, 0.13889, 0.08334],
        "71": [0, 0.68333, 0, 0.08334],
        "72": [0, 0.68333, 0.08125, 0.05556],
        "73": [0, 0.68333, 0.07847, 0.11111],
        "74": [0, 0.68333, 0.09618, 0.16667],
        "75": [0, 0.68333, 0.07153, 0.05556],
        "76": [0, 0.68333, 0, 0.02778],
        "77": [0, 0.68333, 0.10903, 0.08334],
        "78": [0, 0.68333, 0.10903, 0.08334],
        "79": [0, 0.68333, 0.02778, 0.08334],
        "80": [0, 0.68333, 0.13889, 0.08334],
        "81": [0.19444, 0.68333, 0, 0.08334],
        "82": [0, 0.68333, 773e-5, 0.08334],
        "83": [0, 0.68333, 0.05764, 0.08334],
        "84": [0, 0.68333, 0.13889, 0.08334],
        "85": [0, 0.68333, 0.10903, 0.02778],
        "86": [0, 0.68333, 0.22222, 0],
        "87": [0, 0.68333, 0.13889, 0],
        "88": [0, 0.68333, 0.07847, 0.08334],
        "89": [0, 0.68333, 0.22222, 0],
        "90": [0, 0.68333, 0.07153, 0.08334],
        "97": [0, 0.43056, 0, 0],
        "98": M6,
        "99": [0, 0.43056, 0, 0.05556],
        "100": [0, 0.69444, 0, 0.16667],
        "101": [0, 0.43056, 0, 0.05556],
        "102": [0.19444, 0.69444, 0.10764, 0.16667],
        "103": [0.19444, 0.43056, 0.03588, 0.02778],
        "104": M6,
        "105": [0, 0.65952, 0, 0],
        "106": [0.19444, 0.65952, 0.05724, 0],
        "107": [0, 0.69444, 0.03148, 0],
        "108": [0, 0.69444, 0.01968, 0.08334],
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0.05556],
        "112": [0.19444, 0.43056, 0, 0.08334],
        "113": [0.19444, 0.43056, 0.03588, 0.08334],
        "114": [0, 0.43056, 0.02778, 0.05556],
        "115": [0, 0.43056, 0, 0.05556],
        "116": [0, 0.61508, 0, 0.08334],
        "117": [0, 0.43056, 0, 0.02778],
        "118": [0, 0.43056, 0.03588, 0.02778],
        "119": [0, 0.43056, 0.02691, 0.08334],
        "120": [0, 0.43056, 0, 0.02778],
        "121": [0.19444, 0.43056, 0.03588, 0.05556],
        "122": [0, 0.43056, 0.04398, 0.05556],
        "160": M0,
        "915": [0, 0.68333, 0.13889, 0.08334],
        "916": [0, 0.68333, 0, 0.16667],
        "920": [0, 0.68333, 0.02778, 0.08334],
        "923": [0, 0.68333, 0, 0.16667],
        "926": [0, 0.68333, 0.07569, 0.08334],
        "928": [0, 0.68333, 0.08125, 0.05556],
        "931": [0, 0.68333, 0.05764, 0.08334],
        "933": [0, 0.68333, 0.13889, 0.05556],
        "934": [0, 0.68333, 0, 0.08334],
        "936": [0, 0.68333, 0.11, 0.05556],
        "937": [0, 0.68333, 0.05017, 0.08334],
        "945": [0, 0.43056, 37e-4, 0.02778],
        "946": [0.19444, 0.69444, 0.05278, 0.08334],
        "947": [0.19444, 0.43056, 0.05556, 0],
        "948": [0, 0.69444, 0.03785, 0.05556],
        "949": [0, 0.43056, 0, 0.08334],
        "950": [0.19444, 0.69444, 0.07378, 0.08334],
        "951": [0.19444, 0.43056, 0.03588, 0.05556],
        "952": [0, 0.69444, 0.02778, 0.08334],
        "953": [0, 0.43056, 0, 0.05556],
        "954": [0, 0.43056, 0, 0],
        "955": M6,
        "956": [0.19444, 0.43056, 0, 0.02778],
        "957": [0, 0.43056, 0.06366, 0.02778],
        "958": [0.19444, 0.69444, 0.04601, 0.11111],
        "959": [0, 0.43056, 0, 0.05556],
        "960": [0, 0.43056, 0.03588, 0],
        "961": [0.19444, 0.43056, 0, 0.08334],
        "962": [0.09722, 0.43056, 0.07986, 0.08334],
        "963": [0, 0.43056, 0.03588, 0],
        "964": [0, 0.43056, 0.1132, 0.02778],
        "965": [0, 0.43056, 0.03588, 0.02778],
        "966": [0.19444, 0.43056, 0, 0.08334],
        "967": [0.19444, 0.43056, 0, 0.05556],
        "968": [0.19444, 0.69444, 0.03588, 0.11111],
        "969": [0, 0.43056, 0.03588, 0],
        "977": [0, 0.69444, 0, 0.08334],
        "981": [0.19444, 0.69444, 0, 0.08334],
        "982": [0, 0.43056, 0.02778, 0],
        "1009": [0.19444, 0.43056, 0, 0.08334],
        "1013": [0, 0.43056, 0, 0.05556],
        "57649": [0, 0.43056, 0, 0.02778],
        "57911": [0.19444, 0.43056, 0, 0.08334]
      },
      "SansSerif-Bold": {
        "32": M0,
        "33": M6,
        "34": M6,
        "35": M16,
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": M6,
        "39": M6,
        "40": M15,
        "41": M15,
        "42": M14,
        "43": [0.11667, 0.61667, 0, 0],
        "44": [0.10556, 0.13056, 0, 0],
        "45": [0, 0.45833, 0, 0],
        "46": [0, 0.13056, 0, 0],
        "47": M15,
        "48": M6,
        "49": M6,
        "50": M6,
        "51": M6,
        "52": M6,
        "53": M6,
        "54": M6,
        "55": M6,
        "56": M6,
        "57": M6,
        "58": [0, 0.45833, 0, 0],
        "59": [0.10556, 0.45833, 0, 0],
        "61": [-0.09375, 0.40625, 0, 0],
        "63": M6,
        "64": M6,
        "65": M6,
        "66": M6,
        "67": M6,
        "68": M6,
        "69": M6,
        "70": M6,
        "71": M6,
        "72": M6,
        "73": M6,
        "74": M6,
        "75": M6,
        "76": M6,
        "77": M6,
        "78": M6,
        "79": M6,
        "80": M6,
        "81": [0.10556, 0.69444, 0, 0],
        "82": M6,
        "83": M6,
        "84": M6,
        "85": M6,
        "86": [0, 0.69444, 0.01528, 0],
        "87": [0, 0.69444, 0.01528, 0],
        "88": M6,
        "89": [0, 0.69444, 0.0275, 0],
        "90": M6,
        "91": M15,
        "93": M15,
        "94": M6,
        "95": [0.35, 0.10833, 0.03056, 0],
        "97": [0, 0.45833, 0, 0],
        "98": M6,
        "99": [0, 0.45833, 0, 0],
        "100": M6,
        "101": [0, 0.45833, 0, 0],
        "102": [0, 0.69444, 0.07639, 0],
        "103": [0.19444, 0.45833, 0.01528, 0],
        "104": M6,
        "105": M6,
        "106": M16,
        "107": M6,
        "108": M6,
        "109": [0, 0.45833, 0, 0],
        "110": [0, 0.45833, 0, 0],
        "111": [0, 0.45833, 0, 0],
        "112": [0.19444, 0.45833, 0, 0],
        "113": [0.19444, 0.45833, 0, 0],
        "114": [0, 0.45833, 0.01528, 0],
        "115": [0, 0.45833, 0, 0],
        "116": [0, 0.58929, 0, 0],
        "117": [0, 0.45833, 0, 0],
        "118": [0, 0.45833, 0.01528, 0],
        "119": [0, 0.45833, 0.01528, 0],
        "120": [0, 0.45833, 0, 0],
        "121": [0.19444, 0.45833, 0.01528, 0],
        "122": [0, 0.45833, 0, 0],
        "126": [0.35, 0.34444, 0, 0],
        "160": M0,
        "168": M6,
        "176": M6,
        "180": M6,
        "184": [0.17014, 0, 0, 0],
        "305": [0, 0.45833, 0, 0],
        "567": [0.19444, 0.45833, 0, 0],
        "710": M6,
        "711": [0, 0.63542, 0, 0],
        "713": [0, 0.63778, 0, 0],
        "728": M6,
        "729": M6,
        "730": M6,
        "732": M6,
        "733": M6,
        "915": M6,
        "916": M6,
        "920": M6,
        "923": M6,
        "926": M6,
        "928": M6,
        "931": M6,
        "933": M6,
        "934": M6,
        "936": M6,
        "937": M6,
        "8211": [0, 0.45833, 0.03056, 0],
        "8212": [0, 0.45833, 0.03056, 0],
        "8216": M6,
        "8217": M6,
        "8220": M6,
        "8221": M6
      },
      "SansSerif-Italic": {
        "32": M0,
        "33": [0, 0.69444, 0.05733, 0],
        "34": [0, 0.69444, 316e-5, 0],
        "35": [0.19444, 0.69444, 0.05087, 0],
        "36": [0.05556, 0.75, 0.11156, 0],
        "37": [0.05556, 0.75, 0.03126, 0],
        "38": [0, 0.69444, 0.03058, 0],
        "39": [0, 0.69444, 0.07816, 0],
        "40": [0.25, 0.75, 0.13164, 0],
        "41": [0.25, 0.75, 0.02536, 0],
        "42": [0, 0.75, 0.11775, 0],
        "43": [0.08333, 0.58333, 0.02536, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": [0, 0.44444, 0.01946, 0],
        "46": [0, 0.08333, 0, 0],
        "47": [0.25, 0.75, 0.13164, 0],
        "48": [0, 0.65556, 0.11156, 0],
        "49": [0, 0.65556, 0.11156, 0],
        "50": [0, 0.65556, 0.11156, 0],
        "51": [0, 0.65556, 0.11156, 0],
        "52": [0, 0.65556, 0.11156, 0],
        "53": [0, 0.65556, 0.11156, 0],
        "54": [0, 0.65556, 0.11156, 0],
        "55": [0, 0.65556, 0.11156, 0],
        "56": [0, 0.65556, 0.11156, 0],
        "57": [0, 0.65556, 0.11156, 0],
        "58": [0, 0.44444, 0.02502, 0],
        "59": [0.125, 0.44444, 0.02502, 0],
        "61": [-0.13, 0.37, 0.05087, 0],
        "63": [0, 0.69444, 0.11809, 0],
        "64": [0, 0.69444, 0.07555, 0],
        "65": M6,
        "66": [0, 0.69444, 0.08293, 0],
        "67": [0, 0.69444, 0.11983, 0],
        "68": [0, 0.69444, 0.07555, 0],
        "69": [0, 0.69444, 0.11983, 0],
        "70": [0, 0.69444, 0.13372, 0],
        "71": [0, 0.69444, 0.11983, 0],
        "72": [0, 0.69444, 0.08094, 0],
        "73": [0, 0.69444, 0.13372, 0],
        "74": [0, 0.69444, 0.08094, 0],
        "75": [0, 0.69444, 0.11983, 0],
        "76": M6,
        "77": [0, 0.69444, 0.08094, 0],
        "78": [0, 0.69444, 0.08094, 0],
        "79": [0, 0.69444, 0.07555, 0],
        "80": [0, 0.69444, 0.08293, 0],
        "81": [0.125, 0.69444, 0.07555, 0],
        "82": [0, 0.69444, 0.08293, 0],
        "83": [0, 0.69444, 0.09205, 0],
        "84": [0, 0.69444, 0.13372, 0],
        "85": [0, 0.69444, 0.08094, 0],
        "86": [0, 0.69444, 0.1615, 0],
        "87": [0, 0.69444, 0.1615, 0],
        "88": [0, 0.69444, 0.13372, 0],
        "89": [0, 0.69444, 0.17261, 0],
        "90": [0, 0.69444, 0.11983, 0],
        "91": [0.25, 0.75, 0.15942, 0],
        "93": [0.25, 0.75, 0.08719, 0],
        "94": [0, 0.69444, 0.0799, 0],
        "95": [0.35, 0.09444, 0.08616, 0],
        "97": [0, 0.44444, 981e-5, 0],
        "98": [0, 0.69444, 0.03057, 0],
        "99": [0, 0.44444, 0.08336, 0],
        "100": [0, 0.69444, 0.09483, 0],
        "101": [0, 0.44444, 0.06778, 0],
        "102": [0, 0.69444, 0.21705, 0],
        "103": [0.19444, 0.44444, 0.10836, 0],
        "104": [0, 0.69444, 0.01778, 0],
        "105": [0, 0.67937, 0.09718, 0],
        "106": [0.19444, 0.67937, 0.09162, 0],
        "107": [0, 0.69444, 0.08336, 0],
        "108": [0, 0.69444, 0.09483, 0],
        "109": [0, 0.44444, 0.01778, 0],
        "110": [0, 0.44444, 0.01778, 0],
        "111": [0, 0.44444, 0.06613, 0],
        "112": [0.19444, 0.44444, 0.0389, 0],
        "113": [0.19444, 0.44444, 0.04169, 0],
        "114": [0, 0.44444, 0.10836, 0],
        "115": [0, 0.44444, 0.0778, 0],
        "116": [0, 0.57143, 0.07225, 0],
        "117": [0, 0.44444, 0.04169, 0],
        "118": [0, 0.44444, 0.10836, 0],
        "119": [0, 0.44444, 0.10836, 0],
        "120": [0, 0.44444, 0.09169, 0],
        "121": [0.19444, 0.44444, 0.10836, 0],
        "122": [0, 0.44444, 0.08752, 0],
        "126": [0.35, 0.32659, 0.08826, 0],
        "160": M0,
        "168": [0, 0.67937, 0.06385, 0],
        "176": M6,
        "184": [0.17014, 0, 0, 0],
        "305": [0, 0.44444, 0.04169, 0],
        "567": [0.19444, 0.44444, 0.04169, 0],
        "710": [0, 0.69444, 0.0799, 0],
        "711": [0, 0.63194, 0.08432, 0],
        "713": [0, 0.60889, 0.08776, 0],
        "714": [0, 0.69444, 0.09205, 0],
        "715": M6,
        "728": [0, 0.69444, 0.09483, 0],
        "729": [0, 0.67937, 0.07774, 0],
        "730": M6,
        "732": [0, 0.67659, 0.08826, 0],
        "733": [0, 0.69444, 0.09205, 0],
        "915": [0, 0.69444, 0.13372, 0],
        "916": M6,
        "920": [0, 0.69444, 0.07555, 0],
        "923": M6,
        "926": [0, 0.69444, 0.12816, 0],
        "928": [0, 0.69444, 0.08094, 0],
        "931": [0, 0.69444, 0.11983, 0],
        "933": [0, 0.69444, 0.09031, 0],
        "934": [0, 0.69444, 0.04603, 0],
        "936": [0, 0.69444, 0.09031, 0],
        "937": [0, 0.69444, 0.08293, 0],
        "8211": [0, 0.44444, 0.08616, 0],
        "8212": [0, 0.44444, 0.08616, 0],
        "8216": [0, 0.69444, 0.07816, 0],
        "8217": [0, 0.69444, 0.07816, 0],
        "8220": [0, 0.69444, 0.14205, 0],
        "8221": [0, 0.69444, 316e-5, 0]
      },
      "SansSerif-Regular": {
        "32": M0,
        "33": M6,
        "34": M6,
        "35": M16,
        "36": [0.05556, 0.75, 0, 0],
        "37": [0.05556, 0.75, 0, 0],
        "38": M6,
        "39": M6,
        "40": M15,
        "41": M15,
        "42": M14,
        "43": [0.08333, 0.58333, 0, 0],
        "44": [0.125, 0.08333, 0, 0],
        "45": M7,
        "46": [0, 0.08333, 0, 0],
        "47": M15,
        "48": [0, 0.65556, 0, 0],
        "49": [0, 0.65556, 0, 0],
        "50": [0, 0.65556, 0, 0],
        "51": [0, 0.65556, 0, 0],
        "52": [0, 0.65556, 0, 0],
        "53": [0, 0.65556, 0, 0],
        "54": [0, 0.65556, 0, 0],
        "55": [0, 0.65556, 0, 0],
        "56": [0, 0.65556, 0, 0],
        "57": [0, 0.65556, 0, 0],
        "58": M7,
        "59": [0.125, 0.44444, 0, 0],
        "61": [-0.13, 0.37, 0, 0],
        "63": M6,
        "64": M6,
        "65": M6,
        "66": M6,
        "67": M6,
        "68": M6,
        "69": M6,
        "70": M6,
        "71": M6,
        "72": M6,
        "73": M6,
        "74": M6,
        "75": M6,
        "76": M6,
        "77": M6,
        "78": M6,
        "79": M6,
        "80": M6,
        "81": [0.125, 0.69444, 0, 0],
        "82": M6,
        "83": M6,
        "84": M6,
        "85": M6,
        "86": [0, 0.69444, 0.01389, 0],
        "87": [0, 0.69444, 0.01389, 0],
        "88": M6,
        "89": [0, 0.69444, 0.025, 0],
        "90": M6,
        "91": M15,
        "93": M15,
        "94": M6,
        "95": [0.35, 0.09444, 0.02778, 0],
        "97": M7,
        "98": M6,
        "99": M7,
        "100": M6,
        "101": M7,
        "102": [0, 0.69444, 0.06944, 0],
        "103": [0.19444, 0.44444, 0.01389, 0],
        "104": M6,
        "105": [0, 0.67937, 0, 0],
        "106": [0.19444, 0.67937, 0, 0],
        "107": M6,
        "108": M6,
        "109": M7,
        "110": M7,
        "111": M7,
        "112": M8,
        "113": M8,
        "114": [0, 0.44444, 0.01389, 0],
        "115": M7,
        "116": [0, 0.57143, 0, 0],
        "117": M7,
        "118": [0, 0.44444, 0.01389, 0],
        "119": [0, 0.44444, 0.01389, 0],
        "120": M7,
        "121": [0.19444, 0.44444, 0.01389, 0],
        "122": M7,
        "126": [0.35, 0.32659, 0, 0],
        "160": M0,
        "168": [0, 0.67937, 0, 0],
        "176": M6,
        "184": [0.17014, 0, 0, 0],
        "305": M7,
        "567": M8,
        "710": M6,
        "711": [0, 0.63194, 0, 0],
        "713": [0, 0.60889, 0, 0],
        "714": M6,
        "715": M6,
        "728": M6,
        "729": [0, 0.67937, 0, 0],
        "730": M6,
        "732": [0, 0.67659, 0, 0],
        "733": M6,
        "915": M6,
        "916": M6,
        "920": M6,
        "923": M6,
        "926": M6,
        "928": M6,
        "931": M6,
        "933": M6,
        "934": M6,
        "936": M6,
        "937": M6,
        "8211": [0, 0.44444, 0.02778, 0],
        "8212": [0, 0.44444, 0.02778, 0],
        "8216": M6,
        "8217": M6,
        "8220": M6,
        "8221": M6
      },
      "Script-Regular": {
        "32": M0,
        "65": [0, 0.7, 0.22925, 0],
        "66": [0, 0.7, 0.04087, 0],
        "67": [0, 0.7, 0.1689, 0],
        "68": [0, 0.7, 0.09371, 0],
        "69": [0, 0.7, 0.18583, 0],
        "70": [0, 0.7, 0.13634, 0],
        "71": [0, 0.7, 0.17322, 0],
        "72": [0, 0.7, 0.29694, 0],
        "73": [0, 0.7, 0.19189, 0],
        "74": [0.27778, 0.7, 0.19189, 0],
        "75": [0, 0.7, 0.31259, 0],
        "76": [0, 0.7, 0.19189, 0],
        "77": [0, 0.7, 0.15981, 0],
        "78": [0, 0.7, 0.3525, 0],
        "79": [0, 0.7, 0.08078, 0],
        "80": [0, 0.7, 0.08078, 0],
        "81": [0, 0.7, 0.03305, 0],
        "82": [0, 0.7, 0.06259, 0],
        "83": [0, 0.7, 0.19189, 0],
        "84": [0, 0.7, 0.29087, 0],
        "85": [0, 0.7, 0.25815, 0],
        "86": [0, 0.7, 0.27523, 0],
        "87": [0, 0.7, 0.27523, 0],
        "88": [0, 0.7, 0.26006, 0],
        "89": [0, 0.7, 0.2939, 0],
        "90": [0, 0.7, 0.24037, 0],
        "160": M0
      },
      "Size1-Regular": {
        "32": M0,
        "40": M10,
        "41": M10,
        "47": M10,
        "91": M10,
        "92": M10,
        "93": M10,
        "123": M10,
        "125": M10,
        "160": M0,
        "710": [0, 0.72222, 0, 0],
        "732": [0, 0.72222, 0, 0],
        "770": [0, 0.72222, 0, 0],
        "771": [0, 0.72222, 0, 0],
        "8214": [-99e-5, 0.601, 0, 0],
        "8593": [1e-5, 0.6, 0, 0],
        "8595": [1e-5, 0.6, 0, 0],
        "8657": [1e-5, 0.6, 0, 0],
        "8659": [1e-5, 0.6, 0, 0],
        "8719": M17,
        "8720": M17,
        "8721": M17,
        "8730": M10,
        "8739": [-599e-5, 0.606, 0, 0],
        "8741": [-599e-5, 0.606, 0, 0],
        "8747": [0.30612, 0.805, 0.19445, 0],
        "8748": [0.306, 0.805, 0.19445, 0],
        "8749": [0.306, 0.805, 0.19445, 0],
        "8750": [0.30612, 0.805, 0.19445, 0],
        "8896": M17,
        "8897": M17,
        "8898": M17,
        "8899": M17,
        "8968": M10,
        "8969": M10,
        "8970": M10,
        "8971": M10,
        "9168": [-99e-5, 0.601, 0, 0],
        "10216": M10,
        "10217": M10,
        "10752": M17,
        "10753": M17,
        "10754": M17,
        "10756": M17,
        "10758": M17
      },
      "Size2-Regular": {
        "32": M0,
        "40": M19,
        "41": M19,
        "47": M19,
        "91": M19,
        "92": M19,
        "93": M19,
        "123": M19,
        "125": M19,
        "160": M0,
        "710": M14,
        "732": M14,
        "770": M14,
        "771": M14,
        "8719": M18,
        "8720": M18,
        "8721": M18,
        "8730": M19,
        "8747": [0.86225, 1.36, 0.44445, 0],
        "8748": [0.862, 1.36, 0.44445, 0],
        "8749": [0.862, 1.36, 0.44445, 0],
        "8750": [0.86225, 1.36, 0.44445, 0],
        "8896": M18,
        "8897": M18,
        "8898": M18,
        "8899": M18,
        "8968": M19,
        "8969": M19,
        "8970": M19,
        "8971": M19,
        "10216": M19,
        "10217": M19,
        "10752": M18,
        "10753": M18,
        "10754": M18,
        "10756": M18,
        "10758": M18
      },
      "Size3-Regular": {
        "32": M0,
        "40": M13,
        "41": M13,
        "47": M13,
        "91": M13,
        "92": M13,
        "93": M13,
        "123": M13,
        "125": M13,
        "160": M0,
        "710": M14,
        "732": M14,
        "770": M14,
        "771": M14,
        "8730": M13,
        "8968": M13,
        "8969": M13,
        "8970": M13,
        "8971": M13,
        "10216": M13,
        "10217": M13
      },
      "Size4-Regular": {
        "32": M0,
        "40": M12,
        "41": M12,
        "47": M12,
        "91": M12,
        "92": M12,
        "93": M12,
        "123": M12,
        "125": M12,
        "160": M0,
        "710": [0, 0.825, 0, 0],
        "732": [0, 0.825, 0, 0],
        "770": [0, 0.825, 0, 0],
        "771": [0, 0.825, 0, 0],
        "8730": M12,
        "8968": M12,
        "8969": M12,
        "8970": M12,
        "8971": M12,
        "9115": [0.64502, 1.155, 0, 0],
        "9116": [1e-5, 0.6, 0, 0],
        "9117": [0.64502, 1.155, 0, 0],
        "9118": [0.64502, 1.155, 0, 0],
        "9119": [1e-5, 0.6, 0, 0],
        "9120": [0.64502, 1.155, 0, 0],
        "9121": [0.64502, 1.155, 0, 0],
        "9122": [-99e-5, 0.601, 0, 0],
        "9123": [0.64502, 1.155, 0, 0],
        "9124": [0.64502, 1.155, 0, 0],
        "9125": [-99e-5, 0.601, 0, 0],
        "9126": [0.64502, 1.155, 0, 0],
        "9127": [1e-5, 0.9, 0, 0],
        "9128": M19,
        "9129": [0.90001, 0, 0, 0],
        "9130": [0, 0.3, 0, 0],
        "9131": [1e-5, 0.9, 0, 0],
        "9132": M19,
        "9133": [0.90001, 0, 0, 0],
        "9143": [0.88502, 0.915, 0, 0],
        "10216": M12,
        "10217": M12,
        "57344": [-499e-5, 0.605, 0, 0],
        "57345": [-499e-5, 0.605, 0, 0],
        "57680": [0, 0.12, 0, 0],
        "57681": [0, 0.12, 0, 0],
        "57682": [0, 0.12, 0, 0],
        "57683": [0, 0.12, 0, 0]
      },
      "Typewriter-Regular": {
        "32": M0,
        "33": M11,
        "34": M11,
        "35": M11,
        "36": [0.08333, 0.69444, 0, 0],
        "37": [0.08333, 0.69444, 0, 0],
        "38": M11,
        "39": M11,
        "40": [0.08333, 0.69444, 0, 0],
        "41": [0.08333, 0.69444, 0, 0],
        "42": [0, 0.52083, 0, 0],
        "43": [-0.08056, 0.53055, 0, 0],
        "44": [0.13889, 0.125, 0, 0],
        "45": [-0.08056, 0.53055, 0, 0],
        "46": [0, 0.125, 0, 0],
        "47": [0.08333, 0.69444, 0, 0],
        "48": M11,
        "49": M11,
        "50": M11,
        "51": M11,
        "52": M11,
        "53": M11,
        "54": M11,
        "55": M11,
        "56": M11,
        "57": M11,
        "58": [0, 0.43056, 0, 0],
        "59": [0.13889, 0.43056, 0, 0],
        "60": [-0.05556, 0.55556, 0, 0],
        "61": [-0.19549, 0.41562, 0, 0],
        "62": [-0.05556, 0.55556, 0, 0],
        "63": M11,
        "64": M11,
        "65": M11,
        "66": M11,
        "67": M11,
        "68": M11,
        "69": M11,
        "70": M11,
        "71": M11,
        "72": M11,
        "73": M11,
        "74": M11,
        "75": M11,
        "76": M11,
        "77": M11,
        "78": M11,
        "79": M11,
        "80": M11,
        "81": [0.13889, 0.61111, 0, 0],
        "82": M11,
        "83": M11,
        "84": M11,
        "85": M11,
        "86": M11,
        "87": M11,
        "88": M11,
        "89": M11,
        "90": M11,
        "91": [0.08333, 0.69444, 0, 0],
        "92": [0.08333, 0.69444, 0, 0],
        "93": [0.08333, 0.69444, 0, 0],
        "94": M11,
        "95": [0.09514, 0, 0, 0],
        "96": M11,
        "97": [0, 0.43056, 0, 0],
        "98": M11,
        "99": [0, 0.43056, 0, 0],
        "100": M11,
        "101": [0, 0.43056, 0, 0],
        "102": M11,
        "103": [0.22222, 0.43056, 0, 0],
        "104": M11,
        "105": M11,
        "106": [0.22222, 0.61111, 0, 0],
        "107": M11,
        "108": M11,
        "109": [0, 0.43056, 0, 0],
        "110": [0, 0.43056, 0, 0],
        "111": [0, 0.43056, 0, 0],
        "112": [0.22222, 0.43056, 0, 0],
        "113": [0.22222, 0.43056, 0, 0],
        "114": [0, 0.43056, 0, 0],
        "115": [0, 0.43056, 0, 0],
        "116": [0, 0.55358, 0, 0],
        "117": [0, 0.43056, 0, 0],
        "118": [0, 0.43056, 0, 0],
        "119": [0, 0.43056, 0, 0],
        "120": [0, 0.43056, 0, 0],
        "121": [0.22222, 0.43056, 0, 0],
        "122": [0, 0.43056, 0, 0],
        "123": [0.08333, 0.69444, 0, 0],
        "124": [0.08333, 0.69444, 0, 0],
        "125": [0.08333, 0.69444, 0, 0],
        "126": M11,
        "127": M11,
        "160": M0,
        "176": M11,
        "184": [0.19445, 0, 0, 0],
        "305": [0, 0.43056, 0, 0],
        "567": [0.22222, 0.43056, 0, 0],
        "711": [0, 0.56597, 0, 0],
        "713": [0, 0.56555, 0, 0],
        "714": M11,
        "715": M11,
        "728": M11,
        "730": M11,
        "770": M11,
        "771": M11,
        "776": M11,
        "915": M11,
        "916": M11,
        "920": M11,
        "923": M11,
        "926": M11,
        "928": M11,
        "931": M11,
        "933": M11,
        "934": M11,
        "936": M11,
        "937": M11,
        "8216": M11,
        "8217": M11,
        "8242": M11,
        "9251": [0.11111, 0.21944, 0, 0]
      }
    };
    var CJK_REGEX = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/;
    var PT_PER_EM = 10;
    var AXIS_HEIGHT = 0.25;
    var BASELINE_SKIP = 1.2;
    var X_HEIGHT = 0.431;
    var FONT_METRICS = {
      slant: [0.25, 0.25, 0.25],
      space: [0, 0, 0],
      stretch: [0, 0, 0],
      shrink: [0, 0, 0],
      xHeight: [X_HEIGHT, X_HEIGHT, X_HEIGHT],
      quad: [1, 1.171, 1.472],
      extraSpace: [0, 0, 0],
      num1: [0.677, 0.732, 0.925],
      num2: [0.394, 0.384, 0.387],
      num3: [0.444, 0.471, 0.504],
      denom1: [0.686, 0.752, 1.025],
      denom2: [0.345, 0.344, 0.532],
      sup1: [0.413, 0.503, 0.504],
      sup2: [0.363, 0.431, 0.404],
      sup3: [0.289, 0.286, 0.294],
      sub1: [0.15, 0.143, 0.2],
      sub2: [0.247, 0.286, 0.4],
      supDrop: [0.386, 0.353, 0.494],
      subDrop: [0.05, 0.071, 0.1],
      delim1: [2.39, 1.7, 1.98],
      delim2: [1.01, 1.157, 1.42],
      axisHeight: [AXIS_HEIGHT, AXIS_HEIGHT, AXIS_HEIGHT],
      defaultRuleThickness: [0.04, 0.049, 0.049],
      bigOpSpacing1: [0.111, 0.111, 0.111],
      bigOpSpacing2: [0.166, 0.166, 0.166],
      bigOpSpacing3: [0.2, 0.2, 0.2],
      bigOpSpacing4: [0.6, 0.611, 0.611],
      bigOpSpacing5: [0.1, 0.143, 0.143],
      sqrtRuleThickness: [0.04, 0.04, 0.04]
    };
    var FONT_SCALE = [
      0,
      // not used
      0.5,
      // size 1 = scriptscriptstyle
      0.7,
      // size 2 = scriptstyle
      0.8,
      0.9,
      1,
      // size 5 = default
      1.2,
      1.44,
      1.728,
      2.074,
      2.488
      //size 10
    ];
    var DEFAULT_FONT_SIZE = 5;
    var extraCharacterMap = {
      " ": " ",
      // NON-BREAKING SPACE is like space
      "​": " ",
      // ZERO WIDTH SPACE is like space
      // Latin-1
      "Å": "A",
      "Ç": "C",
      "Ð": "D",
      "Þ": "o",
      "å": "a",
      "ç": "c",
      "ð": "d",
      "þ": "o",
      // Cyrillic
      "А": "A",
      "Б": "B",
      "В": "B",
      "Г": "F",
      "Д": "A",
      "Е": "E",
      "Ж": "K",
      "З": "3",
      "И": "N",
      "Й": "N",
      "К": "K",
      "Л": "N",
      "М": "M",
      "Н": "H",
      "О": "O",
      "П": "N",
      "Р": "P",
      "С": "C",
      "Т": "T",
      "У": "y",
      "Ф": "O",
      "Х": "X",
      "Ц": "U",
      "Ч": "h",
      "Ш": "W",
      "Щ": "W",
      "Ъ": "B",
      "Ы": "X",
      "Ь": "B",
      "Э": "3",
      "Ю": "X",
      "Я": "R",
      "а": "a",
      "б": "b",
      "в": "a",
      "г": "r",
      "д": "y",
      "е": "e",
      "ж": "m",
      "з": "e",
      "и": "n",
      "й": "n",
      "к": "n",
      "л": "n",
      "м": "m",
      "н": "n",
      "о": "o",
      "п": "n",
      "р": "p",
      "с": "c",
      "т": "o",
      "у": "y",
      "ф": "b",
      "х": "x",
      "ц": "n",
      "ч": "n",
      "ш": "w",
      "щ": "w",
      "ъ": "a",
      "ы": "m",
      "ь": "a",
      "э": "e",
      "ю": "m",
      "я": "r"
    };
    function getCharacterMetrics(codepoint, fontName) {
      if (codepoint === void 0)
        codepoint = 77;
      const metrics = font_metrics_data_default[fontName][codepoint];
      if (metrics) {
        return {
          defaultMetrics: false,
          depth: metrics[0],
          height: metrics[1],
          italic: metrics[2],
          skew: metrics[3]
        };
      }
      if (codepoint === 11034) {
        return {
          defaultMetrics: true,
          depth: 0.2,
          height: 0.8,
          italic: 0,
          skew: 0
        };
      }
      const char = String.fromCodePoint(codepoint);
      if (char in extraCharacterMap)
        codepoint = extraCharacterMap[char].codePointAt(0);
      else if (CJK_REGEX.test(char)) {
        codepoint = 77;
        return {
          defaultMetrics: true,
          depth: 0.2,
          height: 0.9,
          italic: 0,
          skew: 0
        };
      }
      return {
        defaultMetrics: true,
        depth: 0.2,
        height: 0.7,
        italic: 0,
        skew: 0
      };
    }
    var SVG_BODY = {
      // Adapted from https://github.com/KaTeX/KaTeX/blob/master/src/stretchy.js
      overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
      underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
      xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
      xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
      Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
      xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
      xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
      overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
      xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
      overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
      xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
      xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
      xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
      xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
      overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
      underbrace: [
        ["leftbraceunder", "midbraceunder", "rightbraceunder"],
        1.6,
        548
      ],
      underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
      xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
      xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
      xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
      xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
      xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
      xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
      overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
      overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
      undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
      xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
      xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
      // The next three arrows are from the mhchem package.
      // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
      // document as \xrightarrow or \xrightleftharpoons. Those have
      // min-length = 1.75em, so we set min-length on these next three to match.
      xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
      xrightequilibrium: [
        ["baraboveshortleftharpoon", "rightharpoonaboveshortbar"],
        1.75,
        716
      ],
      xleftequilibrium: [
        ["shortbaraboveleftharpoon", "shortrightharpoonabovebar"],
        1.75,
        716
      ]
    };
    var SVG_ACCENTS = {
      // ViewBoxWidth, viewBoxHeight, height
      widehat1: [1062, 239, 0.24],
      widehat2: [2364, 300, 0.3],
      widehat3: [2364, 360, 0.36],
      widehat4: [2364, 420, 0.42],
      widecheck1: [1062, 239, 0.24],
      widecheck2: [2364, 300, 0.3],
      widecheck3: [2364, 360, 0.36],
      widecheck4: [2364, 420, 0.42],
      widetilde1: [600, 260, 0.26],
      widetilde2: [1033, 286, 0.286],
      widetilde3: [2339, 306, 0.306],
      widetilde4: [2340, 312, 0.34],
      overarc: [1061, 159, 0.3],
      underarc: [1061, 159, 0.3]
    };
    var PATHS = {
      // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
      doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`,
      // Doublerightarrow is from glyph U+21D2 in font KaTeX Main
      doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`,
      // Leftarrow is from glyph U+2190 in font KaTeX Main
      leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`,
      // Overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
      leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`,
      leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`,
      overarc: `M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z`,
      underarc: `m 529 160
  c -179 0 -524 -115 -524 -115
  c -5 -1 -9 -5 -9 -10
  c 0 -1 1 -2 1 -3
  l 4 -22
  c 1 -5 5 -9 11 -9
  h 2
  s 338 93 512 92
  c 174 0 513 -92 513 -92
  h 2
  c 5 0 9 4 11 9
  l 5 22
  c 1 6 -2 12 -8 13
  c 0 0 -342 115 -520 115
  z
  `,
      // Overgroup is from the MnSymbol package (public domain)
      leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`,
      leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`,
      // Harpoons are from glyph U+21BD in font KaTeX Main
      leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`,
      leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`,
      leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`,
      leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`,
      // Hook is from glyph U+21A9 in font KaTeX Main
      lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`,
      leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`,
      leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`,
      // Tofrom is from glyph U+21C4 in font KaTeX AMS Regular
      leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`,
      longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`,
      midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`,
      midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`,
      oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`,
      oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`,
      oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`,
      oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`,
      rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`,
      rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`,
      rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`,
      rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`,
      rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`,
      rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`,
      rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`,
      rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`,
      rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`,
      righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`,
      rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`,
      rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`,
      // Twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
      twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`,
      twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`,
      // Tilde1 is a modified version of a glyph from the MnSymbol package
      widetilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`,
      // Ditto tilde2, tilde3, & tilde4
      widetilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`,
      widetilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`,
      widetilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`,
      // Vec is from glyph U+20D7 in font KaTeX Main
      vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`,
      // Widehat1 is a modified version of a glyph from the MnSymbol package
      widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`,
      // Ditto widehat2, widehat3, & widehat4
      widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`,
      // Widecheck paths are all inverted versions of widehat
      widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`,
      widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`,
      // The next ten paths support reaction arrows from the mhchem package.
      // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
      // baraboveleftarrow is mostly from from glyph U+2190 in font KaTeX Main
      baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`,
      // Rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
      rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`,
      // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
      // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
      baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`,
      rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`,
      shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`,
      shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z`
    };
    function svgBodyToMarkup(svgBodyName) {
      if (SVG_ACCENTS[svgBodyName]) {
        const [vbWidth, vbHeight, height2] = SVG_ACCENTS[svgBodyName];
        const result = `<span class="stretchy" style="height:${height2}em"><svg width="100%" height="${height2}em" viewBox="0 0 ${vbWidth} ${vbHeight}" preserveAspectRatio="none" ><path fill="currentcolor" d="${PATHS[svgBodyName]}"></path></svg></span>`;
        return `<span style="display:inline-block;height:${height2 / 2}em;min-width:0">${result}</span>`;
      }
      const [paths, minWidth, viewBoxHeight, align] = SVG_BODY[svgBodyName];
      let widthClasses;
      let aligns;
      const height = viewBoxHeight / 1e3;
      if (paths.length === 3) {
        widthClasses = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"];
        aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
      } else if (paths.length === 2) {
        widthClasses = ["slice-1-of-2", "slice-2-of-2"];
        aligns = ["xMinYMin", "xMaxYMin"];
      } else {
        widthClasses = ["slice-1-of-1"];
        aligns = [align];
      }
      const body = paths.map(
        (path, i) => `<span class="${widthClasses[i]}" style=height:${height}em><svg width=400em height=${height}em viewBox="0 0 400000 ${viewBoxHeight}" preserveAspectRatio="${aligns[i]} slice"><path fill="currentcolor" d="${PATHS[path]}"></path></svg></span>`
      ).join("");
      return `<span style="display:inline-block;height:${height}em;min-width:${minWidth}em;">${body}</span>`;
    }
    function svgBodyHeight(svgBodyName) {
      if (SVG_BODY[svgBodyName])
        return SVG_BODY[svgBodyName][2] / 1e3;
      return SVG_ACCENTS[svgBodyName][2];
    }
    var _Mode = class {
      constructor(name) {
        _Mode._registry[name] = this;
      }
      static createAtom(mode, command, context, style) {
        return _Mode._registry[mode].createAtom(command, context, style);
      }
      // `run` should be a run (sequence) of atoms all with the same
      // mode
      static serialize(run, options) {
        console.assert(run.length > 0);
        const mode = _Mode._registry[run[0].mode];
        return mode.serialize(run, options);
      }
      static applyStyle(mode, box, style) {
        return _Mode._registry[mode].applyStyle(box, style);
      }
    };
    var Mode = _Mode;
    Mode._registry = {};
    function getModeRuns(atoms) {
      const result = [];
      let run = [];
      let currentMode = "NONE";
      for (const atom of atoms) {
        if (atom.type !== "first") {
          if (atom.mode !== currentMode) {
            if (run.length > 0)
              result.push(run);
            run = [atom];
            currentMode = atom.mode;
          } else
            run.push(atom);
        }
      }
      if (run.length > 0)
        result.push(run);
      return result;
    }
    function getPropertyRuns(atoms, property) {
      const result = [];
      let run = [];
      let currentValue = void 0;
      for (const atom of atoms) {
        if (atom.type !== "first" && atom.style) {
          let value;
          if (property === "variant") {
            value = atom.style.variant;
            if (atom.style.variantStyle && atom.style.variantStyle !== "up")
              value += "-" + atom.style.variantStyle;
          } else if (property === "cssClass") {
            if (atom.type === "group")
              value = atom.customClass;
          } else
            value = atom.style[property];
          if (value === currentValue) {
            run.push(atom);
          } else {
            if (run.length > 0)
              result.push(run);
            run = [atom];
            currentValue = value;
          }
        }
      }
      if (run.length > 0)
        result.push(run);
      return result;
    }
    function applyStyle(mode, box, style) {
      return Mode.applyStyle(mode, box, style);
    }
    var BOX_TYPE = [
      "",
      "chem",
      "mord",
      // > is an ordinary atom like ‘x’ ;
      "mbin",
      // > is a binary operation atom like ‘+’
      "mop",
      // > is a large operator atom like $$\sum$$
      "mrel",
      // > is a relation atom like ‘=’
      "mopen",
      // > is an opening atom like ‘(’
      "mclose",
      // > is a closing atom like ‘)’
      "mpunct",
      // > is a punctuation atom like ‘,’
      "minner",
      // >  is an inner atom like ‘$$\frac12$$'
      "spacing",
      "first",
      "latex",
      "composition",
      "error",
      "placeholder",
      "supsub",
      "none",
      "mathfield"
    ];
    function isBoxType(type) {
      return BOX_TYPE.includes(type);
    }
    var INTER_ATOM_SPACING = {
      mord: { mop: 3, mbin: 4, mrel: 5, minner: 3 },
      mop: { mord: 3, mop: 3, rel: 5, minner: 3 },
      mbin: { mord: 4, mop: 4, mopen: 4, minner: 4 },
      mrel: { mord: 5, mop: 5, mopen: 5, minner: 5 },
      mclose: { mop: 3, mbin: 4, mrel: 5, minner: 3 },
      mpunct: { mord: 3, mop: 3, mrel: 3, mopen: 3, mpunct: 3, minner: 3 },
      minner: { mord: 3, mop: 3, mbin: 4, mrel: 5, mopen: 3, mpunct: 3, minner: 3 }
    };
    var INTER_ATOM_TIGHT_SPACING = {
      mord: { mop: 3 },
      mop: { mord: 3, mop: 3 },
      mclose: { mop: 3 },
      minner: { mop: 3 }
    };
    function toString(arg1, arg2) {
      if (typeof arg1 === "string")
        return arg1;
      if (typeof arg1 === "number") {
        console.assert(Number.isFinite(arg1));
        const numValue = Math.ceil(100 * arg1) / 100;
        if (numValue === 0)
          return "0";
        return numValue.toString() + (arg2 != null ? arg2 : "");
      }
      return "";
    }
    var Box = class {
      constructor(content, options) {
        var _a3, _b3, _c2, _d2, _e, _f;
        if (typeof content === "number")
          this.value = String.fromCodePoint(content);
        else if (typeof content === "string")
          this.value = content;
        else if (isArray2(content))
          this.children = content.filter((x) => x !== null);
        else if (content && content instanceof Box)
          this.children = [content];
        this.type = (_a3 = options == null ? void 0 : options.type) != null ? _a3 : "";
        this.isSelected = false;
        this.isTight = (_b3 = options == null ? void 0 : options.isTight) != null ? _b3 : false;
        this.newList = (_c2 = options == null ? void 0 : options.newList) != null ? _c2 : false;
        if (options == null ? void 0 : options.properties) {
          for (const prop of Object.keys(options.properties))
            this.setStyle(prop, options.properties[prop]);
        }
        if (options == null ? void 0 : options.attributes)
          this.attributes = options.attributes;
        this.classes = (_d2 = options == null ? void 0 : options.classes) != null ? _d2 : "";
        let fontName = (options == null ? void 0 : options.fontFamily) || "Main-Regular";
        if ((options == null ? void 0 : options.style) && this.value) {
          fontName = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          applyStyle((_e = options.mode) != null ? _e : "math", this, options.style) || "Main-Regular";
        }
        this.height = 0;
        this.depth = 0;
        this.skew = 0;
        this.italic = 0;
        this.maxFontSize = 0;
        if (this.type === "latex") {
          this.height = 0.8;
          this.depth = 0.2;
        } else if (typeof content === "number") {
          const metrics = getCharacterMetrics(content, fontName);
          this.height = metrics.height;
          this.depth = metrics.depth;
          this.skew = metrics.skew;
          this.italic = metrics.italic;
        } else if (this.value) {
          this.height = -Infinity;
          this.depth = -Infinity;
          this.skew = -Infinity;
          this.italic = -Infinity;
          for (let i = 0; i < this.value.length; i++) {
            const metrics = getCharacterMetrics(
              this.value.codePointAt(i),
              fontName || "Main-Regular"
            );
            this.height = Math.max(this.height, metrics.height);
            this.depth = Math.max(this.depth, metrics.depth);
            this.skew = metrics.skew;
            this.italic = metrics.italic;
          }
        } else if (this.children && this.children.length > 0) {
          if (this.children.length === 1) {
            const child = this.children[0];
            this.height = child.height;
            this.depth = child.depth;
            this.maxFontSize = child.maxFontSize;
            this.skew = child.skew;
            this.italic = child.italic;
          } else {
            let height = -Infinity;
            let depth = -Infinity;
            let maxFontSize = 0;
            for (const child of this.children) {
              if (child.height > height)
                height = child.height;
              if (child.depth > depth)
                depth = child.depth;
              maxFontSize = Math.max(maxFontSize, (_f = child.maxFontSize) != null ? _f : 0);
            }
            this.height = height;
            this.depth = depth;
            this.maxFontSize = maxFontSize;
          }
        }
        if ((options == null ? void 0 : options.height) !== void 0)
          this.height = options.height;
        if ((options == null ? void 0 : options.depth) !== void 0)
          this.depth = options.depth;
        if ((options == null ? void 0 : options.maxFontSize) !== void 0)
          this.maxFontSize = options.maxFontSize;
      }
      set atomID(id) {
        if (id === void 0 || id.length === 0)
          return;
        if (!this.attributes)
          this.attributes = {};
        this.attributes["data-atom-id"] = id;
      }
      selected(isSelected) {
        if (this.isSelected === isSelected)
          return;
        this.isSelected = isSelected;
        if (this.children)
          for (const child of this.children)
            child.selected(isSelected);
      }
      setStyle(prop, value, unit) {
        if (value === void 0)
          return;
        const v = toString(value, unit);
        if (v.length > 0) {
          if (!this.cssProperties)
            this.cssProperties = {};
          this.cssProperties[prop] = v;
        }
      }
      setTop(top) {
        if (Number.isFinite(top) && Math.abs(top) > 0.01) {
          if (!this.cssProperties)
            this.cssProperties = {};
          this.cssProperties.top = toString(top, "em");
          this.height -= top;
          this.depth += top;
        }
      }
      get left() {
        var _a3;
        if ((_a3 = this.cssProperties) == null ? void 0 : _a3["margin-left"])
          return Number.parseFloat(this.cssProperties["margin-left"]);
        return 0;
      }
      set left(value) {
        if (!Number.isFinite(value))
          return;
        if (value === 0) {
          if (this.cssProperties)
            delete this.cssProperties["margin-left"];
        } else {
          if (!this.cssProperties)
            this.cssProperties = {};
          this.cssProperties["margin-left"] = toString(value, "em");
        }
      }
      set right(value) {
        if (!Number.isFinite(value))
          return;
        if (value === 0) {
          if (this.cssProperties)
            delete this.cssProperties["margin-right"];
        } else {
          if (!this.cssProperties)
            this.cssProperties = {};
          this.cssProperties["margin-right"] = toString(value, "em");
        }
      }
      set width(value) {
        if (!Number.isFinite(value))
          return;
        if (value === 0) {
          if (this.cssProperties)
            delete this.cssProperties.width;
        } else {
          if (!this.cssProperties)
            this.cssProperties = {};
          this.cssProperties.width = toString(value, "em");
        }
      }
      /**
       * If necessary wrap this box with another one that adjust the font-size
       * to account for a change in size between the context and its parent.
       * Also, apply color and background-color attributes.
       */
      wrap(context, options) {
        const parent = context.parent;
        if (!parent)
          return this;
        if (context.isPhantom)
          this.setStyle("opacity", 0);
        let newColor = context.computedColor;
        if (newColor === parent.computedColor)
          newColor = "";
        this.setStyle("color", newColor);
        const newSize = context.effectiveFontSize === parent.effectiveFontSize ? void 0 : context.effectiveFontSize;
        let newBackgroundColor = context.computedBackgroundColor;
        if (this.isSelected)
          newBackgroundColor = highlight(newBackgroundColor);
        if (newBackgroundColor === parent.computedBackgroundColor)
          newBackgroundColor = "";
        if (!newSize && !newBackgroundColor && !(options && (options.classes || options.type)))
          return this;
        let result;
        if (newBackgroundColor) {
          result = makeStruts(this, options);
          result.selected(this.isSelected);
          result.setStyle("background-color", newBackgroundColor);
          result.setStyle("display", "inline-block");
        } else
          result = new Box(this, options);
        const factor = context.scalingFactor;
        if (factor !== 1) {
          result.setStyle("font-size", factor * 100, "%");
          result.height *= factor;
          result.depth *= factor;
          result.italic *= factor;
          result.skew *= factor;
        }
        return result;
      }
      /** If necessary, wrap this box in another that accounts for
       * selected backgroundColor
       */
      wrapSelect(context) {
        if (!this.isSelected)
          return this;
        const parent = context.parent;
        if (!parent)
          return this;
        const newBackgroundColor = highlight(context.computedBackgroundColor);
        const result = makeStruts(this);
        result.selected(true);
        result.setStyle("background-color", newBackgroundColor);
        result.setStyle("display", "inline-block");
        return result;
      }
      /**
       * Generate the HTML markup to represent this box.
       */
      toMarkup() {
        var _a3, _b3, _c2;
        let body = (_a3 = this.value) != null ? _a3 : "";
        if (this.children)
          for (const box of this.children)
            body += box.toMarkup();
        const classes = this.classes.split(" ");
        classes.push(
          (_b3 = {
            latex: "ML__latex",
            placeholder: "ML__placeholder",
            error: "ML__error"
          }[this.type]) != null ? _b3 : ""
        );
        if (this.caret === "latex")
          classes.push("ML__latex-caret");
        const classList = classes.length === 1 ? classes[0] : classes.filter((x, e, a) => x.length > 0 && a.indexOf(x) === e).join(" ");
        let result = "";
        if (body.length > 0 && body !== "​" || classList.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
          let props = "";
          if (this.cssId) {
            props += ` id="${this.cssId.replace(/ /g, "-")}" `;
          }
          if (this.htmlData) {
            const entries = this.htmlData.split(",");
            for (const entry of entries) {
              const matched = entry.match(/([^=]+)=(.+$)/);
              if (matched) {
                const key = matched[1].trim().replace(/ /g, "-");
                if (key)
                  props += ` data-${key}="${matched[2]}" `;
              } else {
                const key = entry.trim().replace(/ /g, "-");
                if (key)
                  props += ` data-${key} `;
              }
            }
          }
          if (this.htmlStyle) {
            const entries = this.htmlStyle.split(";");
            let styleString = "";
            for (const entry of entries) {
              const matched = entry.match(/([^=]+):(.+$)/);
              if (matched) {
                const key = matched[1].trim().replace(/ /g, "-");
                if (key)
                  styleString += `${key}:${matched[2]};`;
              }
            }
            if (styleString)
              props += ` style="${styleString}"`;
          }
          if (this.attributes) {
            props += " " + Object.keys(this.attributes).map((x) => `${x}="${this.attributes[x]}"`).join(" ");
          }
          if (classList.length > 0)
            props += ` class="${classList}"`;
          if (this.cssProperties) {
            const styleString = Object.keys(this.cssProperties).map((x) => `${x}:${this.cssProperties[x]}`).join(";");
            if (styleString.length > 0)
              props += ` style="${styleString}"`;
          }
          let svgMarkup = "";
          if (this.svgBody)
            svgMarkup = svgBodyToMarkup(this.svgBody);
          else if (this.svgOverlay) {
            svgMarkup = '<span style="';
            svgMarkup += "display: inline-block;";
            svgMarkup += `height:${this.height + this.depth}em;`;
            svgMarkup += `vertical-align:${this.depth}em;`;
            svgMarkup += '">';
            svgMarkup += body;
            svgMarkup += "</span>";
            svgMarkup += '<svg style="position:absolute;overflow:overlay;';
            svgMarkup += `height:${this.height + this.depth}em;`;
            if ((_c2 = this.cssProperties) == null ? void 0 : _c2.padding) {
              svgMarkup += `top:${this.cssProperties.padding}em;`;
              svgMarkup += `left:${this.cssProperties.padding}em;`;
              svgMarkup += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`;
            } else
              svgMarkup += "top:0;left:0;width:100%;";
            svgMarkup += "z-index:2;";
            svgMarkup += '"';
            if (this.svgStyle)
              svgMarkup += ` style="${this.svgStyle}"`;
            svgMarkup += `>${this.svgOverlay}</svg>`;
          }
          result = `<span${props}>${body}${svgMarkup}</span>`;
        }
        if (this.caret === "text")
          result += '<span class="ML__text-caret"></span>';
        else if (this.caret === "math")
          result += '<span class="ML__caret"></span>';
        return result;
      }
      /**
       * Can this box be coalesced with 'box'?
       * This is used to 'coalesce' (i.e. group together) a series of boxes that are
       * identical except for their value, and to avoid generating redundant boxes.
       * That is: '12' ->
       *      "<span class='crm'>12</span>"
       * rather than:
       *      "<span class='crm'>1</span><span class='crm'>2</span>"
       */
      tryCoalesceWith(box) {
        if (this.type !== box.type)
          return false;
        if (!/ML__text/.test(this.classes) && !["mord", "mbin", "mrel"].includes(this.type))
          return false;
        if (this.svgBody || !this.value)
          return false;
        if (box.svgBody || !box.value)
          return false;
        const hasChildren = this.children && this.children.length > 0;
        const boxHasChildren = box.children && box.children.length > 0;
        if (hasChildren || boxHasChildren)
          return false;
        const thisStyleCount = this.cssProperties ? Object.keys(this.cssProperties).length : 0;
        const boxStyleCount = box.cssProperties ? Object.keys(box.cssProperties).length : 0;
        if (thisStyleCount !== boxStyleCount)
          return false;
        if (thisStyleCount > 0) {
          for (const prop of Object.keys(this.cssProperties))
            if (this.cssProperties[prop] !== box.cssProperties[prop])
              return false;
        }
        const classes = this.classes.trim().replace(/\s+/g, " ").split(" ");
        const boxClasses = box.classes.trim().replace(/\s+/g, " ").split(" ");
        if (classes.length !== boxClasses.length)
          return false;
        classes.sort();
        boxClasses.sort();
        for (const [i, class_] of classes.entries()) {
          if (class_ === "vertical-separator")
            return false;
          if (class_ !== boxClasses[i])
            return false;
        }
        this.value += box.value;
        this.height = Math.max(this.height, box.height);
        this.depth = Math.max(this.depth, box.depth);
        this.maxFontSize = Math.max(this.maxFontSize, box.maxFontSize);
        this.italic = box.italic;
        return true;
      }
    };
    function coalesceRecursive(boxes) {
      if (!boxes || boxes.length === 0)
        return [];
      boxes[0].children = coalesceRecursive(boxes[0].children);
      const result = [boxes[0]];
      for (let i = 1; i < boxes.length; i++) {
        if (!result[result.length - 1].tryCoalesceWith(boxes[i])) {
          boxes[i].children = coalesceRecursive(boxes[i].children);
          result.push(boxes[i]);
        }
      }
      return result;
    }
    function coalesce(box) {
      if (box.children)
        box.children = coalesceRecursive(box.children);
      return box;
    }
    function adjustType(root) {
      forEachBox(root, (prevBox, box) => {
        if (box.type === "mbin" && (!prevBox || /first|none|mbin|mop|mrel|mopen|mpunct/.test(prevBox.type)))
          box.type = "mord";
        if (prevBox && prevBox.type === "mbin" && /mrel|mclose|mpunct|placeholder/.test(box.type))
          prevBox.type = "mord";
      });
    }
    function applyInterAtomSpacing(root, context) {
      forEachBox(root, (prevBox, box) => {
        var _a3, _b3, _c2, _d2;
        const prevType = (_a3 = prevBox == null ? void 0 : prevBox.type) != null ? _a3 : "none";
        const table = box.isTight ? (_b3 = INTER_ATOM_TIGHT_SPACING[prevType]) != null ? _b3 : null : (_c2 = INTER_ATOM_SPACING[prevType]) != null ? _c2 : null;
        const hskip = (_d2 = table == null ? void 0 : table[box.type]) != null ? _d2 : "none";
        if (hskip !== "none") {
          if (hskip === 3)
            box.left += context.getRegisterAsEm("thinmuskip");
          if (hskip === 4)
            box.left += context.getRegisterAsEm("medmuskip");
          if (hskip === 5)
            box.left += context.getRegisterAsEm("thickmuskip");
        }
      });
    }
    function forEachBoxRecursive(prevBox, box, f) {
      if (box.newList)
        prevBox = null;
      const type = box.type;
      if (type === "first") {
        console.assert(box.newList === true);
        return null;
      }
      if (type === "spacing")
        return prevBox;
      f(prevBox, box);
      if (box.children) {
        let childPrev = null;
        if (type === void 0 || type.length === 0)
          childPrev = prevBox;
        for (const child of box.children)
          childPrev = forEachBoxRecursive(childPrev, child, f);
        if (type === void 0 || type.length === 0)
          prevBox = childPrev;
      }
      if (type !== "supsub" && type !== void 0 && type.length > 0)
        prevBox = box;
      return prevBox;
    }
    function forEachBox(box, f) {
      if (!box)
        return;
      forEachBoxRecursive(null, box, f);
    }
    function adjustInterAtomSpacing(root, context) {
      adjustType(root);
      applyInterAtomSpacing(root, context);
      return root;
    }
    function makeStruts(content, options) {
      if (!content)
        return new Box(null, options);
      const topStrut = new Box(null, { classes: "ML__strut" });
      topStrut.setStyle("height", Math.max(0, content.height), "em");
      const struts = [topStrut];
      if (content.depth !== 0) {
        const bottomStrut = new Box(null, { classes: "ML__strut--bottom" });
        bottomStrut.setStyle("height", content.height + content.depth, "em");
        bottomStrut.setStyle("vertical-align", -content.depth, "em");
        struts.push(bottomStrut);
      }
      struts.push(content);
      return new Box(struts, options);
    }
    function addSVGOverlay(body, svgMarkup, svgStyle) {
      body.svgOverlay = svgMarkup;
      body.svgStyle = svgStyle;
      return body;
    }
    function makeSVGBox(svgBodyName) {
      const height = svgBodyHeight(svgBodyName) / 2;
      const box = new Box(null, {
        height: height + 0.166,
        depth: height - 0.166,
        maxFontSize: 0
      });
      box.svgBody = svgBodyName;
      return box;
    }
    function getVListChildrenAndDepth(params) {
      if ("individualShift" in params) {
        const oldChildren = params.individualShift;
        let prevChild = oldChildren[0];
        const children = [prevChild];
        const depth = -prevChild.shift - prevChild.box.depth;
        let currPos = depth;
        for (let i = 1; i < oldChildren.length; i++) {
          const child = oldChildren[i];
          const diff = -child.shift - currPos - child.box.depth;
          const size2 = diff - (prevChild.box.height + prevChild.box.depth);
          currPos = currPos + diff;
          children.push(size2);
          children.push(child);
          prevChild = child;
        }
        return [children, depth];
      }
      if ("top" in params) {
        let bottom = params.top;
        for (const child of params.children) {
          bottom -= typeof child === "number" ? child : child.box.height + child.box.depth;
        }
        return [params.children, bottom];
      } else if ("bottom" in params)
        return [params.children, -params.bottom];
      else if ("firstBaseline" in params) {
        const firstChild = params.firstBaseline[0];
        if (typeof firstChild === "number")
          throw new Error("First child must be an element.");
        return [params.firstBaseline, -firstChild.box.depth];
      } else if ("shift" in params) {
        const firstChild = params.children[0];
        if (typeof firstChild === "number")
          throw new Error("First child must be an element.");
        return [params.children, -firstChild.box.depth - params.shift];
      }
      return [null, 0];
    }
    function makeRows(params) {
      var _a3;
      const [children, depth] = getVListChildrenAndDepth(params);
      if (!children)
        return [[], 0, 0];
      let pstrutSize = 0;
      for (const child of children) {
        if (typeof child !== "number") {
          const box = child.box;
          pstrutSize = Math.max(pstrutSize, box.maxFontSize, box.height);
        }
      }
      pstrutSize += 2;
      const pstrut = new Box(null, { classes: "pstrut" });
      pstrut.setStyle("height", pstrutSize, "em");
      const realChildren = [];
      let minPos = depth;
      let maxPos = depth;
      let currPos = depth;
      for (const child of children) {
        if (typeof child === "number")
          currPos += child;
        else {
          const box = child.box;
          const classes = (_a3 = child.classes) != null ? _a3 : [];
          const childWrap = new Box([pstrut, box], {
            classes: classes.join(" "),
            style: child.style
          });
          childWrap.setStyle("top", -pstrutSize - currPos - box.depth, "em");
          if (child.marginLeft)
            childWrap.setStyle("margin-left", child.marginLeft, "em");
          if (child.marginRight)
            childWrap.setStyle("margin-right", child.marginRight, "em");
          realChildren.push(childWrap);
          currPos += box.height + box.depth;
        }
        minPos = Math.min(minPos, currPos);
        maxPos = Math.max(maxPos, currPos);
      }
      const vlist = new Box(realChildren, { classes: "vlist" });
      vlist.setStyle("height", maxPos, "em");
      if (minPos >= 0)
        return [[new Box(vlist, { classes: "vlist-r" })], maxPos, -minPos];
      const depthStrut = new Box(new Box(null), { classes: "vlist" });
      depthStrut.setStyle("height", -minPos, "em");
      const topStrut = new Box(8203, {
        classes: "vlist-s",
        maxFontSize: 0,
        height: 0,
        depth: 0
      });
      return [
        [
          new Box([vlist, topStrut], { classes: "vlist-r" }),
          new Box(depthStrut, { classes: "vlist-r" })
        ],
        maxPos,
        -minPos
      ];
    }
    var VBox = class extends Box {
      constructor(content, options) {
        var _a3;
        const [rows, height, depth] = makeRows(content);
        super(rows.length === 1 ? rows[0] : rows, {
          classes: ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "") + " vlist-t" + (rows.length === 2 ? " vlist-t2" : ""),
          height,
          depth,
          type: options == null ? void 0 : options.type
        });
      }
    };
    function makeLimitsStack(context, options) {
      var _a3, _b3, _c2, _d2, _e;
      const metrics = context.metrics;
      const base = new Box(options.base);
      const baseShift = (_a3 = options.baseShift) != null ? _a3 : 0;
      const slant = (_b3 = options.slant) != null ? _b3 : 0;
      let aboveShift = 0;
      let belowShift = 0;
      if (options.above) {
        aboveShift = (_c2 = options.aboveShift) != null ? _c2 : Math.max(
          metrics.bigOpSpacing1,
          metrics.bigOpSpacing3 - options.above.depth
        );
      }
      if (options.below) {
        belowShift = (_d2 = options.belowShift) != null ? _d2 : Math.max(
          metrics.bigOpSpacing2,
          metrics.bigOpSpacing4 - options.below.height
        );
      }
      let result = null;
      if (options.below && options.above) {
        const bottom = metrics.bigOpSpacing5 + options.below.height + options.below.depth + belowShift + base.depth + baseShift;
        result = new VBox({
          bottom,
          children: [
            metrics.bigOpSpacing5,
            {
              box: options.below,
              marginLeft: -slant,
              classes: ["ML__center"]
            },
            belowShift,
            //  We need to center the base to account for the case where the
            // above/below is wider
            { box: base, classes: ["ML__center"] },
            aboveShift,
            {
              box: options.above,
              marginLeft: slant,
              classes: ["ML__center"]
            },
            metrics.bigOpSpacing5
          ]
        }).wrap(context);
      } else if (options.below && !options.above) {
        result = new VBox({
          top: base.height - baseShift,
          children: [
            metrics.bigOpSpacing5,
            {
              box: options.below,
              marginLeft: -slant,
              classes: ["ML__center"]
            },
            belowShift,
            { box: base, classes: ["ML__center"] }
          ]
        }).wrap(context);
      } else if (!options.below && options.above) {
        const bottom = base.depth + baseShift;
        result = new VBox({
          bottom,
          children: [
            { box: base, classes: ["ML__center"] },
            aboveShift,
            {
              box: options.above,
              marginLeft: slant,
              classes: ["ML__center"]
            },
            metrics.bigOpSpacing5
          ]
        }).wrap(context);
      } else {
        const bottom = base.depth + baseShift;
        result = new VBox({
          bottom,
          children: [{ box: base }, metrics.bigOpSpacing5]
        }).wrap(context);
      }
      console.assert(options.type !== void 0);
      return new Box(result, { type: (_e = options.type) != null ? _e : "mop" });
    }
    function stringToCodepoints(string) {
      const result = [];
      for (let i = 0; i < string.length; i++) {
        let code = string.charCodeAt(i);
        if (code === 13 && string.charCodeAt(i + 1) === 10) {
          code = 10;
          i++;
        }
        if (code === 13 || code === 12)
          code = 10;
        if (code === 0)
          code = 65533;
        if (code >= 55296 && code <= 56319) {
          const nextCode = string.charCodeAt(i + 1);
          if (nextCode >= 56320 && nextCode <= 57343) {
            const lead = code - 55296;
            const trail = nextCode - 56320;
            code = 2 ** 16 + lead * 2 ** 10 + trail;
            i++;
          }
        }
        result.push(code);
      }
      return result;
    }
    var ZWJ = 8205;
    var EMOJI_COMBINATOR = [
      [ZWJ, 1],
      [65038, 2],
      // VS-15: text presentation, VS-16: Emoji presentation
      [127995, 5],
      // EMOJI_MODIFIER_FITZPATRICK_TYPE 1-6
      [129456, 4],
      // Red hair..white hair
      [917536, 96]
      // EMOJI_TAG
    ];
    var emojiCombinator;
    var REGIONAL_INDICATOR = [127462, 127487];
    function isEmojiCombinator(code) {
      var _a3;
      if (emojiCombinator === void 0) {
        emojiCombinator = {};
        for (const x of EMOJI_COMBINATOR)
          for (let i = x[0]; i <= x[0] + x[1] - 1; i++)
            emojiCombinator[i] = true;
      }
      return (_a3 = emojiCombinator[code]) != null ? _a3 : false;
    }
    function isRegionalIndicator(code) {
      return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
    }
    function splitGraphemes(string) {
      if (/^[\u0020-\u00FF]*$/.test(string))
        return string;
      const result = [];
      const codePoints = stringToCodepoints(string);
      let index = 0;
      while (index < codePoints.length) {
        const code = codePoints[index++];
        const next = codePoints[index];
        if (next === ZWJ) {
          const baseIndex = index - 1;
          index += 2;
          while (codePoints[index] === ZWJ)
            index += 2;
          result.push(
            String.fromCodePoint(
              ...codePoints.slice(baseIndex, index - baseIndex + 1)
            )
          );
        } else if (isEmojiCombinator(next)) {
          const baseIndex = index - 1;
          while (isEmojiCombinator(codePoints[index]))
            index += codePoints[index] === ZWJ ? 2 : 1;
          result.push(
            String.fromCodePoint(
              ...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)
            )
          );
        } else if (isRegionalIndicator(code)) {
          index += 1;
          result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
        } else
          result.push(String.fromCodePoint(code));
      }
      return result;
    }
    var Tokenizer = class {
      constructor(s) {
        this.s = splitGraphemes(s);
        this.pos = 0;
        this.obeyspaces = false;
      }
      /**
       * @return True if we reached the end of the stream
       */
      end() {
        return this.pos >= this.s.length;
      }
      /**
       * Return the next char and advance
       */
      get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
      }
      /**
       * Return the next char, but do not advance
       */
      peek() {
        return this.s[this.pos];
      }
      /**
       * Return the next substring matching regEx and advance.
       */
      match(regEx) {
        const execResult = typeof this.s === "string" ? regEx.exec(this.s.slice(this.pos)) : regEx.exec(this.s.slice(this.pos).join(""));
        if (execResult == null ? void 0 : execResult[0]) {
          this.pos += execResult[0].length;
          return execResult[0];
        }
        return "";
      }
      /**
       * Return the next token, or null.
       */
      next() {
        if (this.end())
          return null;
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/)) {
          return "<space>";
        }
        if (this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/)) {
          return "<space>";
        }
        const next = this.get();
        if (next === "\\") {
          if (!this.end()) {
            let command = this.match(/^[a-zA-Z\*]+/);
            if (command) {
              this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
            } else {
              command = this.get();
              if (command === " ") {
                return "<space>";
              }
            }
            return "\\" + command;
          }
        } else if (next === "{") {
          return "<{>";
        } else if (next === "}") {
          return "<}>";
        } else if (next === "^") {
          if (this.peek() === "^") {
            this.get();
            const hex = this.match(
              /^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/
            );
            if (hex) {
              return String.fromCodePoint(
                Number.parseInt(hex.slice(hex.lastIndexOf("^") + 1), 16)
              );
            }
          }
          return next;
        } else if (next === "#") {
          if (!this.end()) {
            let isParameter = false;
            if (/[\d?@]/.test(this.peek())) {
              isParameter = true;
              if (this.pos + 1 < this.s.length) {
                const after = this.s[this.pos + 1];
                isParameter = /[^\dA-Za-z]/.test(after);
              }
            }
            if (isParameter)
              return "#" + this.get();
            return "#";
          }
        } else if (next === "$") {
          if (this.peek() === "$") {
            this.get();
            return "<$$>";
          }
          return "<$>";
        }
        return next;
      }
    };
    function expand(lex, args) {
      var _a3, _b3, _c2, _d2;
      const result = [];
      let token = lex.next();
      if (token) {
        if (token === "\\relax")
          ;
        else if (token === "\\noexpand") {
          token = lex.next();
          if (token)
            result.push(token);
        } else if (token === "\\obeyspaces")
          lex.obeyspaces = true;
        else if (token === "\\space" || token === "~") {
          result.push("<space>");
        } else if (token === "\\bgroup") {
          result.push("<{>");
        } else if (token === "\\egroup") {
          result.push("<}>");
        } else if (token === "\\string") {
          token = lex.next();
          if (token) {
            if (token.startsWith("\\"))
              for (const x of token)
                result.push(x === "\\" ? "\\backslash" : x);
            else if (token === "<{>")
              result.push("\\{");
            else if (token === "<space>")
              result.push("~");
            else if (token === "<}>")
              result.push("\\}");
          }
        } else if (token === "\\csname") {
          while (lex.peek() === "<space>")
            lex.next();
          let command = "";
          let done = false;
          let tokens = [];
          do {
            if (tokens.length === 0) {
              if (/^#[\d?@]$/.test(lex.peek())) {
                const parameter = lex.get().slice(1);
                tokens = tokenize(
                  (_b3 = (_a3 = args == null ? void 0 : args(parameter)) != null ? _a3 : args == null ? void 0 : args("?")) != null ? _b3 : "\\placeholder{}",
                  args
                );
                token = tokens[0];
              } else {
                token = lex.next();
                tokens = token ? [token] : [];
              }
            }
            done = tokens.length === 0;
            if (!done && token === "\\endcsname") {
              done = true;
              tokens.shift();
            }
            if (!done) {
              done = token === "<$>" || token === "<$$>" || token === "<{>" || token === "<}>" || typeof token === "string" && token.length > 1 && token.startsWith("\\");
            }
            if (!done)
              command += tokens.shift();
          } while (!done);
          if (command)
            result.push("\\" + command);
          result.push(...tokens);
        } else if (token === "\\endcsname")
          ;
        else if (token.length > 1 && token.startsWith("#")) {
          const parameter = token.slice(1);
          result.push(
            ...tokenize((_d2 = (_c2 = args == null ? void 0 : args(parameter)) != null ? _c2 : args == null ? void 0 : args("?")) != null ? _d2 : "\\placeholder{}", args)
          );
        } else
          result.push(token);
      }
      return result;
    }
    function tokenize(s, args = null) {
      const stream = [];
      let sep = "";
      for (const line of s.toString().split(/\r?\n/)) {
        if (sep)
          stream.push(sep);
        sep = " ";
        const m = line.match(/((?:\\%)|[^%])*/);
        if (m !== null)
          stream.push(m[0]);
      }
      const tokenizer = new Tokenizer(stream.join(""));
      const result = [];
      do
        result.push(...expand(tokenizer, args));
      while (!tokenizer.end());
      return result;
    }
    function joinLatex(segments) {
      let sep = "";
      const result = [];
      for (const segment of segments) {
        if (segment) {
          if (/[a-zA-Z\*]/.test(segment[0]))
            result.push(sep);
          result.push(segment);
          if (/\\[a-zA-Z]+\*?[\"\'][^\ ]+$/.test(segment))
            result.push(" ");
          sep = /\\[a-zA-Z]+\*?$/.test(segment) ? " " : "";
        }
      }
      return result.join("");
    }
    function tokensToString(tokens) {
      return joinLatex(
        tokens.map((token) => {
          var _a3;
          return (_a3 = {
            "<space>": " ",
            "<$$>": "$$",
            "<$>": "$",
            "<{>": "{",
            "<}>": "}"
          }[token]) != null ? _a3 : token;
        })
      );
    }
    var MATH_LETTER_EXCEPTIONS = {
      119893: 8462,
      119965: 8492,
      119968: 8496,
      119969: 8497,
      119971: 8459,
      119972: 8464,
      119975: 8466,
      119976: 8499,
      119981: 8475,
      119994: 8495,
      119996: 8458,
      120004: 8500,
      120070: 8493,
      120075: 8460,
      120076: 8465,
      120085: 8476,
      120093: 8488,
      120122: 8450,
      120127: 8461,
      120133: 8469,
      120135: 8473,
      120136: 8474,
      120137: 8477,
      120145: 8484
    };
    var MATH_UNICODE_BLOCKS = [
      { start: 119808, len: 26, offset: 65, style: "bold" },
      { start: 119834, len: 26, offset: 97, style: "bold" },
      { start: 119860, len: 26, offset: 65, style: "italic" },
      { start: 119886, len: 26, offset: 97, style: "italic" },
      { start: 119912, len: 26, offset: 65, style: "bolditalic" },
      { start: 119938, len: 26, offset: 97, style: "bolditalic" },
      { start: 119964, len: 26, offset: 65, variant: "script" },
      { start: 119990, len: 26, offset: 97, variant: "script" },
      { start: 120016, len: 26, offset: 65, variant: "script", style: "bold" },
      { start: 120042, len: 26, offset: 97, variant: "script", style: "bold" },
      { start: 120068, len: 26, offset: 65, variant: "fraktur" },
      { start: 120094, len: 26, offset: 97, variant: "fraktur" },
      { start: 120172, len: 26, offset: 65, variant: "fraktur", style: "bold" },
      { start: 120198, len: 26, offset: 97, variant: "fraktur", style: "bold" },
      { start: 120120, len: 26, offset: 65, variant: "double-struck" },
      { start: 120146, len: 26, offset: 97, variant: "double-struck" },
      { start: 120224, len: 26, offset: 65, variant: "sans-serif" },
      { start: 120250, len: 26, offset: 97, variant: "sans-serif" },
      {
        start: 120276,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "bold"
      },
      {
        start: 120302,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "bold"
      },
      {
        start: 120328,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "italic"
      },
      {
        start: 120354,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "italic"
      },
      {
        start: 120380,
        len: 26,
        offset: 65,
        variant: "sans-serif",
        style: "bolditalic"
      },
      {
        start: 120406,
        len: 26,
        offset: 97,
        variant: "sans-serif",
        style: "bolditalic"
      },
      { start: 120432, len: 26, offset: 65, variant: "monospace" },
      { start: 120458, len: 26, offset: 97, variant: "monospace" },
      { start: 120488, len: 25, offset: 913, style: "bold" },
      { start: 120514, len: 25, offset: 945, style: "bold" },
      { start: 120546, len: 25, offset: 913, style: "italic" },
      { start: 120572, len: 25, offset: 945, style: "italic" },
      { start: 120604, len: 25, offset: 913, style: "bolditalic" },
      { start: 120630, len: 25, offset: 945, style: "bolditalic" },
      {
        start: 120662,
        len: 25,
        offset: 913,
        variant: "sans-serif",
        style: "bold"
      },
      {
        start: 120688,
        len: 25,
        offset: 945,
        variant: "sans-serif",
        style: "bold"
      },
      {
        start: 120720,
        len: 25,
        offset: 913,
        variant: "sans-serif",
        style: "bolditalic"
      },
      {
        start: 120746,
        len: 25,
        offset: 945,
        variant: "sans-serif",
        style: "bolditalic"
      },
      { start: 120782, len: 10, offset: 48, variant: "main", style: "bold" },
      { start: 120792, len: 10, offset: 48, variant: "double-struck" },
      { start: 120803, len: 10, offset: 48, variant: "sans-serif" },
      {
        start: 120812,
        len: 10,
        offset: 48,
        variant: "sans-serif",
        style: "bold"
      },
      { start: 120822, len: 10, offset: 48, variant: "monospace" }
    ];
    function mathVariantToUnicode(char, variant, style) {
      if (!/[A-Za-z\d]/.test(char))
        return char;
      if (!variant && !style)
        return char;
      const codepoint = char.codePointAt(0);
      if (codepoint === void 0)
        return char;
      for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
        if (!variant || MATH_UNICODE_BLOCK.variant === variant) {
          if (!style || MATH_UNICODE_BLOCK.style === style) {
            if (codepoint >= MATH_UNICODE_BLOCK.offset && codepoint < MATH_UNICODE_BLOCK.offset + MATH_UNICODE_BLOCK.len) {
              const result = MATH_UNICODE_BLOCK.start + codepoint - MATH_UNICODE_BLOCK.offset;
              return String.fromCodePoint(MATH_LETTER_EXCEPTIONS[result] || result);
            }
          }
        }
      }
      return char;
    }
    function unicodeToMathVariant(codepoint) {
      var _a3;
      if ((codepoint < 119808 || codepoint > 120831) && (codepoint < 8448 || codepoint > 8527))
        return { char: String.fromCodePoint(codepoint) };
      for (const c in MATH_LETTER_EXCEPTIONS) {
        if (MATH_LETTER_EXCEPTIONS[c] === codepoint) {
          codepoint = (_a3 = c.codePointAt(0)) != null ? _a3 : 0;
          break;
        }
      }
      for (const MATH_UNICODE_BLOCK of MATH_UNICODE_BLOCKS) {
        if (codepoint >= MATH_UNICODE_BLOCK.start && codepoint < MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.len) {
          return {
            char: String.fromCodePoint(
              codepoint - MATH_UNICODE_BLOCK.start + MATH_UNICODE_BLOCK.offset
            ),
            variant: MATH_UNICODE_BLOCK.variant,
            style: MATH_UNICODE_BLOCK.style
          };
        }
      }
      return { char: String.fromCodePoint(codepoint) };
    }
    var MATH_SYMBOLS = {};
    var REVERSE_MATH_SYMBOLS = {
      60: "\\lt",
      62: "\\gt",
      111: "o",
      // Also \omicron
      38: "\\&",
      // Also \And
      123: "\\lbrace",
      125: "\\rbrace",
      91: "\\lbrack",
      93: "\\rbrack",
      58: "\\colon",
      // Also :
      160: "~",
      // Also \space
      172: "\\neg",
      // Also \lnot
      183: "\\cdot",
      188: "\\frac{1}{4}",
      189: "\\frac{1}{2}",
      190: "\\frac{3}{4}",
      8304: "^{0}",
      8305: "^{i}",
      185: "^{1}",
      178: "^{2}",
      179: "^{3}",
      8224: "\\dagger",
      // Also \dag
      8225: "\\ddagger",
      // Also \ddag
      8230: "\\ldots",
      // Also \mathellipsis
      8308: "^{4}",
      8309: "^{5}",
      8310: "^{6}",
      8311: "^{7}",
      8312: "^{8}",
      8313: "^{9}",
      8314: "^{+}",
      8315: "^{-}",
      8316: "^{=}",
      8319: "^{n}",
      8320: "_{0}",
      8321: "_{1}",
      8322: "_{2}",
      8323: "_{3}",
      8324: "_{4}",
      8325: "_{5}",
      8326: "_{6}",
      8327: "_{7}",
      8328: "_{8}",
      8329: "_{9}",
      8330: "_{+}",
      8331: "_{-}",
      8332: "_{=}",
      8336: "_{a}",
      8337: "_{e}",
      8338: "_{o}",
      8339: "_{x}",
      8242: "\\prime",
      39: "\\prime",
      8592: "\\gets",
      // Also \leftarrow
      8594: "\\to",
      // Also \rightarrow
      9651: "\\triangle",
      // Also \bigtriangleup, \vartriangle
      9661: "\\triangledown",
      8715: "\\owns",
      // Also \ni
      8727: "\\ast",
      // Also *
      8739: "\\vert",
      // Also |, \mvert, \lvert, \rvert
      8741: "\\Vert",
      // Also \parallel \shortparallel
      8743: "\\land",
      // Also \wedge
      8744: "\\lor",
      // Also \vee
      8901: "\\cdot",
      // Also \centerdot, \cdotp
      8904: "\\bowtie",
      // Also \Joint
      8800: "\\ne",
      // Also \neq
      8804: "\\le",
      // Also \leq
      8805: "\\ge",
      // Also \geq
      8869: "\\bot",
      // Also \perp
      10231: "\\biconditional",
      // Also \longleftrightarrow
      10232: "\\impliedby",
      // Also \Longleftarrow
      10233: "\\implies",
      // Also \Longrightarrow
      10234: "\\iff",
      8450: "\\mathbb{C}",
      // Also \doubleStruckCapitalC
      8469: "\\mathbb{N}",
      // Also \doubleStruckCapitalN
      8473: "\\mathbb{P}",
      // Also \doubleStruckCapitalP
      8474: "\\mathbb{Q}",
      // Also \doubleStruckCapitalQ
      8477: "\\mathbb{R}",
      // Also \doubleStruckCapitalR
      8484: "\\mathbb{Z}",
      // Also \doubleStruckCapitalZ
      8461: "\\mathbb{H}",
      8476: "\\Re",
      8465: "\\Im",
      42: "\\ast",
      11036: "\\square",
      9633: "\\square",
      8720: "\\coprod",
      8716: "\\not\\ni",
      9671: "\\diamond",
      8846: "\\uplus",
      8851: "\\sqcap",
      8852: "\\sqcup",
      8768: "\\wr",
      8750: "\\oint",
      8226: "\\textbullet",
      8722: "-",
      978: "\\Upsilon"
    };
    var LATEX_COMMANDS = {};
    var ENVIRONMENTS = {};
    var TEXVC_MACROS = {
      //////////////////////////////////////////////////////////////////////
      // texvc.sty
      // The texvc package contains macros available in mediawiki pages.
      // We omit the functions deprecated at
      // https://en.wikipedia.org/wiki/Help:Displaying_a_formula#Deprecated_syntax
      // We also omit texvc's \O, which conflicts with \text{\O}
      darr: "\\downarrow",
      dArr: "\\Downarrow",
      Darr: "\\Downarrow",
      lang: "\\langle",
      rang: "\\rangle",
      uarr: "\\uparrow",
      uArr: "\\Uparrow",
      Uarr: "\\Uparrow",
      N: "\\mathbb{N}",
      R: "\\mathbb{R}",
      Z: "\\mathbb{Z}",
      alef: "\\aleph",
      alefsym: "\\aleph",
      Alpha: "\\mathrm{A}",
      Beta: "\\mathrm{B}",
      bull: "\\bullet",
      Chi: "\\mathrm{X}",
      clubs: "\\clubsuit",
      cnums: "\\mathbb{C}",
      Complex: "\\mathbb{C}",
      Dagger: "\\ddagger",
      diamonds: "\\diamondsuit",
      empty: "\\emptyset",
      Epsilon: "\\mathrm{E}",
      Eta: "\\mathrm{H}",
      exist: "\\exists",
      harr: "\\leftrightarrow",
      hArr: "\\Leftrightarrow",
      Harr: "\\Leftrightarrow",
      hearts: "\\heartsuit",
      image: "\\Im",
      infin: "\\infty",
      Iota: "\\mathrm{I}",
      isin: "\\in",
      Kappa: "\\mathrm{K}",
      larr: "\\leftarrow",
      lArr: "\\Leftarrow",
      Larr: "\\Leftarrow",
      lrarr: "\\leftrightarrow",
      lrArr: "\\Leftrightarrow",
      Lrarr: "\\Leftrightarrow",
      Mu: "\\mathrm{M}",
      natnums: "\\mathbb{N}",
      Nu: "\\mathrm{N}",
      Omicron: "\\mathrm{O}",
      plusmn: "\\pm",
      rarr: "\\rightarrow",
      rArr: "\\Rightarrow",
      Rarr: "\\Rightarrow",
      real: "\\Re",
      reals: "\\mathbb{R}",
      Reals: "\\mathbb{R}",
      Rho: "\\mathrm{P}",
      sdot: "\\cdot",
      sect: "\\S",
      spades: "\\spadesuit",
      sub: "\\subset",
      sube: "\\subseteq",
      supe: "\\supseteq",
      Tau: "\\mathrm{T}",
      thetasym: "\\vartheta",
      // TODO: varcoppa: { def: "\\\mbox{\\coppa}", expand: false },
      weierp: "\\wp",
      Zeta: "\\mathrm{Z}"
    };
    var AMSMATH_MACROS = {
      // amsmath.sty
      // http://mirrors.concertpass.com/tex-archive/macros/latex/required/amsmath/amsmath.pdf
      // Italic Greek capital letters.  AMS defines these with \DeclareMathSymbol,
      // but they are equivalent to \mathit{\Letter}.
      varGamma: "\\mathit{\\Gamma}",
      varDelta: "\\mathit{\\Delta}",
      varTheta: "\\mathit{\\Theta}",
      varLambda: "\\mathit{\\Lambda}",
      varXi: "\\mathit{\\Xi}",
      varPi: "\\mathit{\\Pi}",
      varSigma: "\\mathit{\\Sigma}",
      varUpsilon: "\\mathit{\\Upsilon}",
      varPhi: "\\mathit{\\Phi}",
      varPsi: "\\mathit{\\Psi}",
      varOmega: "\\mathit{\\Omega}",
      // From http://tug.ctan.org/macros/latex/required/amsmath/amsmath.dtx
      // > \newcommand{\pod}[1]{
      // >    \allowbreak
      // >    \if@display
      // >      \mkern18mu
      // >    \else
      // >      \mkern8mu
      // >    \fi
      // >    (#1)
      // > }
      // 18mu = \quad
      // > \renewcommand{\pmod}[1]{
      // >  \pod{{\operator@font mod}\mkern6mu#1}
      // > }
      pmod: {
        def: "\\quad(\\operatorname{mod}\\ #1)",
        args: 1,
        expand: false
      },
      // > \newcommand{\mod}[1]{
      // >    \allowbreak
      // >    \if@display
      // >      \mkern18mu
      // >    \else
      // >      \mkern12mu
      // >    \fi
      //>     {\operator@font mod}\,\,#1}
      mod: {
        def: "\\quad\\operatorname{mod}\\,\\,#1",
        args: 1,
        expand: false
      },
      // > \renewcommand{\bmod}{
      // >  \nonscript\mskip-\medmuskip\mkern5mu
      // >  \mathbin{\operator@font mod}
      // >  \penalty900 \mkern5mu
      // >  \nonscript\mskip-\medmuskip
      // > }
      // 5mu = \;
      bmod: {
        def: "\\;\\mathbin{\\operatorname{mod }}",
        expand: false
      }
    };
    var BRAKET_MACROS = {
      bra: "\\mathinner{\\langle{#1}|}",
      ket: "\\mathinner{|{#1}\\rangle}",
      braket: "\\mathinner{\\langle{#1}\\rangle}",
      set: "\\mathinner{\\lbrace #1 \\rbrace}",
      Bra: "\\left\\langle #1\\right|",
      Ket: "\\left|#1\\right\\rangle",
      Braket: "\\left\\langle{#1}\\right\\rangle",
      Set: "\\left\\lbrace #1 \\right\\rbrace"
    };
    var DEFAULT_MACROS = {
      "iff": "\\;⟺\\;",
      // >2,000 Note: additional spaces around the arrows
      "nicefrac": "^{#1}\\!\\!/\\!_{#2}",
      // Proof Wiki
      "rd": "\\mathrm{d}",
      "rD": "\\mathrm{D}",
      // From Wolfram Alpha
      "doubleStruckCapitalN": "\\mathbb{N}",
      "doubleStruckCapitalR": "\\mathbb{R}",
      "doubleStruckCapitalQ": "\\mathbb{Q}",
      "doubleStruckCapitalZ": "\\mathbb{Z}",
      "doubleStruckCapitalP": "\\mathbb{P}",
      "scriptCapitalE": "\\mathscr{E}",
      "scriptCapitalH": "\\mathscr{H}",
      "scriptCapitalL": "\\mathscr{L}",
      "gothicCapitalC": "\\mathfrak{C}",
      "gothicCapitalH": "\\mathfrak{H}",
      "gothicCapitalI": "\\mathfrak{I}",
      "gothicCapitalR": "\\mathfrak{R}",
      "imaginaryI": "\\mathrm{i}",
      // NOTE: set in main (upright) as per ISO 80000-2:2009.
      "imaginaryJ": "\\mathrm{j}",
      // NOTE: set in main (upright) as per ISO 80000-2:2009.
      "exponentialE": "\\mathrm{e}",
      // NOTE: set in main (upright) as per ISO 80000-2:2009.
      "differentialD": "\\mathrm{d}",
      // NOTE: set in main (upright) as per ISO 80000-2:2009.
      "capitalDifferentialD": "\\mathrm{D}",
      // NOTE: set in main (upright) as per ISO 80000-2:2009.
      "braket.sty": { package: BRAKET_MACROS },
      "amsmath.sty": {
        package: AMSMATH_MACROS,
        expand: false
      },
      "texvc.sty": {
        package: TEXVC_MACROS,
        expand: false
      }
    };
    var TEXT_SYMBOLS = {
      " ": 32,
      "\\#": 35,
      "\\&": 38,
      "\\$": 36,
      "\\%": 37,
      "\\_": 95,
      "\\euro": 8364,
      "\\maltese": 10016,
      "\\{": 123,
      "\\}": 125,
      "\\nobreakspace": 160,
      "\\ldots": 8230,
      "\\textellipsis": 8230,
      "\\backslash": 92,
      "`": 8216,
      "'": 8217,
      "``": 8220,
      "''": 8221,
      "\\degree": 176,
      "\\textasciicircum": 94,
      "\\textasciitilde": 126,
      "\\textasteriskcentered": 42,
      "\\textbackslash": 92,
      "\\textbraceleft": 123,
      "\\textbraceright": 125,
      "\\textbullet": 8226,
      "\\textdollar": 36,
      "\\textsterling": 163,
      "\\textdagger": 8224,
      "\\textdaggerdbl": 8225,
      "–": 8211,
      // EN DASH
      "—": 8212,
      // EM DASH
      "‘": 8216,
      // LEFT SINGLE QUOTATION MARK
      "’": 8217,
      // RIGHT SINGLE QUOTATION MARK
      "“": 8220,
      // LEFT DOUBLE QUOTATION MARK
      "”": 8221,
      // RIGHT DOUBLE QUOTATION MARK
      '"': 8221,
      // DOUBLE PRIME
      "\\ss": 223,
      // LATIN SMALL LETTER SHARP S
      "\\ae": 230,
      // LATIN SMALL LETTER AE
      "\\oe": 339,
      // LATIN SMALL LIGATURE OE
      "\\AE": 198,
      // LATIN CAPITAL LETTER AE
      "\\OE": 338,
      // LATIN CAPITAL LIGATURE OE
      "\\O": 216,
      // LATIN CAPITAL LETTER O WITH STROKE
      "\\i": 305,
      // LATIN SMALL LETTER DOTLESS I
      "\\j": 567,
      // LATIN SMALL LETTER DOTLESS J
      "\\aa": 229,
      // LATIN SMALL LETTER A WITH RING ABOVE
      "\\AA": 197
      // LATIN CAPITAL LETTER A WITH RING ABOVE
    };
    var COMMAND_MODE_CHARACTERS = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/;
    var LETTER = supportRegexPropertyEscape() ? (
      /* eslint-disable-next-line prefer-regex-literals */
      new RegExp("\\p{Letter}", "u")
    ) : /[a-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒößÖẞìíòúÌÍÒÚáñÁÑ]/;
    var LETTER_AND_DIGITS = supportRegexPropertyEscape() ? (
      /* eslint-disable-next-line prefer-regex-literals */
      new RegExp("[0-9\\p{Letter}]", "u")
    ) : /[\da-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒößÖẞìíòúÌÍÒÚáñÁÑ]/;
    function newSymbol(symbol, value, type = "mord", variant) {
      if (value === void 0)
        return;
      MATH_SYMBOLS[symbol] = {
        definitionType: "symbol",
        type,
        variant,
        codepoint: value
      };
      if (!REVERSE_MATH_SYMBOLS[value])
        REVERSE_MATH_SYMBOLS[value] = symbol;
      if (!TEXT_SYMBOLS[symbol])
        TEXT_SYMBOLS[symbol] = value;
    }
    function newSymbols(value, inType, inVariant) {
      if (typeof value === "string") {
        for (let i = 0; i < value.length; i++) {
          const ch = value.charAt(i);
          newSymbol(ch, ch.codePointAt(0));
        }
        return;
      }
      for (const [symbol, val, type, variant] of value)
        newSymbol(symbol, val, type != null ? type : inType, variant != null ? variant : inVariant);
    }
    function newSymbolRange(from, to) {
      for (let i = from; i <= to; i++)
        newSymbol(String.fromCodePoint(i), i);
    }
    function getEnvironmentDefinition(name) {
      var _a3;
      return (_a3 = ENVIRONMENTS[name]) != null ? _a3 : null;
    }
    function suggest(mf, s) {
      var _a3, _b3;
      if (s === "\\")
        return [];
      if (!s.startsWith("\\"))
        return [];
      const result = [];
      for (const p2 in LATEX_COMMANDS) {
        if (p2.startsWith(s) && !LATEX_COMMANDS[p2].infix)
          result.push({ match: p2, frequency: (_a3 = LATEX_COMMANDS[p2].frequency) != null ? _a3 : 0 });
      }
      for (const p2 in MATH_SYMBOLS) {
        if (p2.startsWith(s))
          result.push({ match: p2, frequency: (_b3 = MATH_SYMBOLS[p2].frequency) != null ? _b3 : 0 });
      }
      const command = s.substring(1);
      for (const p2 of Object.keys(mf.options.macros))
        if (p2.startsWith(command))
          result.push({ match: "\\" + p2, frequency: 0 });
      result.sort((a, b) => {
        var _a4, _b4;
        if (a.frequency === b.frequency) {
          if (a.match.length === b.match.length)
            return a.match < b.match ? -1 : 1;
          return a.match.length - b.match.length;
        }
        return ((_a4 = b.frequency) != null ? _a4 : 0) - ((_b4 = a.frequency) != null ? _b4 : 0);
      });
      return result.map((x) => x.match);
    }
    function parseParameterTemplateArgument(argTemplate) {
      let type = "auto";
      const r = argTemplate.match(/:([^=]+)/);
      if (r)
        type = r[1].trim();
      return type;
    }
    function parseParameterTemplate(parameterTemplate) {
      if (!parameterTemplate)
        return [];
      const result = [];
      let parameters = parameterTemplate.split("]");
      if (parameters[0].startsWith("[")) {
        result.push({
          isOptional: true,
          type: parseParameterTemplateArgument(parameters[0].slice(1))
        });
        for (let i = 1; i <= parameters.length; i++)
          result.push(...parseParameterTemplate(parameters[i]));
      } else {
        parameters = parameterTemplate.split("}");
        if (parameters[0].startsWith("{")) {
          result.push({
            isOptional: false,
            type: parseParameterTemplateArgument(parameters[0].slice(1))
          });
          for (let i = 1; i <= parameters.length; i++)
            result.push(...parseParameterTemplate(parameters[i]));
        }
      }
      return result;
    }
    function parseArgAsString(atoms) {
      if (!atoms)
        return "";
      let result = "";
      let success = true;
      for (const atom of atoms) {
        if (typeof atom.value === "string")
          result += atom.value;
        else
          success = false;
      }
      return success ? result : "";
    }
    function defineEnvironment(names, parameters, createAtom, isTabular = false) {
      if (typeof names === "string")
        names = [names];
      const parsedParameters = parseParameterTemplate(parameters);
      const data = {
        tabular: isTabular,
        // Params: the parameters for this function, an array of
        // {optional, type}
        params: parsedParameters,
        // Handler to create an atom
        createAtom
      };
      for (const name of names)
        ENVIRONMENTS[name] = data;
    }
    function defineTabularEnvironment(names, parameters, createAtom) {
      defineEnvironment(names, parameters, createAtom, true);
    }
    function defineFunction(names, parameters, options) {
      var _a3, _b3;
      if (!options)
        options = {};
      const data = {
        definitionType: "function",
        // The parameters for this function, an array of
        // {optional, type}
        params: parseParameterTemplate(parameters),
        ifMode: options.ifMode,
        isFunction: (_a3 = options.isFunction) != null ? _a3 : false,
        applyMode: options.applyMode,
        infix: (_b3 = options.infix) != null ? _b3 : false,
        createAtom: options.createAtom,
        applyStyle: options.applyStyle
      };
      if (typeof names === "string")
        LATEX_COMMANDS["\\" + names] = data;
      else
        for (const name of names)
          LATEX_COMMANDS["\\" + name] = data;
    }
    var _DEFAULT_MACROS;
    function getMacros(otherMacros) {
      if (!_DEFAULT_MACROS)
        _DEFAULT_MACROS = normalizeMacroDictionary(DEFAULT_MACROS);
      if (!otherMacros)
        return _DEFAULT_MACROS;
      return normalizeMacroDictionary(__spreadValues(__spreadValues({}, _DEFAULT_MACROS), otherMacros));
    }
    function normalizeMacroDefinition(def2, options) {
      var _a3, _b3, _c2, _d2;
      if (typeof def2 === "string") {
        let argCount = 0;
        const defString = def2;
        if (/(^|[^\\])#1/.test(defString))
          argCount = 1;
        if (/(^|[^\\])#2/.test(defString))
          argCount = 2;
        if (/(^|[^\\])#3/.test(defString))
          argCount = 3;
        if (/(^|[^\\])#4/.test(defString))
          argCount = 4;
        if (/(^|[^\\])#5/.test(defString))
          argCount = 5;
        if (/(^|[^\\])#6/.test(defString))
          argCount = 6;
        if (/(^|[^\\])#7/.test(defString))
          argCount = 7;
        if (/(^|[^\\])#8/.test(defString))
          argCount = 8;
        if (/(^|[^\\])#9/.test(defString))
          argCount = 9;
        return {
          expand: (_a3 = options == null ? void 0 : options.expand) != null ? _a3 : true,
          captureSelection: (_b3 = options == null ? void 0 : options.captureSelection) != null ? _b3 : true,
          args: argCount,
          def: defString
        };
      }
      return __spreadValues({
        expand: (_c2 = options == null ? void 0 : options.expand) != null ? _c2 : true,
        captureSelection: (_d2 = options == null ? void 0 : options.captureSelection) != null ? _d2 : true,
        args: 0
      }, def2);
    }
    function normalizeMacroDictionary(macros) {
      if (!macros)
        return {};
      const result = {};
      for (const macro of Object.keys(macros)) {
        const macroDef = macros[macro];
        if (macroDef === void 0 || macroDef === null)
          delete result[macro];
        else if (typeof macroDef === "object" && "package" in macroDef) {
          for (const packageMacro of Object.keys(macroDef.package)) {
            result[packageMacro] = normalizeMacroDefinition(
              macroDef.package[packageMacro],
              {
                expand: macroDef.expand,
                captureSelection: macroDef.captureSelection
              }
            );
          }
        } else
          result[macro] = normalizeMacroDefinition(macroDef);
      }
      return result;
    }
    function binRelType(atoms) {
      if (atoms.length === 1) {
        const atom = atoms[0];
        if (atom.type === "mbin")
          return "mbin";
        if (atom.type === "mrel")
          return "mrel";
      }
      return "mord";
    }
    function defaultGetDefinition(token, parseMode = "math") {
      if (!token || token.length === 0)
        return null;
      let info = null;
      if (token.startsWith("\\")) {
        info = LATEX_COMMANDS[token];
        if (info)
          return info;
        if (parseMode === "math")
          info = MATH_SYMBOLS[token];
        else if (TEXT_SYMBOLS[token]) {
          info = {
            definitionType: "symbol",
            type: "mord",
            codepoint: TEXT_SYMBOLS[token]
          };
        }
      } else if (parseMode === "math") {
        info = MATH_SYMBOLS[token];
        if (!info && token.length === 1) {
          const command = charToLatex("math", token.codePointAt(0));
          if (command.startsWith("\\"))
            return __spreadProps(__spreadValues({}, defaultGetDefinition(command, "math")), { command });
          return null;
        }
      } else if (TEXT_SYMBOLS[token]) {
        info = {
          definitionType: "symbol",
          type: "mord",
          codepoint: TEXT_SYMBOLS[token]
        };
      } else if (parseMode === "text") {
        info = {
          definitionType: "symbol",
          type: "mord",
          codepoint: token.codePointAt(0)
        };
      }
      if (info && info.definitionType === "symbol" && info.type === "mord" && (info.codepoint === 102 || info.codepoint === 103 || info.codepoint === 104))
        info.isFunction = true;
      return info != null ? info : null;
    }
    function getMacroDefinition(token, macros) {
      if (!token.startsWith("\\"))
        return null;
      const command = token.slice(1);
      return macros[command];
    }
    function unicodeCharToLatex(parseMode, char) {
      var _a3;
      if (parseMode === "text")
        return (_a3 = charToLatex(parseMode, char.codePointAt(0))) != null ? _a3 : char;
      let result;
      result = charToLatex(parseMode, char.codePointAt(0));
      if (result)
        return result;
      const cp = char.codePointAt(0);
      const v = unicodeToMathVariant(cp);
      if (!v.style && !v.variant)
        return "";
      result = v.char;
      if (v.variant)
        result = "\\" + v.variant + "{" + result + "}";
      if (v.style === "bold")
        result = "\\mathbf{" + result + "}";
      else if (v.style === "italic")
        result = "\\mathit{" + result + "}";
      else if (v.style === "bolditalic")
        result = "\\mathbfit{" + result + "}";
      return "\\mathord{" + result + "}";
    }
    function charToLatex(parseMode, codepoint) {
      if (codepoint === void 0)
        return "";
      if (parseMode === "math" && REVERSE_MATH_SYMBOLS[codepoint])
        return REVERSE_MATH_SYMBOLS[codepoint];
      if (parseMode === "text") {
        let textSymbol = Object.keys(TEXT_SYMBOLS).find(
          (x) => TEXT_SYMBOLS[x] === codepoint
        );
        if (!textSymbol) {
          const hex = codepoint.toString(16);
          textSymbol = "^".repeat(hex.length) + hex;
        }
        return textSymbol;
      }
      return String.fromCodePoint(codepoint);
    }
    var D = 7;
    var Dc = 6;
    var T = 5;
    var Tc = 4;
    var S = 3;
    var Sc = 2;
    var SS = 1;
    var SSc = 0;
    var Mathstyle = class {
      constructor(id, sizeDelta, cramped) {
        this.id = id;
        this.sizeDelta = sizeDelta;
        this.cramped = cramped;
        const metricsIndex = { "-4": 2, "-3": 1, 0: 0 }[sizeDelta];
        this.metrics = Object.keys(FONT_METRICS).reduce((acc, x) => {
          return __spreadProps(__spreadValues({}, acc), { [x]: FONT_METRICS[x][metricsIndex] });
        }, {});
      }
      getFontSize(size2) {
        return Math.max(1, size2 + this.sizeDelta);
      }
      /**
       * Get the style of a superscript given a base in the current style.
       */
      get sup() {
        return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Sc, S][this.id]];
      }
      /**
       * Get the style of a subscript given a base in the current style.
       */
      get sub() {
        return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Sc, Sc][this.id]];
      }
      /**
       * Get the style of a fraction numerator given the fraction in the current
       * style.
       * See TeXBook p 141.
       */
      get fracNum() {
        return MATHSTYLES[[SSc, SS, SSc, SS, Sc, S, Tc, T][this.id]];
      }
      /**
       * Get the style of a fraction denominator given the fraction in the current
       * style.
       * See TeXBook p 141.
       */
      get fracDen() {
        return MATHSTYLES[[SSc, SSc, SSc, SSc, Sc, Sc, Tc, Tc][this.id]];
      }
      /**
       * Get the cramped version of a style (in particular, cramping a cramped style
       * doesn't change the style).
       */
      get cramp() {
        return MATHSTYLES[[SSc, SSc, Sc, Sc, Tc, Tc, Dc, Dc][this.id]];
      }
      /**
       * Return if this style is tightly spaced (scriptstyle/scriptscriptstyle)
       */
      get isTight() {
        return this.sizeDelta < 0;
      }
    };
    var MATHSTYLES = {
      7: new Mathstyle(D, 0, false),
      6: new Mathstyle(Dc, 0, true),
      5: new Mathstyle(T, 0, false),
      4: new Mathstyle(Tc, 0, true),
      3: new Mathstyle(S, -3, false),
      2: new Mathstyle(Sc, -3, true),
      1: new Mathstyle(SS, -4, false),
      0: new Mathstyle(SSc, -4, true)
    };
    MATHSTYLES.displaystyle = MATHSTYLES[D];
    MATHSTYLES.textstyle = MATHSTYLES[T];
    MATHSTYLES.scriptstyle = MATHSTYLES[S];
    MATHSTYLES.scriptscriptstyle = MATHSTYLES[SS];
    function convertDimensionToPt(value, precision) {
      var _a3;
      if (!value)
        return 0;
      const f = {
        pt: 1,
        mm: 7227 / 2540,
        cm: 7227 / 254,
        ex: 35271 / 8192,
        px: 3 / 4,
        em: PT_PER_EM,
        bp: 803 / 800,
        dd: 1238 / 1157,
        pc: 12,
        in: 72.27,
        mu: 10 / 18
      }[(_a3 = value.unit) != null ? _a3 : "pt"];
      if (Number.isFinite(precision)) {
        const factor = 10 ** precision;
        return Math.round(value.dimension / PT_PER_EM * f * factor) / factor;
      }
      return value.dimension * f;
    }
    function convertDimensionToEm(value, precision) {
      if (value === null)
        return 0;
      return convertDimensionToPt(value, precision) / PT_PER_EM;
    }
    function convertGlueToEm(value) {
      return convertDimensionToEm(value.glue);
    }
    function serializeDimension(value) {
      var _a3;
      return `${value.dimension}${(_a3 = value.unit) != null ? _a3 : "pt"}`;
    }
    var Context = class {
      constructor(parent, style, inMathstyle) {
        var _a3, _b3, _c2, _d2, _e, _f;
        console.assert(parent instanceof Context || (style == null ? void 0 : style.fontSize) !== void 0);
        console.assert(parent instanceof Context || inMathstyle !== void 0);
        if (parent instanceof Context)
          this.parent = parent;
        if (!(parent instanceof Context))
          this.registers = (_a3 = parent.registers) != null ? _a3 : {};
        this.isPhantom = (_d2 = (_c2 = style == null ? void 0 : style.isPhantom) != null ? _c2 : (_b3 = this.parent) == null ? void 0 : _b3.isPhantom) != null ? _d2 : false;
        const from = __spreadValues({}, parent);
        if (style) {
          if (style.letterShapeStyle && style.letterShapeStyle !== "auto")
            from.letterShapeStyle = style.letterShapeStyle;
          if (style.color && style.color !== "none")
            from.color = style.color;
          if (style.backgroundColor && style.backgroundColor !== "none")
            from.backgroundColor = style.backgroundColor;
          if (style.fontSize && style.fontSize !== "auto" && style.fontSize !== ((_e = this.parent) == null ? void 0 : _e._size))
            this._size = style.fontSize;
        }
        this.letterShapeStyle = (_f = from.letterShapeStyle) != null ? _f : "tex";
        this.color = from.color;
        this.backgroundColor = from.backgroundColor;
        let mathstyle;
        if (typeof inMathstyle === "string") {
          if (parent instanceof Context) {
            switch (inMathstyle) {
              case "cramp":
                mathstyle = parent.mathstyle.cramp;
                break;
              case "superscript":
                mathstyle = parent.mathstyle.sup;
                break;
              case "subscript":
                mathstyle = parent.mathstyle.sub;
                break;
              case "numerator":
                mathstyle = parent.mathstyle.fracNum;
                break;
              case "denominator":
                mathstyle = parent.mathstyle.fracDen;
                break;
            }
          }
          switch (inMathstyle) {
            case "textstyle":
              mathstyle = MATHSTYLES.textstyle;
              break;
            case "displaystyle":
              mathstyle = MATHSTYLES.displaystyle;
              break;
            case "scriptstyle":
              mathstyle = MATHSTYLES.scriptstyle;
              break;
            case "scriptscriptstyle":
              mathstyle = MATHSTYLES.scriptscriptstyle;
              break;
          }
        }
        this._mathstyle = mathstyle;
        this.atomIdsSettings = parent.atomIdsSettings;
        this.renderPlaceholder = from.renderPlaceholder;
        console.assert(
          !(parent instanceof Context) || this.atomIdsSettings === parent.atomIdsSettings
        );
      }
      get mathstyle() {
        let result = this._mathstyle;
        let parent = this.parent;
        while (!result) {
          result = parent._mathstyle;
          parent = parent.parent;
        }
        return result;
      }
      getRegister(name) {
        var _a3;
        if ((_a3 = this.registers) == null ? void 0 : _a3[name])
          return this.registers[name];
        if (this.parent)
          return this.parent.getRegister(name);
        return void 0;
      }
      getRegisterAsGlue(name) {
        var _a3;
        if ((_a3 = this.registers) == null ? void 0 : _a3[name]) {
          const value = this.registers[name];
          if (typeof value === "object" && "glue" in value)
            return value;
          else if (typeof value === "object" && "dimension" in value)
            return { glue: { dimension: value.dimension } };
          else if (typeof value === "number")
            return { glue: { dimension: value } };
          return void 0;
        }
        if (this.parent)
          return this.parent.getRegisterAsGlue(name);
        return void 0;
      }
      getRegisterAsEm(name) {
        return convertDimensionToEm(this.getRegisterAsDimension(name));
      }
      getRegisterAsDimension(name) {
        var _a3;
        if ((_a3 = this.registers) == null ? void 0 : _a3[name]) {
          const value = this.registers[name];
          if (typeof value === "object" && "glue" in value)
            return value.glue;
          else if (typeof value === "object" && "dimension" in value)
            return value;
          else if (typeof value === "number")
            return { dimension: value };
          return void 0;
        }
        if (this.parent)
          return this.parent.getRegisterAsDimension(name);
        return void 0;
      }
      setRegister(name, value) {
        if (value === void 0) {
          delete this.registers[name];
          return;
        }
        this.registers[name] = value;
      }
      setGlobalRegister(name, value) {
        let root = this;
        while (root.parent) {
          root.setRegister(name, void 0);
          root = root.parent;
        }
        root.setRegister(name, value);
      }
      get size() {
        let result = this._size;
        let parent = this.parent;
        while (!result) {
          result = parent._size;
          parent = parent.parent;
        }
        return result;
      }
      makeID() {
        if (!this.atomIdsSettings)
          return void 0;
        if (this.atomIdsSettings.overrideID)
          return this.atomIdsSettings.overrideID;
        if (typeof this.atomIdsSettings.seed !== "number") {
          return Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
        }
        const result = this.atomIdsSettings.seed.toString(36);
        this.atomIdsSettings.seed += 1;
        return result;
      }
      // Scale a value, in em, to account for the fontsize and mathstyle
      // of this context
      scale(value) {
        return value * this.effectiveFontSize;
      }
      get scalingFactor() {
        if (!this.parent)
          return 1;
        return this.effectiveFontSize / this.parent.effectiveFontSize;
      }
      get isDisplayStyle() {
        return this.mathstyle.id === D || this.mathstyle.id === Dc;
      }
      get isCramped() {
        return this.mathstyle.cramped;
      }
      get isTight() {
        return this.mathstyle.isTight;
      }
      // Return the font size, in em relative to the mathfield fontsize,
      // accounting both for the base font size and the mathstyle
      get effectiveFontSize() {
        return FONT_SCALE[Math.max(1, this.size + this.mathstyle.sizeDelta)];
      }
      get computedColor() {
        let result = this.color;
        let parent = this.parent;
        if (!result && parent) {
          result = parent.color;
          parent = parent.parent;
        }
        return result != null ? result : "";
      }
      get computedBackgroundColor() {
        let result = this.backgroundColor;
        let parent = this.parent;
        if (!result && parent) {
          result = parent.backgroundColor;
          parent = parent.parent;
        }
        return result != null ? result : "";
      }
      get metrics() {
        return this.mathstyle.metrics;
      }
    };
    var gCustomSerializer = {};
    var NAMED_BRANCHES = [
      "above",
      "body",
      "below",
      "superscript",
      "subscript"
    ];
    function isNamedBranch(branch) {
      return typeof branch === "string" && NAMED_BRANCHES.includes(branch);
    }
    function isCellBranch(branch) {
      return branch !== void 0 && Array.isArray(branch) && branch.length === 2;
    }
    var Atom = class {
      constructor(type, context, options) {
        this.id = void 0;
        this.verbatimLatex = void 0;
        this._isDirty = false;
        this._changeCounter = 0;
        this.subsupPlacement = void 0;
        this.explicitSubsupPlacement = false;
        this.skipBoundary = false;
        this.captureSelection = false;
        var _a3, _b3, _c2, _d2, _e, _f;
        this.type = type;
        this.context = context;
        if (typeof (options == null ? void 0 : options.value) === "string")
          this.value = options.value;
        this.command = (_b3 = (_a3 = options == null ? void 0 : options.command) != null ? _a3 : this.value) != null ? _b3 : "";
        this.mode = (_c2 = options == null ? void 0 : options.mode) != null ? _c2 : "math";
        this.isFunction = (_d2 = options == null ? void 0 : options.isFunction) != null ? _d2 : false;
        this.subsupPlacement = options == null ? void 0 : options.limits;
        this.style = (_e = options == null ? void 0 : options.style) != null ? _e : {};
        this.displayContainsHighlight = (_f = options == null ? void 0 : options.displayContainsHighlight) != null ? _f : false;
        if (options == null ? void 0 : options.serialize) {
          console.assert(typeof options.command === "string");
          gCustomSerializer[options.command] = options.serialize;
        }
      }
      /**
       * Return a list of boxes equivalent to atoms.
       *
       * While an atom represent an abstract element (for example 'genfrac'),
       * a box corresponds to something to draw on screen (a character, a line,
       * etc...).
       *
       * @param parentContext Font family, variant, size, color, and other info useful
       * to render an expression
       * @param options.newList - If true, for the purpose of calculating spacing
       * between atoms, this list of atoms should be considered a new atom list,
       * in the sense of TeX atom lists (i.e. don't consider preceding atoms
       * to calculate spacing)
       */
      static createBox(parentContext, atoms, options) {
        var _a3, _b3, _c2;
        if (!atoms)
          return null;
        const runs = getStyleRuns(atoms);
        if (runs.length === 1) {
          const run = runs[0];
          if (run[0].style) {
            return renderStyleRun(parentContext, run, __spreadProps(__spreadValues({}, options), {
              style: {
                color: run[0].style.color,
                backgroundColor: run[0].style.backgroundColor,
                fontSize: run[0].style.fontSize
              }
            }));
          }
          return renderStyleRun(parentContext, run, options);
        }
        const boxes = [];
        let newList = options == null ? void 0 : options.newList;
        for (const run of runs) {
          const context = new Context(parentContext, {
            color: (_a3 = run[0].style) == null ? void 0 : _a3.color,
            backgroundColor: (_b3 = run[0].style) == null ? void 0 : _b3.backgroundColor,
            fontSize: (_c2 = run[0].style) == null ? void 0 : _c2.fontSize
          });
          const box = renderStyleRun(context, run, { newList });
          if (box) {
            newList = false;
            boxes.push(box);
          }
        }
        if (boxes.length === 0)
          return null;
        if (boxes.length === 1 && !(options == null ? void 0 : options.classes) && !(options == null ? void 0 : options.type))
          return boxes[0].wrap(parentContext);
        return new Box(boxes, {
          classes: options == null ? void 0 : options.classes,
          type: options == null ? void 0 : options.type,
          newList: options == null ? void 0 : options.newList
        }).wrap(parentContext);
      }
      /**
       * Given an atom or an array of atoms, return a LaTeX string representation
       */
      static serialize(value, options) {
        if (isArray2(value))
          return serializeAtoms(value, options);
        if (typeof value === "number" || typeof value === "boolean")
          return value.toString();
        if (typeof value === "string")
          return value.replace(/\s/g, "~");
        if (value === void 0)
          return "";
        if (!options.expandMacro && typeof value.verbatimLatex === "string")
          return value.verbatimLatex;
        if (value.command && gCustomSerializer[value.command])
          return gCustomSerializer[value.command](value, options);
        return value.serialize(options);
      }
      /**
       * The common ancestor between two atoms
       */
      static commonAncestor(a, b) {
        if (a === b)
          return a.parent;
        if (a.parent === b.parent)
          return a.parent;
        const parents = /* @__PURE__ */ new WeakSet();
        let { parent } = a;
        while (parent) {
          parents.add(parent);
          parent = parent.parent;
        }
        parent = b.parent;
        while (parent) {
          if (parents.has(parent))
            return parent;
          parent = parent.parent;
        }
        console.assert(Boolean(parent));
        return void 0;
      }
      static fromJson(json, context) {
        const result = new Atom(json.type, context, json);
        for (const branch of NAMED_BRANCHES)
          if (json[branch])
            result.setChildren(json[branch], branch);
        return result;
      }
      toJson() {
        const result = { type: this.type };
        if (this.mode !== "math")
          result.mode = this.mode;
        if (this.command && this.command !== this.value)
          result.command = this.command;
        if (this.value !== void 0)
          result.value = this.value;
        if (this.style && Object.keys(this.style).length > 0)
          result.style = __spreadValues({}, this.style);
        if (this.verbatimLatex !== void 0)
          result.verbatimLatex = this.verbatimLatex;
        if (this.subsupPlacement)
          result.subsupPlacement = this.subsupPlacement;
        if (this.explicitSubsupPlacement)
          result.explicitSubsupPlacement = true;
        if (this.isFunction)
          result.isFunction = true;
        if (this.displayContainsHighlight)
          result.displayContainsHighlight = true;
        if (this.isExtensibleSymbol)
          result.isExtensibleSymbol = true;
        if (this.skipBoundary)
          result.skipBoundary = true;
        if (this.captureSelection)
          result.captureSelection = true;
        if (this._branches) {
          for (const branch of Object.keys(this._branches)) {
            if (this._branches[branch]) {
              result[branch] = this._branches[branch].filter((x) => x.type !== "first").map((x) => x.toJson());
            }
          }
        }
        return result;
      }
      get changeCounter() {
        return this._changeCounter;
      }
      get isDirty() {
        return this._isDirty;
      }
      set isDirty(dirty) {
        this._isDirty = dirty;
        if (dirty) {
          this._changeCounter++;
          this.verbatimLatex = void 0;
          this._children = void 0;
          let { parent } = this;
          while (parent) {
            parent._isDirty = true;
            parent._changeCounter++;
            parent.verbatimLatex = void 0;
            parent._children = void 0;
            parent = parent.parent;
          }
        }
      }
      /**
       * Serialize the atom  to LaTeX
       */
      serialize(options) {
        var _a3;
        if (this.body && this.command) {
          return joinLatex([
            this.command,
            "{",
            this.bodyToLatex(options),
            "}",
            this.supsubToLatex(options)
          ]);
        }
        if (this.body) {
          return joinLatex([
            this.bodyToLatex(options),
            this.supsubToLatex(options)
          ]);
        }
        if (this.value && this.value !== "​") {
          return (_a3 = this.command) != null ? _a3 : unicodeCharToLatex(this.mode, this.value);
        }
        return "";
      }
      bodyToLatex(options) {
        return serializeAtoms(this.body, options);
      }
      aboveToLatex(options) {
        return serializeAtoms(this.above, options);
      }
      belowToLatex(options) {
        return serializeAtoms(this.below, options);
      }
      supsubToLatex(options) {
        let result = "";
        if (this.branch("subscript") !== void 0) {
          const sub = serializeAtoms(this.subscript, options);
          if (sub.length === 0)
            result += "_{}";
          else if (sub.length === 1)
            result += "_" + sub;
          else
            result += `_{${sub}}`;
        }
        if (this.branch("superscript") !== void 0) {
          const sup = serializeAtoms(this.superscript, options);
          if (sup.length === 0)
            result += "^{}";
          else if (sup.length === 1) {
            if (sup === "′")
              result += "^\\prime ";
            else if (sup === "″")
              result += "^\\doubleprime ";
            else
              result += "^" + sup;
          } else
            result += `^{${sup}}`;
        }
        return result;
      }
      get treeDepth() {
        let result = 1;
        let atom = this.parent;
        while (atom) {
          atom = atom.parent;
          result += 1;
        }
        return result;
      }
      get inCaptureSelection() {
        let atom = this;
        while (atom) {
          if (atom.captureSelection)
            return true;
          atom = atom.parent;
        }
        return false;
      }
      /** Return the parent editable prompt, if it exists */
      get parentPrompt() {
        let atom = this;
        while (atom) {
          if (atom.type === "prompt" && !atom.captureSelection)
            return atom;
          atom = atom.parent;
        }
        return null;
      }
      /**
       * Return the atoms in the branch, if it exists, otherwise null
       */
      branch(name) {
        if (!isNamedBranch(name))
          return void 0;
        if (!this._branches)
          return void 0;
        return this._branches[name];
      }
      /**
       * Return all the branches that exist.
       * Some of them may be empty.
       */
      get branches() {
        if (!this._branches)
          return [];
        const result = [];
        for (const branch of NAMED_BRANCHES)
          if (this._branches[branch])
            result.push(branch);
        return result;
      }
      /**
       * Return the atoms in the branch, if it exists, otherwise create it
       */
      createBranch(name) {
        console.assert(isNamedBranch(name));
        if (!isNamedBranch(name))
          return [];
        if (!this._branches) {
          this._branches = {
            [name]: [this.makeFirstAtom(name)]
          };
        } else if (!this._branches[name])
          this._branches[name] = [this.makeFirstAtom(name)];
        this.isDirty = true;
        return this._branches[name];
      }
      get row() {
        if (!isCellBranch(this.treeBranch))
          return -1;
        return this.treeBranch[0];
      }
      get col() {
        if (!isCellBranch(this.treeBranch))
          return -1;
        return this.treeBranch[1];
      }
      get body() {
        var _a3;
        return (_a3 = this._branches) == null ? void 0 : _a3.body;
      }
      set body(atoms) {
        this.setChildren(atoms, "body");
      }
      get superscript() {
        var _a3;
        return (_a3 = this._branches) == null ? void 0 : _a3.superscript;
      }
      set superscript(atoms) {
        this.setChildren(atoms, "superscript");
      }
      get subscript() {
        var _a3;
        return (_a3 = this._branches) == null ? void 0 : _a3.subscript;
      }
      set subscript(atoms) {
        this.setChildren(atoms, "subscript");
      }
      get above() {
        var _a3;
        return (_a3 = this._branches) == null ? void 0 : _a3.above;
      }
      set above(atoms) {
        this.setChildren(atoms, "above");
      }
      get below() {
        var _a3;
        return (_a3 = this._branches) == null ? void 0 : _a3.below;
      }
      set below(atoms) {
        this.setChildren(atoms, "below");
      }
      get computedStyle() {
        var _a3;
        if (!this.parent)
          return __spreadValues({}, (_a3 = this.style) != null ? _a3 : {});
        const hadVerbatimColor = this.style.verbatimColor !== void 0;
        const hadVerbatimBackgroundColor = this.style.verbatimBackgroundColor !== void 0;
        const result = __spreadValues(__spreadValues({}, this.parent.computedStyle), this.style);
        delete result.variant;
        delete result.variantStyle;
        if (!hadVerbatimBackgroundColor)
          delete result.verbatimBackgroundColor;
        if (!hadVerbatimColor)
          delete result.verbatimColor;
        return result;
      }
      applyStyle(style) {
        this.isDirty = true;
        this.style = __spreadValues(__spreadValues({}, this.style), style);
        if (this.style.fontFamily === "none")
          delete this.style.fontFamily;
        if (this.style.fontShape === "auto")
          delete this.style.fontShape;
        if (this.style.fontSeries === "auto")
          delete this.style.fontSeries;
        if (this.style.color === "none") {
          delete this.style.color;
          delete this.style.verbatimColor;
        }
        if (this.style.backgroundColor === "none") {
          delete this.style.backgroundColor;
          delete this.style.verbatimBackgroundColor;
        }
        if (this.style.fontSize === "auto")
          delete this.style.fontSize;
        for (const child of this.children)
          child.applyStyle(style);
      }
      getInitialBaseElement() {
        var _a3;
        let result = void 0;
        if (!this.hasEmptyBranch("body")) {
          console.assert(((_a3 = this.body) == null ? void 0 : _a3[0].type) === "first");
          result = this.body[1].getInitialBaseElement();
        }
        return result != null ? result : this;
      }
      getFinalBaseElement() {
        if (!this.hasEmptyBranch("body"))
          return this.body[this.body.length - 1].getFinalBaseElement();
        return this;
      }
      isCharacterBox() {
        if (this.type === "leftright")
          return false;
        const base = this.getInitialBaseElement();
        return /mord/.test(base.type);
      }
      hasEmptyBranch(branch) {
        const atoms = this.branch(branch);
        if (!atoms)
          return true;
        console.assert(atoms.length > 0);
        console.assert(atoms[0].type === "first");
        return atoms.length === 1;
      }
      /*
       * Setting `null` does nothing
       * Setting `[]` adds an empty list (the branch is created)
       * The children should *not* start with a `"first"` atom:
       * the `first` atom will be added if necessary
       */
      setChildren(children, branch) {
        var _a3;
        if (!children)
          return;
        console.assert(isNamedBranch(branch));
        if (!isNamedBranch(branch))
          return;
        console.assert(((_a3 = children[0]) == null ? void 0 : _a3.type) !== "first");
        const newBranch = [this.makeFirstAtom(branch), ...children];
        if (this._branches)
          this._branches[branch] = newBranch;
        else
          this._branches = { [branch]: newBranch };
        for (const child of children) {
          child.parent = this;
          child.treeBranch = branch;
        }
        this.isDirty = true;
      }
      makeFirstAtom(branch) {
        const result = new Atom("first", this.context, { mode: this.mode });
        result.parent = this;
        result.treeBranch = branch;
        return result;
      }
      addChild(child, branch) {
        console.assert(child.type !== "first");
        this.createBranch(branch).push(child);
        this.isDirty = true;
        child.parent = this;
        child.treeBranch = branch;
      }
      addChildBefore(child, before) {
        console.assert(before.treeBranch !== void 0);
        const branch = this.createBranch(before.treeBranch);
        branch.splice(branch.indexOf(before), 0, child);
        this.isDirty = true;
        child.parent = this;
        child.treeBranch = before.treeBranch;
      }
      addChildAfter(child, after) {
        console.assert(after.treeBranch !== void 0);
        const branch = this.createBranch(after.treeBranch);
        branch.splice(branch.indexOf(after) + 1, 0, child);
        this.isDirty = true;
        child.parent = this;
        child.treeBranch = after.treeBranch;
      }
      addChildren(children, branch) {
        for (const child of children)
          this.addChild(child, branch);
      }
      /**
       * Return the last atom that was added
       */
      addChildrenAfter(children, after) {
        console.assert(children.length === 0 || children[0].type !== "first");
        console.assert(after.treeBranch !== void 0);
        const branch = this.createBranch(after.treeBranch);
        branch.splice(branch.indexOf(after) + 1, 0, ...children);
        this.isDirty = true;
        for (const child of children) {
          child.parent = this;
          child.treeBranch = after.treeBranch;
        }
        return children[children.length - 1];
      }
      removeBranch(name) {
        const children = this.branch(name);
        if (isNamedBranch(name))
          this._branches[name] = void 0;
        if (!children)
          return [];
        for (const child of children) {
          child.parent = void 0;
          child.treeBranch = void 0;
        }
        console.assert(children[0].type === "first");
        children.shift();
        this.isDirty = true;
        return children;
      }
      removeChild(child) {
        console.assert(child.parent === this);
        if (child.type === "first")
          return;
        const branch = this.branch(child.treeBranch);
        const index = branch.indexOf(child);
        console.assert(index >= 0);
        branch.splice(index, 1);
        this.isDirty = true;
        child.parent = void 0;
        child.treeBranch = void 0;
      }
      get siblings() {
        if (this.type === "root")
          return [];
        return this.parent.branch(this.treeBranch);
      }
      get firstSibling() {
        return this.siblings[0];
      }
      get lastSibling() {
        const { siblings } = this;
        return siblings[siblings.length - 1];
      }
      get isFirstSibling() {
        return this === this.firstSibling;
      }
      get isLastSibling() {
        return this === this.lastSibling;
      }
      get hasNoSiblings() {
        return this.siblings.length === 1;
      }
      get leftSibling() {
        console.assert(this.parent !== void 0);
        const siblings = this.parent.branch(this.treeBranch);
        return siblings[siblings.indexOf(this) - 1];
      }
      get rightSibling() {
        console.assert(this.parent !== void 0);
        const siblings = this.parent.branch(this.treeBranch);
        return siblings[siblings.indexOf(this) + 1];
      }
      get hasChildren() {
        return Boolean(this._branches && this.children.length > 0);
      }
      get firstChild() {
        console.assert(this.hasChildren);
        return this.children[0];
      }
      get lastChild() {
        console.assert(this.hasChildren);
        const { children } = this;
        return children[children.length - 1];
      }
      /**
       * All the children of this atom.
       *
       * The order of the atoms is the order in which they
       * are navigated using the keyboard.
       */
      get children() {
        if (this._children)
          return this._children;
        if (!this._branches)
          return [];
        const result = [];
        for (const branchName of NAMED_BRANCHES) {
          if (this._branches[branchName]) {
            for (const x of this._branches[branchName]) {
              result.push(...x.children);
              result.push(x);
            }
          }
        }
        this._children = result;
        return result;
      }
      /**
       * Render this atom as an array of boxes.
       *
       * The parent context (color, size...) will be applied
       * to the result.
       *
       */
      render(parentContext, options) {
        if (this.type === "first" && !parentContext.atomIdsSettings)
          return null;
        const context = new Context(parentContext, this.style);
        let classes = "";
        if (this.type === "root")
          classes += " ML__base";
        if (this.isSelected)
          classes += " ML__selected";
        let result = this.createBox(context, {
          classes,
          newList: (options == null ? void 0 : options.newList) === true || this.type === "first"
        });
        if (!result)
          return null;
        if (!this.subsupPlacement && (this.superscript || this.subscript)) {
          result = this.attachSupsub(context, { base: result });
        }
        return result.wrap(context);
      }
      attachSupsub(parentContext, options) {
        var _a3, _b3;
        const base = options.base;
        const superscript = this.superscript;
        const subscript = this.subscript;
        if (!superscript && !subscript)
          return base;
        let supBox = null;
        let subBox = null;
        const isCharacterBox = (_a3 = options.isCharacterBox) != null ? _a3 : this.isCharacterBox();
        let supShift = 0;
        if (superscript) {
          const context = new Context(parentContext, void 0, "superscript");
          supBox = Atom.createBox(context, superscript, { newList: true });
          if (!isCharacterBox) {
            supShift = base.height - parentContext.metrics.supDrop * context.scalingFactor;
          }
        }
        let subShift = 0;
        if (subscript) {
          const context = new Context(parentContext, void 0, "subscript");
          subBox = Atom.createBox(context, subscript, { newList: true });
          if (!isCharacterBox) {
            subShift = base.depth + parentContext.metrics.subDrop * context.scalingFactor;
          }
        }
        let minSupShift;
        if (parentContext.isDisplayStyle)
          minSupShift = parentContext.metrics.sup1;
        else if (parentContext.isCramped)
          minSupShift = parentContext.metrics.sup3;
        else
          minSupShift = parentContext.metrics.sup2;
        const scriptspace = 0.5 / PT_PER_EM / parentContext.scalingFactor;
        let supsub = null;
        if (subBox && supBox) {
          supShift = Math.max(
            supShift,
            minSupShift,
            supBox.depth + 0.25 * parentContext.metrics.xHeight
          );
          subShift = Math.max(subShift, parentContext.metrics.sub2);
          const ruleWidth = parentContext.metrics.defaultRuleThickness;
          if (supShift - supBox.depth - (subBox.height - subShift) < 4 * ruleWidth) {
            subShift = 4 * ruleWidth - (supShift - supBox.depth) + subBox.height;
            const psi = 0.8 * parentContext.metrics.xHeight - (supShift - supBox.depth);
            if (psi > 0) {
              supShift += psi;
              subShift -= psi;
            }
          }
          const slant = this.isExtensibleSymbol && base.italic ? -base.italic : 0;
          supsub = new VBox({
            individualShift: [
              { box: subBox, shift: subShift, marginLeft: slant },
              { box: supBox, shift: -supShift }
            ]
          }).wrap(parentContext);
        } else if (subBox && !supBox) {
          subShift = Math.max(
            subShift,
            parentContext.metrics.sub1,
            subBox.height - 0.8 * X_HEIGHT
          );
          supsub = new VBox({
            shift: subShift,
            children: [
              {
                box: subBox,
                marginRight: scriptspace,
                marginLeft: this.isCharacterBox() ? -((_b3 = base.italic) != null ? _b3 : 0) : 0
              }
            ]
          });
        } else if (!subBox && supBox) {
          supShift = Math.max(
            supShift,
            minSupShift,
            supBox.depth + 0.25 * X_HEIGHT
          );
          supsub = new VBox({
            shift: -supShift,
            children: [{ box: supBox, marginRight: scriptspace }]
          });
          supsub.wrap(parentContext);
        }
        const supsubContainer = new Box(supsub, {
          classes: "msubsup" + (this.isSelected ? " ML__selected" : "")
        });
        if (this.caret)
          supsubContainer.caret = this.caret;
        return new Box([base, supsubContainer], { type: options.type });
      }
      attachLimits(parentContext, options) {
        var _a3;
        const above = this.superscript ? Atom.createBox(
          new Context(parentContext, this.style, "superscript"),
          this.superscript,
          { newList: true }
        ) : null;
        const below = this.subscript ? Atom.createBox(
          new Context(parentContext, this.style, "subscript"),
          this.subscript,
          { newList: true }
        ) : null;
        if (!above && !below)
          return options.base.wrap(parentContext);
        return makeLimitsStack(parentContext, __spreadProps(__spreadValues({}, options), {
          above,
          below,
          type: (_a3 = options == null ? void 0 : options.type) != null ? _a3 : "mop"
        }));
      }
      bind(context, box) {
        if (!box || context.isPhantom || this.value === "​")
          return box;
        let parent = this.parent;
        while (parent && !parent.captureSelection)
          parent = parent.parent;
        if (parent == null ? void 0 : parent.captureSelection)
          return box;
        if (!this.id)
          this.id = context.makeID();
        box.atomID = this.id;
        return box;
      }
      /**
       * Create a box with the specified body.
       */
      createBox(context, options) {
        var _a3, _b3, _c2;
        const value = (_a3 = this.value) != null ? _a3 : this.body;
        const type = isBoxType(this.type) ? this.type : void 0;
        let classes = (_b3 = options == null ? void 0 : options.classes) != null ? _b3 : "";
        if (this.mode === "text")
          classes += " ML__text";
        const result = typeof value === "string" || value === void 0 ? new Box(value != null ? value : null, {
          type,
          mode: this.mode,
          maxFontSize: context.scalingFactor,
          style: __spreadProps(__spreadValues({
            variant: "normal"
          }, this.style), {
            letterShapeStyle: context.letterShapeStyle,
            fontSize: Math.max(
              1,
              context.size + context.mathstyle.sizeDelta
            )
          }),
          classes,
          newList: options == null ? void 0 : options.newList
        }) : (_c2 = Atom.createBox(context, value, {
          type,
          mode: this.mode,
          style: this.style,
          classes,
          newList: options == null ? void 0 : options.newList
        })) != null ? _c2 : new Box(null);
        if (context.isTight)
          result.isTight = true;
        if (this.mode !== "math" || this.style.variant === "main")
          result.italic = 0;
        result.right = result.italic;
        this.bind(context, result);
        if (this.caret) {
          if (!this.superscript && !this.subscript)
            result.caret = this.caret;
        }
        return result;
      }
      /** Return true if a digit, or a decimal point, or a french decimal `{,}` */
      isDigit() {
        var _a3;
        if (this.type === "mord" && this.value)
          return /^[\d,.]$/.test(this.value);
        if (this.type === "group" && ((_a3 = this.body) == null ? void 0 : _a3.length) === 2)
          return this.body[0].type === "first" && this.body[1].value === ",";
        return false;
      }
      asDigit() {
        var _a3;
        if (this.type === "mord" && this.value && /^[\d,.]$/.test(this.value))
          return this.value;
        if (this.type === "group" && ((_a3 = this.body) == null ? void 0 : _a3.length) === 2) {
          if (this.body[0].type === "first" && this.body[1].value === ",")
            return ".";
        }
        return "";
      }
    };
    function serializeAtoms(atoms, options) {
      if (!atoms || atoms.length === 0)
        return "";
      if (atoms[0].type === "first") {
        if (atoms.length === 1)
          return "";
        atoms = atoms.slice(1);
      }
      if (atoms.length === 0)
        return "";
      return joinLatex(
        getPropertyRuns(atoms, "cssClass").map(
          (x) => joinLatex(
            getPropertyRuns(x, "color").map(
              (x2) => joinLatex(getModeRuns(x2).map((x3) => Mode.serialize(x3, options)))
            )
          )
        )
      );
    }
    function getStyleRuns(atoms) {
      let style = void 0;
      const runs = [];
      let run = [];
      for (const atom of atoms) {
        if (!style && !atom.style)
          run.push(atom);
        else {
          const atomStyle = atom.computedStyle;
          if (style && atomStyle.color === style.color && atomStyle.backgroundColor === style.backgroundColor && atomStyle.fontSize === style.fontSize) {
            run.push(atom);
          } else {
            if (run.length > 0)
              runs.push(run);
            run = [atom];
            style = atomStyle;
          }
        }
      }
      if (run.length > 0)
        runs.push(run);
      return runs;
    }
    function renderStyleRun(parentContext, atoms, options) {
      var _a3, _b3, _c2, _d2, _e;
      function isText(atom) {
        return atom.mode === "text";
      }
      if (!atoms || atoms.length === 0)
        return null;
      const context = new Context(parentContext, options == null ? void 0 : options.style);
      const displaySelection = !((_a3 = context.atomIdsSettings) == null ? void 0 : _a3.groupNumbers);
      let boxes = [];
      let newList = (_b3 = options == null ? void 0 : options.newList) != null ? _b3 : false;
      if (atoms.length === 1) {
        const atom = atoms[0];
        const box = atom.render(context, { newList });
        if (box) {
          if (displaySelection && atom.isSelected)
            box.selected(true);
          boxes = [box];
        }
      } else {
        let digitOrTextStringID = "";
        let lastWasDigit = true;
        for (const atom of atoms) {
          if (((_c2 = context.atomIdsSettings) == null ? void 0 : _c2.groupNumbers) && digitOrTextStringID && (lastWasDigit && atom.isDigit() || !lastWasDigit && isText(atom)))
            context.atomIdsSettings.overrideID = digitOrTextStringID;
          const box = atom.render(context, { newList });
          if (context.atomIdsSettings)
            context.atomIdsSettings.overrideID = void 0;
          if (box) {
            newList = atom.type === "group" && !atom["boxType"];
            if ((_d2 = context.atomIdsSettings) == null ? void 0 : _d2.groupNumbers) {
              if (atom.isDigit() || isText(atom)) {
                if (!digitOrTextStringID || lastWasDigit !== atom.isDigit()) {
                  lastWasDigit = atom.isDigit();
                  digitOrTextStringID = (_e = atom.id) != null ? _e : "";
                }
              }
              if (digitOrTextStringID && (!(atom.isDigit() || isText(atom)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))) {
                digitOrTextStringID = "";
              }
            }
            if (displaySelection && atom.isSelected)
              box.selected(true);
            boxes.push(box);
          }
        }
      }
      if (boxes.length === 0)
        return null;
      let result;
      if (options || context.isTight || boxes.length > 1) {
        result = new Box(boxes, __spreadValues({
          isTight: context.isTight
        }, options != null ? options : {}));
        result.isSelected = boxes.every((x) => x.isSelected);
      } else
        result = boxes[0];
      return result.wrap(context).wrap(parentContext);
    }
    var AccentAtom = class extends Atom {
      constructor(command, body, context, options) {
        super("accent", context, { command, style: options.style });
        if (options.accentChar)
          this.accent = options.accentChar;
        else
          this.svgAccent = options == null ? void 0 : options.svgAccent;
        this.body = body;
        this.skipBoundary = true;
        this.captureSelection = true;
      }
      static fromJson(json, context) {
        return new AccentAtom(json.command, json.body, context, {
          accentChar: json.accentChar,
          svgAccent: json.svgAccent,
          style: json.style
        });
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), {
          accentChar: this.accent,
          svgAccent: this.svgAccent
        });
      }
      render(parentContext) {
        var _a3;
        const context = new Context(parentContext, this.style, "cramp");
        const base = (_a3 = Atom.createBox(context, this.body)) != null ? _a3 : new Box(null);
        let skew = 0;
        if (!this.hasEmptyBranch("body") && this.body.length === 2 && this.body[1].isCharacterBox())
          skew = base.skew;
        let clearance = Math.min(base.height, X_HEIGHT);
        let accentBox;
        if (this.svgAccent) {
          accentBox = makeSVGBox(this.svgAccent);
          clearance = context.metrics.bigOpSpacing1 - clearance;
        } else if (this.accent) {
          const accent = new Box(this.accent, { fontFamily: "Main-Regular" });
          accent.italic = 0;
          const vecClass = this.accent === 8407 ? " ML__accent-vec" : "";
          accentBox = new Box(new Box(accent), {
            classes: "ML__accent-body" + vecClass
          });
        }
        accentBox = new VBox({
          shift: 0,
          children: [
            { box: new Box(base) },
            -clearance,
            {
              box: accentBox,
              marginLeft: base.left + 2 * skew,
              classes: ["ML__center"]
            }
          ]
        });
        const result = new Box(accentBox, { newList: true, type: "mord" });
        if (this.caret)
          result.caret = this.caret;
        this.bind(context, result.wrap(context));
        return this.attachSupsub(context, { base: result });
      }
    };
    var RIGHT_DELIM = {
      "(": ")",
      "{": "}",
      "[": "]",
      "|": "|",
      "\\lbrace": "\\rbrace",
      "\\lparen": "\\rparen",
      "\\{": "\\}",
      "\\langle": "\\rangle",
      "\\lfloor": "\\rfloor",
      "\\lceil": "\\rceil",
      "\\vert": "\\vert",
      "\\lvert": "\\rvert",
      "\\Vert": "\\Vert",
      "\\lVert": "\\rVert",
      "\\lbrack": "\\rbrack",
      "\\ulcorner": "\\urcorner",
      "\\llcorner": "\\lrcorner",
      "\\lgroup": "\\rgroup",
      "\\lmoustache": "\\rmoustache"
    };
    var LEFT_DELIM = Object.fromEntries(
      Object.entries(RIGHT_DELIM).map(([leftDelim, rightDelim]) => [
        rightDelim,
        leftDelim
      ])
    );
    function getSymbolValue(symbol) {
      var _a3;
      return (_a3 = {
        "[": 91,
        // '[',
        "]": 93,
        // ']',
        "(": 40,
        // '(',
        ")": 41,
        // ')',
        "\\mid": 8739,
        "|": 8739,
        "∣": 8739,
        // DIVIDES
        "∥": 8741,
        // PARALLEL TO
        "\\|": 8739,
        "\\{": 123,
        // '{',
        "\\}": 125,
        // '}',
        "\\lbrace": 123,
        // '{',
        "\\rbrace": 125,
        // '}',
        "\\lparen": 40,
        // '('
        "\\rparen": 41,
        // ')'
        "\\lbrack": 91,
        // '[',
        "\\rbrack": 93,
        // ']',
        "\\vert": 8739,
        "\\lvert": 8739,
        "\\mvert": 8739,
        "\\rvert": 8739,
        "\\Vert": 8741,
        "\\lVert": 8741,
        "\\mVert": 8741,
        "\\rVert": 8741,
        "\\parallel": 8741,
        "\\shortparallel": 8741,
        "\\langle": 10216,
        "\\rangle": 10217,
        "\\lfloor": 8970,
        "\\rfloor": 8971,
        "\\lceil": 8968,
        "\\rceil": 8969,
        "\\ulcorner": 9484,
        "\\urcorner": 9488,
        "\\llcorner": 9492,
        "\\lrcorner": 9496,
        "\\lgroup": 10222,
        "\\rgroup": 10223,
        "\\lmoustache": 9136,
        "\\rmoustache": 9137,
        "\\surd": 8730
      }[symbol]) != null ? _a3 : symbol.codePointAt(0);
    }
    function makeSmallDelim(delim, context, center, options) {
      const text = new Box(getSymbolValue(delim), { fontFamily: "Main-Regular" });
      const box = text.wrap(context, options);
      if (center)
        box.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
      return box;
    }
    function makeLargeDelim(delim, size2, center, parentContext, options) {
      const context = new Context(parentContext, options == null ? void 0 : options.style, "textstyle");
      const result = new Box(getSymbolValue(delim), {
        fontFamily: "Size" + size2 + "-Regular",
        classes: "ML__delim-size" + size2
      }).wrap(context);
      if (center)
        result.setTop((1 - context.scalingFactor) * AXIS_HEIGHT);
      return result;
    }
    function makeStackedDelim(delim, heightTotal, center, context, options) {
      var _a3;
      let top;
      let middle;
      let repeat;
      let bottom;
      top = repeat = bottom = getSymbolValue(delim);
      middle = null;
      let fontFamily = "Size1-Regular";
      if (delim === "\\vert" || delim === "\\lvert" || delim === "\\rvert" || delim === "\\mvert" || delim === "\\mid")
        repeat = top = bottom = 8739;
      else if (delim === "\\Vert" || delim === "\\lVert" || delim === "\\rVert" || delim === "\\mVert" || delim === "\\|")
        repeat = top = bottom = 8741;
      else if (delim === "\\uparrow")
        repeat = bottom = 9168;
      else if (delim === "\\Uparrow")
        repeat = bottom = 8214;
      else if (delim === "\\downarrow")
        top = repeat = 9168;
      else if (delim === "\\Downarrow")
        top = repeat = 8214;
      else if (delim === "\\updownarrow") {
        top = 8593;
        repeat = 9168;
        bottom = 8595;
      } else if (delim === "\\Updownarrow") {
        top = 8657;
        repeat = 8214;
        bottom = 8659;
      } else if (delim === "[" || delim === "\\lbrack") {
        top = 9121;
        repeat = 9122;
        bottom = 9123;
        fontFamily = "Size4-Regular";
      } else if (delim === "]" || delim === "\\rbrack") {
        top = 9124;
        repeat = 9125;
        bottom = 9126;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\lfloor" || delim === "⌊") {
        repeat = top = 9122;
        bottom = 9123;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\lceil" || delim === "⌈") {
        top = 9121;
        repeat = bottom = 9122;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\rfloor" || delim === "⌋") {
        repeat = top = 9125;
        bottom = 9126;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\rceil" || delim === "⌉") {
        top = 9124;
        repeat = bottom = 9125;
        fontFamily = "Size4-Regular";
      } else if (delim === "(" || delim === "\\lparen") {
        top = 9115;
        repeat = 9116;
        bottom = 9117;
        fontFamily = "Size4-Regular";
      } else if (delim === ")" || delim === "\\rparen") {
        top = 9118;
        repeat = 9119;
        bottom = 9120;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\{" || delim === "\\lbrace") {
        top = 9127;
        middle = 9128;
        bottom = 9129;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\}" || delim === "\\rbrace") {
        top = 9131;
        middle = 9132;
        bottom = 9133;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\lgroup" || delim === "⟮") {
        top = 9127;
        bottom = 9129;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\rgroup" || delim === "⟯") {
        top = 9131;
        bottom = 9133;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\lmoustache" || delim === "⎰") {
        top = 9127;
        bottom = 9133;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\rmoustache" || delim === "⎱") {
        top = 9131;
        bottom = 9129;
        repeat = 9130;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\surd") {
        top = 57345;
        bottom = 9143;
        repeat = 57344;
        fontFamily = "Size4-Regular";
      } else if (delim === "\\ulcorner") {
        top = 9484;
        repeat = bottom = 32;
      } else if (delim === "\\urcorner") {
        top = 9488;
        repeat = bottom = 32;
      } else if (delim === "\\llcorner") {
        bottom = 9492;
        repeat = top = 32;
      } else if (delim === "\\lrcorner") {
        top = 9496;
        repeat = top = 32;
      }
      const topMetrics = getCharacterMetrics(top, fontFamily);
      const topHeightTotal = topMetrics.height + topMetrics.depth;
      const repeatMetrics = getCharacterMetrics(repeat, fontFamily);
      const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
      const bottomMetrics = getCharacterMetrics(bottom, fontFamily);
      const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
      let middleHeightTotal = 0;
      let middleFactor = 1;
      if (middle !== null) {
        const middleMetrics = getCharacterMetrics(middle, fontFamily);
        middleHeightTotal = middleMetrics.height + middleMetrics.depth;
        middleFactor = 2;
      }
      const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
      const repeatCount = Math.max(
        0,
        Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal))
      );
      const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
      let axisHeight = AXIS_HEIGHT;
      if (center)
        axisHeight = axisHeight * context.scalingFactor;
      const depth = realHeightTotal / 2 - axisHeight;
      const OVERLAP = 8e-3;
      const stack2 = [];
      stack2.push({ box: new Box(bottom, { fontFamily }) });
      stack2.push(-OVERLAP);
      const repeatBox = new Box(repeat, { fontFamily });
      if (middle === null) {
        for (let i = 0; i < repeatCount; i++)
          stack2.push({ box: repeatBox });
      } else {
        for (let i = 0; i < repeatCount; i++)
          stack2.push({ box: repeatBox });
        stack2.push(-OVERLAP);
        stack2.push({ box: new Box(middle, { fontFamily }) });
        stack2.push(-OVERLAP);
        for (let i = 0; i < repeatCount; i++)
          stack2.push({ box: repeatBox });
      }
      stack2.push(-OVERLAP);
      stack2.push({ box: new Box(top, { fontFamily }) });
      let sizeClass = "";
      if (fontFamily === "Size1-Regular")
        sizeClass = " delim-size1";
      else if (fontFamily === "Size4-Regular")
        sizeClass = " delim-size4";
      const inner = new VBox(
        {
          bottom: depth,
          children: stack2
        },
        { classes: sizeClass }
      );
      const result = new Box(inner, __spreadProps(__spreadValues({}, options != null ? options : {}), {
        classes: ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "") + " ML__delim-mult"
      }));
      return result;
    }
    var stackLargeDelimiters = /* @__PURE__ */ new Set([
      "(",
      ")",
      "\\lparen",
      "\\rparen",
      "[",
      "]",
      "\\lbrack",
      "\\rbrack",
      "\\{",
      "\\}",
      "\\lbrace",
      "\\rbrace",
      "\\lfloor",
      "\\rfloor",
      "\\lceil",
      "\\rceil",
      "\\surd",
      "⌊",
      "⌋",
      "⌈",
      "⌉"
    ]);
    var stackAlwaysDelimiters = /* @__PURE__ */ new Set([
      "\\uparrow",
      "\\downarrow",
      "\\updownarrow",
      "\\Uparrow",
      "\\Downarrow",
      "\\Updownarrow",
      "|",
      "\\|",
      "\\vert",
      "\\Vert",
      "\\lvert",
      "\\rvert",
      "\\lVert",
      "\\rVert",
      "\\mvert",
      "\\mid",
      "\\lgroup",
      "\\rgroup",
      "\\lmoustache",
      "\\rmoustache",
      "⟮",
      "⟯",
      "⎰",
      "⎱"
    ]);
    var stackNeverDelimiters = /* @__PURE__ */ new Set([
      "<",
      ">",
      "\\langle",
      "\\rangle",
      "/",
      "\\backslash",
      "\\lt",
      "\\gt"
    ]);
    var sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
    function makeSizedDelim(delim, size2, context, options) {
      var _a3;
      if (delim === void 0 || delim === ".") {
        return makeNullDelimiter(
          context,
          (_a3 = options.type) != null ? _a3 : "minner",
          options.classes
        );
      }
      if (delim === "<" || delim === "\\lt" || delim === "⟨")
        delim = "\\langle";
      else if (delim === ">" || delim === "\\gt" || delim === "⟩")
        delim = "\\rangle";
      if (stackLargeDelimiters.has(delim) || stackNeverDelimiters.has(delim))
        return makeLargeDelim(delim, size2, false, context, options);
      if (stackAlwaysDelimiters.has(delim)) {
        return makeStackedDelim(
          delim,
          sizeToMaxHeight[size2],
          false,
          context,
          options
        );
      }
      console.assert(false, "Unknown delimiter '" + delim + "'");
      return null;
    }
    var stackNeverDelimiterSequence = [
      { type: "small", mathstyle: "scriptscriptstyle" },
      { type: "small", mathstyle: "scriptstyle" },
      { type: "small", mathstyle: "textstyle" },
      { type: "large", size: 1 },
      { type: "large", size: 2 },
      { type: "large", size: 3 },
      { type: "large", size: 4 }
    ];
    var stackAlwaysDelimiterSequence = [
      { type: "small", mathstyle: "scriptscriptstyle" },
      { type: "small", mathstyle: "scriptscriptstyle" },
      { type: "small", mathstyle: "textstyle" },
      { type: "stack" }
    ];
    var stackLargeDelimiterSequence = [
      { type: "small", mathstyle: "scriptscriptstyle" },
      { type: "small", mathstyle: "scriptstyle" },
      { type: "small", mathstyle: "textstyle" },
      { type: "large", size: 1 },
      { type: "large", size: 2 },
      { type: "large", size: 3 },
      { type: "large", size: 4 },
      { type: "stack" }
    ];
    function delimTypeToFont(info) {
      if (info.type === "small")
        return "Main-Regular";
      if (info.type === "large")
        return "Size" + info.size + "-Regular";
      console.assert(info.type === "stack");
      return "Size4-Regular";
    }
    function traverseSequence(delim, height, sequence, context) {
      const start = { "-4": 0, "-3": 1, "0": 2 }[context.mathstyle.sizeDelta];
      for (let i = start; i < sequence.length; i++) {
        if (sequence[i].type === "stack") {
          break;
        }
        const metrics = getCharacterMetrics(delim, delimTypeToFont(sequence[i]));
        if (metrics.defaultMetrics) {
          return { type: "small", mathstyle: "scriptstyle" };
        }
        let heightDepth = metrics.height + metrics.depth;
        if (sequence[i].type === "small") {
          if (sequence[i].mathstyle === "scriptscriptstyle")
            heightDepth *= FONT_SCALE[Math.max(1, context.size - 2)];
          else if (sequence[i].mathstyle === "scriptstyle")
            heightDepth *= FONT_SCALE[Math.max(1, context.size - 1)];
        }
        if (heightDepth > height)
          return sequence[i];
      }
      return sequence[sequence.length - 1];
    }
    function makeCustomSizedDelim(type, delim, height, center, context, options) {
      var _a3;
      if (!delim || delim.length === 0 || delim === ".")
        return makeNullDelimiter(context, type, type);
      if (delim === "<" || delim === "\\lt")
        delim = "\\langle";
      else if (delim === ">" || delim === "\\gt")
        delim = "\\rangle";
      let sequence;
      if (stackNeverDelimiters.has(delim))
        sequence = stackNeverDelimiterSequence;
      else if (stackLargeDelimiters.has(delim))
        sequence = stackLargeDelimiterSequence;
      else
        sequence = stackAlwaysDelimiterSequence;
      const delimType = traverseSequence(
        getSymbolValue(delim),
        height,
        sequence,
        context
      );
      const delimContext = new Context(
        context,
        options == null ? void 0 : options.style,
        delimType.mathstyle
      );
      if (delimType.type === "small") {
        return makeSmallDelim(delim, delimContext, center, {
          type,
          classes: "ML__small-delim " + ((_a3 = options == null ? void 0 : options.classes) != null ? _a3 : "")
        });
      }
      if (delimType.type === "large") {
        return makeLargeDelim(delim, delimType.size, center, delimContext, __spreadProps(__spreadValues({}, options), {
          type
        }));
      }
      console.assert(delimType.type === "stack");
      return makeStackedDelim(delim, height, center, delimContext, __spreadProps(__spreadValues({}, options), {
        type
      }));
    }
    function makeLeftRightDelim(type, delim, height, depth, context, options) {
      if (delim === ".")
        return makeNullDelimiter(context, type, options == null ? void 0 : options.classes);
      const axisHeight = AXIS_HEIGHT * context.scalingFactor;
      const delimiterFactor = 901;
      const delimiterExtend = 5 / PT_PER_EM;
      const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
      const totalHeight = Math.max(
        maxDistFromAxis / 500 * delimiterFactor,
        2 * maxDistFromAxis - delimiterExtend
      );
      return makeCustomSizedDelim(type, delim, totalHeight, true, context, options);
    }
    function makeNullDelimiter(parentContext, type, classes) {
      const context = new Context(parentContext, void 0, "textstyle");
      return new Box(null, {
        classes: " nulldelimiter " + (classes != null ? classes : ""),
        type
      }).wrap(context);
    }
    var OverunderAtom = class extends Atom {
      constructor(command, context, options) {
        var _a3, _b3, _c2, _d2;
        super("overunder", context, {
          command,
          serialize: options.serialize,
          style: options.style
        });
        this.skipBoundary = (_a3 = options.skipBoundary) != null ? _a3 : true;
        this.subsupPlacement = options.supsubPlacement;
        this.body = options.body;
        this.svgAbove = options.svgAbove;
        this.svgBelow = options.svgBelow;
        this.svgBody = options.svgBody;
        this.above = options.above;
        this.below = options.below;
        this.boxType = (_b3 = options.boxType) != null ? _b3 : "mord";
        this.paddedBody = (_c2 = options.paddedBody) != null ? _c2 : false;
        this.paddedLabels = (_d2 = options.paddedLabels) != null ? _d2 : false;
      }
      static fromJson(json, context) {
        return new OverunderAtom(json.command, context, json);
      }
      toJson() {
        const options = {};
        if (!this.skipBoundary)
          options.skipBoundary = false;
        if (this.subsupPlacement)
          options.subsupPlacement = this.subsupPlacement;
        if (this.svgAbove)
          options.svgAbove = this.svgAbove;
        if (this.svgBelow)
          options.svgBelow = this.svgBelow;
        if (this.svgBody)
          options.svgBody = this.svgBody;
        if (this.boxType !== "mord")
          options.boxType = this.boxType;
        if (this.paddedBody)
          options.paddedBody = true;
        if (this.paddedLabels)
          options.paddedLabels = true;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      /**
       * Combine a base with an atom above and an atom below.
       *
       * See http://tug.ctan.org/macros/latex/required/amsmath/amsmath.dtx
       *
       * > \newcommand{\overset}[2]{\binrel@{#2}%
       * > \binrel@@{\mathop{\kern\z@#2}\limits^{#1}}}
       *
       */
      render(parentContext) {
        let body = this.svgBody ? makeSVGBox(this.svgBody) : Atom.createBox(parentContext, this.body, { newList: true });
        const annotationContext = new Context(
          parentContext,
          this.style,
          "scriptstyle"
        );
        let above = null;
        if (this.svgAbove)
          above = makeSVGBox(this.svgAbove);
        else if (this.above)
          above = Atom.createBox(annotationContext, this.above, { newList: true });
        let below = null;
        if (this.svgBelow)
          below = makeSVGBox(this.svgBelow);
        else if (this.below)
          below = Atom.createBox(annotationContext, this.below, { newList: true });
        if (this.paddedBody) {
          body = new Box(
            [
              makeNullDelimiter(parentContext, "mopen"),
              body,
              makeNullDelimiter(parentContext, "mclose")
            ],
            { newList: true }
          );
        }
        let base = makeOverunderStack(parentContext, {
          base: body,
          above,
          // aboveShift,
          below,
          // belowShift,
          type: this.boxType === "mbin" || this.boxType === "mrel" ? this.boxType : "mord",
          paddedAboveBelow: this.paddedLabels
        });
        if (!base)
          return null;
        if (this.subsupPlacement === "over-under")
          base = this.attachLimits(parentContext, { base, type: base.type });
        else
          base = this.attachSupsub(parentContext, { base });
        if (this.caret)
          base.caret = this.caret;
        return this.bind(parentContext, base);
      }
    };
    function makeOverunderStack(context, options) {
      if (!options.base)
        return null;
      if (!options.above && !options.below) {
        const box = new Box(options.base, { type: options.type });
        box.setStyle("position", "relative");
        return box;
      }
      let aboveShift = 0;
      if (options.above)
        aboveShift = -options.above.depth + context.metrics.bigOpSpacing2;
      let result = null;
      const base = options.base;
      const baseShift = 0;
      const classes = ["ML__center"];
      if (options.paddedAboveBelow)
        classes.push("ML__label_padding");
      if (options.below && options.above) {
        const bottom = context.metrics.bigOpSpacing5 + options.below.height + options.below.depth + base.depth + baseShift;
        result = new VBox({
          bottom,
          children: [
            context.metrics.bigOpSpacing5,
            { box: options.below, classes },
            { box: base, classes: ["ML__center"] },
            aboveShift,
            { box: options.above, classes },
            context.metrics.bigOpSpacing5
          ]
        });
      } else if (options.below) {
        result = new VBox({
          top: base.height - baseShift,
          children: [
            context.metrics.bigOpSpacing5,
            { box: options.below, classes },
            { box: base, classes: ["ML__center"] }
          ]
        });
      } else if (options.above) {
        result = new VBox({
          bottom: base.depth + baseShift,
          children: [
            // base.depth,
            { box: base, classes: ["ML__center"] },
            aboveShift,
            { box: options.above, classes },
            context.metrics.bigOpSpacing5
          ]
        });
      }
      return new Box(result, { type: options.type });
    }
    var ACCENTS = {
      acute: 714,
      grave: 715,
      dot: 729,
      ddot: 168,
      mathring: 730,
      tilde: 126,
      bar: 713,
      breve: 728,
      check: 711,
      hat: 94,
      vec: 8407
    };
    defineFunction(Object.keys(ACCENTS), "{body:auto}", {
      createAtom: (command, args, style, context) => new AccentAtom(command, args[0], context, {
        accentChar: ACCENTS[command.slice(1)],
        style
      })
    });
    defineFunction(["widehat", "widecheck", "widetilde"], "{body:auto}", {
      createAtom: (command, args, style, context) => {
        const baseString = parseArgAsString(args[0]);
        return new AccentAtom(command, args[0], context, {
          style,
          svgAccent: command.slice(1) + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length])
        });
      }
    });
    defineFunction(["overarc", "overparen", "wideparen"], "{body:auto}", {
      createAtom: (command, args, style, context) => {
        return new AccentAtom(command, args[0], context, {
          style,
          svgAccent: "overarc"
        });
      }
    });
    defineFunction(["underarc", "underparen"], "{body:auto}", {
      createAtom: (command, args, style, context) => {
        return new OverunderAtom(command, context, {
          body: args[0],
          style,
          svgBelow: "underarc"
        });
      }
    });
    defineFunction("utilde", "{body:auto}", {
      createAtom: (command, args, style, context) => {
        const baseString = parseArgAsString(args[0]);
        const accent = "widetilde" + (baseString.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][baseString.length]);
        return new OverunderAtom(command, context, {
          body: args[0],
          svgBelow: accent,
          style,
          boxType: binRelType(args[0])
        });
      }
    });
    defineFunction("^", "{:string}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        return new Atom("mord", context, {
          command,
          isFunction: false,
          limits: "adjacent",
          style,
          value: args[0] ? (_a3 = {
            a: "â",
            e: "ê",
            i: "î",
            o: "ô",
            u: "û",
            A: "Â",
            E: "Ê",
            I: "Î",
            O: "Ô",
            U: "Û"
          }[args[0]]) != null ? _a3 : "^" : "^"
        });
      }
    });
    defineFunction("`", "{:string}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        return new Atom("mord", context, {
          command,
          isFunction: false,
          limits: "adjacent",
          style,
          value: args[0] ? (_a3 = {
            a: "à",
            e: "è",
            i: "ì",
            o: "ò",
            u: "ù",
            A: "À",
            E: "È",
            I: "Ì",
            O: "Ò",
            U: "Ù"
          }[args[0]]) != null ? _a3 : "`" : "`"
        });
      }
    });
    defineFunction("'", "{:string}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        return new Atom("mord", context, {
          command,
          isFunction: false,
          limits: "adjacent",
          style,
          value: args[0] ? (_a3 = {
            a: "á",
            e: "é",
            i: "í",
            o: "ó",
            u: "ú",
            A: "Á",
            E: "É",
            I: "Í",
            O: "Ó",
            U: "Ú"
          }[args[0]]) != null ? _a3 : "^" : "^"
        });
      }
    });
    defineFunction("~", "{:string}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        return new Atom("mord", context, {
          command,
          isFunction: false,
          limits: "adjacent",
          style,
          value: args[0] ? (_a3 = { n: "ñ", N: "Ñ", a: "ã", o: "õ", A: "Ã", O: "Õ" }[args[0]]) != null ? _a3 : "´" : "´"
        });
      }
    });
    defineFunction("c", "{:string}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        return new Atom("mord", context, {
          command,
          isFunction: false,
          limits: "adjacent",
          style,
          value: args[0] ? (_a3 = { c: "ç", C: "Ç" }[args[0]]) != null ? _a3 : "" : ""
        });
      }
    });
    var ErrorAtom = class extends Atom {
      constructor(value, context) {
        super("error", context, { value, command: value, mode: "math" });
        this.verbatimLatex = value;
      }
      static fromJson(json, context) {
        return new ErrorAtom(json.command, context);
      }
      toJson() {
        return super.toJson();
      }
      render(context) {
        const result = this.createBox(context, { classes: "ML__error" });
        if (this.caret)
          result.caret = this.caret;
        return result;
      }
    };
    var GroupAtom = class extends Atom {
      constructor(arg, context, options) {
        var _a3, _b3, _c2, _d2;
        super("group", context, {
          command: options == null ? void 0 : options.command,
          mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
          serialize: options == null ? void 0 : options.serialize,
          style: options == null ? void 0 : options.style
        });
        this.body = arg;
        this.mathstyleName = options == null ? void 0 : options.mathstyleName;
        console.assert(
          !(options == null ? void 0 : options.serialize) || !Boolean(options == null ? void 0 : options.latexClose) || !Boolean(options == null ? void 0 : options.latexOpen),
          (_b3 = options == null ? void 0 : options.command) != null ? _b3 : ""
        );
        this.latexOpen = options == null ? void 0 : options.latexOpen;
        this.latexClose = options == null ? void 0 : options.latexClose;
        this.cssId = options == null ? void 0 : options.cssId;
        this.htmlData = options == null ? void 0 : options.htmlData;
        this.htmlStyle = options == null ? void 0 : options.htmlStyle;
        this.customClass = options == null ? void 0 : options.customClass;
        this.boxType = options == null ? void 0 : options.boxType;
        this.skipBoundary = true;
        this.captureSelection = (_c2 = options == null ? void 0 : options.captureSelection) != null ? _c2 : false;
        this.changeMode = (_d2 = options == null ? void 0 : options.changeMode) != null ? _d2 : false;
        this.displayContainsHighlight = false;
        if (arg && arg.length === 1 && arg[0].command === ",")
          this.captureSelection = true;
      }
      static fromJson(json, context) {
        return new GroupAtom(json.body, context, json);
      }
      toJson() {
        const options = {};
        if (this.mathstyleName)
          options.mathstyleName = this.mathstyleName;
        if (this.latexOpen)
          options.latexOpen = this.latexOpen;
        if (this.latexClose)
          options.latexClose = this.latexClose;
        if (this.cssId)
          options.cssId = this.cssId;
        if (this.htmlData)
          options.htmlData = this.htmlData;
        if (this.htmlStyle)
          options.htmlStyle = this.htmlStyle;
        if (this.customClass)
          options.customClass = this.customClass;
        if (this.boxType)
          options.boxType = this.boxType;
        if (this.captureSelection)
          options.captureSelection = true;
        if (this.changeMode)
          options.changeMode = true;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      render(context) {
        const localContext = new Context(context, this.style, this.mathstyleName);
        const box = Atom.createBox(localContext, this.body, {
          type: this.boxType,
          classes: this.customClass,
          mode: this.mode,
          style: { backgroundColor: this.style.backgroundColor },
          newList: !this.boxType
        });
        if (!box)
          return null;
        if (this.cssId)
          box.cssId = this.cssId;
        if (this.htmlData)
          box.htmlData = this.htmlData;
        if (this.htmlStyle)
          box.htmlStyle = this.htmlStyle;
        if (this.caret)
          box.caret = this.caret;
        return this.bind(context, box);
      }
      serialize(options) {
        let result = this.bodyToLatex(options);
        if (typeof this.latexOpen === "string")
          result = this.latexOpen + result + this.latexClose;
        if (this.htmlData)
          result = `\\htmlData{${this.htmlData}}{${result}}`;
        if (this.htmlStyle)
          result = `\\htmlStyle{${this.htmlStyle}}{${result}}`;
        if (this.customClass)
          result = `\\class{${this.customClass}}{${result}}`;
        if (this.cssId)
          result = `\\cssId{${this.cssId}}{${result}}`;
        return result;
      }
    };
    var LeftRightAtom = class extends Atom {
      constructor(variant, body, context, options) {
        super("leftright", context, {
          style: options.style,
          displayContainsHighlight: true
        });
        this.variant = variant;
        this.body = body;
        this.leftDelim = options.leftDelim;
        this.rightDelim = options.rightDelim;
      }
      static fromJson(json, context) {
        var _a3;
        return new LeftRightAtom(
          (_a3 = json.variant) != null ? _a3 : "",
          json.body,
          context,
          json
        );
      }
      toJson() {
        const result = super.toJson();
        if (this.variant)
          result.variant = this.variant;
        if (this.leftDelim)
          result.leftDelim = this.leftDelim;
        if (this.rightDelim)
          result.rightDelim = this.rightDelim;
        return result;
      }
      serialize(options) {
        var _a3, _b3;
        const rightDelim = this.matchingRightDelim();
        if (this.variant === "left...right") {
          return joinLatex([
            "\\left" + ((_a3 = this.leftDelim) != null ? _a3 : "."),
            this.bodyToLatex(options),
            "\\right" + rightDelim
          ]);
        }
        if (this.variant === "mleft...mright") {
          return joinLatex([
            "\\mleft" + ((_b3 = this.leftDelim) != null ? _b3 : "."),
            this.bodyToLatex(options),
            "\\mright" + rightDelim
          ]);
        }
        return joinLatex([
          !this.leftDelim || this.leftDelim === "." ? "" : this.leftDelim,
          this.bodyToLatex(options),
          rightDelim
        ]);
      }
      matchingRightDelim() {
        var _a3, _b3;
        if (this.rightDelim && this.rightDelim !== "?")
          return this.rightDelim;
        const leftDelim = (_a3 = this.leftDelim) != null ? _a3 : ".";
        return (_b3 = RIGHT_DELIM[leftDelim]) != null ? _b3 : leftDelim;
      }
      render(parentContext) {
        var _a3, _b3, _c2;
        const context = new Context(parentContext, this.style);
        console.assert(this.body !== void 0);
        const delimContext = new Context(parentContext, this.style, "textstyle");
        const inner = (_a3 = Atom.createBox(context, this.body, { newList: true })) != null ? _a3 : new Box(null, { newList: true });
        const innerHeight = inner.height / delimContext.scalingFactor;
        const innerDepth = inner.depth / delimContext.scalingFactor;
        const boxes = [];
        if (this.leftDelim) {
          boxes.push(
            this.bind(
              delimContext,
              makeLeftRightDelim(
                "mopen",
                this.leftDelim,
                innerHeight,
                innerDepth,
                delimContext,
                {
                  classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""),
                  mode: this.mode,
                  style: this.style
                }
              )
            )
          );
        }
        if (inner) {
          if (inner.children) {
            for (let i = 0; i < inner.children.length; i++) {
              const child = inner.children[i];
              if (child.delim) {
                const savedCaret = child.caret;
                inner.children[i] = this.bind(
                  context,
                  makeLeftRightDelim(
                    "minner",
                    child.delim,
                    innerHeight,
                    innerDepth,
                    context
                  )
                );
                inner.children[i].caret = savedCaret;
              }
            }
          }
          boxes.push(inner);
        }
        if (this.rightDelim) {
          let classes = this.containsCaret ? " ML__contains-caret" : "";
          let delim = this.rightDelim;
          if (delim === "?") {
            if (this.context.smartFence) {
              delim = this.matchingRightDelim();
              classes += " ML__smart-fence__close";
            } else
              delim = ".";
          }
          boxes.push(
            this.bind(
              delimContext,
              makeLeftRightDelim(
                "mclose",
                delim,
                innerHeight,
                innerDepth,
                delimContext,
                {
                  classes: classes + " ML__close",
                  mode: this.mode,
                  style: this.style
                }
              )
            )
          );
        }
        const tightSpacing = (_c2 = this.variant === "mleft...mright" || ((_b3 = this.leftSibling) == null ? void 0 : _b3.isFunction)) != null ? _c2 : false;
        const result = new Box(boxes, {
          type: tightSpacing ? "mclose" : "minner",
          classes: "left-right"
        });
        if (this.caret)
          result.caret = this.caret;
        return this.bind(context, result.wrap(context));
      }
    };
    var MacroAtom = class extends Atom {
      constructor(macro, context, options) {
        var _a3, _b3;
        super("macro", context, { command: macro });
        this.body = options.body;
        if (options.captureSelection === void 0) {
          if (options.args)
            this.captureSelection = false;
          else
            this.captureSelection = true;
        } else
          this.captureSelection = options.captureSelection;
        this.macroArgs = (_a3 = options.args) != null ? _a3 : "";
        this.expand = (_b3 = options.expand) != null ? _b3 : false;
      }
      static fromJson(json, context) {
        return new MacroAtom(json.command, context, json);
      }
      toJson() {
        const options = super.toJson();
        if (this.expand)
          options.expand = true;
        if (this.captureSelection !== void 0)
          options.captureSelection = this.captureSelection;
        if (this.macroArgs)
          options.args = this.macroArgs;
        return options;
      }
      serialize(options) {
        return options.expandMacro && this.expand ? this.bodyToLatex(options) : this.command + this.macroArgs;
      }
      render(context) {
        const result = Atom.createBox(context, this.body);
        if (!result)
          return null;
        if (this.caret)
          result.caret = this.caret;
        return this.bind(context, result);
      }
    };
    var PromptAtom = class extends Atom {
      constructor(context, placeholderId, correctness, locked = false, body, options) {
        var _a3;
        super("prompt", context, {
          mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
          style: options == null ? void 0 : options.style,
          command: "\\placeholder"
        });
        this.body = body;
        this.correctness = correctness;
        this.placeholderId = placeholderId;
        this.locked = locked;
        this.captureSelection = this.locked;
      }
      static fromJson(json, context) {
        return new PromptAtom(
          context,
          json.placeholderId,
          json.correctness,
          json.locked,
          json.body,
          json
        );
      }
      toJson() {
        const result = super.toJson();
        if (this.placeholderId)
          result.placeholderId = this.placeholderId;
        if (!this.body)
          delete result.body;
        if (this.body) {
          result.body = this.body.filter((x) => x.type !== "first").map((x) => x.toJson());
        }
        if (this.correctness)
          result.correctness = this.correctness;
        result.locked = this.locked;
        return result;
      }
      render(parentContext) {
        const context = new Context(parentContext);
        const fboxsep = convertDimensionToEm(
          context.getRegisterAsDimension("fboxsep")
        );
        const padding = fboxsep;
        const content = Atom.createBox(parentContext, this.body);
        if (!content)
          return null;
        if (!content.height)
          content.height = 0.5;
        content.setStyle("vertical-align", -content.height, "em");
        if (this.correctness === "correct") {
          content.setStyle(
            "color",
            "var(--correct-color, var(--ML__correct-color))"
          );
        } else if (this.correctness === "incorrect") {
          content.setStyle(
            "color",
            "var(--incorrect-color, var(--ML__incorrect-color))"
          );
        }
        const base = new Box(content, { type: "mord" });
        let boxClasses = "ML__prompt ";
        if (this.locked) {
          boxClasses += " ML__lockedPromptBox ";
        } else
          boxClasses += " ML__editablePromptBox ";
        if (this.correctness === "correct")
          boxClasses += " ML__correctPromptBox ";
        else if (this.correctness === "incorrect")
          boxClasses += " ML__incorrectPromptBox ";
        if (this.containsCaret)
          boxClasses += " ML__focusedPromptBox ";
        const box = new Box(null, {
          classes: boxClasses
        });
        box.height = base.height + padding;
        box.depth = base.depth + padding;
        box.setStyle("box-sizing", "border-box");
        box.setStyle("position", "absolute");
        box.setStyle("height", base.height + base.depth + 2 * padding, "em");
        if (padding === 0)
          box.setStyle("width", "100%");
        else {
          box.setStyle("width", `calc(100% + ${2 * padding}em)`);
          box.setStyle("top", fboxsep, "em");
          box.setStyle("left", -padding, "em");
        }
        let svg = "";
        if (this.correctness === "incorrect") {
          svg += '<line x1="3%"  y1="97%" x2="97%" y2="3%" stroke-width="0.5" stroke="var(--incorrect-color, var(--ML__incorrect-color))" stroke-linecap="round" />';
        }
        if (svg)
          addSVGOverlay(box, svg, "");
        base.setStyle("display", "inline-block");
        base.setStyle("height", content.height + content.depth, "em");
        base.setStyle("vertical-align", -padding, "em");
        const result = new Box([box, base], { classes: "ML__prompt-atom" });
        result.setStyle("position", "relative");
        result.setStyle("display", "inline-block");
        result.setStyle("line-height", 0);
        result.height = base.height + padding + 0.2;
        result.depth = base.depth + padding;
        result.left = padding;
        result.right = padding;
        result.setStyle("height", base.height + padding, "em");
        result.setStyle("top", base.depth - base.height, "em");
        result.setStyle("vertical-align", base.depth + padding, "em");
        result.setStyle("margin-left", 0.5, "em");
        result.setStyle("margin-right", 0.5, "em");
        if (this.caret)
          result.caret = this.caret;
        return this.bind(
          context,
          this.attachSupsub(parentContext, { base: result })
        );
      }
      serialize(options) {
        var _a3;
        let value = (_a3 = this.bodyToLatex(options)) != null ? _a3 : "";
        if (value === this.context.placeholderSymbol)
          value = "";
        const id = this.placeholderId ? `[${this.placeholderId}]` : "";
        let correctness;
        if (this.correctness === "correct")
          correctness = "[correct]";
        else if (this.correctness === "incorrect")
          correctness = "[incorrect]";
        else
          correctness = "";
        const locked = this.locked ? "[locked]" : "";
        return `\\placeholder${id}${correctness}${locked}{${value}}`;
      }
    };
    var PlaceholderAtom = class extends Atom {
      constructor(context, options) {
        var _a3;
        const value = (options == null ? void 0 : options.value) || context.placeholderSymbol;
        super("placeholder", context, {
          mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math",
          style: options == null ? void 0 : options.style,
          value,
          command: "\\placeholder"
        });
        this.captureSelection = true;
      }
      static fromJson(json, context) {
        return new PlaceholderAtom(context, json);
      }
      toJson() {
        const result = super.toJson();
        if (this.value === this.context.placeholderSymbol)
          delete result.value;
        if (this.defaultValue)
          result.defaultValue = this.defaultValue.map((x) => x.toJson());
        return result;
      }
      render(context) {
        if (typeof context.renderPlaceholder === "function")
          return context.renderPlaceholder(context);
        let classes = "";
        if (this.caret)
          classes += "ML__placeholder-selected ";
        if (this.isSelected)
          classes += " ML__selected ";
        return this.createBox(context, { classes });
      }
      serialize(_options) {
        let value = this.value;
        if (value === this.context.placeholderSymbol)
          value = "";
        return `\\placeholder{${this.value}}`;
      }
    };
    var SpacingAtom = class extends Atom {
      constructor(command, style, context, width) {
        super("spacing", context, { command, style });
        this.width = width;
      }
      static fromJson(json, context) {
        return new SpacingAtom(json.command, json.style, context, json.width);
      }
      toJson() {
        const options = {};
        if (this.width)
          options.width = this.width;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      render(context) {
        var _a3;
        let result;
        if (this.width) {
          result = new Box(null, { classes: "mspace" });
          result.left = convertGlueToEm(this.width);
        } else {
          const spacingCls = (_a3 = {
            "\\qquad": "qquad",
            "\\quad": "quad",
            "\\enspace": "enspace",
            "\\;": "thickspace",
            "\\:": "mediumspace",
            "\\,": "thinspace",
            "\\!": "negativethinspace"
          }[this.command]) != null ? _a3 : "mediumspace";
          result = new Box(null, { classes: spacingCls });
        }
        result = this.bind(context, result);
        if (this.caret)
          result.caret = this.caret;
        return result;
      }
      serialize(_options) {
        var _a3;
        let result = (_a3 = this.command) != null ? _a3 : "";
        if (this.command === "\\hspace" || this.command === "\\hspace*") {
          if (Number.isFinite(this.width))
            result += `{${this.width}em'}`;
          else
            result += `{0pt}`;
        } else if (Number.isFinite(this.width))
          result += ` ${this.width}em`;
        return result;
      }
    };
    var SubsupAtom = class extends Atom {
      constructor(context, options) {
        super("msubsup", context, { style: options == null ? void 0 : options.style });
      }
      static fromJson(json, context) {
        const result = new SubsupAtom(context, json);
        for (const branch of NAMED_BRANCHES)
          if (json[branch])
            result.setChildren(json[branch], branch);
        return result;
      }
      toJson() {
        return super.toJson();
      }
      render(context) {
        var _a3;
        console.assert(!this.subsupPlacement);
        const leftSibling = this.leftSibling;
        const phantomContex = new Context(context, { isPhantom: true });
        const base = (_a3 = leftSibling.render(phantomContex)) != null ? _a3 : new Box(null);
        const phantom = new Box(null, { height: base.height, depth: base.depth });
        return this.attachSupsub(context, {
          base: phantom,
          isCharacterBox: leftSibling.isCharacterBox(),
          // Set to 'supsub' so that it is skipped when walking the
          // atom to adjust for spacing.
          type: "supsub"
        });
      }
      serialize(options) {
        return this.supsubToLatex(options);
      }
    };
    var TextAtom = class extends Atom {
      constructor(command, value, style, context) {
        super("text", context, {
          command,
          mode: "text",
          displayContainsHighlight: true
        });
        this.value = value;
        this.verbatimLatex = value;
        this.applyStyle(style);
      }
      static fromJson(json, context) {
        return new TextAtom(json.command, json.value, json.style, context);
      }
      toJson() {
        return super.toJson();
      }
      render(context) {
        const result = this.createBox(context);
        if (this.caret)
          result.caret = this.caret;
        return result;
      }
      serialize(_options) {
        var _a3;
        return (_a3 = this.verbatimLatex) != null ? _a3 : charToLatex("text", this.value.codePointAt(0));
      }
    };
    function isLiteral(token) {
      return !/^<({|}|\$|\$\$|space)>$/.test(token);
    }
    var Parser = class {
      /**
       * @param tokens - An array of tokens generated by the lexer.
       *
       * Note: smartFence and registers are usually defined by the GloablContext.
       * However, in some cases they need to be overridden.
       *
       */
      constructor(tokens, context, options) {
        this.index = 0;
        this.endCount = 0;
        var _a3, _b3, _c2, _d2, _e;
        this.tokens = tokens;
        this.context = context;
        this.errors = [];
        this.args = (_a3 = options.args) != null ? _a3 : null;
        this.smartFence = (_b3 = options.smartFence) != null ? _b3 : context.smartFence;
        this._currentParsingContext = {
          parent: void 0,
          mathlist: [],
          style: (_c2 = options.style) != null ? _c2 : {},
          parseMode: (_d2 = options.parseMode) != null ? _d2 : "math",
          mathstyle: (_e = options.mathstyle) != null ? _e : "displaystyle",
          registers: context.registers,
          tabular: false
        };
      }
      get currentContext() {
        return this._currentParsingContext;
      }
      get rootContext() {
        let context = this._currentParsingContext;
        while (context.parent)
          context = context.parent;
        return context;
      }
      beginContext(options) {
        var _a3, _b3, _c2;
        const newContext = {
          parent: this.currentContext,
          mathlist: [],
          style: __spreadValues({}, this.currentContext.style),
          parseMode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : this.currentContext.parseMode,
          mathstyle: (_b3 = options == null ? void 0 : options.mathstyle) != null ? _b3 : this.currentContext.mathstyle,
          registers: null,
          tabular: (_c2 = options == null ? void 0 : options.tabular) != null ? _c2 : false
        };
        this._currentParsingContext = newContext;
      }
      endContext() {
        this._currentParsingContext = this._currentParsingContext.parent;
      }
      onError(err) {
        this.errors.push(__spreadValues({
          before: tokensToString(this.tokens.slice(this.index, this.index + 10)),
          after: tokensToString(
            this.tokens.slice(Math.max(0, this.index - 10), this.index)
          )
        }, err));
      }
      get mathlist() {
        return this.currentContext.mathlist;
      }
      set mathlist(value) {
        this.currentContext.mathlist = value;
      }
      get parseMode() {
        return this.currentContext.parseMode;
      }
      // @revisit
      set parseMode(value) {
        this.currentContext.parseMode = value;
      }
      get tabularMode() {
        return this.currentContext.tabular;
      }
      get style() {
        let context = this.currentContext;
        while (context) {
          if (context.style)
            return context.style;
          context = context.parent;
        }
        return {};
      }
      // @revisit
      set style(value) {
        this.currentContext.style = value;
      }
      getRegister(name) {
        var _a3, _b3, _c2;
        console.assert(name[0] !== "\\");
        if (name.startsWith("global "))
          return (_b3 = (_a3 = this.rootContext.registers) == null ? void 0 : _a3[name.slice(7)]) != null ? _b3 : 0;
        let context = this.currentContext;
        while (context) {
          if ((_c2 = context.registers) == null ? void 0 : _c2[name])
            return context.registers[name];
          context = context.parent;
        }
        return 0;
      }
      setRegister(name, value) {
        var _a3;
        if (name.startsWith("global ")) {
          name = name.slice(7);
          let context = this.currentContext;
          while (context) {
            if ((_a3 = context.registers) == null ? void 0 : _a3[name])
              delete context.registers[name];
            context = context.parent;
          }
          this.rootContext.registers[name] = value;
          return;
        }
        if (!this.currentContext.registers)
          this.currentContext.registers = {};
        this.currentContext.registers[name] = value;
      }
      /**
       * True if we've reached the end of the token stream
       */
      end() {
        this.endCount++;
        return this.index >= this.tokens.length || this.endCount > 1e3;
      }
      get() {
        this.endCount = 0;
        return this.index < this.tokens.length ? this.tokens[this.index++] : "";
      }
      peek() {
        return this.tokens[this.index];
      }
      /**
       * @return True if the next token matches the input, and advance
       */
      match(input) {
        if (this.tokens[this.index] === input) {
          this.index++;
          return true;
        }
        return false;
      }
      /**
       * Return the last atom that can have a subscript/superscript attached to it.
       * If there isn't one, insert a `SubsupAtom` and return it.
       */
      lastSubsupAtom() {
        let atom;
        if (this.mathlist.length > 0) {
          atom = this.mathlist[this.mathlist.length - 1];
          if (atom.type === "msubsup")
            return atom;
          if (atom.subsupPlacement !== void 0)
            return atom;
        }
        atom = new SubsupAtom(this.context, { style: this.style });
        this.mathlist.push(atom);
        return atom;
      }
      /**
       * @return True if the next token matches the specified regular expression pattern.
       */
      hasPattern(pattern) {
        return pattern.test(this.tokens[this.index]);
      }
      hasInfixCommand() {
        var _a3;
        const { index } = this;
        if (index < this.tokens.length && this.tokens[index].startsWith("\\")) {
          const info = this.context.getDefinition(
            this.tokens[index],
            this.parseMode
          );
          if (!info || info.definitionType === "symbol")
            return false;
          if (info.ifMode && !info.ifMode.includes(this.parseMode))
            return false;
          return (_a3 = info.infix) != null ? _a3 : false;
        }
        return false;
      }
      matchColumnSeparator() {
        const { index } = this;
        if (this.tabularMode && this.tokens[index] === "&") {
          this.index++;
          return true;
        }
        return false;
      }
      matchRowSeparator() {
        const { index } = this;
        if (this.tabularMode && (this.tokens[index] === "\\\\" || this.tokens[index] === "\\cr")) {
          this.index++;
          return true;
        }
        return false;
      }
      /**
       * Return the appropriate value for a placeholder, either a default
       * one, or if a value was provided for #? via args, that value.
       */
      placeholder() {
        var _a3;
        const placeHolderArg = (_a3 = this.args) == null ? void 0 : _a3.call(this, "?");
        if (!placeHolderArg) {
          return [
            new PlaceholderAtom(this.context, {
              mode: this.parseMode,
              style: this.style
            })
          ];
        }
        return parseLatex(placeHolderArg, this.context, {
          parseMode: this.parseMode,
          mathstyle: "textstyle"
        });
      }
      matchWhitespace() {
        let found = false;
        while (this.match("<space>"))
          found = true;
        return found;
      }
      skipUntilToken(input) {
        let token = this.tokens[this.index];
        while (token && token !== input)
          token = this.tokens[++this.index];
        if (token === input)
          this.index++;
      }
      skipFiller() {
        let done = false;
        do {
          const skippedSpace = this.matchWhitespace();
          const skippedRelax = this.match("\\relax");
          done = !skippedSpace && !skippedRelax;
        } while (!done);
      }
      /**
       * Keywords are used to specify dimensions, and for various other
       * syntactic constructs.
       *
       * Unlike commands, they are not case sensitive.
       *
       * There are 25 keywords:
       *
       * at by bp cc cm dd depth em ex fil fill filll height in minus
       * mm mu pc plus pt sp spread to true width
       *
       * TeX: 8212
       * @return true if the expected keyword is present
       */
      matchKeyword(keyword) {
        const savedIndex = this.index;
        let done = this.end();
        let value = "";
        while (!done) {
          const token = this.get();
          if (isLiteral(token)) {
            value += token;
            done = this.end() || value.length >= keyword.length;
          } else
            done = true;
        }
        const hasKeyword = keyword.toUpperCase() === value.toUpperCase();
        if (!hasKeyword)
          this.index = savedIndex;
        return hasKeyword;
      }
      /**
       * Return a sequence of characters as a string.
       * i.e. 'abcd' returns 'abcd'.
       * Terminates on the first non-literal token encountered
       * e.g. '<{>', '<}>' etc...
       * Will also terminate on character literal ']'
       */
      scanString() {
        let result = "";
        while (!this.end()) {
          if (this.match("<space>"))
            result += " ";
          else {
            const token = this.peek();
            if (token === "]")
              break;
            if (isLiteral(token))
              result += this.get();
            else if (token.startsWith("\\")) {
              this.onError({ code: "unbalanced-braces" });
              result += this.get();
            } else {
              break;
            }
          }
        }
        return result;
      }
      /**
       * Return a sequence of characters as a string.
       * Terminates on a balanced closing bracket
       * This is used by the `\ce` command
       */
      scanBalancedString() {
        let result = "";
        let done = this.end();
        let level = 1;
        while (!done) {
          if (this.match("<space>"))
            result += " ";
          else {
            const token = this.get();
            if (token === "<{>") {
              result += "{";
              level += 1;
            } else if (token === "<}>") {
              level -= 1;
              if (level > 0)
                result += "}";
              else
                this.index -= 1;
            } else if (token === "<$>")
              result += "$";
            else if (token === "<$$>")
              result += "$$";
            else
              result += token;
          }
          done = level === 0 || this.end();
        }
        return result;
      }
      /**
       * Return the literal tokens, as a string, until a matching closing "}"
       */
      matchLiteralArg() {
        var _a3;
        let result = "";
        if (this.match("<{>")) {
          let depth = 1;
          while (depth > 0 && !this.end()) {
            const token = this.get();
            if (token === "<}>") {
              depth -= 1;
              if (depth > 0) {
                result += "}";
              }
            } else if (token === "<{>") {
              depth += 1;
              result += "{";
            } else {
              result += (_a3 = {
                "<space>": " ",
                "<$$>": "$$",
                "<$>": "$"
              }[token]) != null ? _a3 : token;
            }
          }
        }
        return result;
      }
      /**
       * Return as a number a group of characters representing a
       * numerical quantity.
       *
       * From TeX:8695 (scan_int):
       * > An integer number can be preceded by any number of spaces and `+' or
       * > `-' signs. Then comes either a decimal constant (i.e., radix 10), an
       * > octal constant (i.e., radix 8, preceded by '), a hexadecimal constant
       * > (radix 16, preceded by "), an alphabetic constant (preceded by `), or
       * > an internal variable.
       */
      scanNumber(isInteger = true) {
        var _a3, _b3;
        let negative = false;
        let token = this.peek();
        while (token === "<space>" || token === "+" || token === "-") {
          this.get();
          if (token === "-")
            negative = !negative;
          token = this.peek();
        }
        isInteger = Boolean(isInteger);
        let radix = 10;
        let digits = /\d/;
        if (this.match("'")) {
          radix = 8;
          digits = /[0-7]/;
          isInteger = true;
        } else if (this.match('"') || this.match("x")) {
          radix = 16;
          digits = /[\dA-F]/;
          isInteger = true;
        } else if (this.match("`")) {
          token = this.get();
          if (token) {
            if (token.startsWith("\\") && token.length === 2)
              return (negative ? -1 : 1) * ((_a3 = token.codePointAt(1)) != null ? _a3 : 0);
            return (negative ? -1 : 1) * ((_b3 = token.codePointAt(0)) != null ? _b3 : 0);
          }
          return null;
        }
        let value = "";
        while (this.hasPattern(digits))
          value += this.get();
        if (!isInteger && (this.match(".") || this.match(","))) {
          value += ".";
          while (this.hasPattern(digits))
            value += this.get();
        }
        const result = isInteger ? Number.parseInt(value, radix) : Number.parseFloat(value);
        if (Number.isNaN(result))
          return null;
        return negative ? -result : result;
      }
      /**
       * Return a dimension
       *
       * See TeX:8831
       */
      scanDimen() {
        var _a3, _b3, _c2;
        let value = this.scanNumber(false);
        if (value === null) {
          if ((_a3 = this.peek()) == null ? void 0 : _a3.startsWith("\\"))
            value = 1;
          else
            return null;
        }
        this.matchWhitespace();
        let result;
        if (this.matchKeyword("pt"))
          result = { dimension: value, unit: "pt" };
        else if (this.matchKeyword("mm"))
          result = { dimension: value, unit: "mm" };
        else if (this.matchKeyword("cm"))
          result = { dimension: value, unit: "cm" };
        else if (this.matchKeyword("ex"))
          result = { dimension: value, unit: "ex" };
        else if (this.matchKeyword("px"))
          result = { dimension: value, unit: "px" };
        else if (this.matchKeyword("em"))
          result = { dimension: value, unit: "em" };
        else if (this.matchKeyword("bp"))
          result = { dimension: value, unit: "bp" };
        else if (this.matchKeyword("dd"))
          result = { dimension: value, unit: "dd" };
        else if (this.matchKeyword("pc"))
          result = { dimension: value, unit: "pc" };
        else if (this.matchKeyword("in"))
          result = { dimension: value, unit: "in" };
        else if (this.matchKeyword("mu"))
          result = { dimension: value, unit: "mu" };
        else {
          if ((_b3 = this.peek()) == null ? void 0 : _b3.startsWith("\\")) {
            result = (_c2 = convertToDimension(
              this.getRegister(this.get().slice(1)),
              this.context
            )) != null ? _c2 : { dimension: 0 };
            result.dimension *= value;
          } else {
            if (!this.match("\\relax")) {
              this.onError({ code: "missing-unit" });
            }
            result = { dimension: value, unit: "pt" };
          }
        }
        return result;
      }
      scanGlue() {
        const dimen = this.scanDimen();
        if (dimen === null)
          return null;
        const result = { glue: dimen };
        this.matchWhitespace();
        if (this.match("\\relax"))
          return result;
        if (this.matchKeyword("plus")) {
          this.scanDimen();
        }
        this.matchWhitespace();
        if (this.match("\\relax"))
          return result;
        this.matchWhitespace();
        if (this.matchKeyword("minus")) {
          this.scanDimen();
        }
        return result;
      }
      scanColspec() {
        this.matchWhitespace();
        const result = [];
        while (!this.end() && !(this.peek() === "<}>" || this.peek() === "]")) {
          const literal = this.get();
          if (literal === "c" || literal === "r" || literal === "l")
            result.push({ align: literal });
          else if (literal === "|")
            result.push({ separator: "solid" });
          else if (literal === ":")
            result.push({ separator: "dashed" });
          else if (literal === "@") {
            if (this.match("<{>")) {
              this.beginContext({ mode: "math" });
              result.push({
                gap: this.parse((token) => token === "<}>")
              });
              this.endContext();
            }
            if (!this.match("<}>"))
              this.onError({ code: "unbalanced-braces" });
          }
        }
        return result;
      }
      /**
       * Parse a `\(...\)` or `\[...\]` sequence
       * @return group for the sequence or null
       */
      parseModeSet() {
        let final = "";
        if (this.match("\\("))
          final = "\\)";
        if (!final && this.match("\\["))
          final = "\\]";
        if (!final)
          return null;
        this.beginContext({
          mode: "math",
          mathstyle: final === "\\)" ? "textstyle" : "displaystyle"
        });
        const result = new GroupAtom(
          this.parse((token) => token === final),
          this.context,
          {
            mathstyleName: final === "\\)" ? "textstyle" : "displaystyle",
            latexOpen: final === "\\]" ? "\\[" : "\\(",
            latexClose: final,
            boxType: "mord"
          }
        );
        if (!this.match(final))
          this.onError({ code: "unbalanced-mode-shift" });
        this.endContext();
        if (result.hasEmptyBranch("body"))
          return null;
        return result;
      }
      /**
       * Parse a `$...$` or `$$...$$` sequence
       */
      parseModeShift() {
        let final = "";
        if (this.match("<$>"))
          final = "<$>";
        if (!final && this.match("<$$>"))
          final = "<$$>";
        if (!final)
          return null;
        this.beginContext({
          mode: "math",
          mathstyle: "textstyle"
        });
        const result = new GroupAtom(
          this.parse((token) => token === final),
          this.context,
          {
            mathstyleName: final === "<$>" ? "textstyle" : "displaystyle",
            latexOpen: final === "<$>" ? "$ " : "$$ ",
            latexClose: final === "<$>" ? " $" : " $$"
          }
        );
        if (!this.match(final))
          this.onError({ code: "unbalanced-mode-shift" });
        this.endContext();
        if (result.hasEmptyBranch("body"))
          return null;
        return result;
      }
      /**
       * Parse a \begin{env}...\end{end} sequence
       */
      parseEnvironment() {
        if (!this.match("\\begin"))
          return null;
        const envName = this.parseArgument("string");
        if (!envName)
          return null;
        const def2 = getEnvironmentDefinition(envName);
        if (!def2) {
          this.onError({
            code: "unknown-environment",
            arg: envName
          });
          return null;
        }
        const args = [];
        if (def2.params) {
          for (const parameter of def2.params) {
            if (parameter.isOptional) {
              args.push(this.parseOptionalArgument(parameter.type));
            } else {
              const arg = this.parseArgument(parameter.type);
              if (!arg) {
                this.onError({
                  code: "missing-argument",
                  arg: envName
                });
              }
              args.push(arg);
            }
          }
        }
        this.beginContext({ tabular: def2.tabular });
        const array = [];
        const rowGaps = [];
        let row = [];
        let done = false;
        do {
          if (this.end()) {
            this.onError({ code: "unbalanced-environment", arg: envName });
            done = true;
          }
          if (!done && this.match("\\end")) {
            if (this.parseArgument("string") !== envName) {
              this.onError({
                code: "unbalanced-environment",
                arg: envName
              });
            }
            done = true;
          }
          if (!done) {
            if (this.matchColumnSeparator()) {
              row.push(this.mathlist);
              this.mathlist = [];
            } else if (this.matchRowSeparator()) {
              row.push(this.mathlist);
              this.mathlist = [];
              let gap = null;
              this.matchWhitespace();
              if (this.match("[")) {
                gap = this.scanDimen();
                this.matchWhitespace();
                this.match("]");
              }
              rowGaps.push(gap != null ? gap : { dimension: 0 });
              array.push(row);
              row = [];
            } else {
              this.mathlist.push(
                ...this.parse(
                  (token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"
                )
              );
            }
          }
        } while (!done);
        row.push(this.mathlist);
        if (row.length > 0)
          array.push(row);
        this.endContext();
        return def2.createAtom(this.context, envName, array, rowGaps, args);
      }
      /**
       * Parse a sequence until a group end marker, such as
       * `}`, `\end`, `&`, etc...
       *
       * Returns an array of atoms or an empty array if the sequence
       * terminates right away.
       *
       * @param done - A predicate indicating if a
       * token signals the end of an implicit group
       */
      parse(done) {
        this.beginContext();
        if (!done)
          done = (token) => token === "<}>";
        let infix = "";
        let infixInfo = null;
        let infixArgs = [];
        let prefix = null;
        const saveAtoms = this.mathlist;
        this.mathlist = [];
        while (!this.end() && !done(this.peek())) {
          if (this.hasInfixCommand() && !infix) {
            infix = this.get();
            infixInfo = this.context.getDefinition(
              infix,
              "math"
            );
            if (infixInfo)
              infixArgs = this.parseArguments(infixInfo)[1];
            prefix = this.mathlist;
            this.mathlist = [];
          } else
            this.parseToken();
        }
        let result;
        if (infix) {
          console.assert(Boolean(infixInfo));
          infixArgs.unshift(this.mathlist);
          this.mathlist = saveAtoms;
          if (prefix)
            infixArgs.unshift(prefix);
          result = [
            infixInfo.createAtom(infix, infixArgs, this.style, this.context)
          ];
        } else {
          result = this.mathlist;
          this.mathlist = saveAtoms;
        }
        this.endContext();
        return result;
      }
      /**
       * Parse a group enclosed in a pair of braces: `{...}`.
       *
       * Return either a group Atom or null if not a group.
       *
       * Return a group Atom with an empty body if an empty
       * group (i.e. `{}`).
       */
      parseGroup() {
        if (!this.match("<{>"))
          return null;
        const result = new GroupAtom(
          this.parse((token) => token === "<}>"),
          this.context,
          {
            mode: this.parseMode,
            latexOpen: "{",
            latexClose: "}"
          }
        );
        if (!this.match("<}>"))
          this.onError({ code: "unbalanced-braces" });
        return result;
      }
      scanSmartFence() {
        this.matchWhitespace();
        if (!this.match("("))
          return null;
        this.beginContext();
        let nestLevel = 1;
        while (!this.end() && nestLevel !== 0) {
          if (this.match("("))
            nestLevel += 1;
          if (this.match(")"))
            nestLevel -= 1;
          if (nestLevel !== 0)
            this.parseToken();
        }
        if (nestLevel === 0)
          this.match(")");
        const result = new LeftRightAtom("", this.mathlist, this.context, {
          leftDelim: "(",
          rightDelim: nestLevel === 0 ? ")" : "?"
        });
        this.endContext();
        return result;
      }
      /**
       * Scan a delimiter, e.g. '(', '|', '\vert', '\ulcorner'
       *
       * @return The delimiter (as a character or command) or null
       */
      scanDelim() {
        this.matchWhitespace();
        const token = this.get();
        if (!token) {
          this.onError({ code: "unexpected-end-of-string" });
          return null;
        }
        let delim = ".";
        if (token.startsWith("\\") || isLiteral(token))
          delim = token;
        const info = this.context.getDefinition(delim, "math");
        if (!info) {
          this.onError({ code: "unknown-command", arg: delim });
          return null;
        }
        if (info.definitionType === "function" && info.ifMode && !info.ifMode.includes(this.parseMode)) {
          this.onError({ code: "unexpected-delimiter", arg: delim });
          return null;
        }
        if (info.definitionType === "symbol" && (info.type === "mopen" || info.type === "mclose"))
          return delim;
        if (/^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(
          delim
        ))
          return delim;
        this.onError({ code: "unexpected-delimiter", arg: delim });
        return null;
      }
      /**
       * Parse a `/left.../right` sequence.
       *
       * Note: the `/middle` command can occur multiple times inside a
       * `/left.../right` sequence, and is handled separately.
       *
       * Return either an atom of type `"leftright"` or null
       */
      parseLeftRight() {
        var _a3;
        if (this.match("\\right") || this.match("\\mright")) {
          this.onError({ code: "unbalanced-braces" });
          return null;
        }
        let close = "\\right";
        if (!this.match("\\left")) {
          if (!this.match("\\mleft"))
            return null;
          close = "\\mright";
        }
        const leftDelim = this.scanDelim();
        if (!leftDelim)
          return null;
        this.beginContext();
        while (!this.end() && !this.match(close))
          this.parseToken();
        const body = this.mathlist;
        this.endContext();
        const rightDelim = (_a3 = this.scanDelim()) != null ? _a3 : ".";
        return new LeftRightAtom(
          close === "\\right" ? "left...right" : "mleft...mright",
          body,
          this.context,
          {
            leftDelim,
            rightDelim,
            style: this.style
          }
        );
      }
      /**
       * Parse a subscript/superscript: `^` and `_`.
       *
       * Modify the last atom accordingly, or create a new 'msubsup' carrier.
       *
       */
      parseSupSub() {
        if (this.parseMode !== "math")
          return false;
        let token = this.peek();
        if (token !== "^" && token !== "_" && token !== "'")
          return false;
        while (token === "^" || token === "_" || token === "'") {
          if (this.match("'")) {
            if (this.match("'")) {
              this.lastSubsupAtom().addChild(
                new Atom("mord", this.context, {
                  command: "\\doubleprime",
                  mode: "math",
                  value: "′′"
                  // "\u2033" displays too high
                }),
                "superscript"
              );
            } else {
              this.lastSubsupAtom().addChild(
                new Atom("mord", this.context, {
                  command: "\\prime",
                  mode: "math",
                  value: "′"
                }),
                "superscript"
              );
            }
          } else if (this.match("^") || this.match("_")) {
            const arg = this.parseArgument("math");
            if (arg) {
              this.lastSubsupAtom().addChildren(
                arg,
                token === "_" ? "subscript" : "superscript"
              );
            } else {
              this.lastSubsupAtom().createBranch(
                token === "_" ? "subscript" : "superscript"
              );
            }
          }
          token = this.peek();
        }
        return true;
      }
      /**
       * Parse a `\limits` or `\nolimits` command.
       *
       * This will change the placement of limits to be either above or below
       * (if `\limits`) or in the superscript/subscript position (if `\nolimits`).
       *
       * This overrides the calculation made for the placement, which is usually
       * dependent on the displaystyle (`textstyle` prefers `\nolimits`, while
       * `displaystyle` prefers `\limits`).
       */
      parseLimits() {
        const isLimits = this.match("\\limits");
        const isNoLimits = !isLimits && this.match("\\nolimits");
        const isDisplayLimits = !isNoLimits && !isLimits && this.match("\\displaylimits");
        if (!isLimits && !isNoLimits && !isDisplayLimits)
          return false;
        const opAtom = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
        if (opAtom === null || opAtom.type !== "mop")
          return false;
        if (isLimits) {
          opAtom.subsupPlacement = "over-under";
          opAtom.explicitSubsupPlacement = true;
          return true;
        }
        if (isNoLimits) {
          opAtom.subsupPlacement = "adjacent";
          opAtom.explicitSubsupPlacement = true;
          return true;
        }
        if (isDisplayLimits) {
          opAtom.subsupPlacement = "auto";
          opAtom.explicitSubsupPlacement = true;
          return true;
        }
        return false;
      }
      parseArguments(info) {
        if (!(info == null ? void 0 : info.params))
          return [void 0, []];
        let explicitGroup = void 0;
        const args = [];
        let i = info.infix ? 2 : 0;
        while (i < info.params.length) {
          const parameter = info.params[i];
          if (parameter.type === "rest") {
            args.push(
              this.parse(
                (token) => token === "<}>" || token === "&" || token === "\\end" || token === "\\cr" || token === "\\\\"
              )
            );
          } else if (parameter.isOptional)
            args.push(this.parseOptionalArgument(parameter.type));
          else if (parameter.type.endsWith("*")) {
            explicitGroup = parameter.type.slice(0, -1);
          } else {
            const arg = this.parseArgument(parameter.type);
            if (arg !== null)
              args.push(arg);
            else {
              this.onError({ code: "missing-argument" });
              switch (parameter.type) {
                case "number":
                  args.push(0);
                  break;
                case "dimen":
                  args.push({ dimension: 0, unit: "pt" });
                  break;
                case "glue":
                  args.push({ glue: { dimension: 0, unit: "pt" } });
                  break;
                case "string":
                case "balanced-string":
                  args.push("");
                  break;
                case "delim":
                  args.push(".");
                  break;
                case "colspec":
                  args.push("llllllllll");
                  break;
                case "auto":
                default:
                  args.push(this.placeholder());
                  break;
              }
            }
          }
          i += 1;
        }
        return [explicitGroup, args];
      }
      parseArgument(argType) {
        var _a3, _b3;
        this.skipFiller();
        if (argType === "auto")
          argType = this.parseMode;
        let result = null;
        const hasBrace = this.peek() === "<{>";
        if (!hasBrace) {
          if (argType === "delim")
            return (_a3 = this.scanDelim()) != null ? _a3 : ".";
          if (argType === "text" || argType === "math") {
            this.beginContext();
            const atom = this.parseSimpleToken();
            this.endContext();
            return atom;
          }
        }
        if (hasBrace)
          this.get();
        if (argType === "text" || argType === "math") {
          this.beginContext({ mode: argType });
          do
            this.mathlist.push(...this.parse());
          while (!this.match("<}>") && !this.end());
        } else {
          this.beginContext();
          if (argType === "string")
            result = this.scanString();
          else if (argType === "balanced-string")
            result = this.scanBalancedString();
          else if (argType === "number")
            result = this.scanNumber();
          else if (argType === "colspec")
            result = this.scanColspec();
          else if (argType === "dimen")
            result = this.scanDimen();
          else if (argType === "glue")
            result = this.scanGlue();
          else if (argType === "delim")
            result = (_b3 = this.scanDelim()) != null ? _b3 : ".";
          if (hasBrace)
            this.skipUntilToken("<}>");
          if (result === null) {
            this.endContext();
            return null;
          }
        }
        const atoms = this.mathlist;
        this.endContext();
        return result != null ? result : atoms;
      }
      parseOptionalArgument(argType) {
        var _a3, _b3;
        argType = argType === "auto" ? this.parseMode : argType;
        this.matchWhitespace();
        if (!this.match("["))
          return null;
        let result = null;
        while (!this.end() && !this.match("]")) {
          if (argType === "string")
            result = this.scanString();
          else if (argType === "number")
            result = this.scanNumber();
          else if (argType === "dimen")
            result = this.scanDimen();
          else if (argType === "glue")
            result = this.scanGlue();
          else if (argType === "colspec")
            result = this.scanColspec();
          else if (argType === "bbox") {
            const list = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
            const bboxParameter = {};
            for (const element of list) {
              const color = (_b3 = (_a3 = this.context).backgroundColorMap) == null ? void 0 : _b3.call(_a3, element);
              if (color)
                bboxParameter.backgroundcolor = color;
              else {
                const m = element.match(/^\s*([\d.]+)\s*([a-z]{2})/);
                if (m)
                  bboxParameter.padding = m[0];
                else {
                  const m2 = element.match(/^\s*border\s*:\s*(.*)/);
                  if (m2)
                    bboxParameter.border = m2[1];
                }
              }
            }
            result = bboxParameter;
          } else if (argType === "math") {
            this.beginContext({ mode: "math" });
            result = this.mathlist.concat(this.parse((token) => token === "]"));
            this.endContext();
          }
        }
        return result;
      }
      parseCommand(command) {
        var _a3, _b3, _c2, _d2, _e, _f;
        if (command === "\\placeholder") {
          const id = this.parseOptionalArgument("string");
          const defaultValue = this.parseOptionalArgument("math");
          const defaultAsString = serializeAtoms(defaultValue, {
            defaultMode: "math"
          });
          let defaultAtoms = [];
          let correctness;
          if (!correctness && defaultAsString === "correct")
            correctness = "correct";
          else if (!correctness && defaultAsString === "incorrect")
            correctness = "incorrect";
          else if (defaultAsString !== "")
            defaultAtoms = defaultValue;
          const locked = this.parseOptionalArgument("string") === "locked";
          const value = this.parseArgument("auto");
          let body;
          if (value && value.length > 0)
            body = value;
          else
            body = defaultAtoms;
          if (id) {
            return [
              new PromptAtom(
                this.context,
                id,
                correctness,
                // locked,
                locked,
                body != null ? body : defaultAtoms,
                {
                  mode: this.parseMode,
                  style: this.style
                }
              )
            ];
          }
          return [
            new PlaceholderAtom(this.context, {
              mode: this.parseMode,
              placeholderId: id,
              style: this.style
            })
          ];
        }
        let result = null;
        if (command === "\\char") {
          const initialIndex2 = this.index;
          let codepoint = Math.floor((_a3 = this.scanNumber(true)) != null ? _a3 : Number.NaN);
          if (!Number.isFinite(codepoint) || codepoint < 0 || codepoint > 1114111)
            codepoint = 10067;
          const verbatimLatex = "\\char" + tokensToString(this.tokens.slice(initialIndex2, this.index));
          result = new Atom(
            this.parseMode === "math" ? "mord" : "text",
            this.context,
            {
              command: "\\char",
              mode: this.parseMode,
              value: String.fromCodePoint(codepoint),
              serialize: (atom) => {
                var _a4;
                return (_a4 = atom.verbatimLatex) != null ? _a4 : `\\char"${atom.value.codePointAt(0).toString(16).toUpperCase()}`;
              }
            }
          );
          result.verbatimLatex = verbatimLatex;
          return [result];
        }
        if (command === "\\hskip" || command === "\\kern") {
          const width = this.scanGlue();
          if (!width)
            return null;
          return [new SpacingAtom(command, this.style, this.context, width)];
        }
        result = this.scanMacro(command);
        if (result)
          return [result];
        const info = this.context.getDefinition(command, this.parseMode);
        if (!info) {
          this.onError({ code: "unknown-command", arg: command });
          return [new ErrorAtom(command, this.context)];
        }
        const initialIndex = this.index;
        if (info.definitionType === "symbol") {
          const style = __spreadValues({}, this.style);
          if (info.variant)
            style.variant = info.variant;
          result = new Atom((_b3 = info.type) != null ? _b3 : "mop", this.context, {
            command,
            style,
            value: String.fromCodePoint(info.codepoint),
            mode: this.parseMode
          });
        } else {
          if (info.ifMode && !info.ifMode.includes(this.parseMode)) {
            return [];
          }
          const savedMode = this.parseMode;
          if (info.applyMode)
            this.parseMode = info.applyMode;
          const [deferredArg, args] = this.parseArguments(info);
          this.parseMode = savedMode;
          if (!args)
            return null;
          if (info.applyMode && !info.applyStyle && !info.createAtom)
            return args[0];
          if (info.infix) {
            this.onError({
              code: "too-many-infix-commands",
              arg: command
            });
            return null;
          }
          if (typeof info.createAtom === "function") {
            result = info.createAtom(command, args, this.style, this.context);
            if (deferredArg)
              result.body = (_c2 = this.parseArgument(deferredArg)) != null ? _c2 : void 0;
          } else if (typeof info.applyStyle === "function") {
            const style = info.applyStyle(command, args, this.context);
            const savedMode2 = this.parseMode;
            if (info.applyMode) {
              this.parseMode = info.applyMode;
            }
            if (deferredArg) {
              const saveStyle = this.style;
              this.style = __spreadValues(__spreadValues({}, this.style), style);
              const atoms = this.parseArgument(deferredArg);
              this.style = saveStyle;
              this.parseMode = savedMode2;
              return atoms;
            }
            this.style = __spreadValues(__spreadValues({}, this.style), style);
            this.parseMode = savedMode2;
          } else {
            result = new Atom("mop", this.context, {
              command: (_d2 = info.command) != null ? _d2 : command,
              style: __spreadValues({}, this.style),
              value: command,
              mode: (_e = info.applyMode) != null ? _e : this.parseMode
            });
          }
        }
        if (result instanceof Atom && result.verbatimLatex === void 0 && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(command)) {
          result.verbatimLatex = ((_f = result.command) != null ? _f : "") + tokensToString(this.tokens.slice(initialIndex, this.index));
          if (result.verbatimLatex.length === 0)
            result.verbatimLatex = void 0;
          if (result.isFunction && this.smartFence) {
            const smartFence = this.scanSmartFence();
            if (smartFence)
              return [result, smartFence];
          }
        }
        return result ? [result] : null;
      }
      parseLiteral(literal) {
        const result = Mode.createAtom(this.parseMode, literal, this.context, __spreadValues({}, this.style));
        if (!result)
          return null;
        if (result.isFunction && this.smartFence) {
          const smartFence = this.scanSmartFence();
          if (smartFence)
            return [result, smartFence];
        }
        return [result];
      }
      parseSimpleToken() {
        const token = this.get();
        if (!token)
          return null;
        if (token === "<space>") {
          if (this.parseMode === "text")
            return [new TextAtom(" ", " ", this.style, this.context)];
          return null;
        }
        if (token.startsWith("\\"))
          return this.parseCommand(token);
        if (isLiteral(token))
          return this.parseLiteral(token);
        if (token === "<}>")
          this.onError({ latex: "", code: "unbalanced-braces" });
        else {
          this.onError({
            latex: "",
            code: "unexpected-token",
            arg: token
          });
        }
        return null;
      }
      /**
       * Attempt to scan the macro name and return an atom list if successful.
       * Otherwise, it wasn't a macro.
       */
      scanMacro(macro) {
        var _a3;
        const def2 = this.context.getMacro(macro);
        if (!def2)
          return null;
        const initialIndex = this.index;
        const argCount = def2.args;
        const args = { "?": (_a3 = this.args) == null ? void 0 : _a3.call(this, "?") };
        for (let i = 1; i <= argCount; i++)
          args[i] = this.matchLiteralArg();
        return new MacroAtom(macro, this.context, {
          expand: def2.expand,
          captureSelection: def2.captureSelection,
          args: tokensToString(this.tokens.slice(initialIndex, this.index)),
          body: parseLatex(def2.def, this.context, {
            parseMode: this.parseMode,
            args: (arg) => args[arg],
            mathstyle: this.currentContext.mathstyle
          })
        });
      }
      /**
       * Make an atom for the current token or token group and
       * add it to the parser's mathlist
       */
      parseToken() {
        var _a3, _b3, _c2, _d2;
        let result = (_d2 = (_c2 = (_b3 = (_a3 = this.parseEnvironment()) != null ? _a3 : this.parseModeShift()) != null ? _b3 : this.parseModeSet()) != null ? _c2 : this.parseGroup()) != null ? _d2 : this.parseLeftRight();
        if (result === null) {
          if (this.parseSupSub())
            return true;
          if (this.parseLimits())
            return true;
          result = this.parseSimpleToken();
        }
        if (isArray2(result))
          this.mathlist.push(...result);
        else if (result)
          this.mathlist.push(result);
        return result !== null;
      }
    };
    function parseLatex(s, context, options) {
      var _a3, _b3, _c2;
      const args = (_a3 = options == null ? void 0 : options.args) != null ? _a3 : null;
      const parser = new Parser(tokenize(s, args), context, {
        args,
        mathstyle: (_b3 = options == null ? void 0 : options.mathstyle) != null ? _b3 : "displaystyle",
        parseMode: (_c2 = options == null ? void 0 : options.parseMode) != null ? _c2 : "math"
      });
      const atoms = [];
      while (!parser.end())
        atoms.push(...parser.parse());
      return atoms;
    }
    function validateLatex(s, context, options) {
      var _a3;
      const parser = new Parser(tokenize(s, null), context, {
        args: null,
        mathstyle: "displaystyle",
        parseMode: (_a3 = options == null ? void 0 : options.parseMode) != null ? _a3 : "math"
      });
      while (!parser.end())
        parser.parse();
      return parser.errors;
    }
    function convertToGlue(value, context) {
      if (typeof value === "object" && "glue" in value)
        return value;
      if (typeof value === "object" && "dimension" in value)
        return { glue: value };
      if (typeof value === "number")
        return { glue: { dimension: value } };
      const parser = new Parser(tokenize(value), context, {});
      return parser.scanGlue();
    }
    function convertToDimension(value, context) {
      if (typeof value === "number")
        return { dimension: value, unit: "pt" };
      if (typeof value === "object" && "glue" in value)
        value = value.glue;
      if (typeof value === "object" && "dimension" in value)
        return value;
      const parser = new Parser(tokenize(value), context, {});
      return parser.scanDimen();
    }
    var EncloseAtom = class extends Atom {
      constructor(command, body, notation, context, options) {
        super("enclose", context, { command, style: options.style });
        this.body = body;
        this.backgroundcolor = options.backgroundcolor;
        if (notation.updiagonalarrow)
          notation.updiagonalstrike = false;
        if (notation.box) {
          notation.left = false;
          notation.right = false;
          notation.bottom = false;
          notation.top = false;
        }
        this.notation = notation;
        this.shadow = options.shadow;
        this.strokeWidth = options.strokeWidth;
        this.strokeStyle = options.strokeStyle;
        this.svgStrokeStyle = options.svgStrokeStyle;
        this.strokeColor = options.strokeColor;
        this.borderStyle = options.borderStyle;
        this.padding = options.padding;
        this.captureSelection = true;
      }
      static fromJson(json, context) {
        console.log(json);
        return new EncloseAtom(
          json.command,
          json.body,
          json.notation,
          context,
          json
        );
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), {
          notation: this.notation,
          shadow: this.shadow,
          strokeWidth: this.strokeWidth,
          strokeStyle: this.strokeStyle,
          svgStrokeStyle: this.svgStrokeStyle,
          strokeColor: this.strokeColor,
          borderStyle: this.borderStyle,
          padding: this.padding
        });
      }
      serialize(options) {
        var _a3;
        let result = (_a3 = this.command) != null ? _a3 : "";
        if (this.command === "\\enclose") {
          result += "{" + Object.keys(this.notation).join(" ") + "}";
          let style = "";
          let sep = "";
          if (this.backgroundcolor && this.backgroundcolor !== "transparent") {
            style += sep + 'mathbackground="' + this.backgroundcolor + '"';
            sep = ",";
          }
          if (this.shadow && this.shadow !== "auto") {
            style += sep + 'shadow="' + this.shadow + '"';
            sep = ",";
          }
          if (this.strokeWidth || this.strokeStyle !== "solid") {
            style += sep + this.borderStyle;
            sep = ",";
          } else if (this.strokeColor && this.strokeColor !== "currentColor") {
            style += sep + 'mathcolor="' + this.strokeColor + '"';
            sep = ",";
          }
          if (style)
            result += `[${style}]`;
        }
        result += `{${this.bodyToLatex(options)}}`;
        return result;
      }
      render(parentContext) {
        var _a3;
        const context = new Context(parentContext, this.style);
        const base = Atom.createBox(context, this.body);
        if (!base)
          return null;
        const padding = (_a3 = convertDimensionToEm(
          this.padding && this.padding !== "auto" ? convertToDimension(this.padding, __spreadProps(__spreadValues({}, this.context), {
            registers: parentContext.registers
          })) : context.getRegisterAsDimension("fboxsep")
        )) != null ? _a3 : 0;
        const borderWidth = borderDim(this.borderStyle);
        const notation = new Box(null, { classes: "ML__notation" });
        notation.setStyle("box-sizing", "border-box");
        notation.setStyle("top", `calc(-${borderWidth} / 2 - ${padding}em)`);
        notation.setStyle("left", `calc(-${borderWidth} / 2 - ${padding}em)`);
        notation.setStyle(
          "height",
          `calc(100% + ${2 * padding}em + 2 * ${borderWidth})`
        );
        notation.height = base.height + padding;
        notation.depth = base.depth + padding;
        notation.setStyle(
          "width",
          `calc(100% + ${2 * padding}em + 2 * ${borderWidth})`
        );
        if (this.backgroundcolor)
          notation.setStyle("background-color", this.backgroundcolor);
        if (this.notation.box)
          notation.setStyle("border", this.borderStyle);
        if (this.notation.actuarial) {
          notation.setStyle("border-top", this.borderStyle);
          notation.setStyle("border-right", this.borderStyle);
        }
        if (this.notation.madruwb) {
          notation.setStyle("border-bottom", this.borderStyle);
          notation.setStyle("border-right", this.borderStyle);
        }
        if (this.notation.roundedbox) {
          notation.setStyle("border-radius", "8px");
          notation.setStyle("border", this.borderStyle);
        }
        if (this.notation.circle) {
          notation.setStyle("border-radius", "50%");
          notation.setStyle("border", this.borderStyle);
        }
        if (this.notation.top)
          notation.setStyle("border-top", this.borderStyle);
        if (this.notation.left)
          notation.setStyle("border-left", this.borderStyle);
        if (this.notation.right)
          notation.setStyle("border-right", this.borderStyle);
        if (this.notation.bottom)
          notation.setStyle("border-bottom", this.borderStyle);
        let svg = "";
        if (this.notation.horizontalstrike) {
          svg += '<line x1="3%"  y1="50%" x2="97%" y2="50%"';
          svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
          svg += ' stroke-linecap="round"';
          if (this.svgStrokeStyle)
            svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
          svg += "/>";
        }
        if (this.notation.verticalstrike) {
          svg += '<line x1="50%"  y1="3%" x2="50%" y2="97%"';
          svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
          svg += ' stroke-linecap="round"';
          if (this.svgStrokeStyle)
            svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
          svg += "/>";
        }
        if (this.notation.updiagonalstrike) {
          svg += '<line x1="3%"  y1="97%" x2="97%" y2="3%"';
          svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
          svg += ' stroke-linecap="round"';
          if (this.svgStrokeStyle)
            svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
          svg += "/>";
        }
        if (this.notation.downdiagonalstrike) {
          svg += '<line x1="3%"  y1="3%" x2="97%" y2="97%"';
          svg += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`;
          svg += ' stroke-linecap="round"';
          if (this.svgStrokeStyle)
            svg += ` stroke-dasharray="${this.svgStrokeStyle}"`;
          svg += "/>";
        }
        if (svg) {
          let svgStyle;
          if (this.shadow !== "none") {
            svgStyle = this.shadow === "auto" ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")";
          }
          addSVGOverlay(notation, svg, svgStyle);
        }
        const result = new Box([notation, base]);
        result.setStyle("position", "relative");
        result.setStyle("display", "inline");
        result.height = base.height + padding;
        result.depth = base.depth + padding;
        result.left = padding;
        result.right = padding;
        if (this.caret)
          result.caret = this.caret;
        return result.wrap(context);
      }
    };
    function borderDim(s) {
      if (!s)
        return "1px";
      const m = s.match(/([0-9][a-zA-Z\%]+)/);
      if (m === null)
        return "1px";
      return m[1];
    }
    defineFunction("enclose", "{notation:string}[style:string]{body:auto}", {
      createAtom: (command, args, style, context) => {
        var _a3;
        const options = {
          strokeColor: "currentColor",
          strokeWidth: "",
          strokeStyle: "solid",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          svgStrokeStyle: void 0,
          borderStyle: void 0,
          style
        };
        if (args[1]) {
          const styles = args[1].split(
            /,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/
          );
          for (const s of styles) {
            const shorthand = s.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
            if (shorthand) {
              options.strokeWidth = shorthand[1];
              options.strokeStyle = shorthand[2];
              options.strokeColor = shorthand[3];
            } else {
              const attribute = s.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
              if (attribute) {
                if (attribute[1] === "mathbackground")
                  options.backgroundcolor = attribute[2];
                else if (attribute[1] === "mathcolor")
                  options.strokeColor = attribute[2];
                else if (attribute[1] === "padding")
                  options.padding = attribute[2];
                else if (attribute[1] === "shadow")
                  options.shadow = attribute[2];
              }
            }
          }
          if (options.strokeStyle === "dashed")
            options.svgStrokeStyle = "5,5";
          else if (options.strokeStyle === "dotted")
            options.svgStrokeStyle = "1,5";
        }
        options.borderStyle = `${options.strokeWidth} ${options.strokeStyle} ${options.strokeColor}`;
        const notation = {};
        ((_a3 = args[0]) != null ? _a3 : "").split(/[, ]/).filter((v) => v.length > 0).forEach((x) => {
          notation[x.toLowerCase()] = true;
        });
        return new EncloseAtom(
          command,
          args[2],
          notation,
          context,
          options
        );
      }
    });
    defineFunction("cancel", "{body:auto}", {
      createAtom: (name, args, style, context) => new EncloseAtom(
        name,
        args[0],
        { updiagonalstrike: true },
        context,
        {
          strokeColor: "currentColor",
          strokeWidth: "",
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          style
        }
      )
    });
    defineFunction("bcancel", "{body:auto}", {
      createAtom: (name, args, style, context) => new EncloseAtom(
        name,
        args[0],
        { downdiagonalstrike: true },
        context,
        {
          strokeColor: "currentColor",
          strokeWidth: "",
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          style
        }
      )
    });
    defineFunction("xcancel", "{body:auto}", {
      createAtom: (name, args, style, context) => new EncloseAtom(
        name,
        args[0],
        { updiagonalstrike: true, downdiagonalstrike: true },
        context,
        {
          strokeColor: "currentColor",
          strokeWidth: "",
          strokeStyle: "solid",
          borderStyle: "1px solid currentColor",
          backgroundcolor: "transparent",
          padding: "auto",
          shadow: "auto",
          style
        }
      )
    });
    function normalizeArray(context, atom, array, colFormat) {
      let maxColCount = 0;
      for (const colSpec of colFormat)
        if ("align" in colSpec)
          maxColCount += 1;
      let colCount = 0;
      const rows = [];
      for (const row of array) {
        let colIndex2 = 0;
        colCount = Math.max(colCount, Math.min(row.length, maxColCount));
        while (colIndex2 < row.length) {
          const newRow = [];
          const lastCol = Math.min(row.length, colIndex2 + maxColCount);
          while (colIndex2 < lastCol) {
            if (row[colIndex2].length === 0)
              newRow.push([new Atom("first", context, { mode: atom.mode })]);
            else if (row[colIndex2][0].type !== "first") {
              newRow.push([
                new Atom("first", context, { mode: atom.mode }),
                ...row[colIndex2]
              ]);
            } else
              newRow.push(row[colIndex2]);
            colIndex2 += 1;
          }
          rows.push(newRow);
        }
      }
      if (rows[rows.length - 1].length === 1 && rows[rows.length - 1][0].length === 0)
        rows.pop();
      const result = [];
      for (const row of rows) {
        if (row.length !== colCount) {
          for (let i = row.length; i < colCount; i++) {
            row.push([
              new Atom("first", context, { mode: atom.mode }),
              new PlaceholderAtom(context)
            ]);
          }
        }
        result.push(row);
      }
      let rowIndex = 0;
      let colIndex = 0;
      for (const row of result) {
        colIndex = 0;
        for (const cell of row) {
          for (const element of cell) {
            element.parent = atom;
            element.treeBranch = [rowIndex, colIndex];
          }
          colIndex += 1;
        }
        rowIndex += 1;
      }
      atom.isDirty = true;
      return result;
    }
    var ArrayAtom = class extends Atom {
      constructor(context, envName, array, rowGaps, options = {}) {
        var _a3, _b3;
        super("array", context);
        this.environmentName = envName;
        this.rowGaps = rowGaps;
        if (options.mathstyleName)
          this.mathstyleName = options.mathstyleName;
        if (options.columns) {
          if (options.columns.length === 0)
            this.colFormat = [{ align: "l" }];
          else
            this.colFormat = options.columns;
        }
        if (!this.colFormat) {
          this.colFormat = [
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" },
            { align: "l" }
          ];
        }
        this.array = normalizeArray(context, this, array, this.colFormat);
        if (options.leftDelim)
          this.leftDelim = options.leftDelim;
        if (options.rightDelim)
          this.rightDelim = options.rightDelim;
        if (options.jot !== void 0)
          this.jot = options.jot;
        if (options.arraycolsep)
          this.arraycolsep = options.arraycolsep;
        this.colSeparationType = options.colSeparationType;
        this.arraystretch = (_a3 = options.arraystretch) != null ? _a3 : 1;
        this.minColumns = (_b3 = options.minColumns) != null ? _b3 : 1;
      }
      static fromJson(json, context) {
        return new ArrayAtom(
          context,
          json.environmentName,
          json.array,
          json.rowGaps,
          json
        );
      }
      toJson() {
        const result = __spreadProps(__spreadValues({}, super.toJson()), {
          environmentName: this.environmentName,
          array: this.array.map(
            (row) => row.map((col) => col.map((x) => x.toJson()))
          ),
          rowGaps: this.rowGaps,
          columns: this.colFormat,
          colSeparationType: this.colSeparationType
        });
        if (this.arraystretch !== 1)
          result.arraystretch = this.arraystretch;
        if (this.arraycolsep)
          result.arraycolsep = this.arraycolsep;
        if (this.leftDelim)
          result.leftDelim = this.leftDelim;
        if (this.rightDelim)
          result.rightDelim = this.rightDelim;
        if (this.jot !== void 0)
          result.jot = this.jot;
        return result;
      }
      branch(cell) {
        var _a3;
        if (!isCellBranch(cell))
          return void 0;
        return (_a3 = this.array[cell[0]][cell[1]]) != null ? _a3 : void 0;
      }
      get branches() {
        const result = super.branches;
        this.array.forEach((_, col) => {
          this.array[col].forEach((_2, row) => {
            if (this.array[col][row])
              result.push([col, row]);
          });
        });
        return result;
      }
      createBranch(cell) {
        var _a3;
        if (!isCellBranch(cell))
          return [];
        this.isDirty = true;
        return (_a3 = this.branch(cell)) != null ? _a3 : [];
      }
      get rowCount() {
        return this.array.length;
      }
      get colCount() {
        return this.array[0].length;
      }
      get maxColumns() {
        return this.colFormat.filter((col) => Boolean(col["align"])).length;
      }
      removeBranch(name) {
        if (isNamedBranch(name))
          return super.removeBranch(name);
        const children = this.branch(name);
        this.array[name[0]][name[1]] = void 0;
        children.forEach((x) => {
          x.parent = void 0;
          x.treeBranch = void 0;
        });
        console.assert(children[0].type === "first");
        children.shift();
        this.isDirty = true;
        return children;
      }
      get hasChildren() {
        return this.children.length > 0;
      }
      get children() {
        const result = [];
        for (const row of this.array) {
          for (const cell of row) {
            if (cell) {
              for (const atom of cell) {
                result.push(...atom.children);
                result.push(atom);
              }
            }
          }
        }
        return [...result, ...super.children];
      }
      render(context) {
        var _a3, _b3, _c2, _d2, _e;
        const innerContext = new Context(context, this.style, this.mathstyleName);
        const arrayRuleWidth = innerContext.getRegisterAsEm("arrayrulewidth");
        const arrayColSep = innerContext.getRegisterAsEm("arraycolsep");
        const doubleRuleSep = innerContext.getRegisterAsEm("doublerulesep");
        const arraystretch = (_a3 = this.arraystretch) != null ? _a3 : 1;
        let arraycolsep = typeof this.arraycolsep === "number" ? this.arraycolsep : arrayColSep;
        if (this.colSeparationType === "small") {
          const localMultiplier = new Context(context, void 0, "scriptstyle").scalingFactor;
          arraycolsep = 0.2778 * (localMultiplier / context.scalingFactor);
        }
        const arrayskip = arraystretch * BASELINE_SKIP;
        const arstrutHeight = 0.7 * arrayskip;
        const arstrutDepth = 0.3 * arrayskip;
        let totalHeight = 0;
        const body = [];
        let nc = 0;
        const nr = this.array.length;
        for (let r = 0; r < nr; ++r) {
          const inrow = this.array[r];
          nc = Math.max(nc, inrow.length);
          const cellContext = new Context(
            innerContext,
            this.style,
            this.mathstyleName
          );
          let height = arstrutHeight / cellContext.scalingFactor;
          let depth = arstrutDepth / cellContext.scalingFactor;
          const outrow = { cells: [], height: 0, depth: 0, pos: 0 };
          for (const element of inrow) {
            const elt = (_b3 = Atom.createBox(cellContext, element, { newList: true })) != null ? _b3 : new Box(null, { newList: true });
            depth = Math.max(depth, elt.depth);
            height = Math.max(height, elt.height);
            outrow.cells.push(elt);
          }
          let gap = (_c2 = convertDimensionToEm(this.rowGaps[r])) != null ? _c2 : 0;
          if (gap > 0) {
            gap += arstrutDepth;
            depth = Math.max(depth, gap);
            gap = 0;
          }
          if (this.jot !== void 0)
            depth += this.jot;
          outrow.height = height;
          outrow.depth = depth;
          totalHeight += height;
          outrow.pos = totalHeight;
          totalHeight += depth + gap;
          body.push(outrow);
        }
        const offset = totalHeight / 2 + AXIS_HEIGHT;
        const contentCols = [];
        for (let colIndex = 0; colIndex < nc; colIndex++) {
          const stack2 = [];
          for (const row of body) {
            const element = row.cells[colIndex];
            element.depth = row.depth;
            element.height = row.height;
            stack2.push({ box: element, shift: row.pos - offset });
          }
          if (stack2.length > 0)
            contentCols.push(new VBox({ individualShift: stack2 }));
        }
        const cols = [];
        let previousColContent = false;
        let previousColRule = false;
        let currentContentCol = 0;
        let firstColumn = !this.leftDelim;
        const { colFormat } = this;
        for (const colDesc of colFormat) {
          if ("align" in colDesc && currentContentCol >= contentCols.length) {
            break;
          }
          if ("align" in colDesc) {
            if (previousColContent) {
              cols.push(makeColGap(2 * arraycolsep));
            } else if (previousColRule || firstColumn) {
              cols.push(makeColGap(arraycolsep));
            }
            cols.push(
              new Box(contentCols[currentContentCol], {
                classes: "col-align-" + colDesc.align
              })
            );
            currentContentCol++;
            previousColContent = true;
            previousColRule = false;
            firstColumn = false;
          } else if ("gap" in colDesc) {
            if (typeof colDesc.gap === "number") {
              cols.push(makeColGap(colDesc.gap));
            } else {
              const col = makeColOfRepeatingElements(
                context,
                body,
                offset,
                colDesc.gap
              );
              if (col)
                cols.push(col);
            }
            previousColContent = false;
            previousColRule = false;
            firstColumn = false;
          } else if ("separator" in colDesc) {
            const separator = new Box(null, { classes: "vertical-separator" });
            separator.setStyle("height", totalHeight, "em");
            separator.setStyle(
              "border-right",
              `${arrayRuleWidth}em ${colDesc.separator} currentColor`
            );
            separator.setStyle("vertical-align", -(totalHeight - offset), "em");
            let gap = 0;
            if (previousColRule)
              gap = doubleRuleSep - arrayRuleWidth;
            else if (previousColContent)
              gap = arraycolsep - arrayRuleWidth;
            separator.left = gap;
            cols.push(separator);
            previousColContent = false;
            previousColRule = true;
            firstColumn = false;
          }
        }
        if (previousColContent && !this.rightDelim) {
          cols.push(makeColGap(arraycolsep));
        }
        const inner = new Box(cols, { classes: "mtable" });
        if ((!this.leftDelim || this.leftDelim === ".") && (!this.rightDelim || this.rightDelim === ".")) {
          if (this.caret)
            inner.caret = this.caret;
          return inner;
        }
        const innerHeight = inner.height;
        const innerDepth = inner.depth;
        const result = this.bind(
          context,
          new Box(
            [
              this.bind(
                context,
                makeLeftRightDelim(
                  "mopen",
                  (_d2 = this.leftDelim) != null ? _d2 : ".",
                  innerHeight,
                  innerDepth,
                  innerContext
                )
              ),
              inner,
              this.bind(
                context,
                makeLeftRightDelim(
                  "mclose",
                  (_e = this.rightDelim) != null ? _e : ".",
                  innerHeight,
                  innerDepth,
                  innerContext
                )
              )
            ],
            { type: "mord" }
          )
        );
        if (!result)
          return null;
        if (this.caret)
          result.caret = this.caret;
        return this.attachSupsub(context, { base: result });
      }
      serialize(options) {
        let result = "\\begin{" + this.environmentName + "}";
        if (this.environmentName === "array") {
          result += "{";
          if (this.colFormat !== void 0) {
            for (const format of this.colFormat) {
              if ("align" in format)
                result += format.align;
              else if ("separator" in format && format.separator === "solid")
                result += "|";
              else if ("separator" in format && format.separator === "dashed")
                result += ":";
            }
          }
          result += "}";
        }
        for (let row = 0; row < this.array.length; row++) {
          for (let col = 0; col < this.array[row].length; col++) {
            if (col > 0)
              result += " & ";
            result = joinLatex([
              result,
              Atom.serialize(this.array[row][col], options)
            ]);
          }
          if (row < this.array.length - 1)
            result += " \\\\ ";
        }
        result += "\\end{" + this.environmentName + "}";
        return result;
      }
      getCell(row, col) {
        return this.array[row][col];
      }
      setCell(row, column, value) {
        console.assert(
          this.type === "array" && Array.isArray(this.array) && this.array[row][column] !== void 0
        );
        for (const atom of this.array[row][column]) {
          atom.parent = void 0;
          atom.treeBranch = void 0;
        }
        let atoms = value;
        if (value.length === 0 || value[0].type !== "first")
          atoms = [new Atom("first", this.context, { mode: this.mode }), ...value];
        this.array[row][column] = atoms;
        for (const atom of atoms) {
          atom.parent = this;
          atom.treeBranch = [row, column];
        }
        this.isDirty = true;
      }
      addRowBefore(row) {
        console.assert(this.type === "array" && Array.isArray(this.array));
        const newRow = [];
        for (let i = 0; i < this.colCount; i++)
          newRow.push(makePlaceholderCell(this));
        this.array.splice(row, 0, newRow);
        for (let i = row; i < this.rowCount; i++) {
          for (let j = 0; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      addRowAfter(row) {
        console.assert(this.type === "array" && Array.isArray(this.array));
        const newRow = [];
        for (let i = 0; i < this.colCount; i++)
          newRow.push(makePlaceholderCell(this));
        this.array.splice(row + 1, 0, newRow);
        for (let i = row + 1; i < this.rowCount; i++) {
          for (let j = 0; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      removeRow(row) {
        console.assert(
          this.type === "array" && Array.isArray(this.array) && this.rowCount > row
        );
        const deleted = this.array.splice(row, 1);
        for (const column of deleted) {
          for (const cell of column) {
            if (cell) {
              for (const child of cell) {
                child.parent = void 0;
                child.treeBranch = void 0;
              }
            }
          }
        }
        for (let i = row; i < this.rowCount; i++) {
          for (let j = 0; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      addColumnBefore(col) {
        console.assert(this.type === "array" && Array.isArray(this.array));
        for (const row of this.array)
          row.splice(col, 0, makePlaceholderCell(this));
        for (let i = 0; i < this.rowCount; i++) {
          for (let j = col; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      addColumnAfter(col) {
        console.assert(this.type === "array" && Array.isArray(this.array));
        for (const row of this.array)
          row.splice(col + 1, 0, makePlaceholderCell(this));
        for (let i = 0; i < this.rowCount; i++) {
          for (let j = col + 1; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      addColumn() {
        this.addColumnAfter(this.colCount - 1);
      }
      removeColumn(col) {
        console.assert(
          this.type === "array" && Array.isArray(this.array) && this.colCount > col
        );
        for (const row of this.array) {
          const deleted = row.splice(col, 1);
          for (const cell of deleted) {
            if (cell) {
              for (const child of cell) {
                child.parent = void 0;
                child.treeBranch = void 0;
              }
            }
          }
        }
        for (let i = 0; i < this.rowCount; i++) {
          for (let j = col; j < this.colCount; j++) {
            const atoms = this.array[i][j];
            if (atoms)
              for (const atom of atoms)
                atom.treeBranch = [i, j];
          }
        }
        this.isDirty = true;
      }
      get cells() {
        const result = [];
        for (const row of this.array)
          for (const cell of row)
            if (cell)
              result.push(cell);
        return result;
      }
    };
    function makePlaceholderCell(parent) {
      const first = new Atom("first", parent.context, { mode: parent.mode });
      first.parent = parent;
      const placeholder = new PlaceholderAtom(parent.context, {
        mode: parent.mode
      });
      placeholder.parent = parent;
      return [first, placeholder];
    }
    function makeColGap(width) {
      const separator = new Box(null, { classes: "arraycolsep" });
      separator.width = width;
      return separator;
    }
    function makeColOfRepeatingElements(context, rows, offset, element) {
      if (!element)
        return null;
      const col = [];
      for (const row of rows) {
        const cell = Atom.createBox(context, element, { newList: true });
        if (cell) {
          cell.depth = row.depth;
          cell.height = row.height;
          col.push({ box: cell, shift: row.pos - offset });
        }
      }
      return new VBox({ individualShift: col }).wrap(context);
    }
    defineEnvironment(
      "math",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          mathstyleName: "textstyle"
        });
      }
    );
    defineEnvironment(
      "displaymath",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          mathstyleName: "textstyle"
        });
      }
    );
    defineTabularEnvironment(
      "array",
      "{columns:colspec}",
      (context, name, array, rowGaps, args) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: args[0],
          mathstyleName: "textstyle"
        });
      }
    );
    defineTabularEnvironment(
      ["equation", "equation*", "subequations"],
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: [{ align: "c" }]
        });
      }
    );
    defineTabularEnvironment(
      "multline",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: [{ align: "m" }]
        });
      }
    );
    defineTabularEnvironment(
      ["align", "align*", "aligned", "eqnarray"],
      "",
      (context, name, array, rowGaps) => {
        let colCount = 0;
        if (isEnvironmentEmpty(array)) {
          array = [
            [
              [new Atom("first", context), new PlaceholderAtom(context)],
              [new Atom("first", context), new PlaceholderAtom(context)]
            ]
          ];
        }
        for (const row of array)
          colCount = Math.max(colCount, row.length);
        const colFormat = [
          { gap: 0 },
          { align: "r" },
          { gap: 0.25 },
          { align: "l" }
        ];
        let i = 2;
        while (i < colCount) {
          colFormat.push({ gap: 1 });
          colFormat.push({ align: "r" });
          colFormat.push({ gap: 0.25 });
          colFormat.push({ align: "l" });
          i += 2;
        }
        colFormat.push({ gap: 0 });
        return new ArrayAtom(context, name, array, rowGaps, {
          arraycolsep: 0,
          columns: colFormat,
          colSeparationType: "align",
          jot: 0.3,
          minColumns: 2
        });
      }
    );
    defineTabularEnvironment(
      "split",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [
            [
              [new Atom("first", context), new PlaceholderAtom(context)],
              [new Atom("first", context), new PlaceholderAtom(context)]
            ]
          ];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: [{ align: "r" }, { align: "l" }],
          minColumns: 2
        });
      }
    );
    defineTabularEnvironment(
      ["gather", "gathered"],
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: [{ gap: 0.25 }, { align: "c" }, { gap: 0 }],
          colSeparationType: "gather"
        });
      }
    );
    defineTabularEnvironment(
      [
        "matrix",
        "pmatrix",
        "bmatrix",
        "Bmatrix",
        "vmatrix",
        "Vmatrix",
        "matrix*",
        "pmatrix*",
        "bmatrix*",
        "Bmatrix*",
        "vmatrix*",
        "Vmatrix*"
      ],
      "[columns:colspec]",
      (context, name, array, rowGaps, args) => {
        var _a3;
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        let leftDelim = ".";
        let rightDelim = ".";
        switch (name) {
          case "pmatrix":
          case "pmatrix*":
            leftDelim = "(";
            rightDelim = ")";
            break;
          case "bmatrix":
          case "bmatrix*":
            leftDelim = "[";
            rightDelim = "]";
            break;
          case "Bmatrix":
          case "Bmatrix*":
            leftDelim = "\\lbrace";
            rightDelim = "\\rbrace";
            break;
          case "vmatrix":
          case "vmatrix*":
            leftDelim = "\\vert";
            rightDelim = "\\vert";
            break;
          case "Vmatrix":
          case "Vmatrix*":
            leftDelim = "\\Vert";
            rightDelim = "\\Vert";
            break;
          case "matrix":
          case "matrix*":
            leftDelim = ".";
            rightDelim = ".";
            break;
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          mathstyleName: "textstyle",
          leftDelim,
          rightDelim,
          columns: (_a3 = args[0]) != null ? _a3 : [
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" }
          ]
        });
      }
    );
    defineTabularEnvironment(
      ["smallmatrix", "smallmatrix*"],
      "[columns:colspec]",
      (context, name, array, rowGaps, args) => {
        var _a3;
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          mathstyleName: "scriptstyle",
          columns: (_a3 = args[0]) != null ? _a3 : [
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" },
            { align: "c" }
          ],
          colSeparationType: "small",
          arraystretch: 0.5
        });
      }
    );
    defineTabularEnvironment(
      ["cases", "dcases"],
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          mathstyleName: name === "dcases" ? "displaystyle" : "textstyle",
          arraystretch: 1.2,
          leftDelim: "\\lbrace",
          rightDelim: ".",
          columns: [{ align: "l" }, { gap: 1 }, { align: "l" }]
        });
      }
    );
    defineTabularEnvironment(
      "rcases",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          arraystretch: 1.2,
          leftDelim: ".",
          rightDelim: "\\rbrace",
          columns: [{ align: "l" }, { gap: 1 }, { align: "l" }]
        });
      }
    );
    defineEnvironment(
      "center",
      "",
      (context, name, array, rowGaps) => {
        if (isEnvironmentEmpty(array)) {
          array = [[[new Atom("first", context), new PlaceholderAtom(context)]]];
        }
        return new ArrayAtom(context, name, array, rowGaps, {
          columns: [{ align: "c" }]
        });
      }
    );
    function isEnvironmentEmpty(array) {
      for (const row of array)
        for (const col of row)
          if (col.length > 0)
            return false;
      return true;
    }
    defineFunction(
      [
        "overrightarrow",
        "overleftarrow",
        "Overrightarrow",
        "overleftharpoon",
        "overrightharpoon",
        "overleftrightarrow",
        "overlinesegment",
        "overgroup"
      ],
      "{:auto}",
      {
        createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
          body: args[0],
          skipBoundary: false,
          supsubPlacement: "over-under",
          paddedBody: true,
          boxType: "mrel",
          style,
          // Set the "svgAbove" to the name of a SVG object (which is the same
          // as the command name)
          svgAbove: command.slice(1)
        })
      }
    );
    defineFunction("overbrace", "{:auto}", {
      createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
        body: args[0],
        skipBoundary: false,
        supsubPlacement: "over-under",
        paddedBody: true,
        boxType: "mord",
        style,
        svgAbove: command.slice(1)
      })
    });
    defineFunction(
      [
        "underrightarrow",
        "underleftarrow",
        "underleftrightarrow",
        "underlinesegment",
        "undergroup"
      ],
      "{:auto}",
      {
        createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
          body: args[0],
          skipBoundary: false,
          supsubPlacement: "over-under",
          paddedBody: true,
          boxType: "mrel",
          style,
          // Set the "svgBelow" to the name of a SVG object (which is the same
          // as the command name)
          svgBelow: command.slice(1)
        })
      }
    );
    defineFunction(["underbrace"], "{:auto}", {
      createAtom: (command, args, style, context) => new OverunderAtom(command, context, {
        body: args[0],
        skipBoundary: false,
        supsubPlacement: "over-under",
        paddedBody: true,
        boxType: "mord",
        style,
        svgBelow: command.slice(1)
      })
    });
    defineFunction(
      [
        "xrightarrow",
        "xleftarrow",
        "xRightarrow",
        "xLeftarrow",
        "xleftharpoonup",
        "xleftharpoondown",
        "xrightharpoonup",
        "xrightharpoondown",
        "xlongequal",
        "xtwoheadleftarrow",
        "xtwoheadrightarrow",
        "xleftrightarrow",
        "xLeftrightarrow",
        "xrightleftharpoons",
        "xleftrightharpoons",
        "xhookleftarrow",
        "xhookrightarrow",
        "xmapsto",
        "xtofrom",
        "xrightleftarrows",
        // From mhchem.sty package
        "xrightequilibrium",
        // From mhchem.sty package
        "xleftequilibrium"
        // From mhchem.sty package
      ],
      "[:auto]{:auto}",
      {
        createAtom: (command, args, style, context) => {
          var _a3, _b3;
          return new OverunderAtom(command, context, {
            style,
            // Set the "svgBody" to the name of a SVG object (which is the same
            // as the command name)
            svgBody: command.slice(1),
            // The overscript is optional, i.e. `\xtofrom` is valid
            above: ((_a3 = args[1]) == null ? void 0 : _a3.length) === 0 ? void 0 : args[1],
            below: (_b3 = args[0]) != null ? _b3 : null,
            skipBoundary: false,
            supsubPlacement: "over-under",
            paddedBody: true,
            paddedLabels: true,
            boxType: "mrel",
            serialize: (atom, options) => command + (!atom.hasEmptyBranch("below") ? `[${atom.belowToLatex(options)}]` : "") + `{${atom.aboveToLatex(options)}}${atom.supsubToLatex(options)}`
          });
        }
      }
    );
    var OperatorAtom = class extends Atom {
      constructor(command, symbol, context, options) {
        var _a3, _b3, _c2, _d2;
        super((_a3 = options.type) != null ? _a3 : "mop", context, {
          command,
          style: options.style,
          isFunction: options == null ? void 0 : options.isFunction
        });
        if (typeof symbol === "string")
          this.value = symbol;
        else
          this.body = symbol;
        this.captureSelection = (_b3 = options.captureSelection) != null ? _b3 : false;
        this.hasArgument = (_c2 = options.hasArgument) != null ? _c2 : false;
        this.variant = options == null ? void 0 : options.variant;
        this.variantStyle = options == null ? void 0 : options.variantStyle;
        this.subsupPlacement = options == null ? void 0 : options.limits;
        this.isExtensibleSymbol = (_d2 = options == null ? void 0 : options.isExtensibleSymbol) != null ? _d2 : false;
      }
      static fromJson(json, context) {
        return new OperatorAtom(
          json.command,
          json.body ? json.body : json.value,
          context,
          json
        );
      }
      toJson() {
        const result = super.toJson();
        if (this.hasArgument)
          result.hasArgument = true;
        if (this.variant)
          result.variant = this.variant;
        if (this.variantStyle)
          result.variantStyle = this.variantStyle;
        if (this.subsupPlacement)
          result.limits = this.subsupPlacement;
        if (this.isExtensibleSymbol)
          result.isExtensibleSymbol = true;
        if (this.value)
          result.symbol = this.value;
        return result;
      }
      render(context) {
        var _a3;
        let base;
        let baseShift = 0;
        let slant = 0;
        if (this.isExtensibleSymbol) {
          const large = context.isDisplayStyle && this.value !== "\\smallint";
          base = new Box(this.value, {
            fontFamily: large ? "Size2-Regular" : "Size1-Regular",
            classes: "op-symbol " + (large ? "large-op" : "small-op"),
            type: "mop",
            maxFontSize: context.scalingFactor
          });
          if (!base)
            return null;
          base.right = base.italic;
          baseShift = (base.height - base.depth) / 2 - AXIS_HEIGHT * context.scalingFactor;
          slant = base.italic;
          base.setStyle("color", this.style.color);
          base.setStyle("background-color", this.style.backgroundColor);
        } else if (this.body) {
          base = Atom.createBox(context, this.body, { newList: true });
          if (!base)
            return null;
          base.setStyle("color", this.style.color);
          base.setStyle("background-color", this.style.backgroundColor);
        } else {
          console.assert(this.type === "mop");
          base = new Box(this.value, {
            type: "mop",
            mode: "math",
            maxFontSize: context.scalingFactor,
            style: {
              color: this.style.color,
              backgroundColor: this.style.backgroundColor,
              letterShapeStyle: context.letterShapeStyle,
              variant: this.variant,
              variantStyle: this.variantStyle
            }
          });
        }
        if (this.isExtensibleSymbol)
          base.setTop(baseShift);
        let result = base;
        if (this.superscript || this.subscript) {
          const limits = (_a3 = this.subsupPlacement) != null ? _a3 : "auto";
          result = limits === "over-under" || limits === "auto" && context.isDisplayStyle ? this.attachLimits(context, { base, baseShift, slant }) : this.attachSupsub(context, { base });
        }
        if (this.caret)
          result.caret = this.caret;
        return new Box(this.bind(context, result), {
          type: "mop",
          classes: "op-group" + (this.isSelected ? " ML__selected" : "")
        });
      }
      serialize(options) {
        if (this.value === "​")
          return this.supsubToLatex(options);
        const result = [];
        result.push(this.command);
        if (this.hasArgument)
          result.push(`{${this.bodyToLatex(options)}}`);
        if (this.explicitSubsupPlacement) {
          if (this.subsupPlacement === "over-under")
            result.push("\\limits");
          if (this.subsupPlacement === "adjacent")
            result.push("\\nolimits");
          if (this.subsupPlacement === "auto")
            result.push("\\displaylimits");
        }
        result.push(this.supsubToLatex(options));
        return joinLatex(result);
      }
    };
    var SurdAtom = class extends Atom {
      constructor(command, context, options) {
        var _a3;
        super("surd", context, {
          command,
          mode: (_a3 = options.mode) != null ? _a3 : "math",
          style: options.style,
          displayContainsHighlight: true
        });
        this.body = options.body;
        this.above = options.index;
      }
      static fromJson(json, context) {
        return new SurdAtom(json.command, context, __spreadProps(__spreadValues({}, json), {
          index: json.above
        }));
      }
      toJson() {
        return super.toJson();
      }
      serialize(options) {
        let args = "";
        if (this.above)
          args += `[${this.aboveToLatex(options)}]`;
        args += `{${this.bodyToLatex(options)}}`;
        return this.command + args;
      }
      render(parentContext) {
        var _a3;
        const innerContext = new Context(parentContext, this.style, "cramp");
        const innerBox = (_a3 = Atom.createBox(innerContext, this.body, {
          style: this.style,
          newList: true
        })) != null ? _a3 : new Box(null);
        const factor = innerContext.scalingFactor;
        const ruleWidth = innerContext.metrics.defaultRuleThickness / factor;
        const phi = parentContext.isDisplayStyle ? X_HEIGHT : ruleWidth;
        const line = new Box(null, {
          classes: "ML__sqrt-line",
          style: this.style,
          height: ruleWidth
        });
        let lineClearance = factor * (ruleWidth + phi / 4);
        const innerTotalHeight = Math.max(
          factor * 2 * phi,
          innerBox.height + innerBox.depth
        );
        const minDelimiterHeight = innerTotalHeight + lineClearance + ruleWidth;
        const delimContext = new Context(parentContext, this.style);
        const selectClasses = this.isSelected ? " ML__selected" : "";
        const delimBox = this.bind(
          delimContext,
          new Box(
            makeCustomSizedDelim(
              "",
              "\\surd",
              minDelimiterHeight,
              false,
              delimContext,
              { classes: selectClasses }
            ),
            {
              classes: "ML__sqrt-sign" + selectClasses,
              style: this.style
            }
          )
        );
        if (!delimBox)
          return null;
        const delimDepth = delimBox.height + delimBox.depth - ruleWidth;
        if (delimDepth > innerBox.height + innerBox.depth + lineClearance) {
          lineClearance = (lineClearance + delimDepth - (innerBox.height + innerBox.depth)) / 2;
        }
        delimBox.setTop(delimBox.height - innerBox.height - lineClearance);
        const bodyBox = this.bind(
          parentContext,
          new VBox({
            firstBaseline: [
              { box: new Box(innerBox) },
              // Need to wrap the inner for proper selection bound calculation
              lineClearance - 2 * ruleWidth,
              { box: line },
              ruleWidth
            ]
          }).wrap(parentContext)
        );
        const indexBox = Atom.createBox(
          new Context(parentContext, this.style, "scriptscriptstyle"),
          this.above,
          {
            style: this.style,
            newList: true
          }
        );
        if (!indexBox) {
          const result2 = new Box([delimBox, bodyBox], {
            classes: this.containsCaret ? "ML__contains-caret" : "",
            type: "mord"
          });
          if (this.caret)
            result2.caret = this.caret;
          return this.bind(parentContext, result2.wrap(parentContext));
        }
        const indexStack = new VBox({
          shift: -0.6 * (Math.max(delimBox.height, bodyBox.height) - Math.max(delimBox.depth, bodyBox.depth)),
          children: [{ box: indexBox }]
        });
        const result = new Box(
          [new Box(indexStack, { classes: "ML__sqrt-index" }), delimBox, bodyBox],
          { type: "mord", classes: this.containsCaret ? "ML__contains-caret" : "" }
        );
        result.height = delimBox.height;
        result.depth = delimBox.depth;
        if (this.caret)
          result.caret = this.caret;
        return this.bind(parentContext, result.wrap(parentContext));
      }
    };
    var GenfracAtom = class extends Atom {
      constructor(command, above, below, context, options) {
        var _a3, _b3;
        super("genfrac", context, {
          style: options.style,
          command,
          serialize: options.serialize,
          displayContainsHighlight: true
        });
        this.above = above;
        this.below = below;
        this.hasBarLine = (_a3 = options == null ? void 0 : options.hasBarLine) != null ? _a3 : true;
        this.continuousFraction = (_b3 = options == null ? void 0 : options.continuousFraction) != null ? _b3 : false;
        this.numerPrefix = options == null ? void 0 : options.numerPrefix;
        this.denomPrefix = options == null ? void 0 : options.denomPrefix;
        this.mathstyleName = options == null ? void 0 : options.mathstyleName;
        this.leftDelim = options == null ? void 0 : options.leftDelim;
        this.rightDelim = options == null ? void 0 : options.rightDelim;
      }
      static fromJson(json, context) {
        return new GenfracAtom(
          json.command,
          json.above,
          json.below,
          context,
          json
        );
      }
      toJson() {
        const options = {};
        if (this.continuousFraction)
          options.continuousFraction = true;
        if (this.numerPrefix)
          options.numerPrefix = this.numerPrefix;
        if (this.denomPrefix)
          options.denomPrefix = this.denomPrefix;
        if (this.leftDelim)
          options.leftDelim = this.leftDelim;
        if (this.rightDelim)
          options.rightDelim = this.rightDelim;
        if (!this.hasBarLine)
          options.hasBarLine = false;
        if (this.mathstyleName)
          options.mathstyleName = this.mathstyleName;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      serialize(options) {
        return this.command + `{${this.aboveToLatex(options)}}{${this.belowToLatex(options)}}`;
      }
      // The order of the children, which is used for keyboard navigation order,
      // may be customized for fractions...
      get children() {
        if (this._children)
          return this._children;
        const result = [];
        if (this.context.fractionNavigationOrder === "numerator-denominator") {
          for (const x of this.above) {
            result.push(...x.children);
            result.push(x);
          }
          for (const x of this.below) {
            result.push(...x.children);
            result.push(x);
          }
        } else {
          for (const x of this.below) {
            result.push(...x.children);
            result.push(x);
          }
          for (const x of this.above) {
            result.push(...x.children);
            result.push(x);
          }
        }
        this._children = result;
        return result;
      }
      render(context) {
        var _a3, _b3;
        const fracContext = new Context(context, this.style, this.mathstyleName);
        const metrics = fracContext.metrics;
        const numContext = new Context(
          fracContext,
          this.style,
          this.continuousFraction ? "" : "numerator"
        );
        const numerBox = this.numerPrefix ? new Box(
          [new Box(this.numerPrefix), Atom.createBox(numContext, this.above)],
          { isTight: numContext.isTight, newList: true }
        ) : (_a3 = Atom.createBox(numContext, this.above, { newList: true })) != null ? _a3 : new Box(null, { newList: true });
        const denomContext = new Context(
          fracContext,
          this.style,
          this.continuousFraction ? "" : "denominator"
        );
        const denomBox = this.denomPrefix ? new Box([
          new Box(this.denomPrefix),
          Atom.createBox(denomContext, this.below, { newList: true })
        ]) : (_b3 = Atom.createBox(denomContext, this.below, { newList: true })) != null ? _b3 : new Box(null, { newList: true });
        const ruleWidth = this.hasBarLine ? metrics.defaultRuleThickness : 0;
        let numerShift;
        let clearance = 0;
        let denomShift;
        if (fracContext.isDisplayStyle) {
          numerShift = metrics.num1;
          clearance = ruleWidth > 0 ? 3 * ruleWidth : 7 * ruleWidth;
          denomShift = metrics.denom1;
        } else {
          if (ruleWidth > 0) {
            numerShift = metrics.num2;
            clearance = ruleWidth;
          } else {
            numerShift = metrics.num3;
            clearance = 3 * ruleWidth;
          }
          denomShift = metrics.denom2;
        }
        const classes = [];
        if (this.isSelected)
          classes.push("ML__selected");
        const numerDepth = numerBox.depth;
        const denomHeight = denomBox.height;
        let frac;
        if (ruleWidth <= 0) {
          const candidateClearance = numerShift - numerDepth - (denomHeight - denomShift);
          if (candidateClearance < clearance) {
            numerShift += (clearance - candidateClearance) / 2;
            denomShift += (clearance - candidateClearance) / 2;
          }
          frac = new VBox({
            individualShift: [
              {
                box: numerBox,
                shift: -numerShift,
                classes: [...classes, "ML__center"]
              },
              {
                box: denomBox,
                shift: denomShift,
                classes: [...classes, "ML__center"]
              }
            ]
          }).wrap(fracContext);
        } else {
          const numerLine = AXIS_HEIGHT + ruleWidth / 2;
          const denomLine = AXIS_HEIGHT - ruleWidth / 2;
          if (numerShift < clearance + numerDepth + numerLine)
            numerShift = clearance + numerDepth + numerLine;
          if (denomShift < clearance + denomHeight - denomLine)
            denomShift = clearance + denomHeight - denomLine;
          const fracLine = new Box(null, {
            classes: "ML__frac-line",
            mode: this.mode,
            style: this.style
          });
          fracLine.height = ruleWidth / 2;
          fracLine.depth = ruleWidth / 2;
          frac = new VBox({
            individualShift: [
              {
                box: denomBox,
                shift: denomShift,
                classes: [...classes, "ML__center"]
              },
              { box: fracLine, shift: -denomLine + ruleWidth / 2, classes },
              {
                box: numerBox,
                shift: -numerShift,
                classes: [...classes, "ML__center"]
              }
            ]
          }).wrap(fracContext);
        }
        const delimSize = fracContext.isDisplayStyle ? metrics.delim1 : metrics.delim2;
        const selectClasses = this.isSelected ? " ML__selected" : "";
        const leftDelim = this.leftDelim ? this.bind(
          context,
          makeCustomSizedDelim(
            "mopen",
            this.leftDelim,
            delimSize,
            true,
            context,
            { style: this.style, mode: this.mode, classes: selectClasses }
          )
        ) : makeNullDelimiter(fracContext, "mopen");
        let rightDelim = null;
        if (this.continuousFraction) {
          rightDelim = new Box(null, { type: "mclose" });
        } else if (!this.rightDelim)
          rightDelim = makeNullDelimiter(fracContext, "mclose");
        else {
          rightDelim = this.bind(
            context,
            makeCustomSizedDelim(
              "mclose",
              this.rightDelim,
              delimSize,
              true,
              context,
              { style: this.style, mode: this.mode, classes: selectClasses }
            )
          );
        }
        const result = this.bind(
          context,
          new Box([leftDelim, frac, rightDelim], {
            isTight: fracContext.isTight,
            type: "mord",
            classes: "mfrac"
          })
        );
        if (!result)
          return null;
        if (this.caret)
          result.caret = this.caret;
        return this.attachSupsub(context, { base: result });
      }
    };
    var DelimAtom = class extends Atom {
      constructor(command, delim, context, options) {
        super("delim", context, { command, style: options == null ? void 0 : options.style });
        this.value = delim;
        this.size = options == null ? void 0 : options.size;
      }
      static fromJson(json, context) {
        return new DelimAtom(json.command, json.delim, context, json);
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), { delim: this.value, size: this.size });
      }
      render(_context) {
        const box = new Box(null);
        box.delim = this.value;
        return box;
      }
      serialize(_options) {
        if (this.value.length === 1)
          return this.command + this.value;
        return `${this.command}{${this.value}}`;
      }
    };
    var SizedDelimAtom = class extends Atom {
      constructor(command, delim, context, options) {
        super("sizeddelim", context, { command, style: options.style });
        this.value = delim;
        this.delimClass = options.delimClass;
        this.size = options.size;
      }
      static fromJson(json, context) {
        return new SizedDelimAtom(json.command, json.delim, context, json);
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), {
          delim: this.value,
          size: this.size,
          delimClass: this.delimClass
        });
      }
      render(context) {
        let result = makeSizedDelim(this.value, this.size, context, {
          classes: this.delimClass
        });
        if (!result)
          return null;
        result = this.bind(context, result);
        if (this.caret)
          result.caret = this.caret;
        return result;
      }
      serialize(_options) {
        if (this.value.length === 1)
          return this.command + this.value;
        return `${this.command}{${this.value}}`;
      }
    };
    defineFunction(
      [
        "arccos",
        "arcsin",
        "arctan",
        "arctg",
        // Not LaTeX standard. Used in France
        "arcctg",
        // Not LaTeX standard. Used in France
        "arg",
        "ch",
        // Not LaTeX standard. \cosh
        "cos",
        "cosh",
        "cot",
        "cotg",
        // Not LaTeX standard. Used in France
        "coth",
        "ctg",
        // Not LaTeX standard. Used in France
        "cth",
        "csc",
        // Not LaTeX standard. \cth
        "cosec",
        // Not LaTeX standard.
        "dim",
        "exp",
        "hom",
        "inf",
        "ker",
        "lb",
        // Not LaTeX standard. US Dept of Commerce recommendation for log2
        "lg",
        // Not LaTeX standard. In German and Russian literature,  log10.
        // Sometimes used as the log2
        "ln",
        "log",
        "Pr",
        "sec",
        "sh",
        // Not LaTeX standard. \sinh
        "sin",
        "sinh",
        "sup",
        "tan",
        "tanh",
        "tg",
        // Not LaTeX standard. Used in France
        "th",
        // Not LaTeX standard. \tanh
        "arcsec",
        "arccsc",
        "arsinh",
        "arcosh",
        "artanh",
        "arcsech",
        "arccsch"
      ],
      "",
      {
        isFunction: true,
        createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
          limits: "adjacent",
          isFunction: true,
          variant: "main",
          variantStyle: "up",
          style
        })
      }
    );
    defineFunction(["liminf", "limsup"], "", {
      createAtom: (command, _args, style, context) => new OperatorAtom(
        command,
        { "\\liminf": "lim inf", "\\limsup": "lim sup" }[command],
        context,
        {
          limits: "over-under",
          variant: "main",
          style
        }
      )
    });
    defineFunction(["lim", "mod"], "", {
      createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
        limits: "over-under",
        variant: "main",
        style
      })
    });
    defineFunction(["det", "max", "min"], "", {
      isFunction: true,
      createAtom: (command, _args, style, context) => new OperatorAtom(command, command.slice(1), context, {
        limits: "over-under",
        isFunction: true,
        variant: "main",
        style
      })
    });
    defineFunction(["ang"], "{:math}", {
      isFunction: true,
      createAtom: (_command, args, style, context) => new GroupAtom(
        [
          ...args[0],
          new Atom("mord", context, { value: "°", style })
        ],
        context,
        {
          mode: "math",
          latexOpen: "\\ang{",
          latexClose: "}",
          style
        }
      )
    });
    defineFunction("sqrt", "[index:auto]{radicand:auto}", {
      createAtom: (command, args, style, context) => new SurdAtom(command, context, {
        body: args[1],
        index: args[0],
        style
      })
    });
    defineFunction(
      ["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"],
      "{numerator}{denominator}",
      {
        createAtom: (command, args, style, context) => {
          const options = { style };
          switch (command) {
            case "\\dfrac":
            case "\\frac":
            case "\\tfrac":
              options.hasBarLine = true;
              break;
            case "\\atopfrac":
              options.hasBarLine = false;
              break;
            case "\\dbinom":
            case "\\binom":
            case "\\tbinom":
              options.hasBarLine = false;
              options.leftDelim = "(";
              options.rightDelim = ")";
              break;
          }
          switch (command) {
            case "\\dfrac":
            case "\\dbinom":
              options.mathstyleName = "displaystyle";
              break;
            case "\\tfrac":
            case "\\tbinom":
              options.mathstyleName = "textstyle";
              break;
            case "\\cfrac":
              options.hasBarLine = true;
              options.continuousFraction = true;
              break;
          }
          return new GenfracAtom(
            command,
            args[0],
            args[1],
            context,
            options
          );
        }
      }
    );
    defineFunction(["brace", "brack"], "", {
      infix: true,
      createAtom: (command, args, style, context) => new GenfracAtom(command, args[0], args[1], context, {
        hasBarLine: false,
        leftDelim: command === "\\brace" ? "\\lbrace" : "\\lbrack",
        rightDelim: command === "\\brace" ? "\\rbrace" : "\\rbrack",
        style,
        serialize: (atom, options) => joinLatex([
          atom.aboveToLatex(options),
          atom.command,
          atom.belowToLatex(options)
        ])
      })
    });
    defineFunction(["over", "atop", "choose"], "", {
      infix: true,
      createAtom: (command, args, style, context) => {
        let leftDelim = void 0;
        let rightDelim = void 0;
        if (command === "\\choose") {
          leftDelim = "(";
          rightDelim = ")";
        }
        return new GenfracAtom(
          command,
          args[0],
          args[1],
          context,
          {
            hasBarLine: command === "\\over",
            leftDelim,
            rightDelim,
            style,
            serialize: (atom, options) => joinLatex([
              atom.aboveToLatex(options),
              atom.command,
              atom.belowToLatex(options)
            ])
          }
        );
      }
    });
    defineFunction(
      ["overwithdelims", "atopwithdelims"],
      "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}",
      {
        infix: true,
        createAtom: (name, args, style, context) => new GenfracAtom(name, args[0], args[1], context, {
          leftDelim: args[2],
          rightDelim: args[3],
          hasBarLine: false,
          style,
          serialize: (atom, options) => `${atom.aboveToLatex(options)} ${atom.command}${atom.leftDelim}${atom.rightDelim}${atom.belowToLatex(options)}`
        })
      }
    );
    defineFunction("pdiff", "{numerator}{denominator}", {
      createAtom: (command, args, style, context) => new GenfracAtom(command, args[0], args[1], context, {
        hasBarLine: true,
        numerPrefix: "∂",
        denomPrefix: "∂",
        style
      })
    });
    defineFunction(
      [
        "sum",
        "prod",
        "bigcup",
        "bigcap",
        "coprod",
        "bigvee",
        "bigwedge",
        "biguplus",
        "bigotimes",
        "bigoplus",
        "bigodot",
        "bigsqcup",
        "intop"
      ],
      "",
      {
        createAtom: (command, args, style, context) => new OperatorAtom(
          command,
          {
            coprod: "∐",
            bigvee: "⋁",
            bigwedge: "⋀",
            biguplus: "⨄",
            bigcap: "⋂",
            bigcup: "⋃",
            intop: "∫",
            prod: "∏",
            sum: "∑",
            bigotimes: "⨂",
            bigoplus: "⨁",
            bigodot: "⨀",
            bigsqcup: "⨆",
            smallint: "∫"
          }[command.slice(1)],
          context,
          {
            isExtensibleSymbol: true,
            limits: "auto",
            variant: "main",
            style
          }
        )
      }
    );
    defineFunction("smallint", "", {
      createAtom: (command, _args, style, context) => new OperatorAtom(command, "∫", context, {
        limits: "adjacent",
        isExtensibleSymbol: false,
        style,
        variant: "main"
      })
    });
    var EXTENSIBLE_SYMBOLS = {
      int: "∫",
      iint: "∬",
      iiint: "∭",
      oint: "∮",
      oiint: "∯",
      oiiint: "∰",
      intclockwise: "∱",
      varointclockwise: "∲",
      ointctrclockwise: "∳",
      intctrclockwise: "⨑",
      sqcup: "⊔",
      sqcap: "⊓",
      uplus: "⊎",
      wr: "≀",
      amalg: "⨿",
      Cap: "⋒",
      Cup: "⋓",
      doublecap: "⋒",
      doublecup: "⋓"
    };
    defineFunction(Object.keys(EXTENSIBLE_SYMBOLS), "", {
      createAtom: (command, _args, style, context) => new OperatorAtom(command, EXTENSIBLE_SYMBOLS[command.slice(1)], context, {
        limits: "adjacent",
        isExtensibleSymbol: true,
        style,
        variant: { "⋒": "ams", "⋓": "ams" }[EXTENSIBLE_SYMBOLS[command.slice(1)]]
      })
    });
    defineFunction(["Re", "Im"], "", {
      createAtom: (command, _args, style, context) => new OperatorAtom(
        command,
        { "\\Re": "ℜ", "\\Im": "ℑ" }[command],
        context,
        {
          limits: "adjacent",
          style,
          isFunction: true,
          variant: "fraktur"
        }
      )
    });
    defineFunction("middle", "{:delim}", {
      createAtom: (command, args, style, context) => new DelimAtom(command, args[0], context, { size: 1, style })
    });
    var ChemAtom = class extends Atom {
      constructor(command, arg, context) {
        super("chem", context, { command, mode: "math" });
        const tex = texify.go(
          mhchemParser.go(arg, command === "\\pu" ? "pu" : "ce"),
          false
        );
        this.body = parseLatex(tex, context);
        this.verbatimLatex = command + "{" + arg + "}";
        this.arg = arg;
        this.captureSelection = true;
      }
      static fromJson(json, context) {
        return new ChemAtom(json.command, json.arg, context);
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), { arg: this.arg });
      }
      render(context) {
        const box = Atom.createBox(context, this.body, {
          type: "chem",
          newList: true
        });
        if (this.caret)
          box.caret = this.caret;
        return this.bind(context, box);
      }
      serialize(_options) {
        return this.verbatimLatex;
      }
    };
    defineFunction(["ce", "pu"], "{chemformula:balanced-string}", {
      createAtom: (command, args, _style, context) => new ChemAtom(command, args[0], context)
    });
    var mhchemParser = {
      //
      // Parses mchem \ce syntax
      //
      // Call like
      //   go("H2O");
      //
      go: function(input, stateMachine) {
        if (!input) {
          return [];
        }
        if (stateMachine === void 0) {
          stateMachine = "ce";
        }
        var state = "0";
        var buffer2 = {};
        buffer2["parenthesisLevel"] = 0;
        input = input.replace(/\n/g, " ");
        input = input.replace(/[\u2212\u2013\u2014\u2010]/g, "-");
        input = input.replace(/[\u2026]/g, "...");
        var lastInput;
        var watchdog = 10;
        var output = [];
        while (true) {
          if (lastInput !== input) {
            watchdog = 10;
            lastInput = input;
          } else {
            watchdog--;
          }
          var machine = mhchemParser.stateMachines[stateMachine];
          var t = machine.transitions[state] || machine.transitions["*"];
          iterateTransitions:
            for (var i = 0; i < t.length; i++) {
              var matches = mhchemParser.patterns.match_(t[i].pattern, input);
              if (matches) {
                var task = t[i].task;
                for (var iA = 0; iA < task.action_.length; iA++) {
                  var o;
                  if (machine.actions[task.action_[iA].type_]) {
                    o = machine.actions[task.action_[iA].type_](
                      buffer2,
                      matches.match_,
                      task.action_[iA].option
                    );
                  } else if (mhchemParser.actions[task.action_[iA].type_]) {
                    o = mhchemParser.actions[task.action_[iA].type_](
                      buffer2,
                      matches.match_,
                      task.action_[iA].option
                    );
                  } else {
                    throw [
                      "MhchemBugA",
                      "mhchem bug A. Please report. (" + task.action_[iA].type_ + ")"
                    ];
                  }
                  mhchemParser.concatArray(output, o);
                }
                state = task.nextState || state;
                if (input.length > 0) {
                  if (!task.revisit) {
                    input = matches.remainder;
                  }
                  if (!task.toContinue) {
                    break iterateTransitions;
                  }
                } else {
                  return output;
                }
              }
            }
          if (watchdog <= 0) {
            throw ["MhchemBugU", "mhchem bug U. Please report."];
          }
        }
      },
      concatArray: function(a, b) {
        if (b) {
          if (Array.isArray(b)) {
            for (var iB = 0; iB < b.length; iB++) {
              a.push(b[iB]);
            }
          } else {
            a.push(b);
          }
        }
      },
      patterns: {
        //
        // Matching patterns
        // either regexps or function that return null or {match_:"a", remainder:"bc"}
        //
        patterns: {
          // property names must not look like integers ("2") for correct property traversal order, later on
          "empty": /^$/,
          "else": /^./,
          "else2": /^./,
          "space": /^\s/,
          "space A": /^\s(?=[A-Z\\$])/,
          "space$": /^\s$/,
          "a-z": /^[a-z]/,
          "x": /^x/,
          "x$": /^x$/,
          "i$": /^i$/,
          "letters": /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/,
          "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/,
          "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/,
          "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/,
          "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/,
          "digits": /^[0-9]+/,
          "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/,
          "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/,
          "(-)(9.,9)(e)(99)": function(input) {
            var m = input.match(
              /^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/
            );
            if (m && m[0]) {
              return {
                match_: m.splice(1),
                remainder: input.substr(m[0].length)
              };
            }
            return null;
          },
          "(-)(9)^(-9)": function(input) {
            var m = input.match(
              /^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/
            );
            if (m && m[0]) {
              return {
                match_: m.splice(1),
                remainder: input.substr(m[0].length)
              };
            }
            return null;
          },
          "state of aggregation $": function(input) {
            var a = mhchemParser.patterns.findObserveGroups(
              input,
              "",
              /^\([a-z]{1,3}(?=[\),])/,
              ")",
              ""
            );
            if (a && a.remainder.match(/^($|[\s,;\)\]\}])/)) {
              return a;
            }
            var m = input.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
            if (m) {
              return {
                match_: m[0],
                remainder: input.substr(m[0].length)
              };
            }
            return null;
          },
          "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/,
          "{[(": /^(?:\\\{|\[|\()/,
          ")]}": /^(?:\)|\]|\\\})/,
          ", ": /^[,;]\s*/,
          ",": /^[,;]/,
          ".": /^[.]/,
          ". ": /^([.\u22C5\u00B7\u2022])\s*/,
          "...": /^\.\.\.(?=$|[^.])/,
          "* ": /^([*])\s*/,
          "^{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "^{",
              "",
              "",
              "}"
            );
          },
          "^($...$)": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "^",
              "$",
              "$",
              ""
            );
          },
          "^a": /^\^([0-9]+|[^\\_])/,
          "^\\x{}{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "^",
              /^\\[a-zA-Z]+\{/,
              "}",
              "",
              "",
              "{",
              "}",
              "",
              true
            );
          },
          "^\\x{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "^",
              /^\\[a-zA-Z]+\{/,
              "}",
              ""
            );
          },
          "^\\x": /^\^(\\[a-zA-Z]+)\s*/,
          "^(-1)": /^\^(-?\d+)/,
          "'": /^'/,
          "_{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "_{",
              "",
              "",
              "}"
            );
          },
          "_($...$)": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "_",
              "$",
              "$",
              ""
            );
          },
          "_9": /^_([+\-]?[0-9]+|[^\\])/,
          "_\\x{}{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "_",
              /^\\[a-zA-Z]+\{/,
              "}",
              "",
              "",
              "{",
              "}",
              "",
              true
            );
          },
          "_\\x{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "_",
              /^\\[a-zA-Z]+\{/,
              "}",
              ""
            );
          },
          "_\\x": /^_(\\[a-zA-Z]+)\s*/,
          "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/,
          "{}": /^\{\}/,
          "{...}": function(input) {
            return mhchemParser.patterns.findObserveGroups(input, "", "{", "}", "");
          },
          "{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(input, "{", "", "", "}");
          },
          "$...$": function(input) {
            return mhchemParser.patterns.findObserveGroups(input, "", "$", "$", "");
          },
          "${(...)}$": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "${",
              "",
              "",
              "}$"
            );
          },
          "$(...)$": function(input) {
            return mhchemParser.patterns.findObserveGroups(input, "$", "", "", "$");
          },
          "=<>": /^[=<>]/,
          "#": /^[#\u2261]/,
          "+": /^\+/,
          "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/,
          // -space -, -; -] -/ -$ -state-of-aggregation
          "-9": /^-(?=[0-9])/,
          "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/,
          "-": /^-/,
          "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/,
          "operator": /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/,
          "arrowUpDown": /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/,
          "\\bond{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\bond{",
              "",
              "",
              "}"
            );
          },
          "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/,
          "CMT": /^[CMT](?=\[)/,
          "[(...)]": function(input) {
            return mhchemParser.patterns.findObserveGroups(input, "[", "", "", "]");
          },
          "1st-level escape": /^(&|\\\\|\\hline)\s*/,
          "\\,": /^(?:\\[,\ ;:])/,
          // \\x - but output no space before
          "\\x{}{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "",
              /^\\[a-zA-Z]+\{/,
              "}",
              "",
              "",
              "{",
              "}",
              "",
              true
            );
          },
          "\\x{}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "",
              /^\\[a-zA-Z]+\{/,
              "}",
              ""
            );
          },
          "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/,
          "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/,
          "orbital": /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/,
          // only those with numbers in front, because the others will be formatted correctly anyway
          "others": /^[\/~|]/,
          "\\frac{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\frac{",
              "",
              "",
              "}",
              "{",
              "",
              "",
              "}"
            );
          },
          "\\overset{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\overset{",
              "",
              "",
              "}",
              "{",
              "",
              "",
              "}"
            );
          },
          "\\underset{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\underset{",
              "",
              "",
              "}",
              "{",
              "",
              "",
              "}"
            );
          },
          "\\underbrace{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\underbrace{",
              "",
              "",
              "}_",
              "{",
              "",
              "",
              "}"
            );
          },
          "\\color{(...)}0": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\color{",
              "",
              "",
              "}"
            );
          },
          "\\color{(...)}{(...)}1": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\color{",
              "",
              "",
              "}",
              "{",
              "",
              "",
              "}"
            );
          },
          "\\color(...){(...)}2": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\color",
              "\\",
              "",
              /^(?=\{)/,
              "{",
              "",
              "",
              "}"
            );
          },
          "\\ce{(...)}": function(input) {
            return mhchemParser.patterns.findObserveGroups(
              input,
              "\\ce{",
              "",
              "",
              "}"
            );
          },
          "oxidation$": /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
          "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/,
          // 0 could be oxidation or charge
          "roman numeral": /^[IVX]+/,
          "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/,
          "amount": function(input) {
            var match;
            match = input.match(
              /^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/
            );
            if (match) {
              return {
                match_: match[0],
                remainder: input.substr(match[0].length)
              };
            }
            var a = mhchemParser.patterns.findObserveGroups(
              input,
              "",
              "$",
              "$",
              ""
            );
            if (a) {
              match = a.match_.match(
                /^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/
              );
              if (match) {
                return {
                  match_: match[0],
                  remainder: input.substr(match[0].length)
                };
              }
            }
            return null;
          },
          "amount2": function(input) {
            return this["amount"](input);
          },
          "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/,
          "formula$": function(input) {
            if (input.match(/^\([a-z]+\)$/)) {
              return null;
            }
            var match = input.match(
              /^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/
            );
            if (match) {
              return {
                match_: match[0],
                remainder: input.substr(match[0].length)
              };
            }
            return null;
          },
          "uprightEntities": /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/,
          "/": /^\s*(\/)\s*/,
          "//": /^\s*(\/\/)\s*/,
          "*": /^\s*[*.]\s*/
        },
        findObserveGroups: function(input, begExcl, begIncl, endIncl, endExcl, beg2Excl, beg2Incl, end2Incl, end2Excl, combine) {
          var _match = function(input2, pattern) {
            if (typeof pattern === "string") {
              if (input2.indexOf(pattern) !== 0) {
                return null;
              }
              return pattern;
            } else {
              var match2 = input2.match(pattern);
              if (!match2) {
                return null;
              }
              return match2[0];
            }
          };
          var _findObserveGroups = function(input2, i, endChars) {
            var braces = 0;
            while (i < input2.length) {
              var a = input2.charAt(i);
              var match2 = _match(input2.substr(i), endChars);
              if (match2 !== null && braces === 0) {
                return {
                  endMatchBegin: i,
                  endMatchEnd: i + match2.length
                };
              } else if (a === "{") {
                braces++;
              } else if (a === "}") {
                if (braces === 0) {
                  throw [
                    "ExtraCloseMissingOpen",
                    "Extra close brace or missing open brace"
                  ];
                } else {
                  braces--;
                }
              }
              i++;
            }
            if (braces > 0) {
              return null;
            }
            return null;
          };
          var match = _match(input, begExcl);
          if (match === null) {
            return null;
          }
          input = input.substr(match.length);
          match = _match(input, begIncl);
          if (match === null) {
            return null;
          }
          var e = _findObserveGroups(input, match.length, endIncl || endExcl);
          if (e === null) {
            return null;
          }
          var match1 = input.substring(
            0,
            endIncl ? e.endMatchEnd : e.endMatchBegin
          );
          if (!(beg2Excl || beg2Incl)) {
            return {
              match_: match1,
              remainder: input.substr(e.endMatchEnd)
            };
          } else {
            var group2 = this.findObserveGroups(
              input.substr(e.endMatchEnd),
              beg2Excl,
              beg2Incl,
              end2Incl,
              end2Excl
            );
            if (group2 === null) {
              return null;
            }
            var matchRet = [match1, group2.match_];
            return {
              match_: combine ? matchRet.join("") : matchRet,
              remainder: group2.remainder
            };
          }
        },
        //
        // Matching function
        // e.g. match("a", input) will look for the regexp called "a" and see if it matches
        // returns null or {match_:"a", remainder:"bc"}
        //
        match_: function(m, input) {
          var pattern = mhchemParser.patterns.patterns[m];
          if (pattern === void 0) {
            throw ["MhchemBugP", "mhchem bug P. Please report. (" + m + ")"];
          } else if (typeof pattern === "function") {
            return mhchemParser.patterns.patterns[m](input);
          } else {
            var match = input.match(pattern);
            if (match) {
              var mm;
              if (match[2]) {
                mm = [match[1], match[2]];
              } else if (match[1]) {
                mm = match[1];
              } else {
                mm = match[0];
              }
              return {
                match_: mm,
                remainder: input.substr(match[0].length)
              };
            }
            return null;
          }
        }
      },
      //
      // Generic state machine actions
      //
      actions: {
        "a=": function(buffer2, m) {
          buffer2.a = (buffer2.a || "") + m;
        },
        "b=": function(buffer2, m) {
          buffer2.b = (buffer2.b || "") + m;
        },
        "p=": function(buffer2, m) {
          buffer2.p = (buffer2.p || "") + m;
        },
        "o=": function(buffer2, m) {
          buffer2.o = (buffer2.o || "") + m;
        },
        "q=": function(buffer2, m) {
          buffer2.q = (buffer2.q || "") + m;
        },
        "d=": function(buffer2, m) {
          buffer2.d = (buffer2.d || "") + m;
        },
        "rm=": function(buffer2, m) {
          buffer2.rm = (buffer2.rm || "") + m;
        },
        "text=": function(buffer2, m) {
          buffer2.text_ = (buffer2.text_ || "") + m;
        },
        "insert": function(buffer2, m, a) {
          return { type_: a };
        },
        "insert+p1": function(buffer2, m, a) {
          return { type_: a, p1: m };
        },
        "insert+p1+p2": function(buffer2, m, a) {
          return { type_: a, p1: m[0], p2: m[1] };
        },
        "copy": function(buffer2, m) {
          return m;
        },
        "rm": function(buffer2, m) {
          return { type_: "rm", p1: m || "" };
        },
        "text": function(buffer2, m) {
          return mhchemParser.go(m, "text");
        },
        "{text}": function(buffer2, m) {
          var ret = ["{"];
          mhchemParser.concatArray(ret, mhchemParser.go(m, "text"));
          ret.push("}");
          return ret;
        },
        "tex-math": function(buffer2, m) {
          return mhchemParser.go(m, "tex-math");
        },
        "tex-math tight": function(buffer2, m) {
          return mhchemParser.go(m, "tex-math tight");
        },
        "bond": function(buffer2, m, k) {
          return { type_: "bond", kind_: k || m };
        },
        "color0-output": function(buffer2, m) {
          return { type_: "color0", color: m[0] };
        },
        "ce": function(buffer2, m) {
          return mhchemParser.go(m);
        },
        "1/2": function(buffer2, m) {
          var ret = [];
          if (m.match(/^[+\-]/)) {
            ret.push(m.substr(0, 1));
            m = m.substr(1);
          }
          var n = m.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
          n[1] = n[1].replace(/\$/g, "");
          ret.push({ type_: "frac", p1: n[1], p2: n[2] });
          if (n[3]) {
            n[3] = n[3].replace(/\$/g, "");
            ret.push({ type_: "tex-math", p1: n[3] });
          }
          return ret;
        },
        "9,9": function(buffer2, m) {
          return mhchemParser.go(m, "9,9");
        }
      },
      //
      // createTransitions
      // convert  { 'letter': { 'state': { action_: 'output' } } }  to  { 'state' => [ { pattern: 'letter', task: { action_: [{type_: 'output'}] } } ] }
      // with expansion of 'a|b' to 'a' and 'b' (at 2 places)
      //
      createTransitions: function(o) {
        var pattern, state;
        var stateArray;
        var i;
        var transitions = {};
        for (pattern in o) {
          for (state in o[pattern]) {
            stateArray = state.split("|");
            o[pattern][state].stateArray = stateArray;
            for (i = 0; i < stateArray.length; i++) {
              transitions[stateArray[i]] = [];
            }
          }
        }
        for (pattern in o) {
          for (state in o[pattern]) {
            stateArray = o[pattern][state].stateArray || [];
            for (i = 0; i < stateArray.length; i++) {
              var p2 = o[pattern][state];
              if (p2.action_) {
                p2.action_ = [].concat(p2.action_);
                for (var k = 0; k < p2.action_.length; k++) {
                  if (typeof p2.action_[k] === "string") {
                    p2.action_[k] = { type_: p2.action_[k] };
                  }
                }
              } else {
                p2.action_ = [];
              }
              var patternArray = pattern.split("|");
              for (var j = 0; j < patternArray.length; j++) {
                if (stateArray[i] === "*") {
                  for (var t in transitions) {
                    transitions[t].push({
                      pattern: patternArray[j],
                      task: p2
                    });
                  }
                } else {
                  transitions[stateArray[i]].push({
                    pattern: patternArray[j],
                    task: p2
                  });
                }
              }
            }
          }
        }
        return transitions;
      },
      stateMachines: {}
    };
    mhchemParser.stateMachines = {
      //
      // \ce state machines
      //
      //#region ce
      "ce": {
        // main parser
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "else": {
            "0|1|2": {
              action_: "beginsWithBond=false",
              revisit: true,
              toContinue: true
            }
          },
          "oxidation$": {
            "0": { action_: "oxidation-output" }
          },
          "CMT": {
            r: { action_: "rdt=", nextState: "rt" },
            rd: { action_: "rqt=", nextState: "rdt" }
          },
          "arrowUpDown": {
            "0|1|2|as": {
              action_: ["sb=false", "output", "operator"],
              nextState: "1"
            }
          },
          "uprightEntities": {
            "0|1|2": { action_: ["o=", "output"], nextState: "1" }
          },
          "orbital": {
            "0|1|2|3": { action_: "o=", nextState: "o" }
          },
          "->": {
            "0|1|2|3": { action_: "r=", nextState: "r" },
            "a|as": { action_: ["output", "r="], nextState: "r" },
            "*": { action_: ["output", "r="], nextState: "r" }
          },
          "+": {
            "o": { action_: "d= kv", nextState: "d" },
            "d|D": { action_: "d=", nextState: "d" },
            "q": { action_: "d=", nextState: "qd" },
            "qd|qD": { action_: "d=", nextState: "qd" },
            "dq": { action_: ["output", "d="], nextState: "d" },
            "3": {
              action_: ["sb=false", "output", "operator"],
              nextState: "0"
            }
          },
          "amount": {
            "0|2": { action_: "a=", nextState: "a" }
          },
          "pm-operator": {
            "0|1|2|a|as": {
              action_: [
                "sb=false",
                "output",
                { type_: "operator", option: "\\pm" }
              ],
              nextState: "0"
            }
          },
          "operator": {
            "0|1|2|a|as": {
              action_: ["sb=false", "output", "operator"],
              nextState: "0"
            }
          },
          "-$": {
            "o|q": {
              action_: ["charge or bond", "output"],
              nextState: "qd"
            },
            "d": { action_: "d=", nextState: "d" },
            "D": {
              action_: ["output", { type_: "bond", option: "-" }],
              nextState: "3"
            },
            "q": { action_: "d=", nextState: "qd" },
            "qd": { action_: "d=", nextState: "qd" },
            "qD|dq": {
              action_: ["output", { type_: "bond", option: "-" }],
              nextState: "3"
            }
          },
          "-9": {
            "3|o": {
              action_: ["output", { type_: "insert", option: "hyphen" }],
              nextState: "3"
            }
          },
          "- orbital overlap": {
            o: {
              action_: ["output", { type_: "insert", option: "hyphen" }],
              nextState: "2"
            },
            d: {
              action_: ["output", { type_: "insert", option: "hyphen" }],
              nextState: "2"
            }
          },
          "-": {
            "0|1|2": {
              action_: [
                { type_: "output", option: 1 },
                "beginsWithBond=true",
                { type_: "bond", option: "-" }
              ],
              nextState: "3"
            },
            "3": { action_: { type_: "bond", option: "-" } },
            "a": {
              action_: ["output", { type_: "insert", option: "hyphen" }],
              nextState: "2"
            },
            "as": {
              action_: [
                { type_: "output", option: 2 },
                { type_: "bond", option: "-" }
              ],
              nextState: "3"
            },
            "b": { action_: "b=" },
            "o": {
              action_: { type_: "- after o/d", option: false },
              nextState: "2"
            },
            "q": {
              action_: { type_: "- after o/d", option: false },
              nextState: "2"
            },
            "d|qd|dq": {
              action_: { type_: "- after o/d", option: true },
              nextState: "2"
            },
            "D|qD|p": {
              action_: ["output", { type_: "bond", option: "-" }],
              nextState: "3"
            }
          },
          "amount2": {
            "1|3": { action_: "a=", nextState: "a" }
          },
          "letters": {
            "0|1|2|3|a|as|b|p|bp|o": { action_: "o=", nextState: "o" },
            "q|dq": { action_: ["output", "o="], nextState: "o" },
            "d|D|qd|qD": { action_: "o after d", nextState: "o" }
          },
          "digits": {
            "o": { action_: "q=", nextState: "q" },
            "d|D": { action_: "q=", nextState: "dq" },
            "q": { action_: ["output", "o="], nextState: "o" },
            "a": { action_: "o=", nextState: "o" }
          },
          "space A": {
            "b|p|bp": {}
          },
          "space": {
            "a": { nextState: "as" },
            "0": { action_: "sb=false" },
            "1|2": { action_: "sb=true" },
            "r|rt|rd|rdt|rdq": { action_: "output", nextState: "0" },
            "*": { action_: ["output", "sb=true"], nextState: "1" }
          },
          "1st-level escape": {
            "1|2": {
              action_: [
                "output",
                { type_: "insert+p1", option: "1st-level escape" }
              ]
            },
            "*": {
              action_: [
                "output",
                { type_: "insert+p1", option: "1st-level escape" }
              ],
              nextState: "0"
            }
          },
          "[(...)]": {
            "r|rt": { action_: "rd=", nextState: "rd" },
            "rd|rdt": { action_: "rq=", nextState: "rdq" }
          },
          "...": {
            "o|d|D|dq|qd|qD": {
              action_: ["output", { type_: "bond", option: "..." }],
              nextState: "3"
            },
            "*": {
              action_: [
                { type_: "output", option: 1 },
                { type_: "insert", option: "ellipsis" }
              ],
              nextState: "1"
            }
          },
          ". |* ": {
            "*": {
              action_: ["output", { type_: "insert", option: "addition compound" }],
              nextState: "1"
            }
          },
          "state of aggregation $": {
            "*": {
              action_: ["output", "state of aggregation"],
              nextState: "1"
            }
          },
          "{[(": {
            "a|as|o": {
              action_: ["o=", "output", "parenthesisLevel++"],
              nextState: "2"
            },
            "0|1|2|3": {
              action_: ["o=", "output", "parenthesisLevel++"],
              nextState: "2"
            },
            "*": {
              action_: ["output", "o=", "output", "parenthesisLevel++"],
              nextState: "2"
            }
          },
          ")]}": {
            "0|1|2|3|b|p|bp|o": {
              action_: ["o=", "parenthesisLevel--"],
              nextState: "o"
            },
            "a|as|d|D|q|qd|qD|dq": {
              action_: ["output", "o=", "parenthesisLevel--"],
              nextState: "o"
            }
          },
          ", ": {
            "*": { action_: ["output", "comma"], nextState: "0" }
          },
          "^_": {
            // ^ and _ without a sensible argument
            "*": {}
          },
          "^{(...)}|^($...$)": {
            "0|1|2|as": { action_: "b=", nextState: "b" },
            "p": { action_: "b=", nextState: "bp" },
            "3|o": { action_: "d= kv", nextState: "D" },
            "q": { action_: "d=", nextState: "qD" },
            "d|D|qd|qD|dq": { action_: ["output", "d="], nextState: "D" }
          },
          "^a|^\\x{}{}|^\\x{}|^\\x|'": {
            "0|1|2|as": { action_: "b=", nextState: "b" },
            "p": { action_: "b=", nextState: "bp" },
            "3|o": { action_: "d= kv", nextState: "d" },
            "q": { action_: "d=", nextState: "qd" },
            "d|qd|D|qD": { action_: "d=" },
            "dq": { action_: ["output", "d="], nextState: "d" }
          },
          "_{(state of aggregation)}$": {
            "d|D|q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
          },
          "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": {
            "0|1|2|as": { action_: "p=", nextState: "p" },
            "b": { action_: "p=", nextState: "bp" },
            "3|o": { action_: "q=", nextState: "q" },
            "d|D": { action_: "q=", nextState: "dq" },
            "q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" }
          },
          "=<>": {
            "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": {
              action_: [{ type_: "output", option: 2 }, "bond"],
              nextState: "3"
            }
          },
          "#": {
            "0|1|2|3|a|as|o": {
              action_: [
                { type_: "output", option: 2 },
                { type_: "bond", option: "#" }
              ],
              nextState: "3"
            }
          },
          "{}": {
            "*": {
              action_: { type_: "output", option: 1 },
              nextState: "1"
            }
          },
          "{...}": {
            "0|1|2|3|a|as|b|p|bp": { action_: "o=", nextState: "o" },
            "o|d|D|q|qd|qD|dq": {
              action_: ["output", "o="],
              nextState: "o"
            }
          },
          "$...$": {
            "a": { action_: "a=" },
            // 2$n$
            "0|1|2|3|as|b|p|bp|o": { action_: "o=", nextState: "o" },
            // not 'amount'
            "as|o": { action_: "o=" },
            "q|d|D|qd|qD|dq": { action_: ["output", "o="], nextState: "o" }
          },
          "\\bond{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "bond"],
              nextState: "3"
            }
          },
          "\\frac{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 1 }, "frac-output"],
              nextState: "3"
            }
          },
          "\\overset{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "overset-output"],
              nextState: "3"
            }
          },
          "\\underset{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "underset-output"],
              nextState: "3"
            }
          },
          "\\underbrace{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "underbrace-output"],
              nextState: "3"
            }
          },
          "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "color-output"],
              nextState: "3"
            }
          },
          "\\color{(...)}0": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "color0-output"]
            }
          },
          "\\ce{(...)}": {
            "*": {
              action_: [{ type_: "output", option: 2 }, "ce"],
              nextState: "3"
            }
          },
          "\\,": {
            "*": {
              action_: [{ type_: "output", option: 1 }, "copy"],
              nextState: "1"
            }
          },
          "\\x{}{}|\\x{}|\\x": {
            "0|1|2|3|a|as|b|p|bp|o|c0": {
              action_: ["o=", "output"],
              nextState: "3"
            },
            "*": { action_: ["output", "o=", "output"], nextState: "3" }
          },
          "others": {
            "*": {
              action_: [{ type_: "output", option: 1 }, "copy"],
              nextState: "3"
            }
          },
          "else2": {
            "a": { action_: "a to o", nextState: "o", revisit: true },
            "as": {
              action_: ["output", "sb=true"],
              nextState: "1",
              revisit: true
            },
            "r|rt|rd|rdt|rdq": {
              action_: ["output"],
              nextState: "0",
              revisit: true
            },
            "*": { action_: ["output", "copy"], nextState: "3" }
          }
        }),
        actions: {
          "o after d": function(buffer2, m) {
            var ret;
            if ((buffer2.d || "").match(/^[0-9]+$/)) {
              var tmp = buffer2.d;
              buffer2.d = void 0;
              ret = this["output"](buffer2);
              buffer2.b = tmp;
            } else {
              ret = this["output"](buffer2);
            }
            mhchemParser.actions["o="](buffer2, m);
            return ret;
          },
          "d= kv": function(buffer2, m) {
            buffer2.d = m;
            buffer2.dType = "kv";
          },
          "charge or bond": function(buffer2, m) {
            if (buffer2["beginsWithBond"]) {
              var ret = [];
              mhchemParser.concatArray(ret, this["output"](buffer2));
              mhchemParser.concatArray(
                ret,
                mhchemParser.actions["bond"](buffer2, m, "-")
              );
              return ret;
            } else {
              buffer2.d = m;
            }
          },
          "- after o/d": function(buffer2, m, isAfterD) {
            var c1 = mhchemParser.patterns.match_("orbital", buffer2.o || "");
            var c2 = mhchemParser.patterns.match_(
              "one lowercase greek letter $",
              buffer2.o || ""
            );
            var c3 = mhchemParser.patterns.match_(
              "one lowercase latin letter $",
              buffer2.o || ""
            );
            var c4 = mhchemParser.patterns.match_(
              "$one lowercase latin letter$ $",
              buffer2.o || ""
            );
            var hyphenFollows = m === "-" && (c1 && c1.remainder === "" || c2 || c3 || c4);
            if (hyphenFollows && !buffer2.a && !buffer2.b && !buffer2.p && !buffer2.d && !buffer2.q && !c1 && c3) {
              buffer2.o = "$" + buffer2.o + "$";
            }
            var ret = [];
            if (hyphenFollows) {
              mhchemParser.concatArray(ret, this["output"](buffer2));
              ret.push({ type_: "hyphen" });
            } else {
              c1 = mhchemParser.patterns.match_("digits", buffer2.d || "");
              if (isAfterD && c1 && c1.remainder === "") {
                mhchemParser.concatArray(
                  ret,
                  mhchemParser.actions["d="](buffer2, m)
                );
                mhchemParser.concatArray(ret, this["output"](buffer2));
              } else {
                mhchemParser.concatArray(ret, this["output"](buffer2));
                mhchemParser.concatArray(
                  ret,
                  mhchemParser.actions["bond"](buffer2, m, "-")
                );
              }
            }
            return ret;
          },
          "a to o": function(buffer2) {
            buffer2.o = buffer2.a;
            buffer2.a = void 0;
          },
          "sb=true": function(buffer2) {
            buffer2.sb = true;
          },
          "sb=false": function(buffer2) {
            buffer2.sb = false;
          },
          "beginsWithBond=true": function(buffer2) {
            buffer2["beginsWithBond"] = true;
          },
          "beginsWithBond=false": function(buffer2) {
            buffer2["beginsWithBond"] = false;
          },
          "parenthesisLevel++": function(buffer2) {
            buffer2["parenthesisLevel"]++;
          },
          "parenthesisLevel--": function(buffer2) {
            buffer2["parenthesisLevel"]--;
          },
          "state of aggregation": function(buffer2, m) {
            return {
              type_: "state of aggregation",
              p1: mhchemParser.go(m, "o")
            };
          },
          "comma": function(buffer2, m) {
            var a = m.replace(/\s*$/, "");
            var withSpace = a !== m;
            if (withSpace && buffer2["parenthesisLevel"] === 0) {
              return { type_: "comma enumeration L", p1: a };
            } else {
              return { type_: "comma enumeration M", p1: a };
            }
          },
          "output": function(buffer2, m, entityFollows) {
            var ret;
            if (!buffer2.r) {
              ret = [];
              if (!buffer2.a && !buffer2.b && !buffer2.p && !buffer2.o && !buffer2.q && !buffer2.d && !entityFollows)
                ;
              else {
                if (buffer2.sb) {
                  ret.push({ type_: "entitySkip" });
                }
                if (!buffer2.o && !buffer2.q && !buffer2.d && !buffer2.b && !buffer2.p && entityFollows !== 2) {
                  buffer2.o = buffer2.a;
                  buffer2.a = void 0;
                } else if (!buffer2.o && !buffer2.q && !buffer2.d && (buffer2.b || buffer2.p)) {
                  buffer2.o = buffer2.a;
                  buffer2.d = buffer2.b;
                  buffer2.q = buffer2.p;
                  buffer2.a = buffer2.b = buffer2.p = void 0;
                } else {
                  if (buffer2.o && buffer2.dType === "kv" && mhchemParser.patterns.match_("d-oxidation$", buffer2.d || "")) {
                    buffer2.dType = "oxidation";
                  } else if (buffer2.o && buffer2.dType === "kv" && !buffer2.q) {
                    buffer2.dType = void 0;
                  }
                }
                ret.push({
                  type_: "chemfive",
                  a: mhchemParser.go(buffer2.a, "a"),
                  b: mhchemParser.go(buffer2.b, "bd"),
                  p: mhchemParser.go(buffer2.p, "pq"),
                  o: mhchemParser.go(buffer2.o, "o"),
                  q: mhchemParser.go(buffer2.q, "pq"),
                  d: mhchemParser.go(
                    buffer2.d,
                    buffer2.dType === "oxidation" ? "oxidation" : "bd"
                  ),
                  dType: buffer2.dType
                });
              }
            } else {
              var rd;
              if (buffer2.rdt === "M") {
                rd = mhchemParser.go(buffer2.rd, "tex-math");
              } else if (buffer2.rdt === "T") {
                rd = [{ type_: "text", p1: buffer2.rd || "" }];
              } else {
                rd = mhchemParser.go(buffer2.rd);
              }
              var rq;
              if (buffer2.rqt === "M") {
                rq = mhchemParser.go(buffer2.rq, "tex-math");
              } else if (buffer2.rqt === "T") {
                rq = [{ type_: "text", p1: buffer2.rq || "" }];
              } else {
                rq = mhchemParser.go(buffer2.rq);
              }
              ret = {
                type_: "arrow",
                r: buffer2.r,
                rd,
                rq
              };
            }
            for (var p2 in buffer2) {
              if (p2 !== "parenthesisLevel" && p2 !== "beginsWithBond") {
                delete buffer2[p2];
              }
            }
            return ret;
          },
          "oxidation-output": function(buffer2, m) {
            var ret = ["{"];
            mhchemParser.concatArray(ret, mhchemParser.go(m, "oxidation"));
            ret.push("}");
            return ret;
          },
          "frac-output": function(buffer2, m) {
            return {
              type_: "frac-ce",
              p1: mhchemParser.go(m[0]),
              p2: mhchemParser.go(m[1])
            };
          },
          "overset-output": function(buffer2, m) {
            return {
              type_: "overset",
              p1: mhchemParser.go(m[0]),
              p2: mhchemParser.go(m[1])
            };
          },
          "underset-output": function(buffer2, m) {
            return {
              type_: "underset",
              p1: mhchemParser.go(m[0]),
              p2: mhchemParser.go(m[1])
            };
          },
          "underbrace-output": function(buffer2, m) {
            return {
              type_: "underbrace",
              p1: mhchemParser.go(m[0]),
              p2: mhchemParser.go(m[1])
            };
          },
          "color-output": function(buffer2, m) {
            return {
              type_: "color",
              color1: m[0],
              color2: mhchemParser.go(m[1])
            };
          },
          "r=": function(buffer2, m) {
            buffer2.r = m;
          },
          "rdt=": function(buffer2, m) {
            buffer2.rdt = m;
          },
          "rd=": function(buffer2, m) {
            buffer2.rd = m;
          },
          "rqt=": function(buffer2, m) {
            buffer2.rqt = m;
          },
          "rq=": function(buffer2, m) {
            buffer2.rq = m;
          },
          "operator": function(buffer2, m, p1) {
            return { type_: "operator", kind_: p1 || m };
          }
        }
      },
      "a": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          "1/2$": {
            "0": { action_: "1/2" }
          },
          "else": {
            "0": { nextState: "1", revisit: true }
          },
          "$(...)$": {
            "*": { action_: "tex-math tight", nextState: "1" }
          },
          ",": {
            "*": { action_: { type_: "insert", option: "commaDecimal" } }
          },
          "else2": {
            "*": { action_: "copy" }
          }
        }),
        actions: {}
      },
      "o": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          "1/2$": {
            "0": { action_: "1/2" }
          },
          "else": {
            "0": { nextState: "1", revisit: true }
          },
          "letters": {
            "*": { action_: "rm" }
          },
          "\\ca": {
            "*": { action_: { type_: "insert", option: "circa" } }
          },
          "\\x{}{}|\\x{}|\\x": {
            "*": { action_: "copy" }
          },
          "${(...)}$|$(...)$": {
            "*": { action_: "tex-math" }
          },
          "{(...)}": {
            "*": { action_: "{text}" }
          },
          "else2": {
            "*": { action_: "copy" }
          }
        }),
        actions: {}
      },
      "text": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "{...}": {
            "*": { action_: "text=" }
          },
          "${(...)}$|$(...)$": {
            "*": { action_: "tex-math" }
          },
          "\\greek": {
            "*": { action_: ["output", "rm"] }
          },
          "\\,|\\x{}{}|\\x{}|\\x": {
            "*": { action_: ["output", "copy"] }
          },
          "else": {
            "*": { action_: "text=" }
          }
        }),
        actions: {
          output: function(buffer2) {
            if (buffer2.text_) {
              var ret = { type_: "text", p1: buffer2.text_ };
              for (var p2 in buffer2) {
                delete buffer2[p2];
              }
              return ret;
            }
          }
        }
      },
      "pq": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          "state of aggregation $": {
            "*": { action_: "state of aggregation" }
          },
          "i$": {
            "0": { nextState: "!f", revisit: true }
          },
          "(KV letters),": {
            "0": { action_: "rm", nextState: "0" }
          },
          "formula$": {
            "0": { nextState: "f", revisit: true }
          },
          "1/2$": {
            "0": { action_: "1/2" }
          },
          "else": {
            "0": { nextState: "!f", revisit: true }
          },
          "${(...)}$|$(...)$": {
            "*": { action_: "tex-math" }
          },
          "{(...)}": {
            "*": { action_: "text" }
          },
          "a-z": {
            f: { action_: "tex-math" }
          },
          "letters": {
            "*": { action_: "rm" }
          },
          "-9.,9": {
            "*": { action_: "9,9" }
          },
          ",": {
            "*": {
              action_: {
                type_: "insert+p1",
                option: "comma enumeration S"
              }
            }
          },
          "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
            "*": { action_: "color-output" }
          },
          "\\color{(...)}0": {
            "*": { action_: "color0-output" }
          },
          "\\ce{(...)}": {
            "*": { action_: "ce" }
          },
          "\\,|\\x{}{}|\\x{}|\\x": {
            "*": { action_: "copy" }
          },
          "else2": {
            "*": { action_: "copy" }
          }
        }),
        actions: {
          "state of aggregation": function(buffer2, m) {
            return {
              type_: "state of aggregation subscript",
              p1: mhchemParser.go(m, "o")
            };
          },
          "color-output": function(buffer2, m) {
            return {
              type_: "color",
              color1: m[0],
              color2: mhchemParser.go(m[1], "pq")
            };
          }
        }
      },
      "bd": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          "x$": {
            "0": { nextState: "!f", revisit: true }
          },
          "formula$": {
            "0": { nextState: "f", revisit: true }
          },
          "else": {
            "0": { nextState: "!f", revisit: true }
          },
          "-9.,9 no missing 0": {
            "*": { action_: "9,9" }
          },
          ".": {
            "*": { action_: { type_: "insert", option: "electron dot" } }
          },
          "a-z": {
            f: { action_: "tex-math" }
          },
          "x": {
            "*": { action_: { type_: "insert", option: "KV x" } }
          },
          "letters": {
            "*": { action_: "rm" }
          },
          "'": {
            "*": { action_: { type_: "insert", option: "prime" } }
          },
          "${(...)}$|$(...)$": {
            "*": { action_: "tex-math" }
          },
          "{(...)}": {
            "*": { action_: "text" }
          },
          "\\color{(...)}{(...)}1|\\color(...){(...)}2": {
            "*": { action_: "color-output" }
          },
          "\\color{(...)}0": {
            "*": { action_: "color0-output" }
          },
          "\\ce{(...)}": {
            "*": { action_: "ce" }
          },
          "\\,|\\x{}{}|\\x{}|\\x": {
            "*": { action_: "copy" }
          },
          "else2": {
            "*": { action_: "copy" }
          }
        }),
        actions: {
          "color-output": function(buffer2, m) {
            return {
              type_: "color",
              color1: m[0],
              color2: mhchemParser.go(m[1], "bd")
            };
          }
        }
      },
      "oxidation": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          "roman numeral": {
            "*": { action_: "roman-numeral" }
          },
          "${(...)}$|$(...)$": {
            "*": { action_: "tex-math" }
          },
          "else": {
            "*": { action_: "copy" }
          }
        }),
        actions: {
          "roman-numeral": function(buffer2, m) {
            return { type_: "roman numeral", p1: m || "" };
          }
        }
      },
      "tex-math": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "\\ce{(...)}": {
            "*": { action_: ["output", "ce"] }
          },
          "{...}|\\,|\\x{}{}|\\x{}|\\x": {
            "*": { action_: "o=" }
          },
          "else": {
            "*": { action_: "o=" }
          }
        }),
        actions: {
          output: function(buffer2) {
            if (buffer2.o) {
              var ret = { type_: "tex-math", p1: buffer2.o };
              for (var p2 in buffer2) {
                delete buffer2[p2];
              }
              return ret;
            }
          }
        }
      },
      "tex-math tight": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "\\ce{(...)}": {
            "*": { action_: ["output", "ce"] }
          },
          "{...}|\\,|\\x{}{}|\\x{}|\\x": {
            "*": { action_: "o=" }
          },
          "-|+": {
            "*": { action_: "tight operator" }
          },
          "else": {
            "*": { action_: "o=" }
          }
        }),
        actions: {
          "tight operator": function(buffer2, m) {
            buffer2.o = (buffer2.o || "") + "{" + m + "}";
          },
          "output": function(buffer2) {
            if (buffer2.o) {
              var ret = { type_: "tex-math", p1: buffer2.o };
              for (var p2 in buffer2) {
                delete buffer2[p2];
              }
              return ret;
            }
          }
        }
      },
      "9,9": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": {}
          },
          ",": {
            "*": { action_: "comma" }
          },
          "else": {
            "*": { action_: "copy" }
          }
        }),
        actions: {
          comma: function() {
            return { type_: "commaDecimal" };
          }
        }
      },
      //#endregion
      //
      // \pu state machines
      //
      //#region pu
      "pu": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "space$": {
            "*": { action_: ["output", "space"] }
          },
          "{[(|)]}": {
            "0|a": { action_: "copy" }
          },
          "(-)(9)^(-9)": {
            "0": { action_: "number^", nextState: "a" }
          },
          "(-)(9.,9)(e)(99)": {
            "0": { action_: "enumber", nextState: "a" }
          },
          "space": {
            "0|a": {}
          },
          "pm-operator": {
            "0|a": {
              action_: { type_: "operator", option: "\\pm" },
              nextState: "0"
            }
          },
          "operator": {
            "0|a": { action_: "copy", nextState: "0" }
          },
          "//": {
            d: { action_: "o=", nextState: "/" }
          },
          "/": {
            d: { action_: "o=", nextState: "/" }
          },
          "{...}|else": {
            "0|d": { action_: "d=", nextState: "d" },
            "a": { action_: ["space", "d="], nextState: "d" },
            "/|q": { action_: "q=", nextState: "q" }
          }
        }),
        actions: {
          "enumber": function(buffer2, m) {
            var ret = [];
            if (m[0] === "+-" || m[0] === "+/-") {
              ret.push("\\pm ");
            } else if (m[0]) {
              ret.push(m[0]);
            }
            if (m[1]) {
              mhchemParser.concatArray(ret, mhchemParser.go(m[1], "pu-9,9"));
              if (m[2]) {
                if (m[2].match(/[,.]/)) {
                  mhchemParser.concatArray(ret, mhchemParser.go(m[2], "pu-9,9"));
                } else {
                  ret.push(m[2]);
                }
              }
              m[3] = m[4] || m[3];
              if (m[3]) {
                m[3] = m[3].trim();
                if (m[3] === "e" || m[3].substr(0, 1) === "*") {
                  ret.push({ type_: "cdot" });
                } else {
                  ret.push({ type_: "times" });
                }
              }
            }
            if (m[3]) {
              ret.push("10^{" + m[5] + "}");
            }
            return ret;
          },
          "number^": function(buffer2, m) {
            var ret = [];
            if (m[0] === "+-" || m[0] === "+/-") {
              ret.push("\\pm ");
            } else if (m[0]) {
              ret.push(m[0]);
            }
            mhchemParser.concatArray(ret, mhchemParser.go(m[1], "pu-9,9"));
            ret.push("^{" + m[2] + "}");
            return ret;
          },
          "operator": function(buffer2, m, p1) {
            return { type_: "operator", kind_: p1 || m };
          },
          "space": function() {
            return { type_: "pu-space-1" };
          },
          "output": function(buffer2) {
            var ret;
            var md = mhchemParser.patterns.match_("{(...)}", buffer2.d || "");
            if (md && md.remainder === "") {
              buffer2.d = md.match_;
            }
            var mq = mhchemParser.patterns.match_("{(...)}", buffer2.q || "");
            if (mq && mq.remainder === "") {
              buffer2.q = mq.match_;
            }
            if (buffer2.d) {
              buffer2.d = buffer2.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
              buffer2.d = buffer2.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
            }
            if (buffer2.q) {
              buffer2.q = buffer2.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C");
              buffer2.q = buffer2.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
              var b5 = {
                d: mhchemParser.go(buffer2.d, "pu"),
                q: mhchemParser.go(buffer2.q, "pu")
              };
              if (buffer2.o === "//") {
                ret = { type_: "pu-frac", p1: b5.d, p2: b5.q };
              } else {
                ret = b5.d;
                if (b5.d.length > 1 || b5.q.length > 1) {
                  ret.push({ type_: " / " });
                } else {
                  ret.push({ type_: "/" });
                }
                mhchemParser.concatArray(ret, b5.q);
              }
            } else {
              ret = mhchemParser.go(buffer2.d, "pu-2");
            }
            for (var p2 in buffer2) {
              delete buffer2[p2];
            }
            return ret;
          }
        }
      },
      "pu-2": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "*": { action_: "output" }
          },
          "*": {
            "*": { action_: ["output", "cdot"], nextState: "0" }
          },
          "\\x": {
            "*": { action_: "rm=" }
          },
          "space": {
            "*": { action_: ["output", "space"], nextState: "0" }
          },
          "^{(...)}|^(-1)": {
            "1": { action_: "^(-1)" }
          },
          "-9.,9": {
            "0": { action_: "rm=", nextState: "0" },
            "1": { action_: "^(-1)", nextState: "0" }
          },
          "{...}|else": {
            "*": { action_: "rm=", nextState: "1" }
          }
        }),
        actions: {
          "cdot": function() {
            return { type_: "tight cdot" };
          },
          "^(-1)": function(buffer2, m) {
            buffer2.rm += "^{" + m + "}";
          },
          "space": function() {
            return { type_: "pu-space-2" };
          },
          "output": function(buffer2) {
            var ret = [];
            if (buffer2.rm) {
              var mrm = mhchemParser.patterns.match_("{(...)}", buffer2.rm || "");
              if (mrm && mrm.remainder === "") {
                ret = mhchemParser.go(mrm.match_, "pu");
              } else {
                ret = { type_: "rm", p1: buffer2.rm };
              }
            }
            for (var p2 in buffer2) {
              delete buffer2[p2];
            }
            return ret;
          }
        }
      },
      "pu-9,9": {
        transitions: mhchemParser.createTransitions({
          "empty": {
            "0": { action_: "output-0" },
            "o": { action_: "output-o" }
          },
          ",": {
            "0": { action_: ["output-0", "comma"], nextState: "o" }
          },
          ".": {
            "0": { action_: ["output-0", "copy"], nextState: "o" }
          },
          "else": {
            "*": { action_: "text=" }
          }
        }),
        actions: {
          "comma": function() {
            return { type_: "commaDecimal" };
          },
          "output-0": function(buffer2) {
            var ret = [];
            buffer2.text_ = buffer2.text_ || "";
            if (buffer2.text_.length > 4) {
              var a = buffer2.text_.length % 3;
              if (a === 0) {
                a = 3;
              }
              for (var i = buffer2.text_.length - 3; i > 0; i -= 3) {
                ret.push(buffer2.text_.substr(i, 3));
                ret.push({ type_: "1000 separator" });
              }
              ret.push(buffer2.text_.substr(0, a));
              ret.reverse();
            } else {
              ret.push(buffer2.text_);
            }
            for (var p2 in buffer2) {
              delete buffer2[p2];
            }
            return ret;
          },
          "output-o": function(buffer2) {
            var ret = [];
            buffer2.text_ = buffer2.text_ || "";
            if (buffer2.text_.length > 4) {
              var a = buffer2.text_.length - 3;
              for (var i = 0; i < a; i += 3) {
                ret.push(buffer2.text_.substr(i, 3));
                ret.push({ type_: "1000 separator" });
              }
              ret.push(buffer2.text_.substr(i));
            } else {
              ret.push(buffer2.text_);
            }
            for (var p2 in buffer2) {
              delete buffer2[p2];
            }
            return ret;
          }
        }
      }
      //#endregion
    };
    var texify = {
      go: function(input, isInner) {
        if (!input) {
          return "";
        }
        var res = "";
        var cee = false;
        for (var i = 0; i < input.length; i++) {
          var inputi = input[i];
          if (typeof inputi === "string") {
            res += inputi;
          } else {
            res += texify._go2(inputi);
            if (inputi.type_ === "1st-level escape") {
              cee = true;
            }
          }
        }
        if (!isInner && !cee && res) {
          res = "{" + res + "}";
        }
        return res;
      },
      _goInner: function(input) {
        if (!input) {
          return input;
        }
        return texify.go(input, true);
      },
      _go2: function(buf) {
        var res;
        switch (buf.type_) {
          case "chemfive":
            res = "";
            var b5 = {
              a: texify._goInner(buf.a),
              b: texify._goInner(buf.b),
              p: texify._goInner(buf.p),
              o: texify._goInner(buf.o),
              q: texify._goInner(buf.q),
              d: texify._goInner(buf.d)
            };
            if (b5.a) {
              if (b5.a.match(/^[+\-]/)) {
                b5.a = "{" + b5.a + "}";
              }
              res += b5.a + "\\,";
            }
            if (b5.b || b5.p) {
              res += "{\\vphantom{X}}";
              res += "^{\\hphantom{" + (b5.b || "") + "}}_{\\hphantom{" + (b5.p || "") + "}}";
              res += "{\\vphantom{X}}";
              res += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (b5.b || "") + "}}";
              res += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (b5.p || "") + "}}}";
            }
            if (b5.o) {
              if (b5.o.match(/^[+\-]/)) {
                b5.o = "{" + b5.o + "}";
              }
              res += b5.o;
            }
            if (buf.dType === "kv") {
              if (b5.d || b5.q) {
                res += "{\\vphantom{X}}";
              }
              if (b5.d) {
                res += "^{" + b5.d + "}";
              }
              if (b5.q) {
                res += "_{\\smash[t]{" + b5.q + "}}";
              }
            } else if (buf.dType === "oxidation") {
              if (b5.d) {
                res += "{\\vphantom{X}}";
                res += "^{" + b5.d + "}";
              }
              if (b5.q) {
                res += "{\\vphantom{X}}";
                res += "_{\\smash[t]{" + b5.q + "}}";
              }
            } else {
              if (b5.q) {
                res += "{\\vphantom{X}}";
                res += "_{\\smash[t]{" + b5.q + "}}";
              }
              if (b5.d) {
                res += "{\\vphantom{X}}";
                res += "^{" + b5.d + "}";
              }
            }
            break;
          case "rm":
            res = "\\mathrm{" + buf.p1 + "}";
            break;
          case "text":
            if (buf.p1.match(/[\^_]/)) {
              buf.p1 = buf.p1.replace(" ", "~").replace("-", "\\text{-}");
              res = "\\mathrm{" + buf.p1 + "}";
            } else {
              res = "\\text{" + buf.p1 + "}";
            }
            break;
          case "roman numeral":
            res = "\\mathrm{" + buf.p1 + "}";
            break;
          case "state of aggregation":
            res = "\\mskip2mu " + texify._goInner(buf.p1);
            break;
          case "state of aggregation subscript":
            res = "\\mskip1mu " + texify._goInner(buf.p1);
            break;
          case "bond":
            res = texify._getBond(buf.kind_);
            if (!res) {
              throw [
                "MhchemErrorBond",
                "mhchem Error. Unknown bond type (" + buf.kind_ + ")"
              ];
            }
            break;
          case "frac":
            var c = "\\frac{" + buf.p1 + "}{" + buf.p2 + "}";
            res = "\\mathchoice{\\textstyle" + c + "}{" + c + "}{" + c + "}{" + c + "}";
            break;
          case "pu-frac":
            var d = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
            res = "\\mathchoice{\\textstyle" + d + "}{" + d + "}{" + d + "}{" + d + "}";
            break;
          case "tex-math":
            res = buf.p1 + " ";
            break;
          case "frac-ce":
            res = "\\frac{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
            break;
          case "overset":
            res = "\\overset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
            break;
          case "underset":
            res = "\\underset{" + texify._goInner(buf.p1) + "}{" + texify._goInner(buf.p2) + "}";
            break;
          case "underbrace":
            res = "\\underbrace{" + texify._goInner(buf.p1) + "}_{" + texify._goInner(buf.p2) + "}";
            break;
          case "color":
            res = "{\\color{" + buf.color1 + "}{" + texify._goInner(buf.color2) + "}}";
            break;
          case "color0":
            res = "\\color{" + buf.color + "}";
            break;
          case "arrow":
            var b6 = {
              rd: texify._goInner(buf.rd),
              rq: texify._goInner(buf.rq)
            };
            var arrow = "\\x" + texify._getArrow(buf.r);
            if (b6.rq) {
              arrow += "[{" + b6.rq + "}]";
            }
            if (b6.rd) {
              arrow += "{" + b6.rd + "}";
            } else {
              arrow += "{}";
            }
            res = arrow;
            break;
          case "operator":
            res = texify._getOperator(buf.kind_);
            break;
          case "1st-level escape":
            res = buf.p1 + " ";
            break;
          case "space":
            res = " ";
            break;
          case "entitySkip":
            res = "~";
            break;
          case "pu-space-1":
            res = "~";
            break;
          case "pu-space-2":
            res = "\\mkern3mu ";
            break;
          case "1000 separator":
            res = "\\mkern2mu ";
            break;
          case "commaDecimal":
            res = "{,}";
            break;
          case "comma enumeration L":
            res = "{" + buf.p1 + "}\\mkern6mu ";
            break;
          case "comma enumeration M":
            res = "{" + buf.p1 + "}\\mkern3mu ";
            break;
          case "comma enumeration S":
            res = "{" + buf.p1 + "}\\mkern1mu ";
            break;
          case "hyphen":
            res = "\\text{-}";
            break;
          case "addition compound":
            res = "\\,{\\cdot}\\,";
            break;
          case "electron dot":
            res = "\\mkern1mu \\bullet\\mkern1mu ";
            break;
          case "KV x":
            res = "{\\times}";
            break;
          case "prime":
            res = "\\prime ";
            break;
          case "cdot":
            res = "\\cdot ";
            break;
          case "tight cdot":
            res = "\\mkern1mu{\\cdot}\\mkern1mu ";
            break;
          case "times":
            res = "\\times ";
            break;
          case "circa":
            res = "{\\sim}";
            break;
          case "^":
            res = "uparrow";
            break;
          case "v":
            res = "downarrow";
            break;
          case "ellipsis":
            res = "\\ldots ";
            break;
          case "/":
            res = "/";
            break;
          case " / ":
            res = "\\,/\\,";
            break;
          default:
            throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
        return res;
      },
      _getArrow: function(a) {
        switch (a) {
          case "->":
            return "rightarrow";
          case "→":
            return "rightarrow";
          case "⟶":
            return "rightarrow";
          case "<-":
            return "leftarrow";
          case "<->":
            return "leftrightarrow";
          case "<-->":
            return "rightleftarrows";
          case "<=>":
            return "rightleftharpoons";
          case "⇌":
            return "rightleftharpoons";
          case "<=>>":
            return "rightequilibrium";
          case "<<=>":
            return "leftequilibrium";
          default:
            throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
      },
      _getBond: function(a) {
        switch (a) {
          case "-":
            return "{-}";
          case "1":
            return "{-}";
          case "=":
            return "{=}";
          case "2":
            return "{=}";
          case "#":
            return "{\\equiv}";
          case "3":
            return "{\\equiv}";
          case "~":
            return "{\\tripledash}";
          case "~-":
            return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
          case "~=":
            return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
          case "~--":
            return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
          case "-~-":
            return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
          case "...":
            return "{{\\cdot}{\\cdot}{\\cdot}}";
          case "....":
            return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
          case "->":
            return "{\\rightarrow}";
          case "<-":
            return "{\\leftarrow}";
          case "<":
            return "{<}";
          case ">":
            return "{>}";
          default:
            throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
      },
      _getOperator: function(a) {
        switch (a) {
          case "+":
            return " {}+{} ";
          case "-":
            return " {}-{} ";
          case "=":
            return " {}={} ";
          case "<":
            return " {}<{} ";
          case ">":
            return " {}>{} ";
          case "<<":
            return " {}\\ll{} ";
          case ">>":
            return " {}\\gg{} ";
          case "\\pm":
            return " {}\\pm{} ";
          case "\\approx":
            return " {}\\approx{} ";
          case "$\\approx$":
            return " {}\\approx{} ";
          case "v":
            return " \\downarrow{} ";
          case "(v)":
            return " \\downarrow{} ";
          case "^":
            return " \\uparrow{} ";
          case "(^)":
            return " \\uparrow{} ";
          default:
            throw ["MhchemBugT", "mhchem bug T. Please report."];
        }
      }
    };
    var BoxAtom = class extends Atom {
      constructor(command, body, context, options) {
        super("box", context, {
          command,
          serialize: options.serialize,
          style: options.style
        });
        this.body = body;
        this.framecolor = options.framecolor;
        this.verbatimFramecolor = options.verbatimBackgroundcolor;
        this.backgroundcolor = options.backgroundcolor;
        this.verbatimBackgroundcolor = options.verbatimBackgroundcolor;
        this.padding = options.padding;
        this.border = options.border;
      }
      static fromJson(json, context) {
        return new BoxAtom(json.command, json.body, context, json);
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), {
          framecolor: this.framecolor,
          verbatimFramecolor: this.verbatimFramecolor,
          backgroundcolor: this.backgroundcolor,
          verbatimBackgroundcolor: this.verbatimBackgroundcolor,
          padding: this.padding,
          border: this.border
        });
      }
      render(parentContext) {
        const context = new Context(parentContext, this.style);
        const fboxsep = convertDimensionToEm(
          context.getRegisterAsDimension("fboxsep")
        );
        const padding = this.padding === void 0 ? fboxsep : convertDimensionToEm(
          convertToDimension(this.padding, __spreadProps(__spreadValues({}, this.context), {
            registers: parentContext.registers
          }))
        );
        const content = Atom.createBox(parentContext, this.body);
        if (!content)
          return null;
        content.setStyle("vertical-align", -content.height, "em");
        const base = new Box(content, { type: "mord" });
        const box = new Box(null, { classes: "ML__box" });
        box.height = base.height + padding;
        box.depth = base.depth + padding;
        box.setStyle("box-sizing", "border-box");
        box.setStyle("position", "absolute");
        box.setStyle("height", base.height + base.depth + 2 * padding, "em");
        if (padding === 0)
          box.setStyle("width", "100%");
        else {
          box.setStyle("width", `calc(100% + ${2 * padding}em)`);
          box.setStyle("top", fboxsep, "em");
          box.setStyle("left", -padding, "em");
        }
        if (this.backgroundcolor)
          box.setStyle("background-color", this.backgroundcolor);
        if (this.framecolor) {
          box.setStyle(
            "border",
            `${convertDimensionToEm(
              context.getRegisterAsDimension("fboxrule")
            )}em solid ${this.framecolor}`
          );
        }
        if (this.border)
          box.setStyle("border", this.border);
        base.setStyle("display", "inline-block");
        base.setStyle("height", content.height + content.depth, "em");
        base.setStyle("vertical-align", -padding, "em");
        const result = new Box([box, base]);
        result.setStyle("position", "relative");
        result.setStyle("display", "inline-block");
        result.setStyle("line-height", 0);
        result.height = base.height + padding;
        result.depth = base.depth + padding;
        result.left = padding;
        result.right = padding;
        result.setStyle("height", base.height + padding, "em");
        result.setStyle("top", base.depth - base.height, "em");
        result.setStyle("vertical-align", base.depth + padding, "em");
        if (this.caret)
          result.caret = this.caret;
        return this.attachSupsub(parentContext, { base: result });
      }
    };
    var CompositionAtom = class extends Atom {
      constructor(value, context, options) {
        var _a3;
        super("composition", context, { mode: (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math", value });
      }
      static fromJson(json, context) {
        return new CompositionAtom(json.value, context, json);
      }
      toJson() {
        return super.toJson();
      }
      get computedStyle() {
        return {};
      }
      render(context) {
        const result = new Box(this.value, {
          classes: "ML__composition",
          type: "composition"
        });
        this.bind(context, result);
        if (this.caret)
          result.caret = this.caret;
        return result;
      }
      serialize(_options) {
        return "";
      }
    };
    var LatexAtom = class extends Atom {
      // Display errors with wavy red line
      constructor(value, context, options) {
        var _a3;
        super("latex", context, { value, mode: "latex" });
        this.isSuggestion = (_a3 = options == null ? void 0 : options.isSuggestion) != null ? _a3 : false;
        this.isError = false;
        this.verbatimLatex = value;
      }
      static fromJson(json, context) {
        const result = new LatexAtom(json.command, context);
        if (json.isSuggestion)
          result.isSuggestion = true;
        if (json.isError)
          result.isError = true;
        return result;
      }
      toJson() {
        const options = {};
        if (this.isSuggestion)
          options.isSuggestion = true;
        if (this.isError)
          options.isError = true;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      get computedStyle() {
        return {};
      }
      render(context) {
        const result = new Box(this.value, {
          classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "",
          type: "latex",
          maxFontSize: 1
        });
        if (!result)
          return null;
        if (this.caret)
          result.caret = this.caret;
        return this.bind(context, result);
      }
    };
    var LatexGroupAtom = class extends Atom {
      constructor(latex, context) {
        super("latexgroup", context, { mode: "latex" });
        this.body = [...latex].map((x) => new LatexAtom(x, context));
        this.skipBoundary = false;
      }
      static fromJson(_json, context) {
        return new LatexGroupAtom("", context);
      }
      toJson() {
        return super.toJson();
      }
      render(context) {
        const box = Atom.createBox(context, this.body, { newList: true });
        if (!box)
          return null;
        if (this.caret)
          box.caret = this.caret;
        return this.bind(context, box);
      }
      serialize(_options) {
        var _a3, _b3;
        return (_b3 = (_a3 = this.body) == null ? void 0 : _a3.map((x) => x.value).join("")) != null ? _b3 : "";
      }
    };
    var LineAtom = class extends Atom {
      constructor(command, body, context, options) {
        super("line", context, { command, style: options.style });
        this.skipBoundary = true;
        this.body = body;
        this.position = options.position;
      }
      static fromJson(json, context) {
        return new LineAtom(json.command, json.body, context, json);
      }
      toJson() {
        return __spreadProps(__spreadValues({}, super.toJson()), { position: this.position });
      }
      render(parentContext) {
        const context = new Context(parentContext, this.style, "cramp");
        const inner = Atom.createBox(context, this.body);
        if (!inner)
          return null;
        const ruleWidth = context.metrics.defaultRuleThickness / context.scalingFactor;
        const line = new Box(null, { classes: this.position + "-line" });
        line.height = ruleWidth;
        line.maxFontSize = ruleWidth * 1.125 * context.scalingFactor;
        let stack2;
        if (this.position === "overline") {
          stack2 = new VBox({
            shift: 0,
            children: [{ box: inner }, 3 * ruleWidth, { box: line }, ruleWidth]
          });
        } else {
          stack2 = new VBox({
            top: inner.height,
            children: [ruleWidth, { box: line }, 3 * ruleWidth, { box: inner }]
          });
        }
        if (this.caret)
          stack2.caret = this.caret;
        return new Box(stack2, {
          classes: this.position,
          type: "mord"
        });
      }
    };
    var OverlapAtom = class extends Atom {
      constructor(command, body, context, options) {
        var _a3, _b3;
        super("overlap", context, { command, style: options == null ? void 0 : options.style });
        this.skipBoundary = true;
        if (typeof body === "string")
          this.body = [new Atom("mord", context, { value: body })];
        else
          this.body = body;
        this.align = (_a3 = options == null ? void 0 : options.align) != null ? _a3 : "left";
        this.boxType = (_b3 = options == null ? void 0 : options.boxType) != null ? _b3 : "mord";
      }
      static fromJson(json, context) {
        return new OverlapAtom(json.command, json.body, context, json);
      }
      toJson() {
        const options = {};
        if (this.align)
          options.align = this.align;
        if (this.boxType)
          options.boxType = this.boxType;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      render(context) {
        const inner = Atom.createBox(context, this.body, { classes: "inner" });
        if (!inner)
          return null;
        if (this.caret)
          inner.caret = this.caret;
        return this.bind(
          context,
          new Box([inner, new Box(null, { classes: "fix" })], {
            classes: this.align === "left" ? "llap" : "rlap",
            type: this.boxType
          })
        );
      }
    };
    var PhantomAtom = class extends Atom {
      constructor(command, body, context, options) {
        var _a3, _b3, _c2, _d2;
        super("phantom", context, { command, style: options.style });
        this.captureSelection = true;
        this.body = body;
        this.isInvisible = (_a3 = options.isInvisible) != null ? _a3 : false;
        this.smashDepth = (_b3 = options.smashDepth) != null ? _b3 : false;
        this.smashHeight = (_c2 = options.smashHeight) != null ? _c2 : false;
        this.smashWidth = (_d2 = options.smashWidth) != null ? _d2 : false;
      }
      static fromJson(json, context) {
        return new PhantomAtom(json.command, json.body, context, json);
      }
      toJson() {
        const options = {};
        if (this.isInvisible)
          options.isInvisible = true;
        if (this.smashDepth)
          options.smashDepth = true;
        if (this.smashHeight)
          options.smashHeight = true;
        if (this.smashWidth)
          options.smashWidth = true;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      render(context) {
        const phantom = new Context(context, { isPhantom: true });
        if (!this.smashDepth && !this.smashHeight && !this.smashWidth) {
          console.assert(this.isInvisible);
          return Atom.createBox(phantom, this.body, { classes: "inner" });
        }
        const content = Atom.createBox(
          this.isInvisible ? phantom : context,
          this.body
        );
        if (!content)
          return null;
        if (this.smashWidth) {
          const fix = new Box(null, { classes: "fix" });
          return new Box([content, fix], { classes: "rlap" }).wrap(context);
        }
        if (!this.smashHeight && !this.smashDepth)
          return content;
        if (this.smashHeight)
          content.height = 0;
        if (this.smashDepth)
          content.depth = 0;
        if (content.children) {
          for (const box of content.children) {
            if (this.smashHeight)
              box.height = 0;
            if (this.smashDepth)
              box.depth = 0;
          }
        }
        return new VBox(
          { firstBaseline: [{ box: content }] },
          { type: "mord" }
        ).wrap(context);
      }
    };
    var RuleAtom = class extends Atom {
      constructor(command, context, options) {
        var _a3;
        super("rule", context, { command, style: options.style });
        this.shift = (_a3 = options.shift) != null ? _a3 : { dimension: 0 };
        this.height = options.height;
        this.width = options.width;
      }
      static fromJson(json, context) {
        return new RuleAtom(json.command, context, json);
      }
      toJson() {
        const options = {
          height: this.height,
          width: this.width
        };
        if (this.shift)
          options.shift = this.shift;
        return __spreadValues(__spreadValues({}, super.toJson()), options);
      }
      render(parentContext) {
        const context = new Context(parentContext, this.style, "textstyle");
        const shift = convertDimensionToEm(this.shift);
        const width = convertDimensionToEm(this.width);
        const height = convertDimensionToEm(this.height);
        const result = new Box(null, { classes: "rule", type: "mord" });
        result.setStyle("border-right-width", width, "em");
        result.setStyle("border-top-width", height, "em");
        result.setStyle("border-color", this.style.color);
        result.setStyle("vertical-align", shift, "em");
        if (this.isSelected)
          result.setStyle("opacity", "50%");
        result.width = width;
        result.height = height + shift;
        result.depth = -shift;
        this.bind(parentContext, result);
        if (this.caret)
          result.caret = this.caret;
        return result.wrap(context);
      }
      serialize(_options) {
        var _a3;
        let result = (_a3 = this.command) != null ? _a3 : "";
        if (this.shift)
          result += `[${serializeDimension(this.shift)}]`;
        result += `{${serializeDimension(this.width)}}{${serializeDimension(
          this.height
        )}}`;
        return result;
      }
    };
    var DEFAULT_DIMENSION_REGISTERS = {
      "p@": "1pt ",
      "z@": "0pt",
      "maxdimen": "16383.99999pt",
      "hfuzz": "0.1pt",
      "vfuzz": "0.1pt",
      "overfullrule": "5pt",
      "hsize": "6.5in",
      "vsize": "8.9in",
      "parindent": "20pt",
      "maxdepth": "4pt",
      "splitmaxdepth": "\\maxdimen",
      "boxmaxdepth": "\\maxdimen",
      "delimitershortfall": "5pt",
      //      @todo used in makeLeftRightDelim()
      "nulldelimiterspace": "1.2pt",
      //       @todo use in makeNullDelimiter
      "scriptspace": "0.5pt",
      // In pt.
      "topskip": "10pt",
      "splittopskip": "10pt",
      "normalbaselineskip": "12pt",
      "normallineskip": "1pt",
      "normallineskiplimit": "0pt",
      // @todo: The vertical space between the lines for all math expressions which
      // allow multiple lines (see array, multline)
      "jot": "3pt",
      // The space between adjacent `|` columns in an array definition.
      // From article.cls.txt:455
      "doublerulesep": "2pt",
      // The width of separator lines in {array} environments.
      "arrayrulewidth": "0.4pt",
      "arraycolsep": "5pt",
      // Two values from LaTeX source2e:
      "fboxsep": "3pt",
      // From letter.dtx:1626
      "fboxrule": "0.4pt"
      // From letter.dtx:1627
    };
    var DEFAULT_GLUE_REGISTERS = {
      "z@skip": "0pt plust0pt minus0pt",
      "hideskip": "-1000pt plust 1fill",
      // LaTeX
      "@flushglue": "0pt plust 1fill",
      // LaTeX
      "parskip": "0pt plus 1pt",
      // @todo  the "shortskip" are used if the formula starts to the right of the
      // line before (i.e. centered and short line before)
      "abovedisplayskip": "12pt plus 3pt minus 9pt",
      "abovedisplayshortskip": "0pt plus 3pt",
      "belowdisplayskip": "12pt plus 3pt minus 9pt",
      "belowdisplayshortskip": "7pt plus 3pt minus 4pt",
      "parfillskip": "0pt plus 1fil",
      "thinmuskip": "3mu",
      //  @todo for inter atom spacing
      "medmuskip": "4mu plus 2mu minus 4mu",
      // @todo for inter atom spacing
      "thickmuskip": "5mu plus 5mu",
      //  @todo for inter atom spacing
      "smallskipamount": "3pt plus1pt minus1pt",
      "medskipamount": "6pt plus2pt minus2pt",
      "bigskipamount": "12pt plus4pt minus4pt"
    };
    var DEFAULT_NUMBER_REGISTERS = {
      // 'voidb@x'
      pretolerance: 100,
      tolerance: 200,
      hbadness: 1e3,
      vbadness: 1e3,
      linepenalty: 10,
      hyphenpenalty: 50,
      exhyphenpenalty: 50,
      binoppenalty: 700,
      relpenalty: 500,
      clubpenalty: 150,
      widowpenalty: 150,
      displaywidowpenalty: 50,
      brokenpenalty: 100,
      predisplaypenalty: 1e4,
      doublehyphendemerits: 1e4,
      finalhyphendemerits: 5e3,
      adjdemerits: 1e4,
      tracinglostchars: 1,
      uchyph: 1,
      delimiterfactor: 901,
      defaulthyphenchar: "\\-",
      defaultskewchar: -1,
      newlinechar: -1,
      showboxbreadth: 5,
      showboxdepth: 3,
      errorcontextlines: 5,
      interdisplaylinepenalty: 100,
      interfootnotelinepenalty: 100,
      baselineSkip: 1.2,
      // @todo:
      arraystretch: "",
      month: (/* @__PURE__ */ new Date()).getMonth() + 1,
      day: (/* @__PURE__ */ new Date()).getDate(),
      year: (/* @__PURE__ */ new Date()).getFullYear()
    };
    var gDefaultRegisters;
    function getDefaultRegisters(context) {
      var _a3, _b3;
      if (gDefaultRegisters)
        return gDefaultRegisters;
      gDefaultRegisters = __spreadValues({}, DEFAULT_NUMBER_REGISTERS);
      for (const reg of Object.keys(DEFAULT_DIMENSION_REGISTERS)) {
        gDefaultRegisters[reg] = (_a3 = convertToDimension(DEFAULT_DIMENSION_REGISTERS[reg], __spreadProps(__spreadValues({}, context), {
          registers: gDefaultRegisters
        }))) != null ? _a3 : 0;
      }
      for (const reg of Object.keys(DEFAULT_GLUE_REGISTERS)) {
        gDefaultRegisters[reg] = (_b3 = convertToGlue(DEFAULT_GLUE_REGISTERS[reg], __spreadProps(__spreadValues({}, context), {
          registers: gDefaultRegisters
        }))) != null ? _b3 : 0;
      }
      return gDefaultRegisters;
    }
    function defaultGlobalContext() {
      const result = {
        registers: {},
        smartFence: false,
        fractionNavigationOrder: "numerator-denominator",
        placeholderSymbol: "▢",
        letterShapeStyle: l10n.locale.startsWith("fr") ? "french" : "tex",
        colorMap: defaultColorMap,
        backgroundColorMap: defaultBackgroundColorMap,
        getDefinition: defaultGetDefinition,
        getMacro(token) {
          return getMacroDefinition(token, getMacros());
        }
      };
      return __spreadProps(__spreadValues({}, result), { registers: getDefaultRegisters(result) });
    }
    var TooltipAtom = class extends Atom {
      constructor(body, tooltip, context, options) {
        super("tooltip", context, {
          command: options == null ? void 0 : options.command,
          mode: "math",
          serialize: options == null ? void 0 : options.serialize,
          style: options == null ? void 0 : options.style,
          displayContainsHighlight: true
        });
        this.body = body;
        const tooltipContext = defaultGlobalContext();
        this.tooltip = new Atom("root", tooltipContext, { style: {} });
        this.tooltip.body = tooltip;
        this.skipBoundary = true;
        this.captureSelection = false;
      }
      static fromJson(json, context) {
        return new TooltipAtom(
          json.body,
          fromJson(json.tooltip, context),
          context,
          json
        );
      }
      toJson() {
        var _a3;
        const tooltip = (_a3 = this.tooltip.body) == null ? void 0 : _a3.filter((x) => x.type !== "first").map((x) => x.toJson());
        return __spreadProps(__spreadValues({}, super.toJson()), { tooltip });
      }
      render(context) {
        const body = Atom.createBox(context, this.body, {
          style: this.style
        });
        if (!body)
          return null;
        const tooltipContext = new Context(
          { registers: context.registers },
          { fontSize: DEFAULT_FONT_SIZE },
          "displaystyle"
        );
        const tooltip = coalesce(
          adjustInterAtomSpacing(
            new Box(this.tooltip.render(tooltipContext), {
              classes: "ML__tooltip-content"
            }),
            tooltipContext
          )
        );
        const box = new Box([tooltip, body], { classes: "ML__tooltip-container" });
        if (this.caret)
          box.caret = this.caret;
        return this.bind(context, box);
      }
      serialize(options) {
        return `${this.command}{${this.bodyToLatex(options)}}{${Atom.serialize(
          this.tooltip.body,
          options
        )}}`;
      }
    };
    function fromJson(json, context) {
      if (isArray2(json))
        return json.map((x) => fromJson(x, context));
      json = __spreadValues({}, json);
      for (const branch of NAMED_BRANCHES) {
        if (json[branch])
          json[branch] = fromJson(json[branch], context);
      }
      if (json.array)
        json.array = fromJson(json.array, context);
      const type = json.type;
      let result = void 0;
      if (type === "accent")
        result = AccentAtom.fromJson(json, context);
      if (type === "array")
        result = ArrayAtom.fromJson(json, context);
      if (type === "box")
        result = BoxAtom.fromJson(json, context);
      if (type === "chem")
        result = ChemAtom.fromJson(json, context);
      if (type === "choice")
        result = ChoiceAtom.fromJson(json, context);
      if (type === "composition")
        result = CompositionAtom.fromJson(json, context);
      if (type === "delim")
        result = DelimAtom.fromJson(json, context);
      if (type === "enclose")
        result = EncloseAtom.fromJson(json, context);
      if (type === "error")
        result = ErrorAtom.fromJson(json, context);
      if (type === "genfrac")
        result = GenfracAtom.fromJson(json, context);
      if (type === "group")
        result = GroupAtom.fromJson(json, context);
      if (type === "latex")
        result = LatexAtom.fromJson(json, context);
      if (type === "latexgroup")
        result = LatexGroupAtom.fromJson(json, context);
      if (type === "leftright")
        result = LeftRightAtom.fromJson(json, context);
      if (type === "line")
        result = LineAtom.fromJson(json, context);
      if (type === "macro")
        result = MacroAtom.fromJson(json, context);
      if (type === "msubsup")
        result = SubsupAtom.fromJson(json, context);
      if (type === "overlap")
        result = OverlapAtom.fromJson(json, context);
      if (type === "overunder")
        result = OverunderAtom.fromJson(json, context);
      if (type === "placeholder")
        result = PlaceholderAtom.fromJson(json, context);
      if (type === "prompt")
        result = PromptAtom.fromJson(json, context);
      if (type === "phantom")
        result = PhantomAtom.fromJson(json, context);
      if (type === "rule")
        result = RuleAtom.fromJson(json, context);
      if (type === "sizeddelim")
        result = SizedDelimAtom.fromJson(json, context);
      if (type === "spacing")
        result = SpacingAtom.fromJson(json, context);
      if (type === "surd")
        result = SurdAtom.fromJson(json, context);
      if (type === "text")
        result = TextAtom.fromJson(json, context);
      if (type === "tooltip")
        result = TooltipAtom.fromJson(json, context);
      if (type === "mop")
        result = OperatorAtom.fromJson(json, context);
      if (!result) {
        console.assert(
          [
            "first",
            "mbin",
            "mrel",
            "mclose",
            "minner",
            "mopen",
            "mord",
            "mpunct",
            "root",
            "space"
          ].includes(type),
          `MathLive 0.90.9: an unexpected atom type "${type}" was encountered. Add new atom constructors to \`fromJson()\` in "atom.ts"`
        );
        result = Atom.fromJson(json, context);
      }
      for (const branch of NAMED_BRANCHES)
        if (json[branch])
          result.setChildren(json[branch], branch);
      if (json.verbatimLatex !== void 0)
        result.verbatimLatex = json.verbatimLatex;
      if (json.subsupPlacement)
        result.subsupPlacement = json.subsupPlacement;
      if (json.explicitSubsupPlacement)
        result.explicitSubsupPlacement = true;
      if (json.isFunction)
        result.isFunction = true;
      if (json.isExtensibleSymbol)
        result.isExtensibleSymbol = true;
      if (json.skipBoundary)
        result.skipBoundary = true;
      if (json.captureSelection)
        result.captureSelection = true;
      return result;
    }
    var ChoiceAtom = class extends Atom {
      constructor(choices, context) {
        super("choice", context);
        this.choices = choices;
        this.skipBoundary = true;
      }
      static fromJson(json, context) {
        return new ChoiceAtom(
          [
            fromJson(json.choices[0], context),
            fromJson(json.choices[1], context),
            fromJson(json.choices[2], context),
            fromJson(json.choices[3], context)
          ],
          context
        );
      }
      toJson() {
        const choices = [];
        for (const choice of this.choices) {
          choices.push(
            choice.filter((x) => x.type !== "first").map((x) => x.toJson())
          );
        }
        return __spreadProps(__spreadValues({}, super.toJson()), { choices });
      }
      render(context) {
        const box = Atom.createBox(
          context,
          this.choices[Math.floor(context.mathstyle.id / 2)]
        );
        if (!box)
          return null;
        if (this.caret)
          box.caret = this.caret;
        return this.bind(context, box);
      }
      serialize(options) {
        return `\\mathchoice{${Atom.serialize(
          this.choices[0],
          options
        )}}{${Atom.serialize(this.choices[1], options)}}{${Atom.serialize(
          this.choices[2],
          options
        )}}{${Atom.serialize(this.choices[3], options)}}`;
      }
    };
    defineFunction("mathtip", "{:math}{:math}", {
      createAtom: (name, args, style, context) => new TooltipAtom(args[0], args[1], context, {
        command: name,
        content: "math",
        style
      })
    });
    defineFunction("texttip", "{:math}{:text}", {
      createAtom: (name, args, style, context) => new TooltipAtom(args[0], args[1], context, {
        command: name,
        content: "text",
        style
      })
    });
    defineFunction("error", "{:math}", {
      createAtom: (_name, args, style, context) => new GroupAtom(args[0], context, {
        mode: "math",
        command: "\\error",
        customClass: "ML__error",
        style,
        serialize: (atom, options) => `\\error{${atom.bodyToLatex(options)}}`
      })
    });
    defineFunction("ensuremath", "{:math}", {
      createAtom: (_name, args, style, context) => new GroupAtom(args[0], context, {
        mode: "math",
        latexOpen: "\\ensuremath{",
        latexClose: "}",
        style
        // mathstyleName: 'textstyle',
      })
    });
    defineFunction("color", "{:string}", {
      applyStyle: (_name, args, context) => {
        var _a3, _b3;
        const color = args[0];
        return {
          verbatimColor: args[0],
          color: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
        };
      }
    });
    defineFunction("textcolor", "{:string}{content:auto*}", {
      applyStyle: (_name, args, context) => {
        var _a3, _b3;
        const color = args[0];
        return {
          verbatimColor: color,
          color: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
        };
      }
    });
    defineFunction("boxed", "{content:math}", {
      createAtom: (name, args, style, context) => new BoxAtom(name, args[0], context, {
        framecolor: "black",
        style
      })
    });
    defineFunction("colorbox", "{:string}{content:auto*}", {
      applyMode: "text",
      applyStyle: (_name, args, context) => {
        var _a3, _b3;
        const color = args[0];
        return {
          verbatimBackgroundColor: args[0],
          backgroundColor: (_b3 = (_a3 = context.backgroundColorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color
        };
      }
    });
    defineFunction(
      "fcolorbox",
      "{frame-color:string}{background-color:string}{content:auto}",
      {
        applyMode: "text",
        createAtom: (name, args, style, context) => {
          var _a3, _b3, _c2, _d2;
          const color = args[0];
          const bgColor = args[1];
          return new BoxAtom(name, args[2], context, {
            verbatimFramecolor: color,
            // Save this value to restore it verbatim later
            framecolor: (_b3 = (_a3 = context.colorMap) == null ? void 0 : _a3.call(context, color)) != null ? _b3 : color,
            verbatimBackgroundcolor: args[1],
            // Save this value to restore it verbatim later
            backgroundcolor: (_d2 = (_c2 = context.backgroundColorMap) == null ? void 0 : _c2.call(context, bgColor)) != null ? _d2 : bgColor,
            style,
            serialize: (atom, options) => {
              var _a4, _b4;
              return `${atom.command}{${(_a4 = atom.verbatimFramecolor) != null ? _a4 : atom.framecolor}{${(_b4 = atom.verbatimBackgroundcolor) != null ? _b4 : atom.backgroundcolor}}{${atom.bodyToLatex(options)}}`;
            }
          });
        }
      }
    );
    defineFunction("bbox", "[:bbox]{body:auto}", {
      createAtom: (name, args, style, context) => {
        if (args[0]) {
          const arg = args[0];
          return new BoxAtom(name, args[1], context, {
            padding: arg.padding,
            border: arg.border,
            backgroundcolor: arg.backgroundcolor,
            style,
            serialize: (atom, options) => {
              var _a3;
              let result = name;
              if (Number.isFinite(atom.padding) || atom.border !== void 0 || atom.backgroundcolor !== void 0) {
                const bboxParameters = [];
                if (atom.padding)
                  bboxParameters.push(atom.padding);
                if (atom.border)
                  bboxParameters.push(`border: ${atom.border}`);
                if (atom.verbatimBackgroundcolor || atom.backgroundcolor) {
                  bboxParameters.push(
                    (_a3 = atom.verbatimBackgroundcolor) != null ? _a3 : atom.backgroundcolor
                  );
                }
                result += `[${bboxParameters.join(",")}]`;
              }
              return result + `{${atom.bodyToLatex(options)}}`;
            }
          });
        }
        return new BoxAtom(name, args[1], context, { style });
      }
    });
    defineFunction(
      ["displaystyle", "textstyle", "scriptstyle", "scriptscriptstyle"],
      "{:rest}",
      {
        createAtom: (name, args, style, context) => new GroupAtom(args[0], context, {
          latexOpen: `{${name} `,
          latexClose: "}",
          style,
          mathstyleName: name.slice(1)
        })
      }
    );
    defineFunction(
      [
        "tiny",
        "scriptsize",
        "footnotesize",
        "small",
        "normalsize",
        "large",
        "Large",
        "LARGE",
        "huge",
        "Huge"
      ],
      "",
      {
        // TeX behaves very inconsistently when sizing commands are applied
        // to math mode. We allow sizing commands to be applied in both math and
        // text mode
        applyStyle: (name, _args) => {
          return {
            fontSize: {
              "\\tiny": 1,
              "\\scriptsize": 2,
              // Not to be confused with \scriptstyle
              "\\footnotesize": 3,
              "\\small": 4,
              "\\normalsize": 5,
              "\\large": 6,
              "\\Large": 7,
              "\\LARGE": 8,
              "\\huge": 9,
              "\\Huge": 10
            }[name]
          };
        }
      }
    );
    defineFunction("fontseries", "{:string}", {
      ifMode: "text",
      applyStyle: (_name, args) => {
        return { fontSeries: args[0] };
      }
    });
    defineFunction("fontshape", "{:string}", {
      ifMode: "text",
      applyStyle: (_name, args) => {
        return { fontShape: args[0] };
      }
    });
    defineFunction("fontfamily", "{:string}", {
      ifMode: "text",
      applyStyle: (_name, args) => {
        return { fontFamily: args[0] };
      }
    });
    defineFunction("selectfont", "", {
      ifMode: "text",
      applyStyle: (_name, _args) => {
        return {};
      }
    });
    defineFunction("bf", "", {
      applyStyle: (_name, _args) => {
        return { fontSeries: "b", fontShape: "n", fontFamily: "cmr" };
      }
    });
    defineFunction(["boldsymbol", "bm"], "{:math*}", {
      applyMode: "math",
      createAtom: (name, args, style, context) => new GroupAtom(args[0], context, {
        latexOpen: `${name}{`,
        latexClose: "}",
        style,
        customClass: "ML__boldsymbol"
      })
    });
    defineFunction("bold", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variantStyle: "bold" };
      }
    });
    defineFunction("bfseries", "", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontSeries: "b" };
      }
    });
    defineFunction("mdseries", "", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontSeries: "m" };
      }
    });
    defineFunction("upshape", "", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "n" };
      }
    });
    defineFunction("slshape", "", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "sl" };
      }
    });
    defineFunction("scshape", "", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "sc" };
      }
    });
    defineFunction("textbf", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontSeries: "b" };
      }
    });
    defineFunction("textmd", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontSeries: "m" };
      }
    });
    defineFunction("textup", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "n" };
      }
    });
    defineFunction("textnormal", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "n", fontSeries: "m" };
      }
    });
    defineFunction("textsl", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "sl" };
      }
    });
    defineFunction("textit", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "it" };
      }
    });
    defineFunction("textsc", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontShape: "sc" };
      }
    });
    defineFunction("textrm", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontFamily: "roman" };
      }
    });
    defineFunction("textsf", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontFamily: "sans-serif" };
      }
    });
    defineFunction("texttt", "{:text*}", {
      applyMode: "text",
      applyStyle: (_name, _args) => {
        return { fontFamily: "monospace" };
      }
    });
    defineFunction("mathbf", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "normal", variantStyle: "bold" };
      }
    });
    defineFunction("mathit", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "main", variantStyle: "italic" };
      }
    });
    defineFunction("mathnormal", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "normal", variantStyle: "italic" };
      }
    });
    defineFunction("mathbfit", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "main", variantStyle: "bolditalic" };
      }
    });
    defineFunction("mathrm", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "normal", variantStyle: "up" };
      }
    });
    defineFunction("mathsf", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "sans-serif", variantStyle: "up" };
      }
    });
    defineFunction("mathtt", "{:math*}", {
      applyMode: "math",
      applyStyle: (_name, _args) => {
        return { variant: "monospace", variantStyle: "up" };
      }
    });
    defineFunction("it", "", {
      applyStyle: (_name, _args) => {
        return {
          fontSeries: "m",
          fontShape: "it",
          fontFamily: "cmr",
          variantStyle: "italic"
          // For math mode
        };
      }
    });
    defineFunction("rmfamily", "", {
      applyStyle: (_name, _args) => {
        return { fontFamily: "roman" };
      }
    });
    defineFunction("sffamily", "", {
      applyStyle: (_name, _args) => {
        return { fontFamily: "sans-serif" };
      }
    });
    defineFunction("ttfamily", "", {
      applyStyle: (_name, _args) => {
        return { fontFamily: "monospace" };
      }
    });
    defineFunction(["Bbb", "mathbb"], "{:math*}", {
      applyStyle: (_name, _args) => {
        return { variant: "double-struck", variantStyle: "up" };
      }
    });
    defineFunction(["frak", "mathfrak"], "{:math*}", {
      applyStyle: (_name, _args) => {
        return { variant: "fraktur", variantStyle: "up" };
      }
    });
    defineFunction("mathcal", "{:math*}", {
      applyStyle: (_name, _args) => {
        return { variant: "calligraphic", variantStyle: "up" };
      }
    });
    defineFunction("mathscr", "{:math*}", {
      applyStyle: (_name, _args) => {
        return { variant: "script", variantStyle: "up" };
      }
    });
    defineFunction("mbox", "{:text}", {
      ifMode: "math",
      createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
        changeMode: true,
        style,
        mode: "text",
        command,
        serialize: (atom, options) => `\\mbox{${atom.bodyToLatex(__spreadProps(__spreadValues({}, options), {
          skipModeCommand: true
        }))}}`
      })
    });
    defineFunction("text", "{:text}", {
      ifMode: "math",
      applyMode: "text"
    });
    defineFunction("class", "{name:string}{content:auto*}", {
      createAtom: (_command, args, style, context) => new GroupAtom(args[1], context, {
        customClass: args[0],
        style
      })
    });
    defineFunction("cssId", "{id:string}{content:auto}", {
      createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
        cssId: args[0],
        style
      })
    });
    defineFunction("htmlData", "{data:string}{content:auto}", {
      createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
        htmlData: args[0],
        style
      })
    });
    defineFunction("htmlStyle", "{data:string}{content:auto}", {
      createAtom: (command, args, style, context) => new GroupAtom(args[1], context, {
        htmlStyle: args[0],
        style
      })
    });
    defineFunction("em", "{:auto*}", {
      createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
        latexOpen: "\\em",
        latexClose: "",
        customClass: "ML__emph",
        style
      })
    });
    defineFunction("emph", "{:auto}", {
      createAtom: (command, args, style, context) => new GroupAtom(args[0], context, {
        latexOpen: "\\emph{",
        latexClose: "}",
        customClass: "ML__emph",
        style
      })
    });
    var DELIMITER_SIZES = {
      "\\bigl": { mclass: "mopen", size: 1 },
      "\\Bigl": { mclass: "mopen", size: 2 },
      "\\biggl": { mclass: "mopen", size: 3 },
      "\\Biggl": { mclass: "mopen", size: 4 },
      "\\bigr": { mclass: "mclose", size: 1 },
      "\\Bigr": { mclass: "mclose", size: 2 },
      "\\biggr": { mclass: "mclose", size: 3 },
      "\\Biggr": { mclass: "mclose", size: 4 },
      "\\bigm": { mclass: "mrel", size: 1 },
      "\\Bigm": { mclass: "mrel", size: 2 },
      "\\biggm": { mclass: "mrel", size: 3 },
      "\\Biggm": { mclass: "mrel", size: 4 },
      "\\big": { mclass: "mord", size: 1 },
      "\\Big": { mclass: "mord", size: 2 },
      "\\bigg": { mclass: "mord", size: 3 },
      "\\Bigg": { mclass: "mord", size: 4 }
    };
    defineFunction(
      [
        "bigl",
        "Bigl",
        "biggl",
        "Biggl",
        "bigr",
        "Bigr",
        "biggr",
        "Biggr",
        "bigm",
        "Bigm",
        "biggm",
        "Biggm",
        "big",
        "Big",
        "bigg",
        "Bigg"
      ],
      "{:delim}",
      {
        createAtom: (name, args, style, context) => new SizedDelimAtom(name, args[0], context, {
          size: DELIMITER_SIZES[name].size,
          delimClass: DELIMITER_SIZES[name].mclass,
          style
        })
      }
    );
    defineFunction(
      [
        "hspace",
        "hspace*"
        // \hspace* inserts a non-breakable space, but since we don't line break...
        // it's the same as \hspace.
      ],
      "{width:glue}",
      {
        createAtom: (name, args, style, context) => {
          var _a3;
          return new SpacingAtom(
            name,
            style,
            context,
            (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
          );
        }
      }
    );
    defineFunction(
      [
        "mkern",
        "kern"
        // mkern accepts `mu` as a unit. We're lenient and
        // also accept it with `kern`
      ],
      "{width:glue}",
      {
        createAtom: (name, args, style, context) => {
          var _a3;
          return new SpacingAtom(
            name,
            style,
            context,
            (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
          );
        }
      }
    );
    defineFunction("mspace", "{width:glue}", {
      createAtom: (name, args, style, context) => {
        var _a3;
        return new SpacingAtom(
          name,
          style,
          context,
          (_a3 = args[0]) != null ? _a3 : { glue: { dimension: 0 } }
        );
      }
    });
    defineFunction("mathop", "{:auto}", {
      createAtom: (command, args, style, context) => new OperatorAtom(command, args[0], context, {
        type: "mop",
        captureSelection: true,
        limits: "over-under",
        isFunction: true,
        hasArgument: true,
        style
      })
    });
    defineFunction("mathchoice", "{:math}{:math}{:math}{:math}", {
      createAtom: (_command, args, _style, context) => new ChoiceAtom(args, context)
    });
    defineFunction(
      [
        "mathbin",
        "mathrel",
        "mathopen",
        "mathclose",
        "mathpunct",
        "mathord",
        "mathinner"
      ],
      "{:auto}",
      {
        createAtom: (command, args, style, context) => new OperatorAtom(command, args[0], context, {
          type: {
            "\\mathbin": "mbin",
            "\\mathrel": "mrel",
            "\\mathopen": "mopen",
            "\\mathclose": "mclose",
            "\\mathpunct": "mpunct",
            "\\mathord": "mord",
            "\\mathinner": "minner"
          }[command],
          captureSelection: true,
          hasArgument: true,
          style
        })
      }
    );
    defineFunction(["operatorname", "operatorname*"], "{operator:math}", {
      createAtom: (name, args, style, context) => {
        const result = new OperatorAtom(name, args[0], context, {
          isFunction: true,
          hasArgument: true,
          limits: name === "\\operatorname" ? "adjacent" : "over-under",
          style
        });
        result.captureSelection = true;
        if (result.body) {
          result.body.forEach((x) => {
            var _a3;
            if (x.type !== "first") {
              x.type = "mord";
              x.value = (_a3 = { "∗": "*", "−": "-" }[x.value]) != null ? _a3 : x.value;
              x.isFunction = false;
              if (!x.style.variant && !x.style.variantStyle) {
                x.style.variant = "main";
                x.style.variantStyle = "up";
              }
            }
          });
        }
        return result;
      }
    });
    var UnicodeAtom = class extends Atom {
      constructor(arg, style, context) {
        let codepoint = Number.parseInt(arg);
        if (!Number.isFinite(codepoint))
          codepoint = 10067;
        super("mord", context, {
          value: String.fromCodePoint(codepoint),
          style
        });
        this.codepoint = codepoint;
      }
      serialize(_options) {
        return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6);
      }
    };
    defineFunction("unicode", "{charcode:number}", {
      createAtom: (name, args, style, context) => new UnicodeAtom(args[0], style, context)
    });
    defineFunction("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", {
      createAtom: (name, args, style, context) => new RuleAtom(name, context, {
        shift: args[0],
        width: args[1],
        height: args[2],
        style
      })
    });
    defineFunction("overline", "{:auto}", {
      createAtom: (name, args, style, context) => new LineAtom(name, args[0], context, {
        position: "overline",
        style
      })
    });
    defineFunction("underline", "{:auto}", {
      createAtom: (name, args, style, context) => new LineAtom(name, args[0], context, {
        position: "underline",
        style
      })
    });
    defineFunction("overset", "{above:auto}{base:auto}", {
      createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
        above: args[0],
        body: args[1],
        skipBoundary: false,
        style,
        boxType: binRelType(args[1]),
        serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
      })
    });
    defineFunction("underset", "{below:auto}{base:auto}", {
      createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
        below: args[0],
        body: args[1],
        skipBoundary: false,
        style,
        boxType: binRelType(args[1]),
        serialize: (atom, options) => `${name}{${atom.belowToLatex(options)}}{${atom.bodyToLatex(options)}}`
      })
    });
    defineFunction("overunderset", "{above:auto}{below:auto}{base:auto}", {
      createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
        above: args[0],
        below: args[1],
        body: args[2],
        skipBoundary: false,
        style,
        boxType: binRelType(args[2]),
        serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
      })
    });
    defineFunction(
      ["stackrel", "stackbin"],
      "[below:auto]{above:auto}{base:auto}",
      {
        createAtom: (name, args, style, context) => new OverunderAtom(name, context, {
          body: args[2],
          above: args[1],
          below: args[0],
          skipBoundary: false,
          style,
          boxType: name === "\\stackrel" ? "mrel" : "mbin",
          serialize: (atom, options) => `${atom.command}{${atom.aboveToLatex(options)}}{${atom.bodyToLatex(options)}}`
        })
      }
    );
    defineFunction("smash", "[:string]{:auto}", {
      createAtom: (name, args, style, context) => {
        if (!args[0]) {
          return new PhantomAtom(name, args[1], context, {
            smashHeight: true,
            smashDepth: true,
            style
          });
        }
        return new PhantomAtom(name, args[1], context, {
          smashHeight: args[0].includes("t"),
          smashDepth: args[0].includes("b"),
          style
        });
      }
    });
    defineFunction(["vphantom"], "{:auto*}", {
      createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
        isInvisible: true,
        smashWidth: true,
        style
      })
    });
    defineFunction(["hphantom"], "{:auto*}", {
      createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
        isInvisible: true,
        smashHeight: true,
        smashDepth: true,
        style
      })
    });
    defineFunction(["phantom"], "{:auto*}", {
      createAtom: (name, args, style, context) => new PhantomAtom(name, args[1], context, {
        isInvisible: true,
        style
      })
    });
    defineFunction("not", "{:math}", {
      createAtom: (name, args, style, context) => {
        if (args.length < 1 || args[0] === null) {
          return new Atom("mrel", context, {
            command: name,
            style,
            value: ""
          });
        }
        const arg = args[0];
        return new GroupAtom(
          [
            new OverlapAtom(name, "", context, {
              align: "right",
              style,
              boxType: "mrel"
            }),
            ...arg
          ],
          context,
          {
            boxType: "mrel",
            captureSelection: true,
            command: "\\not",
            serialize: (_atom, options) => {
              const argLatex = Atom.serialize(arg, options);
              if (argLatex.length === 1 && !/[a-zA-Z]/.test(argLatex))
                return "\\not" + argLatex;
              return `\\not{${argLatex}}`;
            }
          }
        );
      }
    });
    defineFunction(["ne", "neq"], "", {
      createAtom: (name, _args, style, context) => new GroupAtom(
        [
          new OverlapAtom(name, "", context, {
            align: "right",
            style,
            boxType: "mrel"
          }),
          new Atom("mrel", context, { style, value: "=" })
        ],
        context,
        {
          boxType: "mrel",
          captureSelection: true,
          serialize: () => name,
          command: name
        }
      )
    });
    defineFunction("rlap", "{:auto}", {
      createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, {
        align: "right",
        style
      })
    });
    defineFunction("llap", "{:auto}", {
      createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, { style })
    });
    defineFunction("mathllap", "{:auto}", {
      createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, { style })
    });
    defineFunction("mathrlap", "{:auto}", {
      createAtom: (name, args, style, context) => new OverlapAtom(name, args[0], context, {
        align: "right",
        style
      })
    });
    newSymbols("0123456789/@.?!");
    newSymbolRange(65, 90);
    newSymbolRange(97, 122);
    newSymbols([
      ["\\forall", 8704],
      ["\\exists", 8707],
      ["\\nexists", 8708, "mord", "ams"],
      ["\\mid", 8739, "mrel"],
      ["\\top", 8868],
      ["\\bot", 8869]
    ]);
    newSymbols([
      ["\\sharp", 9839],
      ["\\flat", 9837],
      ["\\natural", 9838],
      ["\\#", 35],
      ["\\&", 38],
      ["\\clubsuit", 9827],
      ["\\heartsuit", 9825],
      ["\\spadesuit", 9824],
      ["\\diamondsuit", 9826],
      ["\\parallelogram", 9649]
    ]);
    newSymbols([
      ["\\backslash", 92],
      ["\\nabla", 8711],
      ["\\partial", 8706],
      ["\\ell", 8467],
      ["\\hbar", 8463],
      ["\\Q", 81, "mord", "double-struck"],
      // NOTE: Check if standard LaTeX
      ["\\C", 67, "mord", "double-struck"],
      // NOTE: Check if standard LaTeX
      ["\\P", 80, "mord", "double-struck"],
      // NOTE: Check if standard LaTeX
      ["\\pounds", 163],
      ["\\euro", 8364]
      // NOTE: not TeX built-in, but textcomp package
      // TODO Koppa, Stigma, Sampi
    ]);
    newSymbols(
      [
        ["\\rightarrow", 8594],
        ["\\to", 8594],
        ["\\leftarrow", 8592],
        ["\\gets", 8592],
        ["\\Rightarrow", 8658],
        ["\\Leftarrow", 8656],
        ["\\longrightarrow", 10230],
        ["\\longleftarrow", 10229],
        ["\\Longrightarrow", 10233],
        ["\\implies", 10233],
        ["\\Longleftarrow", 10232],
        ["\\impliedby", 10232],
        ["\\longleftrightarrow", 10231],
        ["\\biconditional", 10231],
        ["\\Longleftrightarrow", 10234],
        ["\\mapsto", 8614],
        ["\\longmapsto", 10236],
        ["\\uparrow", 8593],
        ["\\downarrow", 8595],
        ["\\Uparrow", 8657],
        ["\\Downarrow", 8659],
        ["\\updownarrow", 8597],
        ["\\Updownarrow", 8661],
        ["\\hookrightarrow", 8618],
        ["\\hookleftarrow", 8617],
        ["\\rightharpoonup", 8640],
        ["\\leftharpoonup", 8636],
        ["\\rightharpoondown", 8641],
        ["\\leftharpoondown", 8637],
        ["\\searrow", 8600],
        ["\\nearrow", 8599],
        ["\\swarrow", 8601],
        ["\\nwarrow", 8598],
        ["\\originalof", 8886],
        ["\\laplace", 8886],
        ["\\imageof", 8887],
        ["\\Laplace", 8887]
      ],
      "mrel"
    );
    newSymbols([
      // 'ams' Delimiters
      ["\\lbrace", 123, "mopen"],
      ["\\rbrace", 125, "mclose"],
      ["\\lparen", 40, "mopen"],
      ["\\rparen", 41, "mclose"],
      ["\\langle", 10216, "mopen"],
      ["\\rangle", 10217, "mclose"],
      ["\\lfloor", 8970, "mopen"],
      ["\\rfloor", 8971, "mclose"],
      ["\\lceil", 8968, "mopen"],
      ["\\rceil", 8969, "mclose"],
      ["\\vert", 8739],
      ["\\lvert", 8739, "mopen"],
      ["\\rvert", 8739, "mclose"],
      ["\\|", 8741],
      ["\\Vert", 8741],
      ["\\mVert", 8741],
      ["\\lVert", 8741, "mopen"],
      ["\\rVert", 8741, "mclose"],
      ["\\lbrack", 91, "mopen"],
      ["\\rbrack", 93, "mclose"],
      ["\\{", 123, "mopen"],
      ["\\}", 125, "mclose"],
      ["(", 40, "mopen"],
      [")", 41, "mclose"],
      ["[", 91, "mopen"],
      ["]", 93, "mclose"],
      ["\\ulcorner", 9484, "mopen", "ams"],
      ["\\urcorner", 9488, "mclose", "ams"],
      ["\\llcorner", 9492, "mopen", "ams"],
      ["\\lrcorner", 9496, "mclose", "ams"],
      // Large Delimiters
      ["\\lgroup", 10222, "mopen"],
      ["\\rgroup", 10223, "mclose"],
      ["\\lmoustache", 9136, "mopen"],
      ["\\rmoustache", 9137, "mclose"]
      // defineSymbol('\\ne', 0x2260, 'mrel'],
      // defineSymbol('\\neq', 0x2260, 'mrel'],
      // DefineSymbol( '\\longequal', 0xF7D9,  'mrel',  MAIN],   // NOTE: Not TeX
    ]);
    newSymbols(
      [
        // 'ams' arrows
        ["\\dashrightarrow", 8674],
        ["\\dashleftarrow", 8672],
        ["\\Rrightarrow", 8667],
        ["\\Lleftarrow", 8666],
        ["\\leftrightarrows", 8646],
        ["\\rightleftarrows", 8644],
        ["\\curvearrowright", 8631],
        ["\\curvearrowleft", 8630],
        ["\\rightrightarrows", 8649],
        ["\\leftleftarrows", 8647],
        ["\\upuparrows", 8648],
        ["\\downdownarrows", 8650],
        ["\\vartriangle", 9651],
        ["\\triangleq", 8796],
        ["\\vartriangleleft", 8882],
        ["\\trianglelefteq", 8884],
        ["\\ntriangleleft", 8938],
        ["\\ntrianglelefteq", 8940],
        ["\\vartriangleright", 8883],
        ["\\trianglerighteq", 8885],
        ["\\ntriangleright", 8939],
        ["\\ntrianglerighteq", 8941],
        ["\\blacktriangleleft", 9664],
        ["\\blacktriangleright", 9654],
        ["\\leftarrowtail", 8610],
        ["\\rightarrowtail", 8611],
        ["\\looparrowright", 8620],
        ["\\looparrowleft", 8619],
        ["\\twoheadleftarrow", 8606],
        ["\\twoheadrightarrow", 8608],
        ["\\rightleftharpoons", 8652],
        ["\\leftrightharpoons", 8651],
        ["\\Rsh", 8625],
        ["\\Lsh", 8624],
        // 'ams' Relations
        ["\\circlearrowright", 8635],
        ["\\circlearrowleft", 8634],
        ["\\restriction", 8638],
        ["\\upharpoonright", 8638],
        ["\\upharpoonleft", 8639],
        ["\\downharpoonright", 8642],
        ["\\downharpoonleft", 8643],
        ["\\rightsquigarrow", 8669],
        ["\\leadsto", 8669],
        ["\\leftrightsquigarrow", 8621],
        ["\\multimap", 8888],
        // 'ams' Negated Arrows
        ["\\nrightarrow", 8603],
        ["\\nleftarrow", 8602],
        ["\\nRightarrow", 8655],
        ["\\nLeftarrow", 8653],
        ["\\nleftrightarrow", 8622],
        ["\\nLeftrightarrow", 8654],
        // 'ams' Negated Relations
        ["\\shortparallel", 8741],
        ["\\nless", 8814],
        ["\\nleqslant", 57360],
        ["\\lneq", 10887],
        ["\\lneqq", 8808],
        ["\\nleqq", 57361],
        ["\\lvertneqq", 57356],
        ["\\lnsim", 8934],
        ["\\lnapprox", 10889],
        ["\\nprec", 8832],
        ["\\npreceq", 8928],
        ["\\precnsim", 8936],
        ["\\precnapprox", 10937],
        ["\\nsim", 8769],
        ["\\nshortmid", 57350],
        ["\\nmid", 8740],
        ["\\nvdash", 8876],
        ["\\nvDash", 8877],
        ["\\ngtr", 8815],
        ["\\ngeqslant", 57359],
        ["\\ngeqq", 57358],
        ["\\gneq", 10888],
        ["\\gneqq", 8809],
        ["\\gvertneqq", 57357],
        ["\\gnsim", 8935],
        ["\\gnapprox", 10890],
        ["\\nsucc", 8833],
        ["\\nsucceq", 8929],
        ["\\succnsim", 8937],
        ["\\succnapprox", 10938],
        ["\\ncong", 8774],
        ["\\nshortparallel", 57351],
        ["\\nparallel", 8742],
        ["\\nVDash", 8879],
        ["\\nsupseteqq", 57368],
        ["\\supsetneq", 8843],
        ["\\varsupsetneq", 57371],
        ["\\supsetneqq", 10956],
        ["\\varsupsetneqq", 57369],
        ["\\nVdash", 8878],
        ["\\precneqq", 10933],
        ["\\succneqq", 10934],
        ["\\nsubseteqq", 57366],
        ["\\leqslant", 10877],
        ["\\geqslant", 10878],
        ["\\gtrsim", 8819],
        ["\\approxeq", 8778],
        ["\\thickapprox", 8776],
        ["\\lessapprox", 10885],
        ["\\gtrapprox", 10886],
        ["\\precapprox", 10935],
        ["\\succapprox", 10936],
        ["\\thicksim", 8764],
        ["\\succsim", 8831],
        ["\\precsim", 8830],
        ["\\backsim", 8765],
        ["\\eqsim", 8770],
        ["\\backsimeq", 8909],
        ["\\lesssim", 8818],
        ["\\nleq", 8816],
        ["\\ngeq", 8817],
        ["\\smallsmile", 8995],
        ["\\smallfrown", 8994],
        ["\\leqq", 8806],
        ["\\eqslantless", 10901],
        ["\\lll", 8920],
        ["\\lessgtr", 8822],
        ["\\lesseqgtr", 8922],
        ["\\lesseqqgtr", 10891],
        ["\\risingdotseq", 8787],
        ["\\fallingdotseq", 8786],
        ["\\subseteqq", 10949],
        ["\\Subset", 8912],
        ["\\sqsubset", 8847],
        ["\\preccurlyeq", 8828],
        ["\\curlyeqprec", 8926],
        ["\\vDash", 8872],
        ["\\Vvdash", 8874],
        ["\\bumpeq", 8783],
        ["\\Bumpeq", 8782],
        ["\\geqq", 8807],
        ["\\eqslantgtr", 10902],
        ["\\ggg", 8921],
        ["\\gtrless", 8823],
        ["\\gtreqless", 8923],
        ["\\gtreqqless", 10892],
        ["\\supseteqq", 10950],
        ["\\Supset", 8913],
        ["\\sqsupset", 8848],
        ["\\succcurlyeq", 8829],
        ["\\curlyeqsucc", 8927],
        ["\\Vdash", 8873],
        ["\\shortmid", 8739],
        ["\\between", 8812],
        ["\\pitchfork", 8916],
        ["\\varpropto", 8733],
        ["\\backepsilon", 8717],
        ["\\llless", 8920],
        ["\\gggtr", 8921],
        ["\\doteqdot", 8785],
        ["\\Doteq", 8785],
        ["\\eqcirc", 8790],
        ["\\circeq", 8791],
        ["\\therefore", 8756],
        ["\\because", 8757]
      ],
      "mrel",
      "ams"
    );
    newSymbols(
      [
        ["+", 43],
        ["-", 8722],
        ["−", 8722],
        ["\\pm", 177],
        ["\\mp", 8723],
        ["*", 8727],
        ["\\times", 215],
        ["\\div", 247],
        ["\\divides", 8739],
        ["\\cdot", 8901],
        ["\\cap", 8745],
        ["\\cup", 8746],
        ["\\setminus", 8726],
        ["\\land", 8743],
        ["\\wedge", 8743],
        ["\\lor", 8744],
        ["\\vee", 8744],
        ["\\circ", 8728],
        ["\\bigcirc", 9711],
        ["\\bullet", 8729],
        ["\\oplus", 8853],
        ["\\ominus", 8854],
        ["\\otimes", 8855],
        ["\\odot", 8857],
        ["\\oslash", 8856],
        ["\\bigtriangleup", 9651],
        ["\\bigtriangledown", 9661],
        ["\\triangleleft", 9667],
        ["\\triangleright", 9657],
        ["\\And", 38],
        ["\\dagger", 8224],
        ["\\dag", 8224],
        ["\\ddag", 8225],
        ["\\ddagger", 8225],
        ["\\ast", 8727],
        ["\\star", 8902],
        ["\\bigstar", 9733],
        ["\\diamond", 8900]
      ],
      "mbin"
    );
    newSymbols(
      [
        ["\\lhd", 8882],
        ["\\rhd", 8883],
        ["\\lessdot", 8918],
        ["\\gtrdot", 8919],
        ["\\ltimes", 8905],
        ["\\rtimes", 8906],
        ["\\leftthreetimes", 8907],
        ["\\rightthreetimes", 8908],
        ["\\intercal", 8890],
        ["\\dotplus", 8724],
        ["\\doublebarwedge", 10846],
        ["\\divideontimes", 8903],
        ["\\centerdot", 8901],
        ["\\smallsetminus", 8726],
        ["\\barwedge", 8892],
        ["\\veebar", 8891],
        ["\\nor", 8891],
        // NOTE: Not TeX, Mathematica
        ["\\curlywedge", 8911],
        ["\\curlyvee", 8910],
        ["\\boxminus", 8863],
        ["\\boxplus", 8862],
        ["\\boxtimes", 8864],
        ["\\boxdot", 8865],
        ["\\circleddash", 8861],
        ["\\circledast", 8859],
        ["\\circledcirc", 8858],
        ["\\unlhd", 8884],
        ["\\unrhd", 8885]
      ],
      "mbin",
      "ams"
    );
    newSymbols([
      ["\\surd", 8730],
      // From MnSymbol package
      ["\\infty", 8734],
      ["\\prime", 8242],
      ["\\doubleprime", 8243],
      // NOTE: Not in TeX, but Mathematica
      ["\\angle", 8736],
      ["`", 8216],
      ["\\$", 36],
      ["\\%", 37],
      ["\\_", 95],
      // Note: In TeX, greek symbols are only available in Math mode
      ["\\alpha", 945],
      ["\\beta", 946],
      ["\\gamma", 947],
      ["\\delta", 948],
      ["\\epsilon", 1013],
      ["\\varepsilon", 949],
      ["\\zeta", 950],
      ["\\eta", 951],
      ["\\theta", 952],
      ["\\vartheta", 977],
      ["\\iota", 953],
      ["\\kappa", 954],
      ["\\varkappa", 1008, "mord", "ams"],
      ["\\lambda", 955],
      ["\\mu", 956],
      ["\\nu", 957],
      ["\\xi", 958],
      ["\\omicron", 111],
      ["\\pi", 960],
      ["\\varpi", 982],
      ["\\rho", 961],
      ["\\varrho", 1009],
      ["\\sigma", 963],
      ["\\varsigma", 962],
      ["\\tau", 964],
      ["\\phi", 981],
      ["\\varphi", 966],
      ["\\upsilon", 965],
      ["\\chi", 967],
      ["\\psi", 968],
      ["\\omega", 969],
      ["\\Gamma", 915],
      ["\\Delta", 916],
      ["\\Theta", 920],
      ["\\Lambda", 923],
      ["\\Xi", 926],
      ["\\Pi", 928],
      ["\\Sigma", 931],
      ["\\Upsilon", 933],
      ["\\Phi", 934],
      ["\\Psi", 936],
      ["\\Omega", 937],
      // 'ams' Greek
      ["\\digamma", 989, "mord", "ams"],
      ["\\emptyset", 8709]
    ]);
    newSymbols(
      [
        ["=", 61],
        ["<", 60],
        ["\\lt", 60],
        [">", 62],
        ["\\gt", 62],
        ["\\le", 8804],
        ["\\leq", 8804],
        ["\\ge", 8805],
        ["\\geq", 8805],
        ["\\ll", 8810],
        ["\\gg", 8811],
        ["\\coloneq", 8788],
        ["\\measeq", 8797],
        // MEASSURED BY
        ["\\eqdef", 8798],
        ["\\questeq", 8799],
        // QUESTIONED EQUAL TO
        [":", 58],
        ["\\cong", 8773],
        ["\\equiv", 8801],
        ["\\prec", 8826],
        ["\\preceq", 10927],
        ["\\succ", 8827],
        ["\\succeq", 10928],
        ["\\perp", 8869],
        ["\\propto", 8733],
        ["\\Colon", 8759],
        ["\\smile", 8995],
        ["\\frown", 8994],
        ["\\sim", 8764],
        ["\\doteq", 8784],
        ["\\bowtie", 8904],
        ["\\Join", 8904],
        ["\\asymp", 8781],
        ["\\sqsubseteq", 8849],
        ["\\sqsupseteq", 8850],
        ["\\approx", 8776],
        // In TeX, '~' is a spacing command (non-breaking space).
        // However, '~' is used as an ASCII Math shortctut character, so define a \\~
        // command which maps to the '~' character
        ["\\~", 126],
        ["\\leftrightarrow", 8596],
        ["\\Leftrightarrow", 8660],
        ["\\models", 8872],
        ["\\vdash", 8866],
        ["\\dashv", 8867],
        ["\\roundimplies", 10608],
        ["\\in", 8712],
        ["\\notin", 8713],
        // defineSymbol('\\not', 0x0338],
        // defineSymbol('\\not', 0xe020],
        ["\\ni", 8715],
        ["\\owns", 8715],
        ["\\subset", 8834],
        ["\\supset", 8835],
        ["\\subseteq", 8838],
        ["\\supseteq", 8839],
        ["\\differencedelta", 8710],
        ["\\mvert", 8739],
        ["\\parallel", 8741],
        ["\\simeq", 8771]
      ],
      "mrel"
    );
    newSymbols(
      [
        ["\\lnot", 172],
        ["\\neg", 172],
        ["\\triangle", 9651],
        ["\\subsetneq", 8842],
        ["\\varsubsetneq", 57370],
        ["\\subsetneqq", 10955],
        ["\\varsubsetneqq", 57367],
        ["\\nsubset", 8836],
        // NOTE: Not TeX?
        ["\\nsupset", 8837],
        // NOTE: Not TeX?
        ["\\nsubseteq", 8840],
        ["\\nsupseteq", 8841]
      ],
      "mrel",
      "ams"
    );
    newSymbols([
      ["\\wp", 8472],
      ["\\aleph", 8501]
    ]);
    newSymbols(
      [
        ["\\blacktriangle", 9650],
        ["\\hslash", 8463],
        ["\\Finv", 8498],
        ["\\Game", 8513],
        ["\\eth", 240],
        ["\\mho", 8487],
        ["\\Bbbk", 107],
        ["\\yen", 165],
        ["\\square", 9633],
        ["\\Box", 9633],
        ["\\blacksquare", 9632],
        ["\\circledS", 9416],
        ["\\circledR", 174],
        ["\\triangledown", 9661],
        ["\\blacktriangledown", 9660],
        ["\\checkmark", 10003],
        ["\\diagup", 9585],
        ["\\measuredangle", 8737],
        ["\\sphericalangle", 8738],
        ["\\backprime", 8245],
        ["\\backdoubleprime", 8246],
        ["\\Diamond", 9674],
        ["\\lozenge", 9674],
        ["\\blacklozenge", 10731],
        ["\\varnothing", 8709],
        ["\\complement", 8705],
        ["\\maltese", 10016],
        // 'ams' Hebrew
        ["\\beth", 8502],
        ["\\daleth", 8504],
        ["\\gimel", 8503]
      ],
      "mord",
      "ams"
    );
    newSymbols(
      [
        // See http://tex.stackexchange.com/questions/41476/lengths-and-when-to-use-them
        ["\\ ", 160],
        ["~", 160],
        ["\\space", 160]
      ],
      "space"
    );
    defineFunction(["!", ",", ":", ";", "enskip", "enspace", "quad", "qquad"], "", {
      createAtom: (command, _args, style, context) => new SpacingAtom(command, style, context)
    });
    newSymbols(
      [
        ["\\colon", 58],
        ["\\cdotp", 8901],
        ["\\vdots", 8942, "mord"],
        ["\\ldotp", 46],
        [",", 44],
        [";", 59]
      ],
      "mpunct"
    );
    newSymbols(
      [
        ["\\cdots", 8943],
        ["\\ddots", 8945],
        ["\\ldots", 8230],
        ["\\mathellipsis", 8230]
      ],
      "minner"
    );
    newSymbols([
      ["\\/", 47],
      ["|", 8739, "mord"],
      ["\\imath", 305],
      ["\\jmath", 567],
      ["\\degree", 176],
      ["'", 8242],
      // Prime
      ['"', 8221]
      // Double Prime
      // defineSymbol( "\'', 0x2033,  'mord',  MAIN],       // Double Prime
    ]);
    function compareSelection(a, b) {
      if (a.direction === b.direction) {
        const l = a.ranges.length;
        if (b.ranges.length === l) {
          let i = 0;
          while (i < l && compareRange(a.ranges[i], b.ranges[i]) === "equal")
            i++;
          return i === l ? "equal" : "different";
        }
      }
      return "different";
    }
    function compareRange(a, b) {
      if (a[0] === b[0] && a[1] === b[1])
        return "equal";
      return "different";
    }
    function range(selection) {
      let first = Infinity;
      let last = -Infinity;
      for (const range2 of selection.ranges) {
        first = Math.min(first, range2[0], range2[1]);
        last = Math.max(last, range2[0], range2[1]);
      }
      return [first, last];
    }
    function validateShortcut(siblings, shortcut) {
      if (!shortcut)
        return "";
      if (typeof shortcut === "string")
        return shortcut;
      if (!siblings || shortcut.after === void 0)
        return shortcut.value;
      let nothing = false;
      let letter = false;
      let digit = false;
      let isFunction2 = false;
      let frac = false;
      let surd = false;
      let binop = false;
      let relop = false;
      let operator = false;
      let punct = false;
      let array = false;
      let openfence = false;
      let closefence = false;
      let text = false;
      let space = false;
      let sibling = siblings[0];
      let index = 0;
      while (sibling && /msubsup|placeholder/.test(sibling.type)) {
        index += 1;
        sibling = siblings[index];
      }
      nothing = !sibling || sibling.type === "first";
      if (sibling) {
        text = sibling.mode === "text";
        letter = !text && sibling.type === "mord" && LETTER.test(sibling.value);
        digit = !text && sibling.type === "mord" && /\d+$/.test(sibling.value);
        isFunction2 = !text && sibling.isFunction;
        frac = sibling.type === "genfrac";
        surd = sibling.type === "surd";
        binop = sibling.type === "mbin";
        relop = sibling.type === "mrel";
        operator = sibling.type === "mop";
        punct = sibling.type === "mpunct" || sibling.type === "minner";
        array = sibling.type === "array";
        openfence = sibling.type === "mopen";
        closefence = sibling.type === "mclose" || sibling.type === "leftright";
        space = sibling.type === "space";
      }
      if (shortcut.after.includes("nothing") && nothing || shortcut.after.includes("letter") && letter || shortcut.after.includes("digit") && digit || shortcut.after.includes("function") && isFunction2 || shortcut.after.includes("frac") && frac || shortcut.after.includes("surd") && surd || shortcut.after.includes("binop") && binop || shortcut.after.includes("relop") && relop || shortcut.after.includes("operator") && operator || shortcut.after.includes("punct") && punct || shortcut.after.includes("array") && array || shortcut.after.includes("openfence") && openfence || shortcut.after.includes("closefence") && closefence || shortcut.after.includes("text") && text || shortcut.after.includes("space") && space)
        return shortcut.value;
      return "";
    }
    function getInlineShortcut(context, s, shortcuts) {
      if (!shortcuts)
        return "";
      return validateShortcut(context, shortcuts[s]);
    }
    var INLINE_SHORTCUTS = {
      "&": "\\&",
      "%": "\\%",
      // Primes
      "''": "^{\\doubleprime}",
      // Greek letters
      "alpha": "\\alpha",
      "delta": "\\delta",
      "Delta": "\\Delta",
      "pi": "\\pi",
      "Pi": "\\Pi",
      "theta": "\\theta",
      "Theta": "\\Theta",
      // Letter-like
      "ii": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\imaginaryI"
      },
      "jj": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\imaginaryJ"
      },
      "ee": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\exponentialE"
      },
      "nabla": "\\nabla",
      "grad": "\\nabla",
      "del": "\\partial",
      "deg": { after: "digit+space", value: "\\degree" },
      "infty": "\\infty",
      "∞": "\\infty",
      // @TODO: doesn't work
      // '&infin;': '\\infty',
      // '&#8734;': '\\infty',
      "oo": {
        after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space",
        value: "\\infty"
      },
      // Big operators
      "∑": "\\sum",
      "sum": "\\sum_{#?}^{#?}",
      "int": "\\int_{#?}^{#?}",
      "prod": "\\prod_{#?}^{#?}",
      "sqrt": "\\sqrt{#?}",
      // '∫':                    '\\int',             // There's a alt-B command for this
      "∆": "\\differentialD",
      // @TODO: is \\diffD most common?
      "∂": "\\differentialD",
      // Functions
      "arcsin": "\\arcsin",
      "arccos": "\\arccos",
      "arctan": "\\arctan",
      "arcsec": "\\arcsec",
      "arccsc": "\\arccsc",
      "arsinh": "\\arsinh",
      "arcosh": "\\arcosh",
      "artanh": "\\artanh",
      "arcsech": "\\arcsech",
      "arccsch": "\\arccsch",
      "arg": "\\arg",
      "ch": "\\ch",
      "cosec": "\\cosec",
      "cosh": "\\cosh",
      "cot": "\\cot",
      "cotg": "\\cotg",
      "coth": "\\coth",
      "csc": "\\csc",
      "ctg": "\\ctg",
      "cth": "\\cth",
      "sec": "\\sec",
      "sinh": "\\sinh",
      "sh": "\\sh",
      "tanh": "\\tanh",
      "tg": "\\tg",
      "th": "\\th",
      "sin": "\\sin",
      "cos": "\\cos",
      "tan": "\\tan",
      "lg": "\\lg",
      "lb": "\\lb",
      "log": "\\log",
      "ln": "\\ln",
      "exp": "\\exp",
      "lim": "\\lim_{#?}",
      // Differentials
      // According to ISO31/XI (ISO 80000-2), differentials should be upright
      "dx": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD x"
      },
      "dy": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD y"
      },
      "dt": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\differentialD t"
      },
      // Logic
      "AA": "\\forall",
      "EE": "\\exists",
      "!EE": "\\nexists",
      "&&": "\\land",
      // The shortcut for the greek letter "xi" is interfering with "x in"
      "xin": {
        after: "nothing+text+relop+punct+openfence+space",
        value: "x \\in"
      },
      "in": {
        after: "nothing+letter+closefence",
        value: "\\in"
      },
      "!in": "\\notin",
      // Sets
      "NN": "\\mathbb{N}",
      // Natural numbers
      "ZZ": "\\Z",
      // Integers
      "QQ": "\\Q",
      // Rational numbers
      "RR": "\\R",
      // Real numbers
      "CC": "\\C",
      // Complex numbers
      // Operators
      "xx": "\\times",
      "+-": "\\pm",
      // Relational operators
      "≠": "\\ne",
      "!=": "\\ne",
      "≥": "\\ge",
      ">=": "\\ge",
      "≤": "\\le",
      "<=": "\\le",
      "<<": "\\ll",
      ">>": "\\gg",
      "~~": "\\approx",
      // More operators
      "≈": "\\approx",
      "?=": "\\questeq",
      "÷": "\\div",
      "¬": "\\neg",
      ":=": "\\coloneq",
      "::": "\\Colon",
      // Fences
      "(:": "\\langle",
      ":)": "\\rangle",
      // More Greek letters
      "beta": "\\beta",
      "chi": "\\chi",
      "epsilon": "\\epsilon",
      "varepsilon": "\\varepsilon",
      "eta": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\eta"
      },
      "gamma": "\\gamma",
      "Gamma": "\\Gamma",
      "iota": "\\iota",
      "kappa": "\\kappa",
      "lambda": "\\lambda",
      "Lambda": "\\Lambda",
      "mu": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\mu"
      },
      "nu": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\nu"
      },
      "µ": "\\mu",
      // @TODO: or micro?
      "phi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\phi"
      },
      "Phi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Phi"
      },
      "varphi": "\\varphi",
      "psi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\psi"
      },
      "Psi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Psi"
      },
      "rho": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\rho"
      },
      "sigma": "\\sigma",
      "Sigma": "\\Sigma",
      "tau": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\tau"
      },
      "vartheta": "\\vartheta",
      "upsilon": "\\upsilon",
      "xi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space",
        value: "\\xi"
      },
      "Xi": {
        after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text",
        value: "\\Xi"
      },
      "zeta": "\\zeta",
      "omega": "\\omega",
      "Omega": "\\Omega",
      "Ω": "\\omega",
      // @TODO: or ohm?
      // More Logic
      "forall": "\\forall",
      "exists": "\\exists",
      "!exists": "\\nexists",
      ":.": "\\therefore",
      // MORE FUNCTIONS
      // 'arg': '\\arg',
      "liminf": "\\liminf_{#?}",
      "limsup": "\\limsup_{#?}",
      "argmin": "\\operatorname*{arg~min}_{#?}",
      "argmax": "\\operatorname*{arg~max}_{#?}",
      "det": "\\det",
      "mod": "\\mod",
      "max": "\\max",
      "min": "\\min",
      "erf": "\\operatorname{erf}",
      "erfc": "\\operatorname{erfc}",
      "bessel": "\\operatorname{bessel}",
      "mean": "\\operatorname{mean}",
      "median": "\\operatorname{median}",
      "fft": "\\operatorname{fft}",
      "lcm": "\\operatorname{lcm}",
      "gcd": "\\operatorname{gcd}",
      "randomReal": "\\operatorname{randomReal}",
      "randomInteger": "\\operatorname{randomInteger}",
      "Re": "\\operatorname{Re}",
      "Im": "\\operatorname{Im}",
      // UNITS
      "mm": {
        after: "nothing+digit+operator",
        value: "\\operatorname{mm}"
        // Millimeter
      },
      "cm": {
        after: "nothing+digit+operator",
        value: "\\operatorname{cm}"
        // Centimeter
      },
      "km": {
        after: "nothing+digit+operator",
        value: "\\operatorname{km}"
        // Kilometer
      },
      "kg": {
        after: "nothing+digit+operator",
        value: "\\operatorname{kg}"
        // Kilogram
      },
      // '||':                   '\\lor',
      "...": "\\ldots",
      // In general, use \ldots
      "+...": "+\\cdots",
      // ... but use \cdots after + ...
      "-...": "-\\cdots",
      // ... - and ...
      "->...": "\\to\\cdots",
      // ->
      "->": "\\to",
      "|->": "\\mapsto",
      "-->": "\\longrightarrow",
      //    '<-':                   '\\leftarrow',
      "<--": "\\longleftarrow",
      "=>": "\\Rightarrow",
      "==>": "\\Longrightarrow",
      // '<=': '\\Leftarrow',     // CONFLICTS WITH LESS THAN OR EQUAL
      "<=>": "\\Leftrightarrow",
      "<->": "\\leftrightarrow",
      "(.)": "\\odot",
      "(+)": "\\oplus",
      "(/)": "\\oslash",
      "(*)": "\\otimes",
      "(-)": "\\ominus",
      // '(-)':                  '\\circleddash',
      "||": "\\Vert",
      "{": "\\{",
      "}": "\\}",
      "*": "\\cdot"
      /*
          //
          // ASCIIIMath
          //
          // Binary operation symbols
          '**':                   '\\ast',
          '***':                  '\\star',
          '//':                   '\\slash',
          '\\\\':                 '\\backslash',
          'setminus':             '\\backslash',
          '|><':                  '\\ltimes',
          '><|':                  '\\rtimes',
          '|><|':                 '\\bowtie',
          '-:':                   '\\div',
          'divide':               '\\div',
          '@':                    '\\circ',
          'o+':                   '\\oplus',
          'ox':                   '\\otimes',
          'o.':                   '\\odot',
          '^^':                   '\\wedge',
          '^^^':                  '\\bigwedge',
          'vv':                   '\\vee',
          'vvv':                  '\\bigvee',
          'nn':                   '\\cap',
          'nnn':                  '\\bigcap',
          'uu':                   '\\cup',
          'uuu':                  '\\bigcup',
      
          // Binary relation symbols
          '-=':                   '\\equiv',
          '~=':                   '\\cong',
          'lt':                   '<',
          'lt=':                  '\\leq',
          'gt':                   '>',
          'gt=':                  '\\geq',
          '-<':                   '\\prec',
          '-lt':                  '\\prec',
          '-<=':                  '\\preceq',
          // '>-':                   '\\succ',
          '>-=':                  '\\succeq',
          'prop':                 '\\propto',
          'diamond':              '\\diamond',
          'square':               '\\square',
          'iff':                  '\\iff',
      
          'sub':                  '\\subset',
          'sup':                  '\\supset',
          'sube':                 '\\subseteq',
          'supe':                 '\\supseteq',
          'uarr':                 '\\uparrow',
          'darr':                 '\\downarrow',
          'rarr':                 '\\rightarrow',
          'rArr':                 '\\Rightarrow',
          'larr':                 '\\leftarrow',
          'lArr':                 '\\Leftarrow',
          'harr':                 '\\leftrightarrow',
          'hArr':                 '\\Leftrightarrow',
          'aleph':                '\\aleph',
      
          // Logic
          'and':                  '\\land',
          'or':                   '\\lor',
          'not':                  '\\neg',
          '_|_':                   '\\bot',
          'TT':                   '\\top',
          '|--':                  '\\vdash',
          '|==':                  '\\models',
          
          // Other functions
          '|__':                  '\\lfloor',
          '__|':                  '\\rfloor',
      
          '|~':                   '\\lceil',
          '~|':                   '\\rceil',
      
          // Arrows
          '>->':                   '\\rightarrowtail',
          '->>':                   '\\twoheadrightarrow',
          '>->>':                  '\\twoheadrightarrowtail'
      */
    };
    function parseMathString(s, options) {
      var _a3;
      let format = (_a3 = options == null ? void 0 : options.format) != null ? _a3 : "auto";
      if (format === "auto")
        [format, s] = inferFormat(s);
      if (format === "ascii-math") {
        s = s.replace(/\u2061/gu, "");
        s = s.replace(/\u3016/gu, "{");
        s = s.replace(/\u3017/gu, "}");
        s = s.replace(/([^\\])sinx/g, "$1\\sin x");
        s = s.replace(/([^\\])cosx/g, "$1\\cos x ");
        s = s.replace(/\u2013/g, "-");
        return [
          "ascii-math",
          parseMathExpression(s, { inlineShortcuts: options == null ? void 0 : options.inlineShortcuts })
        ];
      }
      return ["latex", s];
    }
    function parseMathExpression(s, options) {
      var _a3, _b3, _c2;
      if (!s)
        return "";
      let done = false;
      let m;
      const inlineShortcuts = (_a3 = options.inlineShortcuts) != null ? _a3 : INLINE_SHORTCUTS;
      if (!done && (s.startsWith("^") || s.startsWith("_"))) {
        m = parseMathArgument(s.slice(1), { inlineShortcuts, noWrap: true });
        s = s[0] + "{" + m.match + "}";
        s += parseMathExpression(m.rest, options);
        done = true;
      }
      if (!done) {
        m = s.match(/^(sqrt|\u221A)(.*)/);
        if (m) {
          m = parseMathArgument(m[2], { inlineShortcuts, noWrap: true });
          const sqrtArgument = (_b3 = m.match) != null ? _b3 : "\\placeholder{}";
          s = "\\sqrt{" + sqrtArgument + "}";
          s += parseMathExpression(m.rest, options);
          done = true;
        }
      }
      if (!done) {
        m = s.match(/^(\\cbrt|\u221B)(.*)/);
        if (m) {
          m = parseMathArgument(m[2], { inlineShortcuts, noWrap: true });
          const sqrtArgument = (_c2 = m.match) != null ? _c2 : "\\placeholder{}";
          s = "\\sqrt[3]{" + sqrtArgument + "}";
          s += parseMathExpression(m.rest, options);
          done = true;
        }
      }
      if (!done) {
        m = s.match(/^abs(.*)/);
        if (m) {
          m = parseMathArgument(m[1], { inlineShortcuts, noWrap: true });
          s = "\\left|" + m.match + "\\right|";
          s += parseMathExpression(m.rest, options);
          done = true;
        }
      }
      if (!done) {
        m = s.match(/^["”“](.*?)["”“](.*)/);
        if (m) {
          s = "\\text{" + m[1] + "}";
          s += parseMathExpression(m[2], options);
          done = true;
        }
      }
      if (!done) {
        m = s.match(/^([^a-zA-Z\(\{\[\_\^\\\s"]+)(.*)/);
        if (m) {
          s = paddedShortcut(m[1], inlineShortcuts);
          s += parseMathExpression(m[2], options);
          done = true;
        }
      }
      if (!done && /^([fgh])[^a-zA-Z]/.test(s)) {
        m = parseMathArgument(s.slice(1), { inlineShortcuts, noWrap: true });
        s = s[1] === "(" ? s[0] + "\\left(" + m.match + "\\right)" : s[0] + m.match;
        s += parseMathExpression(m.rest, options);
        done = true;
      }
      if (!done) {
        m = s.match(/^([a-zA-Z]+)(.*)/);
        if (m) {
          s = paddedShortcut(m[1], inlineShortcuts);
          s += parseMathExpression(m[2], options);
          done = true;
        }
      }
      if (!done) {
        m = parseMathArgument(s, { inlineShortcuts, noWrap: true });
        if (m.match && m.rest[0] === "/") {
          const m2 = parseMathArgument(m.rest.slice(1), {
            inlineShortcuts,
            noWrap: true
          });
          if (m2.match) {
            s = "\\frac{" + m.match + "}{" + m2.match + "}" + parseMathExpression(m2.rest, options);
          }
          done = true;
        } else if (m.match) {
          s = s.startsWith("(") ? "\\left(" + m.match + "\\right)" + parseMathExpression(m.rest, options) : m.match + parseMathExpression(m.rest, options);
          done = true;
        }
      }
      if (!done) {
        m = s.match(/^(\s+)(.*)$/);
        if (m) {
          s = " " + parseMathExpression(m[2], options);
          done = true;
        }
      }
      return s;
    }
    function parseMathArgument(s, options) {
      let match = "";
      s = s.trim();
      let rest = s;
      let lFence = s.charAt(0);
      let rFence = { "(": ")", "{": "}", "[": "]" }[lFence];
      if (rFence) {
        let level = 1;
        let i = 1;
        while (i < s.length && level > 0) {
          if (s[i] === lFence)
            level++;
          if (s[i] === rFence)
            level--;
          i++;
        }
        if (level === 0) {
          if (options.noWrap && lFence === "(")
            match = parseMathExpression(s.substring(1, i - 1), options);
          else {
            if (lFence === "{" && rFence === "}") {
              lFence = "\\{";
              rFence = "\\}";
            }
            match = "\\left" + lFence + parseMathExpression(s.substring(1, i - 1), options) + "\\right" + rFence;
          }
          rest = s.slice(Math.max(0, i));
        } else {
          match = s.substring(1, i);
          rest = "";
        }
      } else {
        let m = s.match(/^([a-zA-Z]+)/);
        if (m) {
          let shortcut = getInlineShortcut(null, s, options.inlineShortcuts);
          if (shortcut) {
            shortcut = shortcut.replace("_{#?}", "");
            shortcut = shortcut.replace("^{#?}", "");
            return { match: shortcut, rest: s.slice(shortcut.length) };
          }
        }
        m = s.match(/^([a-zA-Z])/);
        if (m) {
          return { match: m[1], rest: s.slice(1) };
        }
        m = s.match(/^(-)?\d+(\.\d*)?/);
        if (m) {
          return { match: m[0], rest: s.slice(m[0].length) };
        }
        if (!/^\\(left|right)/.test(s)) {
          m = s.match(/^(\\[a-zA-Z]+)/);
          if (m) {
            rest = s.slice(m[1].length);
            match = m[1];
          }
        }
      }
      return { match, rest };
    }
    function paddedShortcut(s, shortcuts) {
      let result = getInlineShortcut(null, s, shortcuts);
      if (result) {
        result = result.replace("_{#?}", "");
        result = result.replace("^{#?}", "");
        result += " ";
      } else
        result = s;
      return result;
    }
    var MODE_SHIFT_COMMANDS = [
      ["\\[", "\\]"],
      ["\\(", "\\)"],
      ["$$", "$$"],
      ["$", "$"],
      // Must be *after* $$..$$
      ["\\begin{math}", "\\end{math}"],
      ["\\begin{displaymath}", "\\end{displaymath}"],
      ["\\begin{equation}", "\\end{equation}"],
      ["\\begin{equation*}", "\\end{equation*}"]
    ];
    function trimModeShiftCommand(s) {
      const trimedString = s.trim();
      for (const mode of MODE_SHIFT_COMMANDS) {
        if (trimedString.startsWith(mode[0]) && trimedString.endsWith(mode[1])) {
          return [
            true,
            trimedString.substring(
              mode[0].length,
              trimedString.length - mode[1].length
            )
          ];
        }
      }
      return [false, s];
    }
    function inferFormat(s) {
      s = s.trim();
      if (s.length <= 1)
        return ["latex", s];
      let hasLatexModeShiftCommand;
      [hasLatexModeShiftCommand, s] = trimModeShiftCommand(s);
      if (hasLatexModeShiftCommand)
        return ["latex", s];
      if (s.startsWith("`") && s.endsWith("`")) {
        s = s.substring(1, s.length - 1);
        return ["ascii-math", s];
      }
      if (s.includes("\\")) {
        return ["latex", s];
      }
      if (/\$.+\$/.test(s)) {
        return ["latex", `\\text{${s}}`];
      }
      return [void 0, s];
    }
    var CLIPBOARD_LATEX_BEGIN = "$$";
    var CLIPBOARD_LATEX_END = "$$";
    var defaultExportHook = (_from, latex, _range) => {
      if (!MODE_SHIFT_COMMANDS.some(
        (x) => latex.startsWith(x[0]) && latex.endsWith(x[1])
      ))
        latex = `${CLIPBOARD_LATEX_BEGIN} ${latex} ${CLIPBOARD_LATEX_END}`;
      return latex;
    };
    var _ModeEditor = class {
      constructor(name) {
        _ModeEditor._registry[name] = this;
      }
      static onPaste(mode, mathfield, data) {
        var _a3;
        if (!mathfield.contentEditable && mathfield.userSelect === "none") {
          mathfield.model.announce("plonk");
          return false;
        }
        if (typeof data === "string") {
          const dataTransfer = new DataTransfer();
          dataTransfer.setData("text/plain", data);
          data = dataTransfer;
        }
        const redispatchedEvent = new ClipboardEvent("paste", {
          clipboardData: data,
          cancelable: true
        });
        if (!((_a3 = mathfield.host) == null ? void 0 : _a3.dispatchEvent(redispatchedEvent)))
          return false;
        return _ModeEditor._registry[mode].onPaste(mathfield, data);
      }
      static onCopy(mathfield, ev) {
        if (!ev.clipboardData)
          return;
        if (!mathfield.contentEditable && mathfield.userSelect === "none") {
          mathfield.model.announce("plonk");
          return;
        }
        const model = mathfield.model;
        const exportRange = model.selectionIsCollapsed ? [0, model.lastOffset] : range(model.selection);
        let atoms = model.getAtoms(exportRange);
        if (atoms.every((x) => x.mode === "text" || !x.mode)) {
          ev.clipboardData.setData(
            "text/plain",
            atoms.filter((x) => x instanceof TextAtom).map((x) => x.value).join("")
          );
        } else if (atoms.every((x) => x.mode === "latex")) {
          ev.clipboardData.setData(
            "text/plain",
            model.getAtoms(exportRange, { includeChildren: true }).map((x) => {
              var _a3;
              return (_a3 = x.value) != null ? _a3 : "";
            }).join("")
          );
        } else {
          let latex;
          if (atoms.length === 1 && atoms[0].verbatimLatex !== void 0)
            latex = atoms[0].verbatimLatex;
          else
            latex = model.getValue(exportRange, "latex-expanded");
          ev.clipboardData.setData("application/x-latex", latex);
          try {
            ev.clipboardData.setData(
              "text/plain",
              mathfield.options.onExport(mathfield, latex, exportRange)
            );
          } catch (e) {
          }
          if (atoms.length === 1 && (atoms[0].type === "root" || atoms[0].type === "group"))
            atoms = atoms[0].body.filter((x) => x.type !== "first");
          try {
            ev.clipboardData.setData(
              "application/json+mathlive",
              JSON.stringify(atoms.map((x) => x.toJson()))
            );
          } catch (e) {
          }
          const ce = window.MathfieldElement.computeEngine;
          if (ce) {
            try {
              ce.jsonSerializationOptions = { metadata: ["latex"] };
              const expr = ce.parse(latex);
              const mathJson = JSON.stringify(expr.json);
              if (mathJson)
                ev.clipboardData.setData("application/json", mathJson);
            } catch (e) {
            }
          }
        }
        ev.preventDefault();
      }
      static insert(mode, model, text, options = {}) {
        return _ModeEditor._registry[mode].insert(model, text, options);
      }
      // eslint-disable-next-line @typescript-eslint/no-empty-function
      onPaste(_mathfield, _data) {
        return false;
      }
      insert(_model, _text, _options) {
        return false;
      }
    };
    var ModeEditor = _ModeEditor;
    ModeEditor._registry = {};
    var DEFAULT_KEYBINDINGS = [
      { key: "left", command: "moveToPreviousChar" },
      { key: "right", command: "moveToNextChar" },
      { key: "up", command: "moveUp" },
      { key: "down", command: "moveDown" },
      { key: "shift+[ArrowLeft]", command: "extendSelectionBackward" },
      { key: "shift+[ArrowRight]", command: "extendSelectionForward" },
      { key: "shift+[ArrowUp]", command: "extendSelectionUpward" },
      { key: "shift+[ArrowDown]", command: "extendSelectionDownward" },
      { key: "[Backspace]", command: "deleteBackward" },
      { key: "alt+[Delete]", command: "deleteBackward" },
      { key: "[Delete]", command: "deleteForward" },
      { key: "alt+[Backspace]", command: "deleteForward" },
      { key: "alt+[ArrowLeft]", command: "moveToPreviousWord" },
      { key: "alt+[ArrowRight]", command: "moveToNextWord" },
      { key: "shift+alt+[ArrowLeft]", command: "extendToPreviousWord" },
      { key: "shift+alt+[ArrowRight]", command: "extendToNextWord" },
      { key: "ctrl+[ArrowLeft]", command: "moveToGroupStart" },
      { key: "ctrl+[ArrowRight]", command: "moveToGroupEnd" },
      { key: "shift+ctrl+[ArrowLeft]", command: "extendToGroupStart" },
      { key: "shift+ctrl+[ArrowRight]", command: "extendToGroupEnd" },
      { key: "[Space]", ifMode: "math", command: "moveAfterParent" },
      { key: "shift+[Space]", ifMode: "math", command: "moveBeforeParent" },
      { key: "[Home]", command: "moveToMathfieldStart" },
      { key: "cmd+[ArrowLeft]", command: "moveToMathfieldStart" },
      { key: "shift+[Home]", command: "extendToMathFieldStart" },
      { key: "shift+cmd+[ArrowLeft]", command: "extendToMathFieldStart" },
      { key: "[End]", command: "moveToMathfieldEnd" },
      { key: "cmd+[ArrowRight]", command: "moveToMathfieldEnd" },
      { key: "shift+[End]", command: "extendToMathFieldEnd" },
      { key: "shift+cmd+[ArrowRight]", command: "extendToMathFieldEnd" },
      { key: "[Pageup]", command: "moveToGroupStart" },
      { key: "[Pagedown]", command: "moveToGroupEnd" },
      { key: "[Tab]", ifMode: "math", command: "moveToNextPlaceholder" },
      {
        key: "shift+[Tab]",
        ifMode: "math",
        command: "moveToPreviousPlaceholder"
      },
      { key: "[Tab]", ifMode: "text", command: "moveToNextPlaceholder" },
      {
        key: "shift+[Tab]",
        ifMode: "text",
        command: "moveToPreviousPlaceholder"
      },
      { key: "[Escape]", ifMode: "math", command: ["switchMode", "latex"] },
      { key: "[Escape]", ifMode: "text", command: ["switchMode", "latex"] },
      {
        key: "[Escape]",
        ifMode: "latex",
        command: ["complete", "complete", { selectItem: "true" }]
      },
      // Accept the entry (without the suggestion) and select
      {
        key: "\\",
        ifMode: "math",
        command: ["switchMode", "latex", "\\"]
      },
      // { key: '[Backslash]', ifMode: 'math', command: ['switchMode', 'latex'] },
      {
        key: "[IntlBackslash]",
        ifMode: "math",
        command: ["switchMode", "latex", "\\"]
      },
      // On UK QWERTY keyboards
      {
        key: "[Tab]",
        ifMode: "latex",
        command: ["complete", "accept-suggestion"]
      },
      // Complete the suggestion
      { key: "[Return]", ifMode: "latex", command: "complete" },
      { key: "[Enter]", ifMode: "latex", command: "complete" },
      {
        key: "shift+[Escape]",
        ifMode: "latex",
        command: ["complete", "reject"]
      },
      // Some keyboards can't generate
      // this combination, for example in 60% keyboards it is mapped to ~
      { key: "[ArrowDown]", ifMode: "latex", command: "nextSuggestion" },
      // { key: 'ios:command:[Tab]', ifMode: 'latex',command: 'nextSuggestion' },
      { key: "[ArrowUp]", ifMode: "latex", command: "previousSuggestion" },
      { key: "ctrl+a", ifPlatform: "!macos", command: "selectAll" },
      { key: "cmd+a", command: "selectAll" },
      // Rare keys on some extended keyboards
      { key: "[Cut]", command: "cutToClipboard" },
      { key: "[Copy]", command: "copyToClipboard" },
      { key: "[Paste]", command: "pasteFromClipboard" },
      { key: "[Clear]", command: "deleteBackward" },
      { key: "[Undo]", command: "undo" },
      { key: "[Redo]", command: "redo" },
      { key: "[EraseEof]", command: "deleteToGroupEnd" },
      { key: "ctrl+x", command: "cutToClipboard" },
      { key: "cmd+x", command: "cutToClipboard" },
      { key: "ctrl+c", command: "copyToClipboard" },
      { key: "cmd+c", command: "copyToClipboard" },
      { key: "ctrl+v", command: "pasteFromClipboard" },
      { key: "cmd+v", command: "pasteFromClipboard" },
      { key: "ctrl+z", ifPlatform: "!macos", command: "undo" },
      { key: "cmd+z", command: "undo" },
      { key: "ctrl+y", ifPlatform: "!macos", command: "redo" },
      // ARIA recommendation
      { key: "shift+cmd+y", command: "redo" },
      { key: "shift+ctrl+z", ifPlatform: "!macos", command: "redo" },
      { key: "shift+cmd+z", command: "redo" },
      // EMACS/MACOS BINDINGS
      { key: "ctrl+b", ifPlatform: "macos", command: "moveToPreviousChar" },
      { key: "ctrl+f", ifPlatform: "macos", command: "moveToNextChar" },
      { key: "ctrl+p", ifPlatform: "macos", command: "moveUp" },
      { key: "ctrl+n", ifPlatform: "macos", command: "moveDown" },
      { key: "ctrl+a", ifPlatform: "macos", command: "moveToMathfieldStart" },
      { key: "ctrl+e", ifPlatform: "macos", command: "moveToMathfieldEnd" },
      {
        key: "shift+ctrl+b",
        ifPlatform: "macos",
        command: "extendSelectionBackward"
      },
      {
        key: "shift+ctrl+f",
        ifPlatform: "macos",
        command: "extendSelectionForward"
      },
      {
        key: "shift+ctrl+p",
        ifPlatform: "macos",
        command: "extendSelectionUpward"
      },
      {
        key: "shift+ctrl+n",
        ifPlatform: "macos",
        command: "extendSelectionDownward"
      },
      {
        key: "shift+ctrl+a",
        ifPlatform: "macos",
        command: "extendToMathFieldStart"
      },
      {
        key: "shift+ctrl+e",
        ifPlatform: "macos",
        command: "extendToMathFieldEnd"
      },
      { key: "alt+ctrl+b", ifPlatform: "macos", command: "moveToPreviousWord" },
      { key: "alt+ctrl+f", ifPlatform: "macos", command: "moveToNextWord" },
      {
        key: "shift+alt+ctrl+b",
        ifPlatform: "macos",
        command: "extendToPreviousWord"
      },
      {
        key: "shift+alt+ctrl+f",
        ifPlatform: "macos",
        command: "extendToNextWord"
      },
      { key: "ctrl+h", ifPlatform: "macos", command: "deleteBackward" },
      { key: "ctrl+d", ifPlatform: "macos", command: "deleteForward" },
      { key: "ctrl+l", ifPlatform: "macos", command: "scrollIntoView" },
      // { key: 'ctrl+t', ifPlatform: 'macos', command: 'transpose' },
      // WOLFRAM MATHEMATICA BINDINGS
      {
        key: "ctrl+[Digit2]",
        ifMode: "math",
        command: ["insert", "\\sqrt{#0}"]
      },
      { key: "ctrl+[Digit5]", ifMode: "math", command: "moveToOpposite" },
      { key: "ctrl+[Digit6]", ifMode: "math", command: "moveToSuperscript" },
      { key: "ctrl+[Return]", ifMode: "math", command: "addRowAfter" },
      { key: "ctrl+[Enter]", ifMode: "math", command: "addRowAfter" },
      { key: "cmd+[Return]", ifMode: "math", command: "addRowAfter" },
      { key: "cmd+[Enter]", ifMode: "math", command: "addRowAfter" },
      // Excel keybindings:
      // shift+space: select entire row, ctrl+space: select an entire column
      // shift+ctrl++ or ctrl+numpad+
      // ctrl+- to delete a row or columns
      // MATHLIVE BINDINGS
      // { key: 'alt+a', command: ['insert', '\\theta'] },
      { key: "alt+p", ifMode: "math", command: ["insert", "\\pi"] },
      { key: "alt+v", ifMode: "math", command: ["insert", "\\sqrt{#0}"] },
      {
        key: "alt+w",
        ifMode: "math",
        command: ["insert", "\\sum_{i=#?}^{#?}"]
      },
      { key: "alt+b", command: ["insert", "\\int_{#?}^{#?}"] },
      { key: "alt+u", ifMode: "math", command: ["insert", "\\cup"] },
      { key: "alt+n", ifMode: "math", command: ["insert", "\\cap"] },
      { key: "alt+o", ifMode: "math", command: ["insert", "\\emptyset"] },
      {
        key: "alt+d",
        ifMode: "math",
        command: ["insert", "\\differentialD"]
      },
      {
        key: "shift+alt+o",
        ifMode: "math",
        command: ["insert", "\\varnothing"]
      },
      {
        key: "shift+alt+d",
        ifMode: "math",
        command: ["insert", "\\partial"]
      },
      {
        key: "shift+alt+p",
        ifMode: "math",
        command: ["insert", "\\prod_{i=#?}^{#?}"]
      },
      { key: "shift+alt+u", ifMode: "math", command: ["insert", "\\bigcup"] },
      { key: "shift+alt+n", ifMode: "math", command: ["insert", "\\bigcap"] },
      { key: "shift+alt+a", ifMode: "math", command: ["insert", "\\forall"] },
      { key: "shift+alt+e", ifMode: "math", command: ["insert", "\\exists"] },
      {
        key: "alt+[Backslash]",
        ifMode: "math",
        command: ["insert", "\\backslash"]
      },
      // "|" key} override command mode
      {
        key: "[NumpadDivide]",
        ifMode: "math",
        command: ["insert", "\\frac{#@}{#?}"]
      },
      // ??
      {
        key: "alt+[NumpadDivide]",
        ifMode: "math",
        command: ["insert", "\\frac{#?}{#@}"]
      },
      // ??
      // Accessibility
      { key: "shift+alt+k", command: "toggleKeystrokeCaption" },
      { key: "alt+[Space]", command: "toggleVirtualKeyboard" },
      // Note: On Mac OS (as of 10.12), there is a bug/behavior that causes
      // a beep to be generated with certain command+control key combinations.
      // The workaround is to create a default binding file to silence them.
      // In ~/Library/KeyBindings/DefaultKeyBinding.dict add these entries:
      //
      //   {
      //      "^@\UF701" = "noop:";
      //    "^@\UF702" = "noop:";
      //      "^@\UF703" = "noop:";
      //  }
      {
        key: "alt+ctrl+[ArrowUp]",
        command: ["speak", "all", { withHighlighting: false }]
      },
      {
        key: "alt+ctrl+[ArrowDown]",
        command: ["speak", "selection", { withHighlighting: false }]
      },
      //
      // Punctuations and some non-alpha key combinations
      // only work with specific keyboard layouts
      //
      {
        key: "alt+[Equal]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["applyStyle", { mode: "text" }]
      },
      {
        key: "alt+[Equal]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "text",
        command: ["applyStyle", { mode: "math" }]
      },
      {
        key: "shift+[Quote]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["switchMode", "text", "", ""]
      },
      {
        key: "shift+alt+[KeyT]",
        ifMode: "math",
        command: ["switchMode", "text", "", ""]
      },
      {
        key: "shift+alt+[KeyT]",
        ifMode: "text",
        command: ["switchMode", "math", "", ""]
      },
      {
        key: "shift+[Quote]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "text",
        command: ["switchMode", "math", "", ""]
      },
      {
        key: "/",
        ifMode: "math",
        command: ["insert", "\\frac{#@}{#?}"]
      },
      {
        key: "alt+/",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\/"]
      },
      {
        key: "alt+[BracketLeft]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\left\\lbrack #0 \\right\\rbrack"]
      },
      // ??
      {
        key: "ctrl+[Minus]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "moveToSubscript"
      },
      // ??
      {
        key: "shift+alt+[BracketLeft]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\left\\lbrace #0 \\right\\rbrace"]
      },
      // ??
      {
        key: "ctrl+;",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addRowAfter"
      },
      {
        key: "cmd+;",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addRowAfter"
      },
      {
        key: "shift+ctrl+;",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addRowBefore"
      },
      {
        key: "shift+cmd+;",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addRowBefore"
      },
      {
        key: "ctrl+[Backspace]",
        ifMode: "math",
        command: "removeRow"
      },
      {
        key: "cmd+[Backspace]",
        ifMode: "math",
        command: "removeRow"
      },
      {
        key: "ctrl+[Comma]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addColumnAfter"
      },
      {
        key: "cmd+[Comma]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addColumnAfter"
      },
      {
        key: "shift+ctrl+[Comma]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addColumnBefore"
      },
      {
        key: "shift+cmd+[Comma]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: "addColumnBefore"
      },
      {
        key: "shift+[Backspace]",
        ifMode: "math",
        command: "removeColumn"
      },
      {
        key: "alt+[Digit5]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "$\\infty"]
      },
      // "%" key
      {
        key: "alt+[Digit6]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\wedge"]
      },
      // "^" key
      {
        key: "shift+alt+[Digit6]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\vee"]
      },
      // "^" key
      {
        key: "alt+[Digit9]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "("]
      },
      // "(" key} override smartFence
      {
        key: "alt+[Digit0]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", ")"]
      },
      // ")" key} override smartFence
      {
        key: "alt+|",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "|"]
      },
      // "|" key} override smartFence
      {
        key: "shift+[Backquote]",
        ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"],
        ifMode: "math",
        command: ["insert", "\\~"]
      },
      // ??
      {
        key: "[Backquote]",
        ifLayout: ["windows.french", "linux.french"],
        ifMode: "math",
        command: ["insert", "^2"]
      }
    ];
    var REVERSE_KEYBINDINGS = {
      "\\theta": "alt+q",
      "\\sqrt": ["alt+v", "ctrl+[Digit2]"],
      "\\pi": "alt+p",
      "\\prod": "shift+alt+p",
      "\\sum": "alt+w",
      "\\int": "alt+b",
      "\\cup": "alt+u",
      "\\cap": "alt+n",
      "\\bigcup": "shift+alt+u",
      "\\bigcap": "shift+alt+n",
      "\\forall": "shift+alt+a",
      "\\exists": "shift+alt+e",
      "\\infty": "alt+[Digit5]",
      "\\wedge": "alt+[Digit6]",
      "\\vee": "shift+alt+[Digit6]",
      "\\differentialD": "alt+d",
      "\\partial": "shift+alt+d",
      "\\frac": "Slash",
      "\\emptyset": "alt+o",
      "\\varnothing": "shift+alt+o",
      "\\~": "~"
    };
    function update(current, updates) {
      const result = get2(
        current,
        Object.keys(current)
      );
      for (const key of Object.keys(updates)) {
        switch (key) {
          case "scriptDepth":
            if (isArray2(updates.scriptDepth))
              result.scriptDepth = [updates.scriptDepth[0], updates.scriptDepth[1]];
            else if (typeof updates.scriptDepth === "number")
              result.scriptDepth = [updates.scriptDepth, updates.scriptDepth];
            else
              throw new TypeError("Unexpected value for scriptDepth");
            break;
          case "mathVirtualKeyboardPolicy":
            const keyboardPolicy = updates.mathVirtualKeyboardPolicy.toLowerCase();
            result.mathVirtualKeyboardPolicy = keyboardPolicy;
            break;
          case "letterShapeStyle":
            if (updates.letterShapeStyle === "auto") {
              if (l10n.locale.startsWith("fr"))
                result.letterShapeStyle = "french";
              else
                result.letterShapeStyle = "tex";
            } else
              result.letterShapeStyle = updates.letterShapeStyle;
            break;
          case "defaultMode":
            if (!["text", "math", "inline-math"].includes(
              updates.defaultMode
            )) {
              console.error(
                `MathLive 0.90.9:  valid values for defaultMode are "text", "math" or "inline-math"`
              );
              result.defaultMode = "math";
            } else
              result.defaultMode = updates.defaultMode;
            break;
          case "macros":
            result.macros = normalizeMacroDictionary(updates.macros);
            break;
          default:
            if (isArray2(updates[key]))
              result[key] = [...updates[key]];
            else if (typeof updates[key] === "object")
              result[key] = __spreadValues({}, updates[key]);
            else
              result[key] = updates[key];
        }
      }
      return result;
    }
    function get2(config, keys) {
      let resolvedKeys;
      if (typeof keys === "string")
        resolvedKeys = [keys];
      else if (keys === void 0)
        resolvedKeys = Object.keys(config);
      else
        resolvedKeys = keys;
      const result = {};
      for (const x of resolvedKeys) {
        if (config[x] === null)
          result[x] = null;
        else if (isArray2(config[x]))
          result[x] = [...config[x]];
        else if (typeof config[x] === "object" && !(config[x] instanceof Element) && x !== "computeEngine") {
          result[x] = __spreadValues({}, config[x]);
        } else
          result[x] = config[x];
      }
      if (typeof keys === "string")
        return result[keys];
      return result;
    }
    function getDefault() {
      return {
        readOnly: false,
        defaultMode: "math",
        macros: getMacros(),
        registers: {},
        colorMap: defaultColorMap,
        backgroundColorMap: defaultBackgroundColorMap,
        letterShapeStyle: l10n.locale.startsWith("fr") ? "french" : "tex",
        smartMode: false,
        smartFence: true,
        smartSuperscript: true,
        scriptDepth: [Infinity, Infinity],
        removeExtraneousParentheses: true,
        mathModeSpace: "",
        placeholderSymbol: "▢",
        popoverPolicy: "auto",
        keybindings: DEFAULT_KEYBINDINGS,
        inlineShortcuts: INLINE_SHORTCUTS,
        inlineShortcutTimeout: 0,
        mathVirtualKeyboardPolicy: "auto",
        virtualKeyboardTargetOrigin: window == null ? void 0 : window.origin,
        originValidator: "none",
        onInlineShortcut: () => "",
        onExport: defaultExportHook,
        value: ""
      };
    }
    function effectiveMode(options) {
      if (options.defaultMode === "inline-math")
        return "math";
      return options.defaultMode;
    }
    function isOffset(value) {
      return typeof value === "number" && !Number.isNaN(value);
    }
    function isRange(value) {
      return Array.isArray(value) && value.length === 2;
    }
    function isSelection(value) {
      return value !== void 0 && value !== null && typeof value === "object" && "ranges" in value && Array.isArray(value.ranges);
    }
    var VARIANTS = {
      // Handle some special characters which are only available in "main" font (not "math")
      "main": ["Main-Regular", "ML__cmr"],
      "main-italic": ["Main-Italic", "ML__cmr ML__it"],
      "main-bold": ["Main-Bold", "ML__cmr ML__bold"],
      "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML__bold ML__it"],
      "normal": ["Main-Regular", "ML__cmr"],
      // 'main' font. There is no 'math' regular (upright)
      "normal-bold": ["Main-Bold", "ML__mathbf"],
      // 'main' font. There is no 'math' bold
      "normal-italic": ["Math-Italic", "ML__mathit"],
      // Special metrics for 'math'
      "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"],
      // Special metrics for 'math'
      // Extended math symbols, arrows, etc.. at their standard Unicode codepoints
      "ams": ["AMS-Regular", "ML__ams"],
      "ams-bold": ["AMS-Regular", "ML__ams"],
      "ams-italic": ["AMS-Regular", "ML__ams"],
      "ams-bolditalic": ["AMS-Regular", "ML__ams"],
      "sans-serif": ["SansSerif-Regular", "ML__sans"],
      "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"],
      "sans-serif-italic": ["SansSerif-Regular", "ML__sans"],
      "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"],
      "calligraphic": ["Caligraphic-Regular", "ML__cal"],
      "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"],
      "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"],
      "calligraphic-bolditalic": ["Caligraphic-Regular", "ML__cal ML__bold ML__it"],
      "script": ["Script-Regular", "ML__script"],
      "script-bold": ["Script-Regular", "ML__script ML__bold"],
      "script-italic": ["Script-Regular", "ML__script ML__it"],
      "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"],
      "fraktur": ["Fraktur-Regular", "ML__frak"],
      "fraktur-bold": ["Fraktur-Regular", "ML__frak"],
      "fraktur-italic": ["Fraktur-Regular", "ML__frak"],
      "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"],
      "monospace": ["Typewriter-Regular", "ML__tt"],
      "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"],
      "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"],
      "monospace-bolditalic": ["Typewriter-Regular", "ML__tt ML__bold ML__it"],
      // Blackboard characters are 'A-Z' in the AMS font
      "double-struck": ["AMS-Regular", "ML__bb"],
      "double-struck-bold": ["AMS-Regular", "ML__bb"],
      "double-struck-italic": ["AMS-Regular", "ML__bb"],
      "double-struck-bolditalic": ["AMS-Regular", "ML__bb"]
    };
    var VARIANT_REPERTOIRE = {
      "double-struck": /^[A-Z ]$/,
      "script": /^[A-Z ]$/,
      "calligraphic": /^[\dA-Z ]$/,
      "fraktur": /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^’‘]$/,
      "monospace": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/,
      "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/
    };
    var GREEK_LOWERCASE = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/;
    var GREEK_UPPERCASE = /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/;
    var LETTER_SHAPE_RANGES = [
      /^[a-z]$/,
      // Lowercase latin
      /^[A-Z]$/,
      // Uppercase latin
      GREEK_LOWERCASE,
      GREEK_UPPERCASE
    ];
    var LETTER_SHAPE_MODIFIER = {
      iso: ["it", "it", "it", "it"],
      tex: ["it", "it", "it", "up"],
      french: ["it", "up", "up", "up"],
      upright: ["up", "up", "up", "up"]
    };
    var MathMode = class extends Mode {
      constructor() {
        super("math");
      }
      createAtom(command, context, style) {
        var _a3, _b3, _c2, _d2, _e;
        const info = context.getDefinition(command, "math");
        if (info === null) {
          return new Atom("mord", context, {
            mode: "math",
            command,
            value: command,
            style
          });
        }
        if (info.definitionType === "symbol") {
          const result2 = new Atom((_a3 = info.type) != null ? _a3 : "mord", context, {
            mode: "math",
            command: (_b3 = info.command) != null ? _b3 : command,
            value: String.fromCodePoint(info.codepoint),
            style
          });
          if ((_c2 = info.isFunction) != null ? _c2 : false)
            result2.isFunction = true;
          if (command.startsWith("\\"))
            result2.verbatimLatex = command;
          return result2;
        }
        const result = new Atom("mord", context, {
          mode: "math",
          command: (_d2 = info.command) != null ? _d2 : command,
          value: command,
          style
        });
        if ((_e = info.isFunction) != null ? _e : false)
          result.isFunction = true;
        if (command.startsWith("\\"))
          result.verbatimLatex = command;
        return result;
      }
      serialize(run, options) {
        const { parent } = run[0];
        const contextFontsize = parent == null ? void 0 : parent.computedStyle.fontSize;
        return joinLatex(
          getPropertyRuns(run, "fontSize").map((x) => {
            const result = emitBackgroundColorRun(x, options);
            const fontsize = x[0].computedStyle.fontSize;
            if (fontsize && (!parent || contextFontsize !== fontsize)) {
              return "\\" + [
                "",
                "tiny",
                "scriptsize",
                "footnotesize",
                "small",
                "normalsize",
                "large",
                "Large",
                "LARGE",
                "huge",
                "Huge"
              ][fontsize] + " " + result;
            }
            return result;
          })
        );
      }
      applyStyle(box, style) {
        if (style.variant === void 0)
          return "";
        const letterShapeStyle = style.letterShapeStyle === "auto" || !style.letterShapeStyle ? "tex" : style.letterShapeStyle;
        let { variant } = style;
        let { variantStyle } = style;
        if (variant === "normal" && !variantStyle && /[\u00A3\u0131\u0237]/.test(box.value)) {
          variant = "main";
          variantStyle = "italic";
        }
        if (variant === "normal" && !variantStyle && box.value.length === 1) {
          LETTER_SHAPE_RANGES.forEach((x, i) => {
            if (x.test(box.value) && LETTER_SHAPE_MODIFIER[letterShapeStyle][i] === "it")
              variantStyle = "italic";
          });
        }
        if (variantStyle === "up")
          variantStyle = void 0;
        const styledVariant = variantStyle ? variant + "-" + variantStyle : variant;
        console.assert(VARIANTS[styledVariant] !== void 0);
        const [fontName, classes] = VARIANTS[styledVariant];
        if (VARIANT_REPERTOIRE[variant] && !VARIANT_REPERTOIRE[variant].test(box.value)) {
          box.value = mathVariantToUnicode(box.value, variant, variantStyle);
          return null;
        }
        if (GREEK_LOWERCASE.test(box.value))
          box.classes += " lcGreek";
        if (classes)
          box.classes += " " + classes;
        return fontName;
      }
    };
    function emitVariantRun(run, options) {
      var _a3;
      const { parent } = run[0];
      const contextVariant = variantString(parent);
      const parentMode = (_a3 = parent == null ? void 0 : parent.mode) != null ? _a3 : "math";
      return joinLatex(
        getPropertyRuns(run, "variant").map((x) => {
          const variant = variantString(x[0]);
          if (x.every((x2) => {
            const info = x2.context.getDefinition(x2.command, parentMode);
            if (!info || info.definitionType === "function" || !info.variant)
              return false;
            return variantString(x2) === variant;
          }))
            return joinLatex(x.map((x2) => Atom.serialize(x2, options)));
          let command = "";
          if (variant && variant !== contextVariant) {
            command = {
              "calligraphic": "\\mathcal{",
              "fraktur": "\\mathfrak{",
              "double-struck": "\\mathbb{",
              "script": "\\mathscr{",
              "monospace": "\\mathtt{",
              "sans-serif": "\\mathsf{",
              "normal": "\\mathrm{",
              "normal-italic": "\\mathnormal{",
              "normal-bold": "\\mathbf{",
              "normal-bolditalic": "\\mathbfit{",
              "ams": "",
              "ams-italic": "\\mathit{",
              "ams-bold": "\\mathbf{",
              "ams-bolditalic": "\\mathbfit{",
              "main": "",
              "main-italic": "\\mathit{",
              "main-bold": "\\mathbf{",
              "main-bolditalic": "\\mathbfit{"
              // There are a few rare font families possible, which
              // are not supported:
              // mathbbm, mathbbmss, mathbbmtt, mathds, swab, goth
              // In addition, the 'main' and 'math' font technically
              // map to \mathnormal{}
            }[variant];
            console.assert(command !== void 0);
          }
          if (!command)
            return joinLatex(x.map((x2) => Atom.serialize(x2, options)));
          return command + joinLatex(x.map((x2) => Atom.serialize(x2, options))) + "}";
        })
      );
    }
    function emitColorRun(run, options) {
      const { parent } = run[0];
      const contextColor = parent == null ? void 0 : parent.computedStyle.color;
      return joinLatex(
        getPropertyRuns(run, "color").map((x) => {
          var _a3, _b3;
          const result = emitVariantRun(x, options);
          const style = x[0].computedStyle;
          if (!((_a3 = options.skipStyles) != null ? _a3 : false) && style.color && (!parent || contextColor !== style.color)) {
            return "\\textcolor{" + ((_b3 = style.verbatimColor) != null ? _b3 : style.color) + "}{" + result + "}";
          }
          return result;
        })
      );
    }
    function emitBackgroundColorRun(run, options) {
      const { parent } = run[0];
      const parentColor = parent == null ? void 0 : parent.computedStyle.backgroundColor;
      return joinLatex(
        getPropertyRuns(run, "backgroundColor").map((x) => {
          var _a3, _b3;
          let result = emitColorRun(x, options);
          const style = x[0].computedStyle;
          if (!((_a3 = options.skipStyles) != null ? _a3 : false) && result.trim() && style.backgroundColor && (!parent || parentColor !== style.backgroundColor) && (x.length > 0 || !(x[0] instanceof BoxAtom))) {
            result = `\\ensuremath{${result}}`;
            result = `\\colorbox{${(_b3 = style.verbatimBackgroundColor) != null ? _b3 : style.backgroundColor}}{${result}}`;
          }
          return result;
        })
      );
    }
    function variantString(atom) {
      if (!atom)
        return "";
      const { style } = atom;
      if (style.variant === void 0)
        return "";
      let result = style.variant;
      if (style.variantStyle && style.variantStyle !== "up")
        result += "-" + style.variantStyle;
      return result;
    }
    new MathMode();
    function join(segments) {
      return [
        joinLatex(segments.map((x) => x[0])),
        segments.map((x) => x[1]).some((x) => x === true)
      ];
    }
    function emitStringTextRun(run, options) {
      return [joinLatex(run.map((x) => Atom.serialize(x, options))), true];
    }
    function emitFontShapeTextRun(run, options) {
      return join(
        getPropertyRuns(run, "fontShape").map((x) => {
          const [s, needsWrap] = emitStringTextRun(x, options);
          const { fontShape } = x[0].style;
          if (fontShape === "it")
            return ["\\textit{" + s + "}", false];
          if (fontShape === "sl")
            return ["\\textsl{" + s + "}", false];
          if (fontShape === "sc")
            return ["\\textsc{" + s + "}", false];
          if (fontShape === "n")
            return ["\\textup{" + s + "}", false];
          if (fontShape)
            return [`{\\fontshape{${x[0].style.fontShape}}${s}`, false];
          return [s, needsWrap];
        })
      );
    }
    function emitFontSeriesTextRun(run, options) {
      return join(
        getPropertyRuns(run, "fontSeries").map((x) => {
          const [s, needsWrap] = emitFontShapeTextRun(x, options);
          const { fontSeries } = x[0].style;
          if (fontSeries === "b")
            return [`\\textbf{${s}}`, false];
          if (fontSeries === "l")
            return [`\\textlf{${s}}`, false];
          if (fontSeries === "m")
            return [`\\textmd{${s}}`, false];
          if (fontSeries)
            return [`\\fontseries{${fontSeries}}${s}`, false];
          return [s, needsWrap];
        })
      );
    }
    function emitSizeTextRun(run, options) {
      return join(
        getPropertyRuns(run, "fontSize").map((x) => {
          var _a3, _b3;
          const [s, needsWrap] = emitFontSeriesTextRun(x, options);
          const command = (_b3 = [
            "",
            "tiny",
            "scriptsize",
            "footnotesize",
            "small",
            "normalsize",
            "large",
            "Large",
            "LARGE",
            "huge",
            "Huge"
          ][(_a3 = x[0].style.fontSize) != null ? _a3 : ""]) != null ? _b3 : "";
          if (command)
            return [`{\\${command} ${s}}`, needsWrap];
          return [s, needsWrap];
        })
      );
    }
    function emitFontFamilyTextRun(run, options) {
      return join(
        getPropertyRuns(run, "fontFamily").map((x) => {
          var _a3, _b3;
          const [s, needsWrap] = emitSizeTextRun(x, options);
          const command = (_b3 = {
            "roman": "textrm",
            "monospace": "texttt",
            "sans-serif": "textsf"
          }[(_a3 = x[0].style.fontFamily) != null ? _a3 : ""]) != null ? _b3 : "";
          if (command)
            return [`\\${command}{${s}}`, false];
          if (x[0].style.fontFamily)
            return [`\\fontfamily{${x[0].style.fontFamily}}${s}`, needsWrap];
          return [s, needsWrap];
        })
      );
    }
    function emitStyledTextRun(run, options) {
      return emitFontFamilyTextRun(run, options);
    }
    function emitBackgroundColorRun2(run, options) {
      return join(
        getPropertyRuns(run, "backgroundColor").map((x) => {
          var _a3, _b3;
          const [s, needsWrap] = emitColorRun2(x, options);
          const style = x[0].computedStyle;
          if (!((_a3 = options.skipStyles) != null ? _a3 : false) && style.backgroundColor && style.backgroundColor !== "none") {
            return [
              `\\colorbox{${(_b3 = style.verbatimBackgroundColor) != null ? _b3 : style.backgroundColor}}{${s}}`,
              false
            ];
          }
          return [s, needsWrap];
        })
      );
    }
    function emitColorRun2(run, options) {
      var _a3;
      if (!run || run.length === 0)
        return ["", false];
      const parentColor = (_a3 = run[0].parent) == null ? void 0 : _a3.style.color;
      return join(
        getPropertyRuns(run, "color").map((x) => {
          var _a4, _b3;
          const [s, needsWrap] = emitStyledTextRun(x, options);
          if (!((_a4 = options.skipStyles) != null ? _a4 : false) && x[0].style.color && x[0].style.color !== "none" && parentColor !== x[0].style.color) {
            return [
              `\\textcolor{${(_b3 = x[0].style.verbatimColor) != null ? _b3 : x[0].style.color}}{${s}}`,
              false
            ];
          }
          return [s, needsWrap];
        })
      );
    }
    var TEXT_FONT_CLASS = {
      "roman": "",
      "sans-serif": "ML__sans",
      "monospace": "ML__tt"
    };
    var TextMode = class extends Mode {
      constructor() {
        super("text");
      }
      createAtom(command, context, style) {
        const info = context.getDefinition(command, "text");
        if (!info)
          return null;
        if (info.definitionType === "symbol") {
          return new TextAtom(
            command,
            String.fromCodePoint(info.codepoint),
            style != null ? style : {},
            context
          );
        }
        return null;
      }
      serialize(run, options) {
        var _a3;
        let [result, needWrapper] = emitBackgroundColorRun2(run, options);
        if (((_a3 = options.skipModeCommand) != null ? _a3 : false) === true)
          needWrapper = false;
        if (needWrapper)
          result = `\\text{${result}}`;
        return result;
      }
      /**
       * Return the font-family name
       */
      applyStyle(box, style) {
        var _a3, _b3, _c2, _d2, _e;
        const { fontFamily } = style;
        if (TEXT_FONT_CLASS[fontFamily])
          box.classes += " " + TEXT_FONT_CLASS[fontFamily];
        else if (fontFamily) {
          box.setStyle("font-family", fontFamily);
        }
        if (style.fontShape) {
          box.classes += " ";
          box.classes += (_a3 = {
            it: "ML__it",
            sl: "ML__shape_sl",
            // Slanted
            sc: "ML__shape_sc",
            // Small caps
            ol: "ML__shape_ol"
            // Outline
          }[style.fontShape]) != null ? _a3 : "";
        }
        if (style.fontSeries) {
          const m = style.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
          if (m) {
            box.classes += " ";
            box.classes += (_c2 = {
              ul: "ML__series_ul",
              el: "ML__series_el",
              l: "ML__series_l",
              sl: "ML__series_sl",
              m: "",
              // Medium (default)
              sb: "ML__series_sb",
              b: "ML__bold",
              eb: "ML__series_eb",
              ub: "ML__series_ub"
            }[(_b3 = m[1]) != null ? _b3 : ""]) != null ? _c2 : "";
            box.classes += " ";
            box.classes += (_e = {
              uc: "ML__series_uc",
              ec: "ML__series_ec",
              c: "ML__series_c",
              sc: "ML__series_sc",
              n: "",
              // Normal (default)
              sx: "ML__series_sx",
              x: "ML__series_x",
              ex: "ML__series_ex",
              ux: "ML__series_ux"
            }[(_d2 = m[2]) != null ? _d2 : ""]) != null ? _e : "";
          }
        }
        return "Main-Regular";
      }
    };
    new TextMode();
    var LatexMode = class extends Mode {
      constructor() {
        super("latex");
      }
      createAtom(command, context, _style) {
        return new LatexAtom(command, context);
      }
      serialize(run, _options) {
        return run.filter((x) => x instanceof LatexAtom && !x.isSuggestion).map((x) => x.value).join("");
      }
      applyStyle() {
        return null;
      }
    };
    new LatexMode();
    var SPECIAL_OPERATORS = {
      "\\ne": "<mo>&ne;</mo>",
      "\\neq": "<mo>&neq;</mo>",
      "\\pm": "&#177;",
      "\\times": "&#215;",
      "\\colon": ":",
      "\\vert": "|",
      "\\Vert": "∥",
      "\\mid": "∣",
      "\\lbrace": "{",
      "\\rbrace": "}",
      "\\lparen": "(",
      "\\rparen": ")",
      "\\langle": "⟨",
      "\\rangle": "⟩",
      "\\lfloor": "⌊",
      "\\rfloor": "⌋",
      "\\lceil": "⌈",
      "\\rceil": "⌉",
      "\\vec": "&#x20d7;",
      "\\acute": "&#x00b4;",
      "\\grave": "&#x0060;",
      "\\dot": "&#x02d9;",
      "\\ddot": "&#x00a8;",
      "\\tilde": "&#x007e;",
      "\\bar": "&#x00af;",
      "\\breve": "&#x02d8;",
      "\\check": "&#x02c7;",
      "\\hat": "&#x005e;"
    };
    var APPLY_FUNCTION = "<mo>&#x2061;</mo>";
    var INVISIBLE_TIMES = "<mo>&#8290;</mo>";
    function xmlEscape(string) {
      return string.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function makeID(id, options) {
      if (!id || !options.generateID)
        return "";
      return ` extid="${id}"`;
    }
    function scanIdentifier(stream, final, options) {
      var _a3, _b3, _c2, _d2, _e, _f, _g, _h;
      let result = false;
      final = final != null ? final : stream.atoms.length;
      let mathML = "";
      let body = "";
      let atom = stream.atoms[stream.index];
      if (atom.command === "\\operatorname") {
        body = toString2(atom.body);
        stream.index += 1;
      } else {
        const variant = (_b3 = (_a3 = atom.style) == null ? void 0 : _a3.variant) != null ? _b3 : "";
        const variantStyle = (_d2 = (_c2 = atom.style) == null ? void 0 : _c2.variantStyle) != null ? _d2 : "";
        while (stream.index < final && (atom.type === "mord" || atom.type === "macro") && !atom.isDigit() && variant === ((_f = (_e = atom.style) == null ? void 0 : _e.variant) != null ? _f : "") && variantStyle === ((_h = (_g = atom.style) == null ? void 0 : _g.variantStyle) != null ? _h : "")) {
          body += toString2([atom]);
          stream.index += 1;
          atom = stream.atoms[stream.index];
        }
      }
      if (body.length > 0) {
        result = true;
        mathML = `<mi>${body}</mi>`;
        if ((stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mtext" || stream.lastType === "fence") && !/^<mo>(.*)<\/mo>$/.test(mathML))
          mathML = INVISIBLE_TIMES + mathML;
        if (body.endsWith(">f</mi>") || body.endsWith(">g</mi>")) {
          mathML += APPLY_FUNCTION;
          stream.lastType = "applyfunction";
        } else
          stream.lastType = /^<mo>(.*)<\/mo>$/.test(mathML) ? "mo" : "mi";
        if (!parseSubsup(body, stream, options))
          stream.mathML += mathML;
      }
      return result;
    }
    function isSuperscriptAtom(stream) {
      return stream.index < stream.atoms.length && stream.atoms[stream.index].superscript && stream.atoms[stream.index].type === "msubsup";
    }
    function indexOfSuperscriptInNumber(stream) {
      let result = -1;
      let i = stream.index;
      let done = false;
      let found = false;
      while (i < stream.atoms.length && !done && !found) {
        const atom = stream.atoms[i];
        done = !atom.isDigit();
        found = !done && atom.superscript !== void 0;
        i++;
      }
      if (found)
        result = i - 1;
      return result;
    }
    function parseSubsup(base, stream, options) {
      var _a3;
      let atom = stream.atoms[stream.index - 1];
      if (!atom)
        return false;
      if (!atom.superscript && !atom.subscript) {
        if (((_a3 = stream.atoms[stream.index]) == null ? void 0 : _a3.type) === "msubsup") {
          atom = stream.atoms[stream.index];
          stream.index += 1;
        } else
          return false;
      }
      const superscript = toMathML(atom.superscript, options);
      const subscript = toMathML(atom.subscript, options);
      if (!superscript && !subscript)
        return false;
      let mathML = "";
      if (superscript && subscript)
        mathML = `<msubsup>${base}${subscript}${superscript}</msubsup>`;
      else if (superscript)
        mathML = `<msup>${base}${superscript}</msup>`;
      else if (subscript)
        mathML = `<msub>${base}${subscript}</msub>`;
      stream.mathML += mathML;
      stream.lastType = "";
      return true;
    }
    function scanText(stream, final, options) {
      final = final != null ? final : stream.atoms.length;
      const initial = stream.index;
      let mathML = "";
      while (stream.index < final && stream.atoms[stream.index].mode === "text") {
        mathML += stream.atoms[stream.index].value ? stream.atoms[stream.index].value : " ";
        stream.index += 1;
      }
      if (mathML.length > 0) {
        stream.mathML += `<mtext ${makeID(stream.atoms[initial].id, options)}
      >${mathML}</mtext>`;
        stream.lastType = "mtext";
        return true;
      }
      return false;
    }
    function scanNumber(stream, final, options) {
      final = final != null ? final : stream.atoms.length;
      const initial = stream.index;
      let mathML = "";
      let superscript = indexOfSuperscriptInNumber(stream);
      if (superscript >= 0 && superscript < final)
        final = superscript;
      while (stream.index < final && stream.atoms[stream.index].isDigit()) {
        mathML += stream.atoms[stream.index].asDigit();
        stream.index += 1;
      }
      if (mathML.length <= 0)
        return false;
      mathML = "<mn" + makeID(stream.atoms[initial].id, options) + ">" + mathML + "</mn>";
      if (superscript < 0 && isSuperscriptAtom(stream)) {
        superscript = stream.index;
        stream.index += 1;
      }
      if (!parseSubsup(mathML, stream, options)) {
        stream.mathML += mathML;
        stream.lastType = "mn";
      }
      return true;
    }
    function scanFence(stream, final, options) {
      let result = false;
      final = final != null ? final : stream.atoms.length;
      let mathML = "";
      let lastType = "";
      if (stream.index < final && stream.atoms[stream.index].type === "mopen") {
        let found = false;
        let depth = 0;
        const openIndex = stream.index;
        let closeIndex = -1;
        let index = openIndex + 1;
        while (index < final && !found) {
          if (stream.atoms[index].type === "mopen")
            depth += 1;
          else if (stream.atoms[index].type === "mclose")
            depth -= 1;
          if (depth === -1) {
            found = true;
            closeIndex = index;
          }
          index += 1;
        }
        if (found) {
          mathML = "<mrow>";
          mathML += toMo(stream.atoms[openIndex], options);
          mathML += toMathML(stream.atoms, options, openIndex + 1, closeIndex);
          mathML += toMo(stream.atoms[closeIndex], options);
          mathML += "</mrow>";
          stream.index = closeIndex + 1;
          if (stream.lastType === "mi" || stream.lastType === "mn" || stream.lastType === "mfrac" || stream.lastType === "fence")
            stream.mathML += INVISIBLE_TIMES;
          if (parseSubsup(mathML, stream, options)) {
            result = true;
            stream.lastType = "";
            mathML = "";
          }
          lastType = "fence";
        }
      }
      if (mathML.length > 0) {
        result = true;
        stream.mathML += mathML;
        stream.lastType = lastType;
      }
      return result;
    }
    function scanOperator(stream, final, options) {
      let result = false;
      final = final != null ? final : stream.atoms.length;
      let mathML = "";
      let lastType = "";
      const atom = stream.atoms[stream.index];
      if (stream.index < final && (atom.type === "mbin" || atom.type === "mrel")) {
        mathML += atomToMathML(stream.atoms[stream.index], options);
        stream.index += 1;
        lastType = "mo";
      } else if (stream.index < final && atom.type === "mop") {
        if (atom.subsupPlacement === "over-under" && (atom.superscript || atom.subscript)) {
          const op = toMo(atom, options);
          if (atom.superscript && atom.subscript) {
            mathML += "<munderover>" + op;
            mathML += toMathML(atom.subscript, options);
            mathML += toMathML(atom.superscript, options);
            mathML += "</munderover>";
          } else if (atom.superscript) {
            mathML += "<mover>" + op;
            mathML += toMathML(atom.superscript, options);
            mathML += "</mover>";
          } else if (atom.subscript) {
            mathML += "<munder>" + op;
            mathML += toMathML(atom.subscript, options);
            mathML += "</munder>";
          }
          lastType = "mo";
        } else {
          const atom2 = stream.atoms[stream.index];
          const isUnit = atom2.value === "\\operatorname";
          const op = isUnit ? '<mi class="MathML-Unit"' + makeID(atom2.id, options) + ">" + toString2(atom2.value) + "</mi>" : toMo(atom2, options);
          mathML += op;
          if (!isUnit && !/^<mo>(.*)<\/mo>$/.test(op)) {
            mathML += APPLY_FUNCTION;
            lastType = "applyfunction";
          } else
            lastType = isUnit ? "mi" : "mo";
        }
        if ((stream.lastType === "mi" || stream.lastType === "mn") && !/^<mo>(.*)<\/mo>$/.test(mathML))
          mathML = INVISIBLE_TIMES + mathML;
        stream.index += 1;
      }
      if (mathML.length > 0) {
        result = true;
        if (!parseSubsup(mathML, stream, options)) {
          stream.mathML += mathML;
          stream.lastType = lastType;
        }
      }
      return result;
    }
    function toMathML(input, options, initial, final) {
      options != null ? options : options = {};
      const result = {
        atoms: [],
        index: initial != null ? initial : 0,
        mathML: "",
        lastType: ""
      };
      if (typeof input === "number" || typeof input === "boolean")
        result.mathML = input.toString();
      else if (typeof input === "string")
        result.mathML = input;
      else if (input instanceof Atom)
        result.mathML = atomToMathML(input, options);
      else if (Array.isArray(input)) {
        result.atoms = input;
        let count = 0;
        final = final ? final : input ? input.length : 0;
        while (result.index < final) {
          if (scanText(result, final, options) || scanNumber(result, final, options) || scanIdentifier(result, final, options) || scanOperator(result, final, options) || scanFence(result, final, options))
            count += 1;
          else if (result.index < final) {
            let mathML = atomToMathML(result.atoms[result.index], options);
            if (result.lastType === "mn" && mathML.length > 0 && result.atoms[result.index].type === "genfrac") {
              mathML = "<mo>&#x2064;</mo>" + mathML;
            }
            if (result.atoms[result.index].type === "genfrac")
              result.lastType = "mfrac";
            else
              result.lastType = "";
            result.index += 1;
            if (parseSubsup(mathML, result, options))
              count += 1;
            else {
              if (mathML.length > 0) {
                result.mathML += mathML;
                count += 1;
              }
            }
          }
        }
        if (count > 1)
          result.mathML = "<mrow>" + result.mathML + "</mrow>";
      }
      return result.mathML;
    }
    function toMo(atom, options) {
      let result = "";
      const body = toString2(atom.value);
      if (body)
        result = "<mo" + makeID(atom.id, options) + ">" + body + "</mo>";
      return result;
    }
    function toString2(atoms) {
      if (!atoms)
        return "";
      if (typeof atoms === "string")
        return xmlEscape(atoms);
      if (!Array.isArray(atoms) && typeof atoms.body === "string")
        return xmlEscape(atoms.body);
      let result = "";
      for (const atom of atoms)
        if (typeof atom.value === "string")
          result += atom.value;
      return xmlEscape(result);
    }
    function atomToMathML(atom, options) {
      var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
      const SVG_CODE_POINTS = {
        widehat: "^",
        widecheck: "ˇ",
        widetilde: "~",
        utilde: "~",
        overleftarrow: "←",
        underleftarrow: "←",
        xleftarrow: "←",
        overrightarrow: "→",
        underrightarrow: "→",
        xrightarrow: "→",
        underbrace: "⏟",
        overbrace: "⏞",
        overgroup: "⏠",
        undergroup: "⏡",
        overleftrightarrow: "↔",
        underleftrightarrow: "↔",
        xleftrightarrow: "↔",
        Overrightarrow: "⇒",
        xRightarrow: "⇒",
        overleftharpoon: "↼",
        xleftharpoonup: "↼",
        overrightharpoon: "⇀",
        xrightharpoonup: "⇀",
        xLeftarrow: "⇐",
        xLeftrightarrow: "⇔",
        xhookleftarrow: "↩",
        xhookrightarrow: "↪",
        xmapsto: "↦",
        xrightharpoondown: "⇁",
        xleftharpoondown: "↽",
        xrightleftharpoons: "⇌",
        xleftrightharpoons: "⇋",
        xtwoheadleftarrow: "↞",
        xtwoheadrightarrow: "↠",
        xlongequal: "=",
        xtofrom: "⇄",
        xrightleftarrows: "⇄",
        xrightequilibrium: "⇌",
        // Not a perfect match.
        xleftequilibrium: "⇋"
        // None better available.
      };
      const SPECIAL_IDENTIFIERS2 = {
        "\\exponentialE": "&#x02147;",
        "\\imaginaryI": "&#x2148;",
        "\\differentialD": "&#x2146;",
        "\\capitalDifferentialD": "&#x2145;",
        "\\alpha": "&#x03b1;",
        "\\pi": "&#x03c0;",
        "\\infty": "&#x221e;",
        "\\forall": "&#x2200;",
        "\\nexists": "&#x2204;",
        "\\exists": "&#x2203;",
        "\\hbar": "ℏ",
        "\\cdotp": "⋅",
        "\\ldots": "…",
        "\\cdots": "⋯",
        "\\ddots": "⋱",
        "\\vdots": "⋮",
        "\\ldotp": "."
      };
      const MATH_VARIANTS = {
        cal: "script",
        frak: "fraktur",
        bb: "double-struck",
        scr: "script",
        cmtt: "monospace",
        cmss: "sans-serif"
      };
      const SPACING = {
        "\\!": -3 / 18,
        "\\ ": 6 / 18,
        "\\,": 3 / 18,
        "\\:": 4 / 18,
        "\\;": 5 / 18,
        "\\enspace": 0.5,
        "\\quad": 1,
        "\\qquad": 2,
        "\\enskip": 0.5
      };
      let result = "";
      let sep = "";
      let col;
      let row;
      let i;
      let underscript;
      let overscript;
      let body;
      let variant = (_b3 = MATH_VARIANTS[(_a3 = atom.fontFamily) != null ? _a3 : atom.font]) != null ? _b3 : "";
      if (variant)
        variant = ` mathvariant="${variant}"`;
      const { command } = atom;
      if (atom.mode === "text")
        result = `<mi${makeID(atom.id, options)}>${atom.value}</mi>`;
      else {
        switch (atom.type) {
          case "first":
            break;
          case "group":
          case "root":
            if (SPECIAL_OPERATORS[atom.command])
              result = SPECIAL_OPERATORS[atom.command];
            else
              result = toMathML(atom.body, options);
            break;
          case "array":
            if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
              result += "<mrow>";
              if (atom.leftDelim && atom.leftDelim !== ".") {
                result += "<mo>" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.leftDelim) + "</mo>";
              }
            }
            result += "<mtable";
            if (atom.colFormat) {
              result += ' columnalign="';
              for (i = 0; i < atom.colFormat.length; i++) {
                if (atom.colFormat[i].align) {
                  result += { l: "left", c: "center", r: "right" }[atom.colFormat[i].align] + " ";
                }
              }
              result += '"';
            }
            result += ">";
            for (row = 0; row < atom.array.length; row++) {
              result += "<mtr>";
              for (col = 0; col < atom.array[row].length; col++) {
                result += "<mtd>" + toMathML(atom.array[row][col], options) + "</mtd>";
              }
              result += "</mtr>";
            }
            result += "</mtable>";
            if (atom.leftDelim && atom.leftDelim !== "." || atom.rightDelim && atom.rightDelim !== ".") {
              if (atom.rightDelim && atom.rightDelim !== ".") {
                result += "<mo>" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.rightDelim) + "</mo>";
              }
              result += "</mrow>";
            }
            break;
          case "genfrac":
            if (atom.leftDelim || atom.rightDelim)
              result += "<mrow>";
            if (atom.leftDelim && atom.leftDelim !== ".") {
              result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.leftDelim] || atom.leftDelim) + "</mo>";
            }
            if (atom.hasBarLine) {
              result += "<mfrac>";
              result += toMathML(atom.above, options) || "<mi>&nbsp;</mi>";
              result += toMathML(atom.below, options) || "<mi>&nbsp;</mi>";
              result += "</mfrac>";
            } else {
              result += "<mtable" + makeID(atom.id, options) + ">";
              result += "<mtr>" + toMathML(atom.above, options) + "</mtr>";
              result += "<mtr>" + toMathML(atom.below, options) + "</mtr>";
              result += "</mtable>";
            }
            if (atom.rightDelim && atom.rightDelim !== ".") {
              result += "<mo" + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.rightDelim] || atom.rightDelim) + "</mo>";
            }
            if (atom.leftDelim || atom.rightDelim)
              result += "</mrow>";
            break;
          case "surd":
            if (!atom.hasEmptyBranch("above")) {
              result += "<mroot" + makeID(atom.id, options) + ">";
              result += toMathML(atom.body, options);
              result += toMathML(atom.above, options);
              result += "</mroot>";
            } else {
              result += "<msqrt" + makeID(atom.id, options) + ">";
              result += toMathML(atom.body, options);
              result += "</msqrt>";
            }
            break;
          case "leftright":
            result = "<mrow>";
            if (atom.leftDelim && atom.leftDelim !== ".") {
              result += "<mo" + makeID(atom.id, options) + ">" + ((_c2 = SPECIAL_OPERATORS[atom.leftDelim]) != null ? _c2 : atom.leftDelim) + "</mo>";
            }
            if (atom.body)
              result += toMathML(atom.body, options);
            if (atom.rightDelim && atom.rightDelim !== ".") {
              result += "<mo" + makeID(atom.id, options) + ">" + ((_d2 = SPECIAL_OPERATORS[atom.rightDelim]) != null ? _d2 : atom.rightDelim) + "</mo>";
            }
            result += "</mrow>";
            break;
          case "sizeddelim":
          case "delim":
            result += '<mo separator="true"' + makeID(atom.id, options) + ">" + (SPECIAL_OPERATORS[atom.delim] || atom.delim) + "</mo>";
            break;
          case "accent":
            result += '<mover accent="true"' + makeID(atom.id, options) + ">";
            result += toMathML(atom.body, options);
            result += "<mo>" + (SPECIAL_OPERATORS[command] || atom.accent) + "</mo>";
            result += "</mover>";
            break;
          case "line":
          case "overlap":
            break;
          case "overunder":
            overscript = atom.above;
            underscript = atom.below;
            if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript))
              body = atom.body;
            else if (overscript && overscript.length > 0) {
              body = atom.body;
              if ((_f = (_e = atom.body) == null ? void 0 : _e[0]) == null ? void 0 : _f.below) {
                underscript = atom.body[0].below;
                body = atom.body[0].body;
              } else if (((_h = (_g = atom.body) == null ? void 0 : _g[0]) == null ? void 0 : _h.type) === "first" && ((_j = (_i = atom.body) == null ? void 0 : _i[1]) == null ? void 0 : _j.below)) {
                underscript = atom.body[1].below;
                body = atom.body[1].body;
              }
            } else if (underscript && underscript.length > 0) {
              body = atom.body;
              if ((_l = (_k = atom.body) == null ? void 0 : _k[0]) == null ? void 0 : _l.above) {
                overscript = atom.body[0].above;
                body = atom.body[0].body;
              } else if (((_n = (_m = atom.body) == null ? void 0 : _m[0]) == null ? void 0 : _n.type) === "first" && ((_p = (_o = atom.body) == null ? void 0 : _o[1]) == null ? void 0 : _p.above)) {
                overscript = atom.body[1].overscript;
                body = atom.body[1].body;
              }
            }
            if ((atom.svgAbove || overscript) && (atom.svgBelow || underscript)) {
              result += `<munderover ${variant} ${makeID(atom.id, options)}>`;
              result += (_q = SVG_CODE_POINTS[atom.svgBody]) != null ? _q : toMathML(body, options);
              result += (_r = SVG_CODE_POINTS[atom.svgBelow]) != null ? _r : toMathML(underscript, options);
              result += (_s = SVG_CODE_POINTS[atom.svgAbove]) != null ? _s : toMathML(overscript, options);
              result += "</munderover>";
            } else if (atom.svgAbove || overscript) {
              result += `<mover ${variant} ${makeID(atom.id, options)}>` + ((_t = SVG_CODE_POINTS[atom.svgBody]) != null ? _t : toMathML(body, options));
              result += (_u = SVG_CODE_POINTS[atom.svgAbove]) != null ? _u : toMathML(overscript, options);
              result += "</mover>";
            } else if (atom.svgBelow || underscript) {
              result += `<munder ${variant} ${makeID(atom.id, options)}>` + ((_v = SVG_CODE_POINTS[atom.svgBody]) != null ? _v : toMathML(body, options));
              result += (_w = SVG_CODE_POINTS[atom.svgBelow]) != null ? _w : toMathML(underscript, options);
              result += "</munder>";
            }
            break;
          case "placeholder":
          case "mord": {
            result = SPECIAL_IDENTIFIERS2[command] || command || (typeof atom.value === "string" ? atom.value : "");
            const m = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
            if (m) {
              result = "&#x" + m[1] + ";";
            } else if (result.length > 0 && result.startsWith("\\")) {
              if (typeof atom.value === "string" && atom.value.charCodeAt(0) > 255) {
                result = "&#x" + ("000000" + atom.value.charCodeAt(0).toString(16)).slice(-4) + ";";
              } else if (typeof atom.value === "string")
                result = atom.value.charAt(0);
              else {
                console.log("Did not expect this");
                result = "";
              }
            }
            const tag = /\d/.test(result) ? "mn" : "mi";
            result = `<${tag}${variant}${makeID(atom.id, options)}>${xmlEscape(
              result
            )}</${tag}>`;
            break;
          }
          case "mbin":
          case "mrel":
          case "minner":
            if (command && SPECIAL_IDENTIFIERS2[command]) {
              result = "<mi" + makeID(atom.id, options) + ">" + SPECIAL_IDENTIFIERS2[command] + "</mi>";
            } else if (command && SPECIAL_OPERATORS[command]) {
              result = "<mo" + makeID(atom.id, options) + ">" + SPECIAL_OPERATORS[command] + "</mo>";
            } else
              result = toMo(atom, options);
            break;
          case "mpunct":
            result = '<mo separator="true"' + makeID(atom.id, options) + ">" + ((_x = SPECIAL_OPERATORS[command]) != null ? _x : command) + "</mo>";
            break;
          case "mop":
            if (atom.body !== "​") {
              result = "<mo" + makeID(atom.id, options) + ">";
              result += command === "\\operatorname" ? atom.body : command || atom.body;
              result += "</mo>";
            }
            break;
          case "box":
            result = '<menclose notation="box"';
            if (atom.backgroundcolor)
              result += ' mathbackground="' + atom.backgroundcolor + '"';
            result += makeID(atom.id, options) + ">" + toMathML(atom.body, options) + "</menclose>";
            break;
          case "spacing":
            result += '<mspace width="' + ((_y = SPACING[command]) != null ? _y : 0) + 'em"/>';
            break;
          case "enclose":
            result = '<menclose notation="';
            for (const notation in atom.notation) {
              if (Object.prototype.hasOwnProperty.call(atom.notation, notation) && atom.notation[notation]) {
                result += sep + notation;
                sep = " ";
              }
            }
            result += makeID(atom.id, options) + '">' + toMathML(atom.body, options) + "</menclose>";
            break;
          case "prompt":
            result = '<menclose notation="roundexbox""">' + toMathML(atom.body, options) + "</menclose>";
            break;
          case "space":
            result += "&nbsp;";
            break;
          case "msubsup":
            break;
          case "phantom":
            break;
          case "composition":
            break;
          case "rule":
            console.log("In conversion to MathML, unknown type : " + atom.type);
            break;
          case "chem":
            break;
          case "mopen":
            result += toMo(atom, options);
            break;
          case "mclose":
            result += toMo(atom, options);
            break;
          case "macro":
            {
              const body2 = atom.command + toString2(atom.macroArgs);
              if (body2)
                result += `<mo ${makeID(atom.id, options)}>${body2}</mo>`;
            }
            break;
          case "error":
            console.log("In conversion to MathML, unknown type : " + atom.type);
            break;
          case "latexgroup":
            result += toMathML(atom.body, options);
            break;
          case "latex":
            result += "<mtext" + makeID(atom.id, options) + ">" + atom.value + "</mtext>";
            break;
          case "tooltip":
            result += toMathML(atom.body, options);
            break;
          default:
            console.log("In conversion to MathML, unknown type : " + atom.type);
        }
      }
      return result;
    }
    var SPECIAL_IDENTIFIERS = {
      "\\ne": "≠",
      "\\neq": "≠",
      "−": "-",
      // MINUS SIGN
      "-": "-",
      "\\alpha": "alpha",
      "\\beta": "beta",
      "\\gamma": "gamma",
      "\\delta": "delta",
      "\\epsilon": "epsilon",
      "\\varepsilon": "varepsilon",
      "\\zeta": "zeta",
      "\\eta": "eta",
      "\\theta": "theta",
      "\\vartheta": "vartheta",
      "\\iota": "iota",
      "\\kappa": "kappa",
      "\\lambda": "lambda",
      "\\mu": "mu",
      "\\nu": "nu",
      "\\xi": "xi",
      "\\pi": "pi",
      "\\rho": "rho",
      "\\sigma": "sigma",
      "\\tau": "tau",
      "\\upsilon": "upsilon",
      "\\phi": "phi",
      "\\varphi": "varphi",
      "\\chi": "chi",
      "\\psi": "psi",
      "\\omega": "omega",
      "\\Gamma": "Gamma",
      "\\Delta": "Delta",
      "\\Theta": "Theta",
      "\\Lambda": "Lambda",
      "\\Xi": "Xi",
      "\\Pi": "Pi",
      "\\Sigma": "Sigma",
      "\\Phi": "Phi",
      "\\Psi": "Psi",
      "\\Omega": "Omega",
      "\\exponentialE": "e",
      "\\imaginaryI": "i",
      "\\imaginaryJ": "j",
      "\\!": " ",
      "\\,": " ",
      "\\:": " ",
      "\\;": " ",
      "\\enskip": " ",
      "\\enspace": " ",
      "\\qquad": " ",
      "\\quad": " "
    };
    var SPECIAL_OPERATORS2 = {
      "\\pm": "+-",
      "\\times": "xx",
      "\\colon": ":",
      "\\vert": "|",
      "\\Vert": "||",
      "\\mid": "|",
      "\\lbrace": "{",
      "\\rbrace": "}",
      "\\lparen": "(",
      "\\rparen": ")",
      "\\langle": "(:",
      "\\rangle": ":)"
      // '\\lfloor': '\u230a',
      // '\\rfloor': '\u230b',
      // '\\lceil': '\u2308',
      // '\\rceil': '\u2309',
      // '\\vec': '&#x20d7;',
      // '\\acute': '&#x00b4;',
      // '\\grave': '&#x0060;',
      // '\\dot': '&#x02d9;',
      // '\\ddot': '&#x00a8;',
      // '\\tilde': '&#x007e;',
      // '\\bar': '&#x00af;',
      // '\\breve': '&#x02d8;',
      // '\\check': '&#x02c7;',
      // '\\hat': '&#x005e;'
    };
    function atomToAsciiMath(atom) {
      var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m;
      if (!atom)
        return "";
      if (isArray2(atom)) {
        if (atom.length === 0)
          return "";
        if (atom[0].type === "first")
          atom = atom.slice(1);
        if (atom.length === 0)
          return "";
        let result2 = "";
        if (atom[0].mode === "latex")
          for (const x of atom)
            result2 += atomToAsciiMath(x);
        else if (atom[0].mode === "text") {
          let i = 0;
          result2 = '"';
          while (((_a3 = atom[i]) == null ? void 0 : _a3.mode) === "text") {
            result2 += atom[i].body ? atomToAsciiMath(atom[i].body) : atom[i].value;
            i++;
          }
          result2 += '"' + atomToAsciiMath(atom.slice(i));
        } else if (atom[0].mode === "math") {
          let i = 0;
          while (atom[i] && atom[i].mode === "math") {
            result2 += atomToAsciiMath(atom[i]);
            i++;
          }
          result2 += atomToAsciiMath(atom.slice(i));
        } else
          console.warn("toASCIIMath: Unexpected mode");
        return result2.trim();
      }
      if (atom.mode === "text")
        return '"' + atom.value + '"';
      let result = "";
      const { command } = atom;
      let m;
      switch (atom.type) {
        case "first":
          return "";
        case "group":
        case "root":
          result = (_b3 = SPECIAL_IDENTIFIERS[command]) != null ? _b3 : atomToAsciiMath(atom.body);
          break;
        case "genfrac":
          {
            const genfracAtom = atom;
            if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
              result += genfracAtom.leftDelim === "." || !genfracAtom.leftDelim ? "{:" : genfracAtom.leftDelim;
            }
            if (genfracAtom.hasBarLine) {
              result += "(";
              result += atomToAsciiMath(genfracAtom.above);
              result += ")/(";
              result += atomToAsciiMath(genfracAtom.below);
              result += ")";
            } else {
              result += "(" + atomToAsciiMath(genfracAtom.above) + "),";
              result += "(" + atomToAsciiMath(genfracAtom.below) + ")";
            }
            if (genfracAtom.leftDelim || genfracAtom.rightDelim) {
              result += genfracAtom.rightDelim === "." || !genfracAtom.rightDelim ? "{:" : genfracAtom.rightDelim;
            }
          }
          break;
        case "surd":
          result += !atom.hasEmptyBranch("above") ? "root(" + atomToAsciiMath(atom.above) + ")(" + atomToAsciiMath(atom.body) + ")" : "sqrt(" + atomToAsciiMath(atom.body) + ")";
          break;
        case "latex":
          result = atom.value;
          break;
        case "leftright":
          {
            const leftrightAtom = atom;
            result += leftrightAtom.leftDelim === "." || !leftrightAtom.leftDelim ? "{:" : leftrightAtom.leftDelim;
            result += atomToAsciiMath(leftrightAtom.body);
            result += leftrightAtom.rightDelim === "." || !leftrightAtom.rightDelim ? ":}" : leftrightAtom.rightDelim;
          }
          break;
        case "sizeddelim":
        case "delim":
          break;
        case "overlap":
          break;
        case "overunder":
          break;
        case "mord":
          result = (_d2 = (_c2 = SPECIAL_IDENTIFIERS[command]) != null ? _c2 : command) != null ? _d2 : typeof atom.value === "string" ? atom.value : "";
          if (result.startsWith("\\"))
            result += " ";
          m = command ? command.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
          if (m) {
            result = String.fromCodePoint(Number.parseInt("0x" + m[1]));
          } else if (result.length > 0 && result.startsWith("\\")) {
            result = typeof atom.value === "string" ? atom.value.charAt(0) : atom.command;
          }
          break;
        case "mbin":
        case "mrel":
        case "minner":
          result = (_f = (_e = SPECIAL_IDENTIFIERS[command]) != null ? _e : SPECIAL_OPERATORS2[command]) != null ? _f : atom.value;
          break;
        case "mopen":
        case "mclose":
          result += atom.value;
          break;
        case "mpunct":
          result = (_g = SPECIAL_OPERATORS2[command]) != null ? _g : command;
          break;
        case "mop":
          if (atom.value !== "​") {
            result = "";
            result += command === "\\operatorname" ? atomToAsciiMath(atom.body) : (_h = atom.value) != null ? _h : command;
            result += " ";
          }
          break;
        case "array":
          const array = atom.array;
          const environment = atom.environmentName;
          const rowDelim = (_i = {
            "bmatrix": ["[", "]"],
            "bmatrix*": ["[", "]"]
          }[environment]) != null ? _i : ["(", ")"];
          const rows = [];
          for (const row of array) {
            const cells = [];
            for (const cell of row)
              cells.push(rowDelim[0] + atomToAsciiMath(cell) + rowDelim[1]);
            rows.push(cells.join(","));
          }
          const delim = (_j = {
            "bmatrix": ["[", "]"],
            "bmatrix*": ["[", "]"],
            "cases": ["{", ":}"]
          }[environment]) != null ? _j : ["(", ")"];
          result = delim[0] + rows.join(",") + delim[1];
          break;
        case "box":
          break;
        case "spacing":
          result = (_k = SPECIAL_IDENTIFIERS[command]) != null ? _k : " ";
          break;
        case "enclose":
          result = "(" + atomToAsciiMath(atom.body) + ")";
          break;
        case "space":
          result = " ";
          break;
        case "msubsup":
          result = "";
          break;
        case "macro":
          result = (_m = (_l = SPECIAL_IDENTIFIERS[command]) != null ? _l : SPECIAL_OPERATORS2[command]) != null ? _m : atomToAsciiMath(atom.body);
          break;
      }
      if (!atom.hasEmptyBranch("subscript")) {
        result += "_";
        const arg = atomToAsciiMath(atom.subscript);
        result += arg.length > 1 ? "(" + arg + ")" : arg;
      }
      if (!atom.hasEmptyBranch("superscript")) {
        result += "^";
        const arg = atomToAsciiMath(atom.superscript);
        result += arg.length > 1 ? "(" + arg + ")" : arg;
      }
      return result;
    }
    var PRONUNCIATION = {
      "\\alpha": "alpha ",
      "\\mu": "mew ",
      "\\sigma": "sigma ",
      "\\pi": "pie ",
      "\\imaginaryI": "eye ",
      "\\sum": "Summation ",
      "\\prod": "Product ",
      "+": "plus ",
      "-": "minus ",
      ";": '<break time="150ms"/> semi-colon <break time="150ms"/>',
      ",": '<break time="150ms"/> comma  <break time="150ms"/>',
      "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>',
      "(": '<break time="150ms"/>Open paren. <break time="150ms"/>',
      ")": '<break time="150ms"/> Close paren. <break time="150ms"/>',
      "=": "equals ",
      "<": "is less than ",
      "\\lt": "is less than ",
      "<=": "is less than or equal to ",
      "\\le": "is less than or equal to ",
      "\\gt": "is greater than ",
      ">": "is greater than ",
      "\\pm": "plus or minus",
      "\\mp": "minus or plus",
      "\\ge": "is greater than or equal to ",
      "\\geq": "is greater than or equal to ",
      "\\leq": "is less than or equal to ",
      "!": "factorial ",
      "\\sin": "sine ",
      "\\cos": "cosine ",
      "​": "",
      "−": "minus ",
      ":": '<break time="150ms"/> such that <break time="200ms"/> ',
      "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ',
      "\\hbar": "etch bar ",
      "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
      "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>',
      "\\land": "and ",
      "\\lor": "or ",
      "\\neg": "not ",
      "\\div": "divided by ",
      "\\forall": "for all ",
      "\\exists": "there exists ",
      "\\nexists": "there does not exists ",
      "\\in": "element of ",
      "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>',
      "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>',
      "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>',
      "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>',
      "\\infty": "infinity ",
      "\\nabla": "nabla ",
      "\\partial": "partial derivative of ",
      "\\cdot": "times ",
      "\\cdots": "dot dot dot ",
      "\\Rightarrow": "implies ",
      "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>',
      "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>',
      "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>',
      "\\{": '<break time="150ms"/>open brace<break time="150ms"/>',
      "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>',
      "\\}": '<break time="150ms"/>close brace<break time="150ms"/>',
      "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>',
      "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>',
      "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>',
      "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>',
      "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>',
      "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>',
      "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>',
      "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>',
      "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>',
      "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>',
      // '\\lbrack':		'left bracket',
      // '\\rbrack':		'right bracket',
      "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>',
      "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>',
      // Need to add code to detect singluar/plural. Until then spoken as plural since that is vastly more common
      // note: need to worry about intervening &InvisibleTimes;.
      // note: need to also do this when in numerator of fraction and number preceeds fraction
      // note: need to do this for <msup>
      "mm": "millimeters",
      "cm": "centimeters",
      "km": "kilometers",
      "kg": "kilograms"
    };
    var ENVIRONMENTS_NAMES = {
      "array": "array",
      "matrix": "matrix",
      "pmatrix": "parenthesis matrix",
      "bmatrix": "square brackets matrix",
      "Bmatrix": "braces matrix",
      "vmatrix": "bars matrix",
      "Vmatrix": "double bars matrix",
      "matrix*": "matrix",
      "smallmatrix": "small matrix"
    };
    function getSpokenName(latex) {
      let result = "";
      if (latex.startsWith("\\"))
        result = " " + latex.replace("\\", "") + " ";
      return result;
    }
    function isAtomic(atoms) {
      let count = 0;
      if (isArray2(atoms)) {
        for (const atom of atoms)
          if (atom.type !== "first")
            count += 1;
      }
      return count === 1;
    }
    function atomicID(atoms) {
      if (isArray2(atoms)) {
        for (const atom of atoms)
          if (atom.type !== "first" && atom.id)
            return atom.id.toString();
      }
      return "";
    }
    function atomicValue(atoms) {
      let result = "";
      if (isArray2(atoms)) {
        for (const atom of atoms) {
          if (atom.type !== "first" && typeof atom.value === "string")
            result += atom.value;
        }
      }
      return result;
    }
    function atomsAsText(atoms) {
      if (!atoms)
        return "";
      return atoms.map((atom) => atom.value).join("");
    }
    function atomToSpeakableFragment(mode, atom) {
      var _a3, _b3, _c2, _d2, _e;
      function letter(c) {
        if (!window.MathfieldElement.textToSpeechMarkup) {
          if (/[a-z]/.test(c))
            return " '" + c.toUpperCase() + "'";
          if (/[A-Z]/.test(c))
            return " 'capital " + c.toUpperCase() + "'";
          return c;
        }
        if (/[a-z]/.test(c))
          return ` <say-as interpret-as="character">${c}</say-as>`;
        if (/[A-Z]/.test(c))
          return `capital <say-as interpret-as="character">${c.toLowerCase()}</say-as>`;
        return c;
      }
      function emph(s) {
        return "<emphasis>" + s + "</emphasis>";
      }
      if (!atom)
        return "";
      let result = "";
      if (isArray2(atom)) {
        let isInDigitRun = false;
        let isInTextRun = false;
        for (let i = 0; i < atom.length; i++) {
          if (atom[i].type === "first")
            continue;
          if (atom[i].mode !== "text")
            isInTextRun = false;
          if (i < atom.length - 2 && atom[i].type === "mopen" && atom[i + 2].type === "mclose" && atom[i + 1].type === "mord") {
            result += " of ";
            result += emph(atomToSpeakableFragment(mode, atom[i + 1]));
            i += 2;
          } else if (atom[i].mode === "text") {
            if (isInTextRun)
              result += (_a3 = atom[i].value) != null ? _a3 : " ";
            else {
              isInTextRun = true;
              result += atomToSpeakableFragment("text", atom[i]);
            }
          } else if (atom[i].isDigit()) {
            if (isInDigitRun)
              result += atom[i].asDigit();
            else {
              isInDigitRun = true;
              result += atomToSpeakableFragment(mode, atom[i]);
            }
          } else {
            isInDigitRun = false;
            result += atomToSpeakableFragment(mode, atom[i]);
          }
        }
      } else if (atom.mode === "text") {
        if (atom.id && mode === "math")
          result += '<mark name="' + atom.id.toString() + '"/>';
        result += atom.value;
      } else {
        if (atom.id && mode === "math")
          result += '<mark name="' + atom.id.toString() + '"/>';
        let numer = "";
        let denom = "";
        let body = "";
        let supsubHandled = false;
        const { command } = atom;
        switch (atom.type) {
          case "prompt":
            const input = atom.body.length > 1 ? 'start input . <break time="500ms"/> ' + atomToSpeakableFragment(mode, atom.body) + '. <break time="500ms"/> end input' : "blank";
            result += ' <break time="300ms"/> ' + input + '. <break time="700ms"/>' + ((_b3 = atom.correctness) != null ? _b3 : "") + ' . <break time="700ms"/> ';
            break;
          case "accent":
            if (command === "\\vec")
              result += "vector " + atomToSpeakableFragment(mode, atom.body);
            break;
          case "array":
            const array = atom.array;
            const environment = atom.environmentName;
            if (Object.keys(ENVIRONMENTS_NAMES).includes(environment)) {
              result += ` begin ${ENVIRONMENTS_NAMES[environment]} `;
              for (let i = 0; i < array.length; i++) {
                if (i > 0)
                  result += ",";
                result += ` row ${i + 1} `;
                for (let j = 0; j < array[i].length; j++) {
                  if (j > 0)
                    result += ",";
                  result += ` column ${j + 1}: `;
                  result += atomToSpeakableFragment("math", array[i][j]);
                }
              }
              result += ` end ${ENVIRONMENTS_NAMES[environment]} `;
            }
            break;
          case "group":
            if (command === "\\ne")
              result += " not equal ";
            else if (command === "\\not") {
              result += " not ";
              result += atomToSpeakableFragment("math", atom.body);
            } else {
              result += atomToSpeakableFragment("math", atom.body);
            }
            break;
          case "root":
            result += atomToSpeakableFragment("math", atom.body);
            break;
          case "genfrac":
            numer = atomToSpeakableFragment("math", atom.above);
            denom = atomToSpeakableFragment("math", atom.below);
            if (isAtomic(atom.above) && isAtomic(atom.below)) {
              const COMMON_FRACTIONS = {
                "1/2": " half ",
                "1/3": " one third ",
                "2/3": " two third",
                "1/4": " one quarter ",
                "3/4": " three quarter ",
                "1/5": " one fifth ",
                "2/5": " two fifths ",
                "3/5": " three fifths ",
                "4/5": " four fifths ",
                "1/6": " one sixth ",
                "5/6": " five sixths ",
                "1/8": " one eight ",
                "3/8": " three eights ",
                "5/8": " five eights ",
                "7/8": " seven eights ",
                "1/9": " one ninth ",
                "2/9": " two ninths ",
                "4/9": " four ninths ",
                "5/9": " five ninths ",
                "7/9": " seven ninths ",
                "8/9": " eight ninths "
                // '1/10':     ' one tenth ',
                // '1/12':     ' one twelfth ',
                // 'x/2':     ' <say-as interpret-as="character">X</say-as> over 2',
              };
              const commonFraction = COMMON_FRACTIONS[atomicValue(atom.above) + "/" + atomicValue(atom.below)];
              if (commonFraction)
                result = commonFraction;
              else
                result += numer + " over " + denom;
            } else {
              result += ' the fraction <break time="150ms"/>' + numer + ' over <break time="150ms"/>' + denom + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
            }
            break;
          case "surd":
            body = atomToSpeakableFragment("math", atom.body);
            if (atom.hasEmptyBranch("above")) {
              result += isAtomic(atom.body) ? " the square root of " + body + " , " : ' the square root of <break time="200ms"/>' + body + '. <break time="200ms"/> End square root';
            } else {
              let index = atomToSpeakableFragment("math", atom.above);
              index = index.trim();
              const index2 = index.replace(/<mark([^/]*)\/>/g, "");
              if (index2 === "3") {
                result += ' the cube root of <break time="200ms"/>' + body + '. <break time="200ms"/> End cube root';
              } else if (index2 === "n") {
                result += ' the nth root of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
              } else {
                result += ' the root with index: <break time="200ms"/>' + index + ', of <break time="200ms"/>' + body + '. <break time="200ms"/> End root';
              }
            }
            break;
          case "leftright":
            {
              const delimAtom = atom;
              result += (_c2 = delimAtom.leftDelim ? PRONUNCIATION[delimAtom.leftDelim] : void 0) != null ? _c2 : delimAtom.leftDelim;
              result += atomToSpeakableFragment("math", atom.body);
              result += (_d2 = delimAtom.rightDelim ? PRONUNCIATION[delimAtom.rightDelim] : void 0) != null ? _d2 : delimAtom.rightDelim;
            }
            break;
          case "rule":
            break;
          case "overunder":
            break;
          case "overlap":
            break;
          case "line":
            const position = atom.position;
            result += `${position} `;
            result += atomToSpeakableFragment("math", atom.body);
            result += ` end ${position} `;
            break;
          case "macro":
            const macroName = command.replace(/^\\/g, "");
            const macro = getMacros()[macroName];
            if (macro) {
              if (macro == null ? void 0 : macro.expand)
                result += atomToSpeakableFragment("math", atom.body);
              else
                result += `${macroName} `;
            }
            break;
          case "placeholder":
            result += "placeholder ";
            break;
          case "delim":
          case "sizeddelim":
          case "mord":
          case "minner":
          case "mbin":
          case "mrel":
          case "mpunct":
          case "mopen":
          case "mclose": {
            if (command === "\\mathbin" || command === "\\mathrel" || command === "\\mathopen" || command === "\\mathclose" || command === "\\mathpunct" || command === "\\mathord" || command === "\\mathinner") {
              result = atomToSpeakableFragment(mode, atom.body);
              break;
            }
            let atomValue = atom.isDigit() ? atom.asDigit() : atom.value;
            let latexValue = atom.command;
            if (atom.type === "delim" || atom.type === "sizeddelim") {
              latexValue = atom.value;
              atomValue = latexValue;
            }
            if (mode === "text")
              result += atomValue;
            else {
              if (atom.type === "mbin")
                result += '<break time="150ms"/>';
              if (atomValue) {
                const value = PRONUNCIATION[atomValue] || (latexValue ? PRONUNCIATION[latexValue.trim()] : "");
                if (value)
                  result += " " + value;
                else {
                  const spokenName = latexValue ? getSpokenName(latexValue.trim()) : "";
                  result += spokenName ? spokenName : letter(atomValue);
                }
              } else
                result += atomToSpeakableFragment("math", atom.body);
              if (atom.type === "mbin")
                result += '<break time="150ms"/>';
            }
            break;
          }
          case "mop":
            if (atom.value !== "​") {
              const trimLatex = atom.command;
              if (trimLatex === "\\sum") {
                if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                  let sup = atomToSpeakableFragment("math", atom.superscript);
                  sup = sup.trim();
                  let sub = atomToSpeakableFragment("math", atom.subscript);
                  sub = sub.trim();
                  result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> to  <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
                  supsubHandled = true;
                } else if (!atom.hasEmptyBranch("subscript")) {
                  let sub = atomToSpeakableFragment("math", atom.subscript);
                  sub = sub.trim();
                  result += ' the summation from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
                  supsubHandled = true;
                } else
                  result += " the summation of";
              } else if (trimLatex === "\\prod") {
                if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                  let sup = atomToSpeakableFragment("math", atom.superscript);
                  sup = sup.trim();
                  let sub = atomToSpeakableFragment("math", atom.subscript);
                  sub = sub.trim();
                  result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> to <break time="200ms"/>' + sup + '<break time="200ms"/> of <break time="150ms"/>';
                  supsubHandled = true;
                } else if (!atom.hasEmptyBranch("subscript")) {
                  let sub = atomToSpeakableFragment("math", atom.subscript);
                  sub = sub.trim();
                  result += ' the product from <break time="200ms"/>' + sub + '<break time="200ms"/> of <break time="150ms"/>';
                  supsubHandled = true;
                } else
                  result += " the product  of ";
              } else if (trimLatex === "\\int") {
                if (!atom.hasEmptyBranch("superscript") && !atom.hasEmptyBranch("subscript")) {
                  let sup = atomToSpeakableFragment("math", atom.superscript);
                  sup = sup.trim();
                  let sub = atomToSpeakableFragment("math", atom.subscript);
                  sub = sub.trim();
                  result += ' the integral from <break time="200ms"/>' + emph(sub) + '<break time="200ms"/> to <break time="200ms"/>' + emph(sup) + ' <break time="200ms"/> of ';
                  supsubHandled = true;
                } else
                  result += ' the integral of <break time="200ms"/> ';
              } else if (typeof atom.value === "string") {
                const value = (_e = PRONUNCIATION[atom.value]) != null ? _e : atom.command ? PRONUNCIATION[atom.command] : void 0;
                result += value ? value : " " + atom.value;
              } else if (atom.command) {
                if (atom.command === "\\mathop")
                  result += atomToSpeakableFragment("math", atom.body);
                else if (atom.command === "\\operatorname")
                  result += atomsAsText(atom.body);
                else {
                  result += atom.command.startsWith("\\") ? " " + atom.command.slice(1) : " " + atom.command;
                }
              }
            }
            break;
          case "enclose":
            body = atomToSpeakableFragment("math", atom.body);
            result += " crossed out " + body + ". End crossed out.";
            break;
        }
        if (!supsubHandled && !atom.hasEmptyBranch("superscript")) {
          let sup = atomToSpeakableFragment(mode, atom.superscript);
          sup = sup.trim();
          const sup2 = sup.replace(/<[^>]*>/g, "");
          if (isAtomic(atom.superscript)) {
            if (mode === "math") {
              const id = atomicID(atom.superscript);
              if (id)
                result += '<mark name="' + id + '"/>';
            }
            if (sup2 === "′")
              result += " prime ";
            else if (sup2 === "2")
              result += " squared ";
            else if (sup2 === "3")
              result += " cubed ";
            else if (Number.isNaN(Number.parseInt(sup2)))
              result += " to the " + sup + "; ";
            else {
              result += ' to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
            }
          } else if (Number.isNaN(Number.parseInt(sup2)))
            result += " raised to the " + sup + "; ";
          else {
            result += ' raised to the <say-as interpret-as="ordinal">' + sup2 + "</say-as> power; ";
          }
        }
        if (!supsubHandled && !atom.hasEmptyBranch("subscript")) {
          let sub = atomToSpeakableFragment("math", atom.subscript);
          sub = sub.trim();
          result += isAtomic(atom.subscript) ? " sub " + sub : " subscript " + sub + ". End subscript. ";
        }
      }
      return result;
    }
    function atomToSpeakableText(atoms) {
      var _a3, _b3;
      if (window.MathfieldElement.textToSpeechRules === "sre" && ("sre" in window || "SRE" in window)) {
        const mathML = toMathML(atoms);
        if (mathML) {
          if (window.MathfieldElement.textToSpeechMarkup) {
            window.MathfieldElement.textToSpeechRulesOptions = (_a3 = window.MathfieldElement.textToSpeechRulesOptions) != null ? _a3 : {};
            window.MathfieldElement.textToSpeechRulesOptions.markup = window.MathfieldElement.textToSpeechMarkup;
            if (window.MathfieldElement.textToSpeechRulesOptions.markup === "ssml")
              window.MathfieldElement.textToSpeechRulesOptions.markup = "ssml_step";
            window.MathfieldElement.textToSpeechRulesOptions.rate = window.MathfieldElement.speechEngineRate;
          }
          const SRE = (_b3 = window["SRE"]) != null ? _b3 : window.sre.System.getInstance();
          if (window.MathfieldElement.textToSpeechRulesOptions)
            SRE.setupEngine(window.MathfieldElement.textToSpeechRulesOptions);
          let result2 = "";
          try {
            result2 = SRE.toSpeech(mathML);
          } catch (e) {
            console.error(
              `MathLive 0.90.9: \`SRE.toSpeech()\` runtime error`,
              e
            );
          }
          return result2;
        }
        return "";
      }
      let result = atomToSpeakableFragment("math", atoms);
      if (window.MathfieldElement.textToSpeechMarkup === "ssml") {
        let prosody = "";
        if (window.MathfieldElement.speechEngineRate) {
          prosody = '<prosody rate="' + window.MathfieldElement.speechEngineRate + '">';
        }
        result = `<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>` + prosody + "<p><s>" + result + "</s></p>" + (prosody ? "</prosody>" : "") + "</amazon:auto-breaths></speak>";
      } else if (window.MathfieldElement.textToSpeechMarkup === "mac" && osPlatform() === "macos") {
        result = result.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "");
      } else {
        result = result.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
      }
      return result;
    }
    function on(element, inSelectors, listener, options) {
      const selectors = inSelectors.split(" ");
      for (const sel of selectors) {
        const m = sel.match(/(.*):(.*)/);
        if (m) {
          const options2 = options != null ? options : {};
          if (m[2] === "active")
            options2.passive = false;
          else
            options2[m[2]] = true;
          element.addEventListener(m[1], listener, options2);
        } else
          element.addEventListener(sel, listener, options);
      }
    }
    function off(element, inSelectors, listener, options) {
      const selectors = inSelectors.split(" ");
      for (const sel of selectors) {
        const m = sel.match(/(.*):(.*)/);
        if (m) {
          const options2 = options != null ? options : {};
          if (m[2] === "active")
            options2.passive = false;
          else
            options2[m[2]] = true;
          element.removeEventListener(m[1], listener, options2);
        } else
          element.removeEventListener(sel, listener, options);
      }
    }
    function getSharedElement(id) {
      var _a3;
      throwIfNotInBrowser();
      let result = document.getElementById(id);
      if (result) {
        result.dataset.refcount = Number(
          Number.parseInt((_a3 = result.getAttribute("data-refcount")) != null ? _a3 : "0") + 1
        ).toString();
      } else {
        result = document.createElement("div");
        result.setAttribute("aria-hidden", "true");
        result.dataset.refcount = "1";
        result.id = id;
        document.body.append(result);
      }
      return result;
    }
    function releaseSharedElement(element) {
      var _a3;
      if (!element)
        return;
      const refcount = Number.parseInt(
        (_a3 = element.getAttribute("data-refcount")) != null ? _a3 : "0"
      );
      if (refcount <= 1)
        element.remove();
      else
        element.dataset.refcount = Number(refcount - 1).toString();
    }
    function isValidMathfield(mf) {
      var _a3;
      return ((_a3 = mf.element) == null ? void 0 : _a3.mathfield) === mf;
    }
    function findElementWithCaret(element) {
      var _a3, _b3;
      return (_b3 = (_a3 = element.querySelector(".ML__caret")) != null ? _a3 : element.querySelector(".ML__text-caret")) != null ? _b3 : element.querySelector(".ML__latex-caret");
    }
    function getCaretPoint(element) {
      const caret = findElementWithCaret(element);
      if (!caret)
        return null;
      const bounds = caret.getBoundingClientRect();
      return {
        x: bounds.right,
        y: bounds.bottom,
        height: bounds.height
      };
    }
    function branchId(atom) {
      var _a3;
      if (!atom.parent)
        return "root";
      let result = (_a3 = atom.parent.id) != null ? _a3 : "";
      result += typeof atom.treeBranch === "string" ? "-" + atom.treeBranch : `-${atom.treeBranch[0]}/${atom.treeBranch[0]}`;
      return result;
    }
    function adjustForScrolling(mathfield, rect) {
      if (!rect)
        return null;
      const fieldRect = mathfield.field.getBoundingClientRect();
      const w = rect.right - rect.left;
      const h = rect.bottom - rect.top;
      const left = Math.ceil(
        rect.left - fieldRect.left + mathfield.field.scrollLeft
      );
      const top = Math.ceil(rect.top - fieldRect.top);
      return {
        left,
        right: left + w,
        top,
        bottom: top + h
      };
    }
    function getNodeBounds(node) {
      const bounds = node.getBoundingClientRect();
      const marginRight = parseInt(getComputedStyle(node).marginRight);
      const result = {
        top: bounds.top - 1,
        bottom: bounds.bottom,
        left: bounds.left,
        right: bounds.right - 1 + marginRight
      };
      if (node.children.length === 0 || node.tagName.toUpperCase() === "SVG")
        return result;
      for (const child of node.children) {
        if (child.nodeType === 1 && "atomId" in child.dataset && !child.classList.contains("pstrut")) {
          const r = getNodeBounds(child);
          result.left = Math.min(result.left, r.left);
          result.right = Math.max(result.right, r.right);
          result.top = Math.min(result.top, r.top);
          result.bottom = Math.max(result.bottom, r.bottom);
        }
      }
      return result;
    }
    function getAtomBounds(mathfield, atom) {
      var _a3, _b3;
      if (!atom.id)
        return null;
      let result = (_b3 = (_a3 = mathfield.atomBoundsCache) == null ? void 0 : _a3.get(atom.id)) != null ? _b3 : null;
      if (result !== null)
        return result;
      const node = mathfield.field.querySelector(`[data-atom-id="${atom.id}"]`);
      result = node ? getNodeBounds(node) : null;
      if (mathfield.atomBoundsCache) {
        if (result)
          mathfield.atomBoundsCache.set(atom.id, result);
        else
          mathfield.atomBoundsCache.delete(atom.id);
      }
      return result != null ? result : null;
    }
    function getRangeBounds(mathfield, range2, options) {
      const rects = /* @__PURE__ */ new Map();
      for (const atom of mathfield.model.getAtoms(range2, {
        includeChildren: true
      })) {
        if ((options == null ? void 0 : options.excludeAtomsWithBackground) && atom.style.backgroundColor)
          break;
        const bounds = adjustForScrolling(
          mathfield,
          getAtomBounds(mathfield, atom)
        );
        if (bounds) {
          const id = branchId(atom);
          if (rects.has(id)) {
            const r = rects.get(id);
            rects.set(id, {
              left: Math.min(r.left, bounds.left),
              right: Math.max(r.right, bounds.right),
              top: Math.min(r.top, bounds.top),
              bottom: Math.max(r.bottom, bounds.bottom)
            });
          } else
            rects.set(id, bounds);
        }
      }
      return [...rects.values()];
    }
    function getSelectionBounds(mathfield, options) {
      return mathfield.model.selection.ranges.reduce(
        (acc, x) => acc.concat(...getRangeBounds(mathfield, x, options)),
        []
      );
    }
    function validateOrigin(origin, originValidator) {
      if (origin === "*" || originValidator === "none")
        return true;
      if (originValidator === "same-origin")
        return !window.origin || origin === window.origin;
      if (typeof originValidator === "function")
        return originValidator(origin);
      return false;
    }
    function getLocalDOMRect(el) {
      let offsetTop = 0;
      let offsetLeft = 0;
      const width = el.offsetWidth;
      const height = el.offsetHeight;
      while (el instanceof HTMLElement) {
        offsetTop += el.offsetTop;
        offsetLeft += el.offsetLeft;
        el = el.offsetParent;
      }
      return new DOMRect(offsetLeft, offsetTop, width, height);
    }
    function hashCode(s) {
      let hash2 = 0;
      for (let i = 0; i < s.length; i++)
        hash2 = Math.imul(31, hash2) + s.charCodeAt(i) | 0;
      return Math.abs(hash2);
    }
    function inject2(element, css, id) {
      var _a3, _b3;
      if (!css)
        return null;
      let root = (_a3 = element == null ? void 0 : element.getRootNode()) != null ? _a3 : document == null ? void 0 : document.head;
      if (!root)
        return null;
      if (root === document)
        root = document.head;
      const element_ = root.querySelector(
        `style[data-id="${id}"]`
      );
      if (element_) {
        const refCount = Number.parseFloat(
          (_b3 = element_.getAttribute("data-refcount")) != null ? _b3 : "0"
        );
        element_.dataset.refcount = Number(refCount + 1).toString();
      } else {
        const styleNode = document.createElement("style");
        styleNode.dataset.id = id;
        styleNode.dataset.refcount = "1";
        styleNode.append(document.createTextNode(css));
        root.appendChild(styleNode);
      }
      return {
        release: () => {
          var _a4;
          const element_2 = root.querySelector(
            `style[data-id="${id}"]`
          );
          if (element_2) {
            const refCount = Number.parseFloat(
              (_a4 = element_2.getAttribute("data-refcount")) != null ? _a4 : "0"
            );
            if (refCount === 1)
              element_2.remove();
            else
              element_2.dataset.refcount = Number(refCount - 1).toString();
          }
        }
      };
    }
    function keystrokeModifiersFromString(key) {
      const segments = key.split("+");
      const result = {
        shift: false,
        alt: false,
        cmd: false,
        win: false,
        meta: false,
        ctrl: false,
        key: segments.pop()
      };
      if (segments.includes("shift"))
        result.shift = true;
      if (segments.includes("alt"))
        result.alt = true;
      if (segments.includes("ctrl"))
        result.ctrl = true;
      if (segments.includes("cmd"))
        result.cmd = true;
      if (segments.includes("win"))
        result.win = true;
      if (segments.includes("meta"))
        result.meta = true;
      return result;
    }
    function keystrokeModifiersToString(key) {
      let result = "";
      if (key.shift)
        result += "shift+";
      if (key.alt)
        result += "alt+";
      if (key.ctrl)
        result += "ctrl+";
      if (key.cmd)
        result += "cmd+";
      if (key.win)
        result += "win+";
      if (key.meta)
        result += "meta+";
      return result + key.key;
    }
    var DEFAULT_KEYBOARD_LAYOUT = platform() === "apple" ? {
      id: "apple.en-intl",
      displayName: "English (international)",
      virtualLayout: "qwerty",
      platform: "apple",
      locale: "en",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "å", "Å"],
        KeyB: ["b", "B", "∫", "ı"],
        KeyC: ["c", "C", "ç", "Ç"],
        KeyD: ["d", "D", "∂", "Î"],
        KeyE: ["e", "E", "´", "´"],
        KeyF: ["f", "F", "ƒ", "Ï"],
        KeyG: ["g", "G", "©", "˝"],
        KeyH: ["h", "H", "˙", "Ó"],
        KeyI: ["i", "I", "ˆ", "ˆ"],
        KeyJ: ["j", "J", "∆", "Ô"],
        KeyK: ["k", "K", "˚", ""],
        KeyL: ["l", "L", "¬", "Ò"],
        KeyM: ["m", "M", "µ", "Â"],
        KeyN: ["n", "N", "˜", "˜"],
        KeyO: ["o", "O", "ø", "Ø"],
        KeyP: ["p", "P", "π", "∏"],
        KeyQ: ["q", "Q", "œ", "Œ"],
        KeyR: ["r", "R", "®", "‰"],
        KeyS: ["s", "S", "ß", "Í"],
        KeyT: ["t", "T", "†", "ˇ"],
        KeyU: ["u", "U", "¨", "¨"],
        KeyV: ["v", "V", "√", "◊"],
        KeyW: ["w", "W", "∑", "„"],
        KeyX: ["x", "X", "≈", "˛"],
        KeyY: ["y", "Y", "¥", "Á"],
        KeyZ: ["z", "Z", "Ω", "¸"],
        Digit1: ["1", "!", "¡", "⁄"],
        Digit2: ["2", "@", "™", "€"],
        Digit3: ["3", "#", "£", "‹"],
        Digit4: ["4", "$", "¢", "›"],
        Digit5: ["5", "%", "∞", "ﬁ"],
        Digit6: ["6", "^", "§", "ﬂ"],
        Digit7: ["7", "&", "¶", "‡"],
        Digit8: ["8", "*", "•", "°"],
        Digit9: ["9", "(", "ª", "·"],
        Digit0: ["0", ")", "º", "‚"],
        Space: [" ", " ", " ", " "],
        Minus: ["-", "_", "–", "—"],
        Equal: ["=", "+", "≠", "±"],
        BracketLeft: ["[", "{", "“", "”"],
        BracketRight: ["]", "}", "‘", "’"],
        Backslash: ["\\", "|", "«", "»"],
        Semicolon: [";", ":", "…", "Ú"],
        Quote: ["'", '"', "æ", "Æ"],
        Backquote: ["`", "˜", "`", "`"],
        Comma: [",", "<", "≤", "¯"],
        Period: [".", ">", "≥", "˘"],
        Slash: ["/", "?", "÷", "¿"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        Numpad1: ["1", "1", "1", "1"],
        Numpad2: ["2", "2", "2", "2"],
        Numpad3: ["3", "3", "3", "3"],
        Numpad4: ["4", "4", "4", "4"],
        Numpad5: ["5", "5", "5", "5"],
        Numpad6: ["6", "6", "6", "6"],
        Numpad7: ["7", "7", "7", "7"],
        Numpad8: ["8", "8", "8", "8"],
        Numpad9: ["9", "9", "9", "9"],
        Numpad0: ["0", "0", "0", "0"],
        NumpadDecimal: [".", ".", ".", "."],
        IntlBackslash: ["§", "±", "§", "±"],
        NumpadEqual: ["=", "=", "=", "="],
        AudioVolumeUp: ["", "=", "", "="]
      }
    } : platform() === "windows" ? {
      id: "windows.en-intl",
      displayName: "English (international)",
      platform: "windows",
      virtualLayout: "qwerty",
      locale: "en",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "á", "Á"],
        KeyB: ["b", "B", "", ""],
        KeyC: ["c", "C", "©", "¢"],
        KeyD: ["d", "D", "ð", "Ð"],
        KeyE: ["e", "E", "é", "É"],
        KeyF: ["f", "F", "", ""],
        KeyG: ["g", "G", "", ""],
        KeyH: ["h", "H", "", ""],
        KeyI: ["i", "I", "í", "Í"],
        KeyJ: ["j", "J", "", ""],
        KeyK: ["k", "K", "", ""],
        KeyL: ["l", "L", "ø", "Ø"],
        KeyM: ["m", "M", "µ", ""],
        KeyN: ["n", "N", "ñ", "Ñ"],
        KeyO: ["o", "O", "ó", "Ó"],
        KeyP: ["p", "P", "ö", "Ö"],
        KeyQ: ["q", "Q", "ä", "Ä"],
        KeyR: ["r", "R", "®", ""],
        KeyS: ["s", "S", "ß", "§"],
        KeyT: ["t", "T", "þ", "Þ"],
        KeyU: ["u", "U", "ú", "Ú"],
        KeyV: ["v", "V", "", ""],
        KeyW: ["w", "W", "å", "Å"],
        KeyX: ["x", "X", "", ""],
        KeyY: ["y", "Y", "ü", "Ü"],
        KeyZ: ["z", "Z", "æ", "Æ"],
        Digit1: ["1", "!", "¡", "¹"],
        Digit2: ["2", "@", "²", ""],
        Digit3: ["3", "#", "³", ""],
        Digit4: ["4", "$", "¤", "£"],
        Digit5: ["5", "%", "€", ""],
        Digit6: ["6", "^", "¼", ""],
        Digit7: ["7", "&", "½", ""],
        Digit8: ["8", "*", "¾", ""],
        Digit9: ["9", "(", "‘", ""],
        Digit0: ["0", ")", "’", ""],
        Space: [" ", " ", "", ""],
        Minus: ["-", "_", "¥", ""],
        Equal: ["=", "+", "×", "÷"],
        BracketLeft: ["[", "{", "«", ""],
        BracketRight: ["]", "}", "»", ""],
        Backslash: ["\\", "|", "¬", "¦"],
        Semicolon: [";", ":", "¶", "°"],
        Quote: ["'", '"', "´", "¨"],
        Backquote: ["`", "~", "", ""],
        Comma: [",", "<", "ç", "Ç"],
        Period: [".", ">", "", ""],
        Slash: ["/", "?", "¿", ""],
        NumpadDivide: ["/", "/", "", ""],
        NumpadMultiply: ["*", "*", "", ""],
        NumpadSubtract: ["-", "-", "", ""],
        NumpadAdd: ["+", "+", "", ""],
        IntlBackslash: ["\\", "|", "", ""]
      }
    } : {
      id: "linux.en",
      displayName: "English",
      platform: "linux",
      virtualLayout: "qwerty",
      locale: "en",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "a", "A"],
        KeyB: ["b", "B", "b", "B"],
        KeyC: ["c", "C", "c", "C"],
        KeyD: ["d", "D", "d", "D"],
        KeyE: ["e", "E", "e", "E"],
        KeyF: ["f", "F", "f", "F"],
        KeyG: ["g", "G", "g", "G"],
        KeyH: ["h", "H", "h", "H"],
        KeyI: ["i", "I", "i", "I"],
        KeyJ: ["j", "J", "j", "J"],
        KeyK: ["k", "K", "k", "K"],
        KeyL: ["l", "L", "l", "L"],
        KeyM: ["m", "M", "m", "M"],
        KeyN: ["n", "N", "n", "N"],
        KeyO: ["o", "O", "o", "O"],
        KeyP: ["p", "P", "p", "P"],
        KeyQ: ["q", "Q", "q", "Q"],
        KeyR: ["r", "R", "r", "R"],
        KeyS: ["s", "S", "s", "S"],
        KeyT: ["t", "T", "t", "T"],
        KeyU: ["u", "U", "u", "U"],
        KeyV: ["v", "V", "v", "V"],
        KeyW: ["w", "W", "w", "W"],
        KeyX: ["x", "X", "x", "X"],
        KeyY: ["y", "Y", "y", "Y"],
        KeyZ: ["z", "Z", "z", "Z"],
        Digit1: ["1", "!", "1", "!"],
        Digit2: ["2", "@", "2", "@"],
        Digit3: ["3", "#", "3", "#"],
        Digit4: ["4", "$", "4", "$"],
        Digit5: ["5", "%", "5", "%"],
        Digit6: ["6", "^", "6", "^"],
        Digit7: ["7", "&", "7", "&"],
        Digit8: ["8", "*", "8", "*"],
        Digit9: ["9", "(", "9", "("],
        Digit0: ["0", ")", "0", ")"],
        Space: [" ", " ", " ", " "],
        Minus: ["-", "_", "-", "_"],
        Equal: ["=", "+", "=", "+"],
        BracketLeft: ["[", "{", "[", "{"],
        BracketRight: ["]", "}", "]", "}"],
        Backslash: ["\\", "|", "\\", "|"],
        Semicolon: [";", ":", ";", ":"],
        Quote: ["'", '"', "'", '"'],
        Backquote: ["`", "~", "`", "~"],
        Comma: [",", "<", ",", "<"],
        Period: [".", ">", ".", ">"],
        Slash: ["/", "?", "/", "?"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        Numpad1: ["1", "1", "1", "1"],
        Numpad2: ["2", "2", "2", "2"],
        Numpad3: ["3", "3", "3", "3"],
        Numpad4: ["4", "4", "4", "4"],
        Numpad5: ["5", "5", "5", "5"],
        Numpad6: ["6", "6", "6", "6"],
        Numpad7: ["7", "7", "7", "7"],
        Numpad8: ["8", "8", "8", "8"],
        Numpad9: ["9", "9", "9", "9"],
        Numpad0: ["0", "0", "0", "0"],
        NumpadDecimal: ["", ".", "", "."],
        IntlBackslash: ["<", ">", "|", "¦"],
        NumpadEqual: ["=", "=", "=", "="],
        NumpadComma: [".", ".", ".", "."],
        NumpadParenLeft: ["(", "(", "(", "("],
        NumpadParenRight: [")", ")", ")", ")"]
      }
    };
    var BASE_LAYOUT_MAPPING = {
      enter: "[Enter]",
      escape: "[Escape]",
      backspace: "[Backspace]",
      tab: "[Tab]",
      space: "[Space]",
      pausebreak: "[Pause]",
      insert: "[Insert]",
      home: "[Home]",
      pageup: "[PageUp]",
      delete: "[Delete]",
      end: "[End]",
      pagedown: "[PageDown]",
      right: "[ArrowRight]",
      left: "[ArrowLeft]",
      down: "[ArrowDown]",
      up: "[ArrowUp]",
      numpad0: "[Numpad0]",
      numpad1: "[Numpad1]",
      numpad2: "[Numpad2]",
      numpad3: "[Numpad3]",
      numpad4: "[Numpad4]",
      numpad5: "[Numpad5]",
      numpad6: "[Numpad6]",
      numpad7: "[Numpad7]",
      numpad8: "[Numpad8]",
      numpad9: "[Numpad9]",
      "numpad_divide": "[NumpadDivide]",
      "numpad_multiply": "[NumpadMultiply]",
      "numpad_subtract": "[NumpadSubtract]",
      "numpad_add": "[NumpadAdd]",
      "numpad_decimal": "[NumpadDecimal]",
      "numpad_separator": "[NumpadComma]",
      capslock: "[Capslock]",
      f1: "[F1]",
      f2: "[F2]",
      f3: "[F3]",
      f4: "[F4]",
      f5: "[F5]",
      f6: "[F6]",
      f7: "[F7]",
      f8: "[F8]",
      f9: "[F9]",
      f10: "[F10]",
      f11: "[F11]",
      f12: "[F12]",
      f13: "[F13]",
      f14: "[F14]",
      f15: "[F15]",
      f16: "[F16]",
      f17: "[F17]",
      f18: "[F18]",
      f19: "[F19]"
    };
    var gKeyboardLayouts = [];
    function platform() {
      switch (osPlatform()) {
        case "macos":
        case "ios":
          return "apple";
        case "windows":
          return "windows";
      }
      return "linux";
    }
    function register(layout) {
      if (!layout.platform || layout.platform === platform())
        gKeyboardLayouts.push(layout);
    }
    function getCodeForKey(k, layout) {
      var _a3;
      const result = {
        shift: false,
        alt: false,
        cmd: false,
        win: false,
        meta: false,
        ctrl: false,
        key: ""
      };
      if (!k)
        return result;
      for (const [key, value] of Object.entries(layout.mapping)) {
        if (value[0] === k) {
          result.key = `[${key}]`;
          return result;
        }
        if (value[1] === k) {
          result.shift = true;
          result.key = `[${key}]`;
          return result;
        }
        if (value[2] === k) {
          result.alt = true;
          result.key = `[${key}]`;
          return result;
        }
        if (value[3] === k) {
          result.shift = true;
          result.alt = true;
          result.key = `[${key}]`;
          return result;
        }
      }
      result.key = (_a3 = BASE_LAYOUT_MAPPING[k]) != null ? _a3 : "";
      return result;
    }
    function normalizeKeyboardEvent(evt) {
      if (evt.code)
        return evt;
      const mapping = Object.entries(getActiveKeyboardLayout().mapping);
      let altKey = false;
      let shiftKey = false;
      let code = "";
      for (let index = 0; index < 4; index++) {
        for (const [key, value] of mapping) {
          if (value[index] === evt.key) {
            code = key;
            if (index === 3) {
              altKey = true;
              shiftKey = true;
            } else if (index === 2)
              altKey = true;
            else if (index === 1)
              shiftKey = true;
            break;
          }
        }
        if (code)
          break;
      }
      return new KeyboardEvent(evt.type, __spreadProps(__spreadValues({}, evt), { altKey, shiftKey, code }));
    }
    function validateKeyboardLayout(evt) {
      var _a3, _b3;
      if (!evt)
        return;
      if (evt.key === "Unidentified")
        return;
      if (evt.key === "Dead")
        return;
      const index = evt.shiftKey && evt.altKey ? 3 : evt.altKey ? 2 : evt.shiftKey ? 1 : 0;
      for (const layout of gKeyboardLayouts) {
        if (((_a3 = layout.mapping[evt.code]) == null ? void 0 : _a3[index]) === evt.key) {
          layout.score += 1;
        } else if ((_b3 = layout.mapping[evt.code]) == null ? void 0 : _b3[index]) {
          layout.score = 0;
        }
      }
      gKeyboardLayouts.sort((a, b) => b.score - a.score);
    }
    function getActiveKeyboardLayout() {
      return gKeyboardLayouts[0];
    }
    register(DEFAULT_KEYBOARD_LAYOUT);
    register({
      id: "apple.french",
      locale: "fr",
      displayName: "French",
      platform: "apple",
      virtualLayout: "azerty",
      score: 0,
      mapping: {
        KeyA: ["q", "Q", "‡", "Ω"],
        KeyB: ["b", "B", "ß", "∫"],
        KeyC: ["c", "C", "©", "¢"],
        KeyD: ["d", "D", "∂", "∆"],
        KeyE: ["e", "E", "ê", "Ê"],
        KeyF: ["f", "F", "ƒ", "·"],
        KeyG: ["g", "G", "ﬁ", "ﬂ"],
        KeyH: ["h", "H", "Ì", "Î"],
        KeyI: ["i", "I", "î", "ï"],
        KeyJ: ["j", "J", "Ï", "Í"],
        KeyK: ["k", "K", "È", "Ë"],
        KeyL: ["l", "L", "¬", "|"],
        KeyM: [",", "?", "∞", "¿"],
        KeyN: ["n", "N", "~", "ı"],
        KeyO: ["o", "O", "œ", "Œ"],
        KeyP: ["p", "P", "π", "∏"],
        KeyQ: ["a", "A", "æ", "Æ"],
        KeyR: ["r", "R", "®", "‚"],
        KeyS: ["s", "S", "Ò", "∑"],
        KeyT: ["t", "T", "†", "™"],
        KeyU: ["u", "U", "º", "ª"],
        KeyV: ["v", "V", "◊", "√"],
        KeyW: ["z", "Z", "Â", "Å"],
        KeyX: ["x", "X", "≈", "⁄"],
        KeyY: ["y", "Y", "Ú", "Ÿ"],
        KeyZ: ["w", "W", "‹", "›"],
        Digit1: ["&", "1", "", "´"],
        Digit2: ["é", "2", "ë", "„"],
        Digit3: ['"', "3", "“", "”"],
        Digit4: ["'", "4", "‘", "’"],
        Digit5: ["(", "5", "{", "["],
        Digit6: ["§", "6", "¶", "å"],
        Digit7: ["è", "7", "«", "»"],
        Digit8: ["!", "8", "¡", "Û"],
        Digit9: ["ç", "9", "Ç", "Á"],
        Digit0: ["à", "0", "ø", "Ø"],
        Space: [" ", " ", " ", " "],
        Minus: [")", "°", "}", "]"],
        Equal: ["-", "_", "—", "–"],
        BracketLeft: ["^", "¨", "ô", "Ô"],
        BracketRight: ["$", "*", "€", "¥"],
        Backslash: ["`", "£", "@", "#"],
        Semicolon: ["m", "M", "µ", "Ó"],
        Quote: ["ù", "%", "Ù", "‰"],
        Backquote: ["<", ">", "≤", "≥"],
        Comma: [";", ".", "…", "•"],
        Period: [":", "/", "÷", "\\"],
        Slash: ["=", "+", "≠", "±"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        NumpadDecimal: [",", ".", ",", "."],
        IntlBackslash: ["@", "#", "•", "Ÿ"],
        NumpadEqual: ["=", "=", "=", "="]
      }
    });
    register({
      id: "apple.spanish",
      locale: "es",
      displayName: "Spanish ISO",
      platform: "apple",
      virtualLayout: "qwerty",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "å", "Å"],
        KeyB: ["b", "B", "ß", ""],
        KeyC: ["c", "C", "©", " "],
        KeyD: ["d", "D", "∂", "∆"],
        KeyE: ["e", "E", "€", "€"],
        KeyF: ["f", "F", "ƒ", "ﬁ"],
        KeyG: ["g", "G", "", "ﬂ"],
        KeyH: ["h", "H", "™", " "],
        KeyI: ["i", "I", " ", " "],
        KeyJ: ["j", "J", "¶", "¯"],
        KeyK: ["k", "K", "§", "ˇ"],
        KeyL: ["l", "L", " ", "˘"],
        KeyM: ["m", "M", "µ", "˚"],
        KeyN: ["n", "N", " ", "˙"],
        KeyO: ["o", "O", "ø", "Ø"],
        KeyP: ["p", "P", "π", "∏"],
        KeyQ: ["q", "Q", "œ", "Œ"],
        KeyR: ["r", "R", "®", " "],
        KeyS: ["s", "S", "∫", " "],
        KeyT: ["t", "T", "†", "‡"],
        KeyU: ["u", "U", " ", " "],
        KeyV: ["v", "V", "√", "◊"],
        KeyW: ["w", "W", "æ", "Æ"],
        KeyX: ["x", "X", "∑", "›"],
        KeyY: ["y", "Y", "¥", " "],
        KeyZ: ["z", "Z", "Ω", "‹"],
        Digit1: ["1", "!", "|", "ı"],
        Digit2: ["2", '"', "@", "˝"],
        Digit3: ["3", "·", "#", "•"],
        Digit4: ["4", "$", "¢", "£"],
        Digit5: ["5", "%", "∞", "‰"],
        Digit6: ["6", "&", "¬", " "],
        Digit7: ["7", "/", "÷", "⁄"],
        Digit8: ["8", "(", "“", "‘"],
        Digit9: ["9", ")", "”", "’"],
        Digit0: ["0", "=", "≠", "≈"],
        Space: [" ", " ", " ", " "],
        Minus: ["'", "?", "´", "¸"],
        Equal: ["¡", "¿", "‚", "˛"],
        BracketLeft: ["`", "^", "[", "ˆ"],
        BracketRight: ["+", "*", "]", "±"],
        Backslash: ["ç", "Ç", "}", "»"],
        Semicolon: ["ñ", "Ñ", "~", "˜"],
        Quote: ["´", "¨", "{", "«"],
        Backquote: ["<", ">", "≤", "≥"],
        Comma: [",", ";", "„", ""],
        Period: [".", ":", "…", "…"],
        Slash: ["-", "_", "–", "—"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        Numpad1: ["1", "1", "1", "1"],
        Numpad2: ["2", "2", "2", "2"],
        Numpad3: ["3", "3", "3", "3"],
        Numpad4: ["4", "4", "4", "4"],
        Numpad5: ["5", "5", "5", "5"],
        Numpad6: ["6", "6", "6", "6"],
        Numpad7: ["7", "7", "7", "7"],
        Numpad8: ["8", "8", "8", "8"],
        Numpad9: ["9", "9", "9", "9"],
        Numpad0: ["0", "0", "0", "0"],
        NumpadDecimal: [",", ",", ",", ","],
        IntlBackslash: ["º", "ª", "\\", "°"]
      }
    });
    register({
      id: "windows.spanish",
      locale: "es",
      displayName: "Spanish",
      platform: "windows",
      virtualLayout: "qwerty",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "", ""],
        KeyB: ["b", "B", "", ""],
        KeyC: ["c", "C", "", ""],
        KeyD: ["d", "D", "", ""],
        KeyE: ["e", "E", "€", ""],
        KeyF: ["f", "F", "", ""],
        KeyG: ["g", "G", "", ""],
        KeyH: ["h", "H", "", ""],
        KeyI: ["i", "I", "", ""],
        KeyJ: ["j", "J", "", ""],
        KeyK: ["k", "K", "", ""],
        KeyL: ["l", "L", "", ""],
        KeyM: ["m", "M", "", ""],
        KeyN: ["n", "N", "", ""],
        KeyO: ["o", "O", "", ""],
        KeyP: ["p", "P", "", ""],
        KeyQ: ["q", "Q", "", ""],
        KeyR: ["r", "R", "", ""],
        KeyS: ["s", "S", "", ""],
        KeyT: ["t", "T", "", ""],
        KeyU: ["u", "U", "", ""],
        KeyV: ["v", "V", "", ""],
        KeyW: ["w", "W", "", ""],
        KeyX: ["x", "X", "", ""],
        KeyY: ["y", "Y", "", ""],
        KeyZ: ["z", "Z", "", ""],
        Digit1: ["1", "!", "|", ""],
        Digit2: ["2", '"', "@", ""],
        Digit3: ["3", "·", "#", ""],
        Digit4: ["4", "$", "~", ""],
        Digit5: ["5", "%", "€", ""],
        Digit6: ["6", "&", "¬", ""],
        Digit7: ["7", "/", "", ""],
        Digit8: ["8", "(", "", ""],
        Digit9: ["9", ")", "", ""],
        Digit0: ["0", "=", "", ""],
        Space: [" ", " ", "", ""],
        Minus: ["'", "?", "", ""],
        Equal: ["¡", "¿", "", ""],
        BracketLeft: ["`", "^", "[", ""],
        BracketRight: ["+", "*", "]", ""],
        Backslash: ["ç", "Ç", "}", ""],
        Semicolon: ["ñ", "Ñ", "", ""],
        Quote: ["´", "¨", "{", ""],
        Backquote: ["º", "ª", "\\", ""],
        Comma: [",", ";", "", ""],
        Period: [".", ":", "", ""],
        Slash: ["-", "_", "", ""],
        NumpadDivide: ["/", "/", "", ""],
        NumpadMultiply: ["*", "*", "", ""],
        NumpadSubtract: ["-", "-", "", ""],
        NumpadAdd: ["+", "+", "", ""],
        IntlBackslash: ["<", ">", "", ""]
      }
    });
    register({
      id: "linux.spanish",
      locale: "es",
      displayName: "Spanish",
      platform: "linux",
      virtualLayout: "qwerty",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "æ", "Æ"],
        KeyB: ["b", "B", "”", "’"],
        KeyC: ["c", "C", "¢", "©"],
        KeyD: ["d", "D", "ð", "Ð"],
        KeyE: ["e", "E", "€", "¢"],
        KeyF: ["f", "F", "đ", "ª"],
        KeyG: ["g", "G", "ŋ", "Ŋ"],
        KeyH: ["h", "H", "ħ", "Ħ"],
        KeyI: ["i", "I", "→", "ı"],
        KeyJ: ["j", "J", "̉", "̛"],
        KeyK: ["k", "K", "ĸ", "&"],
        KeyL: ["l", "L", "ł", "Ł"],
        KeyM: ["m", "M", "µ", "º"],
        KeyN: ["n", "N", "n", "N"],
        KeyO: ["o", "O", "ø", "Ø"],
        KeyP: ["p", "P", "þ", "Þ"],
        KeyQ: ["q", "Q", "@", "Ω"],
        KeyR: ["r", "R", "¶", "®"],
        KeyS: ["s", "S", "ß", "§"],
        KeyT: ["t", "T", "ŧ", "Ŧ"],
        KeyU: ["u", "U", "↓", "↑"],
        KeyV: ["v", "V", "“", "‘"],
        KeyW: ["w", "W", "ł", "Ł"],
        KeyX: ["x", "X", "»", ">"],
        KeyY: ["y", "Y", "←", "¥"],
        KeyZ: ["z", "Z", "«", "<"],
        Digit1: ["1", "!", "|", "¡"],
        Digit2: ["2", '"', "@", "⅛"],
        Digit3: ["3", "·", "#", "£"],
        Digit4: ["4", "$", "~", "$"],
        Digit5: ["5", "%", "½", "⅜"],
        Digit6: ["6", "&", "¬", "⅝"],
        Digit7: ["7", "/", "{", "⅞"],
        Digit8: ["8", "(", "[", "™"],
        Digit9: ["9", ")", "]", "±"],
        Digit0: ["0", "=", "}", "°"],
        Enter: ["\r", "\r", "\r", "\r"],
        Escape: ["\x1B", "\x1B", "\x1B", "\x1B"],
        Backspace: ["\b", "\b", "\b", "\b"],
        Tab: ["	", "", "	", ""],
        Space: [" ", " ", " ", " "],
        Minus: ["'", "?", "\\", "¿"],
        Equal: ["¡", "¿", "̃", "~"],
        BracketLeft: ["̀", "̂", "[", "̊"],
        BracketRight: ["+", "*", "]", "̄"],
        Backslash: ["ç", "Ç", "}", "̆"],
        Semicolon: ["ñ", "Ñ", "~", "̋"],
        Quote: ["́", "̈", "{", "{"],
        Backquote: ["º", "ª", "\\", "\\"],
        Comma: [",", ";", "─", "×"],
        Period: [".", ":", "·", "÷"],
        Slash: ["-", "_", "̣", "̇"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        NumpadEnter: ["\r", "\r", "\r", "\r"],
        Numpad1: ["", "1", "", "1"],
        Numpad2: ["", "2", "", "2"],
        Numpad3: ["", "3", "", "3"],
        Numpad4: ["", "4", "", "4"],
        Numpad5: ["", "5", "", "5"],
        Numpad6: ["", "6", "", "6"],
        Numpad7: ["", "7", "", "7"],
        Numpad8: ["", "8", "", "8"],
        Numpad9: ["", "9", "", "9"],
        Numpad0: ["", "0", "", "0"],
        NumpadDecimal: ["", ".", "", "."],
        IntlBackslash: ["<", ">", "|", "¦"],
        NumpadEqual: ["=", "=", "=", "="],
        NumpadComma: [".", ".", ".", "."],
        NumpadParenLeft: ["(", "(", "(", "("],
        NumpadParenRight: [")", ")", ")", ")"]
      }
    });
    register({
      id: "linux.french",
      locale: "fr",
      displayName: "French",
      virtualLayout: "azerty",
      platform: "linux",
      score: 0,
      mapping: {
        KeyA: ["q", "Q", "@", "Ω"],
        KeyB: ["b", "B", "”", "’"],
        KeyC: ["c", "C", "¢", "©"],
        KeyD: ["d", "D", "ð", "Ð"],
        KeyE: ["e", "E", "€", "¢"],
        KeyF: ["f", "F", "đ", "ª"],
        KeyG: ["g", "G", "ŋ", "Ŋ"],
        KeyH: ["h", "H", "ħ", "Ħ"],
        KeyI: ["i", "I", "→", "ı"],
        KeyJ: ["j", "J", "̉", "̛"],
        KeyK: ["k", "K", "ĸ", "&"],
        KeyL: ["l", "L", "ł", "Ł"],
        KeyM: [",", "?", "́", "̋"],
        KeyN: ["n", "N", "n", "N"],
        KeyO: ["o", "O", "ø", "Ø"],
        KeyP: ["p", "P", "þ", "Þ"],
        KeyQ: ["a", "A", "æ", "Æ"],
        KeyR: ["r", "R", "¶", "®"],
        KeyS: ["s", "S", "ß", "§"],
        KeyT: ["t", "T", "ŧ", "Ŧ"],
        KeyU: ["u", "U", "↓", "↑"],
        KeyV: ["v", "V", "“", "‘"],
        KeyW: ["z", "Z", "«", "<"],
        KeyX: ["x", "X", "»", ">"],
        KeyY: ["y", "Y", "←", "¥"],
        KeyZ: ["w", "W", "ł", "Ł"],
        Digit1: ["&", "1", "¹", "¡"],
        Digit2: ["é", "2", "~", "⅛"],
        Digit3: ['"', "3", "#", "£"],
        Digit4: ["'", "4", "{", "$"],
        Digit5: ["(", "5", "[", "⅜"],
        Digit6: ["-", "6", "|", "⅝"],
        Digit7: ["è", "7", "`", "⅞"],
        Digit8: ["_", "8", "\\", "™"],
        Digit9: ["ç", "9", "^", "±"],
        Digit0: ["à", "0", "@", "°"],
        Enter: ["\r", "\r", "\r", "\r"],
        Escape: ["\x1B", "\x1B", "\x1B", "\x1B"],
        Backspace: ["\b", "\b", "\b", "\b"],
        Tab: ["	", "", "	", ""],
        Space: [" ", " ", " ", " "],
        Minus: [")", "°", "]", "¿"],
        Equal: ["=", "+", "}", "̨"],
        BracketLeft: ["̂", "̈", "̈", "̊"],
        BracketRight: ["$", "£", "¤", "̄"],
        Backslash: ["*", "µ", "̀", "̆"],
        Semicolon: ["m", "M", "µ", "º"],
        Quote: ["ù", "%", "̂", "̌"],
        Backquote: ["²", "~", "¬", "¬"],
        Comma: [";", ".", "─", "×"],
        Period: [":", "/", "·", "÷"],
        Slash: ["!", "§", "̣", "̇"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        NumpadDecimal: ["", ".", "", "."],
        IntlBackslash: ["<", ">", "|", "¦"]
      }
    });
    register({
      id: "windows.french",
      locale: "fr",
      displayName: "French",
      virtualLayout: "azerty",
      platform: "windows",
      score: 0,
      mapping: {
        KeyA: ["q", "Q", "", ""],
        KeyB: ["b", "B", "", ""],
        KeyC: ["c", "C", "", ""],
        KeyD: ["d", "D", "", ""],
        KeyE: ["e", "E", "€", ""],
        KeyF: ["f", "F", "", ""],
        KeyG: ["g", "G", "", ""],
        KeyH: ["h", "H", "", ""],
        KeyI: ["i", "I", "", ""],
        KeyJ: ["j", "J", "", ""],
        KeyK: ["k", "K", "", ""],
        KeyL: ["l", "L", "", ""],
        KeyM: [",", "?", "", ""],
        KeyN: ["n", "N", "", ""],
        KeyO: ["o", "O", "", ""],
        KeyP: ["p", "P", "", ""],
        KeyQ: ["a", "A", "", ""],
        KeyR: ["r", "R", "", ""],
        KeyS: ["s", "S", "", ""],
        KeyT: ["t", "T", "", ""],
        KeyU: ["u", "U", "", ""],
        KeyV: ["v", "V", "", ""],
        KeyW: ["z", "Z", "", ""],
        KeyX: ["x", "X", "", ""],
        KeyY: ["y", "Y", "", ""],
        KeyZ: ["w", "W", "", ""],
        Digit1: ["&", "1", "", ""],
        Digit2: ["é", "2", "~", ""],
        Digit3: ['"', "3", "#", ""],
        Digit4: ["'", "4", "{", ""],
        Digit5: ["(", "5", "[", ""],
        Digit6: ["-", "6", "|", ""],
        Digit7: ["è", "7", "`", ""],
        Digit8: ["_", "8", "\\", ""],
        Digit9: ["ç", "9", "^", ""],
        Digit0: ["à", "0", "@", ""],
        Space: [" ", " ", "", ""],
        Minus: [")", "°", "]", ""],
        Equal: ["=", "+", "}", ""],
        BracketLeft: ["^", "¨", "", ""],
        BracketRight: ["$", "£", "¤", ""],
        Backslash: ["*", "µ", "", ""],
        Semicolon: ["m", "M", "", ""],
        Quote: ["ù", "%", "", ""],
        Backquote: ["²", "", "", ""],
        Comma: [";", ".", "", ""],
        Period: [":", "/", "", ""],
        Slash: ["!", "§", "", ""],
        NumpadDivide: ["/", "/", "", ""],
        NumpadMultiply: ["*", "*", "", ""],
        NumpadSubtract: ["-", "-", "", ""],
        NumpadAdd: ["+", "+", "", ""],
        IntlBackslash: ["<", ">", "", ""]
      }
    });
    register({
      id: "windows.german",
      locale: "de",
      displayName: "German",
      platform: "windows",
      virtualLayout: "qwertz",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "", ""],
        KeyB: ["b", "B", "", ""],
        KeyC: ["c", "C", "", ""],
        KeyD: ["d", "D", "", ""],
        KeyE: ["e", "E", "€", ""],
        KeyF: ["f", "F", "", ""],
        KeyG: ["g", "G", "", ""],
        KeyH: ["h", "H", "", ""],
        KeyI: ["i", "I", "", ""],
        KeyJ: ["j", "J", "", ""],
        KeyK: ["k", "K", "", ""],
        KeyL: ["l", "L", "", ""],
        KeyM: ["m", "M", "µ", ""],
        KeyN: ["n", "N", "", ""],
        KeyO: ["o", "O", "", ""],
        KeyP: ["p", "P", "", ""],
        KeyQ: ["q", "Q", "@", ""],
        KeyR: ["r", "R", "", ""],
        KeyS: ["s", "S", "", ""],
        KeyT: ["t", "T", "", ""],
        KeyU: ["u", "U", "", ""],
        KeyV: ["v", "V", "", ""],
        KeyW: ["w", "W", "", ""],
        KeyX: ["x", "X", "", ""],
        KeyY: ["z", "Z", "", ""],
        KeyZ: ["y", "Y", "", ""],
        Digit1: ["1", "!", "", ""],
        Digit2: ["2", '"', "²", ""],
        Digit3: ["3", "§", "³", ""],
        Digit4: ["4", "$", "", ""],
        Digit5: ["5", "%", "", ""],
        Digit6: ["6", "&", "", ""],
        Digit7: ["7", "/", "{", ""],
        Digit8: ["8", "(", "[", ""],
        Digit9: ["9", ")", "]", ""],
        Digit0: ["0", "=", "}", ""],
        Space: [" ", " ", "", ""],
        Minus: ["ß", "?", "\\", "ẞ"],
        Equal: ["´", "`", "", ""],
        BracketLeft: ["ü", "Ü", "", ""],
        BracketRight: ["+", "*", "~", ""],
        Backslash: ["#", "'", "", ""],
        Semicolon: ["ö", "Ö", "", ""],
        Quote: ["ä", "Ä", "", ""],
        Backquote: ["^", "°", "", ""],
        Comma: [",", ";", "", ""],
        Period: [".", ":", "", ""],
        Slash: ["-", "_", "", ""],
        NumpadDivide: ["/", "/", "", ""],
        NumpadMultiply: ["*", "*", "", ""],
        NumpadSubtract: ["-", "-", "", ""],
        NumpadAdd: ["+", "+", "", ""],
        IntlBackslash: ["<", ">", "|", ""]
      }
    });
    register({
      id: "apple.german",
      locale: "de",
      displayName: "German",
      virtualLayout: "qwertz",
      platform: "apple",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "å", "Å"],
        KeyB: ["b", "B", "∫", "‹"],
        KeyC: ["c", "C", "ç", "Ç"],
        KeyD: ["d", "D", "∂", "™"],
        KeyE: ["e", "E", "€", "‰"],
        KeyF: ["f", "F", "ƒ", "Ï"],
        KeyG: ["g", "G", "©", "Ì"],
        KeyH: ["h", "H", "ª", "Ó"],
        KeyI: ["i", "I", "⁄", "Û"],
        KeyJ: ["j", "J", "º", "ı"],
        KeyK: ["k", "K", "∆", "ˆ"],
        KeyL: ["l", "L", "@", "ﬂ"],
        KeyM: ["m", "M", "µ", "˘"],
        KeyN: ["n", "N", "~", "›"],
        KeyO: ["o", "O", "ø", "Ø"],
        KeyP: ["p", "P", "π", "∏"],
        KeyQ: ["q", "Q", "«", "»"],
        KeyR: ["r", "R", "®", "¸"],
        KeyS: ["s", "S", "‚", "Í"],
        KeyT: ["t", "T", "†", "˝"],
        KeyU: ["u", "U", "¨", "Á"],
        KeyV: ["v", "V", "√", "◊"],
        KeyW: ["w", "W", "∑", "„"],
        KeyX: ["x", "X", "≈", "Ù"],
        KeyY: ["z", "Z", "Ω", "ˇ"],
        KeyZ: ["y", "Y", "¥", "‡"],
        Digit1: ["1", "!", "¡", "¬"],
        Digit2: ["2", '"', "“", "”"],
        Digit3: ["3", "§", "¶", "#"],
        Digit4: ["4", "$", "¢", "£"],
        Digit5: ["5", "%", "[", "ﬁ"],
        Digit6: ["6", "&", "]", "^"],
        Digit7: ["7", "/", "|", "\\"],
        Digit8: ["8", "(", "{", "˜"],
        Digit9: ["9", ")", "}", "·"],
        Digit0: ["0", "=", "≠", "¯"],
        Space: [" ", " ", " ", " "],
        Minus: ["ß", "?", "¿", "˙"],
        Equal: ["´", "`", "'", "˚"],
        BracketLeft: ["ü", "Ü", "•", "°"],
        BracketRight: ["+", "*", "±", ""],
        Backslash: ["#", "'", "‘", "’"],
        Semicolon: ["ö", "Ö", "œ", "Œ"],
        Quote: ["ä", "Ä", "æ", "Æ"],
        Backquote: ["<", ">", "≤", "≥"],
        Comma: [",", ";", "∞", "˛"],
        Period: [".", ":", "…", "÷"],
        Slash: ["-", "_", "–", "—"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        NumpadDecimal: [",", ",", ".", "."],
        IntlBackslash: ["^", "°", "„", "“"],
        NumpadEqual: ["=", "=", "=", "="]
      }
    });
    register({
      id: "dvorak",
      locale: "en",
      displayName: "Dvorak",
      virtualLayout: "dvorak",
      platform: "",
      score: 0,
      mapping: {
        KeyA: ["a", "A", "å", "Å"],
        KeyB: ["x", "X", "≈", "˛"],
        KeyC: ["j", "J", "∆", "Ô"],
        KeyD: ["e", "E", "´", "´"],
        KeyE: [".", ">", "≥", "˘"],
        KeyF: ["u", "U", "¨", "¨"],
        KeyG: ["i", "I", "ˆ", "ˆ"],
        KeyH: ["d", "D", "∂", "Î"],
        KeyI: ["c", "C", "ç", "Ç"],
        KeyJ: ["h", "H", "˙", "Ó"],
        KeyK: ["t", "T", "†", "ˇ"],
        KeyL: ["n", "N", "˜", "˜"],
        KeyM: ["m", "M", "µ", "Â"],
        KeyN: ["b", "B", "∫", "ı"],
        KeyO: ["r", "R", "®", "‰"],
        KeyP: ["l", "L", "¬", "Ò"],
        KeyQ: ["'", '"', "æ", "Æ"],
        KeyR: ["p", "P", "π", "∏"],
        KeyS: ["o", "O", "ø", "Ø"],
        KeyT: ["y", "Y", "¥", "Á"],
        KeyU: ["g", "G", "©", "˝"],
        KeyV: ["k", "K", "˚", ""],
        KeyW: [",", "<", "≤", "¯"],
        KeyX: ["q", "Q", "œ", "Œ"],
        KeyY: ["f", "F", "ƒ", "Ï"],
        KeyZ: [";", ":", "…", "Ú"],
        Digit1: ["1", "!", "¡", "⁄"],
        Digit2: ["2", "@", "™", "€"],
        Digit3: ["3", "#", "£", "‹"],
        Digit4: ["4", "$", "¢", "›"],
        Digit5: ["5", "%", "∞", "ﬁ"],
        Digit6: ["6", "^", "§", "ﬂ"],
        Digit7: ["7", "&", "¶", "‡"],
        Digit8: ["8", "*", "•", "°"],
        Digit9: ["9", "(", "ª", "·"],
        Digit0: ["0", ")", "º", "‚"],
        Space: [" ", " ", " ", " "],
        Minus: ["[", "{", "“", "”"],
        Equal: ["]", "}", "‘", "’"],
        BracketLeft: ["/", "?", "÷", "¿"],
        BracketRight: ["=", "+", "≠", "±"],
        Backslash: ["\\", "|", "«", "»"],
        Semicolon: ["s", "S", "ß", "Í"],
        Quote: ["-", "_", "–", "—"],
        Backquote: ["`", "~", "`", "`"],
        Comma: ["w", "W", "∑", "„"],
        Period: ["v", "V", "√", "◊"],
        Slash: ["z", "Z", "Ω", "¸"],
        NumpadDivide: ["/", "/", "/", "/"],
        NumpadMultiply: ["*", "*", "*", "*"],
        NumpadSubtract: ["-", "-", "-", "-"],
        NumpadAdd: ["+", "+", "+", "+"],
        Numpad1: ["1", "1", "1", "1"],
        Numpad2: ["2", "2", "2", "2"],
        Numpad3: ["3", "3", "3", "3"],
        Numpad4: ["4", "4", "4", "4"],
        Numpad5: ["5", "5", "5", "5"],
        Numpad6: ["6", "6", "6", "6"],
        Numpad7: ["7", "7", "7", "7"],
        Numpad8: ["8", "8", "8", "8"],
        Numpad9: ["9", "9", "9", "9"],
        Numpad0: ["0", "0", "0", "0"],
        NumpadDecimal: [".", ".", ".", "."],
        IntlBackslash: ["§", "±", "§", "±"],
        NumpadEqual: ["=", "=", "=", "="],
        AudioVolumeUp: ["", "=", "", "="]
      }
    });
    function matchPlatform(p2) {
      if (isBrowser()) {
        const plat = osPlatform();
        const isNeg = p2.startsWith("!");
        const isMatch = p2.endsWith(plat);
        if (isNeg && !isMatch)
          return true;
        if (!isNeg && isMatch)
          return true;
      }
      if (p2 === "!other")
        return false;
      return p2 === "other";
    }
    function getCommandForKeybinding(keybindings, mode, inKeystroke) {
      if (keybindings.length === 0)
        return "";
      const keystroke = keystrokeModifiersToString(
        keystrokeModifiersFromString(inKeystroke)
      );
      for (let i = keybindings.length - 1; i >= 0; i--) {
        if (keybindings[i].key === keystroke) {
          if (!keybindings[i].ifMode || keybindings[i].ifMode === mode)
            return keybindings[i].command;
        }
      }
      return "";
    }
    function commandToString(command) {
      let result = command;
      if (isArray2(result)) {
        result = result.length > 0 ? result[0] + "(" + result.slice(1).join("") + ")" : "";
      }
      return result;
    }
    function getKeybindingsForCommand(keybindings, command) {
      let result = [];
      if (typeof command === "string") {
        const candidate = REVERSE_KEYBINDINGS[command];
        if (isArray2(candidate))
          result = candidate.slice();
        else if (candidate)
          result.push(candidate);
      }
      const normalizedCommand = commandToString(command);
      const regex = new RegExp(
        "^" + normalizedCommand.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)"
      );
      for (const keybinding of keybindings) {
        if (regex.test(commandToString(keybinding.command)))
          result.push(keybinding.key);
      }
      return result.map(getKeybindingMarkup);
    }
    function getKeybindingMarkup(keystroke) {
      var _a3;
      const useSymbol = /macos|ios|/.test(osPlatform());
      const segments = keystroke.split("+");
      let result = "";
      for (const segment of segments) {
        if (!useSymbol && result)
          result += '<span class="ML__shortcut-join">+</span>';
        if (segment.startsWith("[Key"))
          result += segment.slice(4, 5);
        else if (segment.startsWith("Key"))
          result += segment.slice(3, 4);
        else if (segment.startsWith("[Digit"))
          result += segment.slice(6, 7);
        else if (segment.startsWith("Digit"))
          result += segment.slice(5, 6);
        else {
          result += (_a3 = {
            "cmd": "⌘",
            "meta": useSymbol ? "⌘" : "command",
            "shift": useSymbol ? "⇧" : "shift",
            "alt": useSymbol ? "⌥" : "alt",
            "ctrl": useSymbol ? "⌃" : "control",
            "\n": useSymbol ? "⏎" : "return",
            "[return]": useSymbol ? "⏎" : "return",
            "[enter]": useSymbol ? "⌤" : "enter",
            "[tab]": useSymbol ? "⇥" : "tab",
            // 'Esc':          useSymbol ? '\u238b' : 'esc',
            "[escape]": "esc",
            "[backspace]": useSymbol ? "⌫" : "backspace",
            "[delete]": useSymbol ? "⌦" : "del",
            "[pageup]": useSymbol ? "⇞" : "page up",
            "[pagedown]": useSymbol ? "⇟" : "page down",
            "[home]": useSymbol ? "⤒" : "home",
            "[end]": useSymbol ? "⤓" : "end",
            "[space]": "space",
            "[equal]": "=",
            "[minus]": "-",
            "[comma]": ",",
            "[slash]": "/",
            "[backslash]": "\\",
            "[bracketleft]": "[",
            "[bracketright]": "]",
            "semicolon": ";",
            "period": ".",
            "comma": ",",
            "minus": "-",
            "equal": "=",
            "quote": "'",
            "bracketLeft": "[",
            "bracketRight": "]",
            "backslash": "\\",
            "intlbackslash": "\\",
            "backquote": "`",
            "slash": "/",
            "numpadmultiply": "* &#128290;",
            "numpaddivide": "/ &#128290;",
            // Numeric keypad
            "numpadsubtract": "- &#128290;",
            "numpadadd": "+ &#128290;",
            "numpaddecimal": ". &#128290;",
            "numpadcomma": ", &#128290;",
            "help": "help",
            "left": "⇠",
            "up": "⇡",
            "right": "⇢",
            "down": "⇣",
            "[arrowleft]": "⇠",
            "[arrowup]": "⇡",
            "[arrowright]": "⇢",
            "[arrowdown]": "⇣",
            "[digit0]": "0",
            "[digit1]": "1",
            "[digit2]": "2",
            "[digit3]": "3",
            "[digit4]": "4",
            "[digit5]": "5",
            "[digit6]": "6",
            "[digit7]": "7",
            "[digit8]": "8",
            "[digit9]": "9"
          }[segment.toLowerCase()]) != null ? _a3 : segment.toUpperCase();
        }
      }
      return result;
    }
    function normalizeKeybinding(keybinding, layout) {
      if (keybinding.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(
        keybinding.ifPlatform
      )) {
        throw new Error(
          `Unexpected platform "${keybinding.ifPlatform}" for keybinding ${keybinding.key}`
        );
      }
      if (keybinding.ifLayout !== void 0 && (layout.score === 0 || !keybinding.ifLayout.includes(layout.id)))
        return void 0;
      const modifiers = keystrokeModifiersFromString(keybinding.key);
      let platform2 = keybinding.ifPlatform;
      if (modifiers.cmd) {
        if (platform2 && platform2 !== "macos" && platform2 !== "ios") {
          throw new Error(
            'Unexpected "cmd" modifier with platform "' + platform2 + '"\n"cmd" modifier can only be used with macOS or iOS platform.'
          );
        }
        if (!platform2)
          platform2 = osPlatform() === "ios" ? "ios" : "macos";
        modifiers.win = false;
        modifiers.cmd = false;
        modifiers.meta = true;
      }
      if (modifiers.win) {
        if (platform2 && platform2 !== "windows") {
          throw new Error(
            'Unexpected "win" modifier with platform "' + platform2 + '"\n"win" modifier can only be used with Windows platform.'
          );
        }
        platform2 = "windows";
        modifiers.win = false;
        modifiers.cmd = false;
        modifiers.meta = true;
      }
      if (platform2 && !matchPlatform(platform2))
        return void 0;
      if (/^\[.+\]$/.test(modifiers.key)) {
        return __spreadProps(__spreadValues({}, keybinding), {
          ifPlatform: platform2,
          key: keystrokeModifiersToString(modifiers)
        });
      }
      const code = getCodeForKey(modifiers.key, layout);
      if (!code)
        throw new Error('Invalid keybinding key "' + keybinding.key + '"');
      if (code.shift && modifiers.shift || code.alt && modifiers.alt) {
        throw new Error(
          `The keybinding ${keybinding.key} (${selectorToString(
            keybinding.command
          )}) is conflicting with the key combination ${keystrokeModifiersToString(
            code
          )} using the ${layout.displayName} keyboard layout`
        );
      }
      code.shift = code.shift || modifiers.shift;
      code.alt = code.alt || modifiers.alt;
      code.meta = modifiers.meta;
      code.ctrl = modifiers.ctrl;
      return __spreadProps(__spreadValues({}, keybinding), {
        ifPlatform: platform2,
        key: keystrokeModifiersToString(code)
      });
    }
    function selectorToString(selector) {
      if (Array.isArray(selector)) {
        const sel = [...selector];
        return sel.shift() + "(" + sel.map((x) => typeof x === "string" ? `"${x}"` : x.toString()).join(", ") + ")";
      }
      return selector;
    }
    function normalizeKeybindings(keybindings, layout) {
      const result = [];
      const errors = [];
      for (const x of keybindings) {
        try {
          const keybinding = normalizeKeybinding(x, layout);
          if (keybinding) {
            const matches = result.filter(
              (x2) => x2.key === keybinding.key && x2.ifMode === keybinding.ifMode
            );
            if (matches.length > 0) {
              throw new Error(
                `Ambiguous key binding ${x.key} (${selectorToString(
                  x.command
                )}) matches ${matches[0].key} (${selectorToString(
                  matches[0].command
                )}) with the ${layout.displayName} keyboard layout`
              );
            }
            result.push(keybinding);
          }
        } catch (error) {
          if (error instanceof Error)
            errors.push(error.message);
        }
      }
      return [result, errors];
    }
    var popover_default = `/* The element that display info while in latex mode */
#mathlive-popover-panel {
  visibility: hidden;
  background-color: rgba(97, 97, 97, 0.95);
  color: #fff;
  text-align: center;
  border-radius: 8px;
  position: fixed;
  z-index: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
  transition: all 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  /* The 'tip' of the popover panel */
}
#mathlive-popover-panel::after {
  content: '';
  position: absolute;
  top: -5px;
  left: calc(50% - 3px);
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  font-size: 1rem;
  border-bottom: 5px solid rgba(97, 97, 97, 0.9);
}
#mathlive-popover-panel.is-visible {
  visibility: inherit;
  animation: ML__fade-in cubic-bezier(0, 0, 0.2, 1) 0.15s;
}
@keyframes ML__fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* The wrapper class for the entire content of the popover panel */
#mathlive-popover-panel ul {
  display: flex;
  flex-flow: column;
  list-style: none;
  margin: 0;
  padding: 0;
  align-items: flex-start;
  justify-content: center;
}
#mathlive-popover-panel li {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  margin: 8px;
  padding: 8px;
  width: calc(100% - 16px - 16px);
  column-gap: 1em;
  border-radius: 8px;
  cursor: pointer;
  /* Since the content can be clicked on, provide feedback on hover */
}
#mathlive-popover-panel li a {
  color: #5ea6fd;
  padding-top: 0.3em;
  margin-top: 0.4em;
  display: block;
}
#mathlive-popover-panel li a:hover {
  color: #5ea6fd;
  text-decoration: underline;
}
#mathlive-popover-panel li:hover,
#mathlive-popover-panel li.is-pressed,
#mathlive-popover-panel li.is-active {
  background: rgba(255, 255, 255, 0.1);
}
/* The command inside a popover (inside a #mathlive-popover-panel) */
.ML__popover__command {
  font-size: 1.6rem;
  font-family: KaTeX_Main;
}
.ML__popover__latex {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;
  align-self: center;
}
/* The keyboard shortcuts for a symbol as displayed in the popover */
.ML__popover__keybinding {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 0.8em;
  opacity: 0.7;
}
/* Style for the character that joins the modifiers of a keyboard shortcut 
(usually a "+" sign)*/
.ML__shortcut-join {
  opacity: 0.5;
}
`;
    var core_default = `.ML__sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  clip-path: inset(50%);
  white-space: nowrap;
  border: 0;
}
.ML__is-inline {
  display: inline-block;
}
.ML__base {
  visibility: inherit;
  display: inline-block;
  position: relative;
  cursor: text;
  padding: 0;
  margin: 0;
  box-sizing: content-box;
  border: 0;
  outline: 0;
  vertical-align: baseline;
  font-weight: inherit;
  font-family: inherit;
  font-style: inherit;
  text-decoration: none;
  width: min-content;
}
.ML__strut,
.ML__strut--bottom {
  display: inline-block;
  min-height: 0.5em;
}
.ML__small-delim {
  font-family: KaTeX_Main;
}
/* Text mode */
.ML__text {
  font-family: var(--text-font-family, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif);
  white-space: pre;
}
/* Use cmr for 'math upright' */
.ML__cmr {
  font-family: KaTeX_Main;
  font-style: normal;
}
.ML__mathit {
  font-family: KaTeX_Math;
  /* The KaTeX_Math font is italic by default, so the font-style below is only 
     useful when a fallback font is used
  */
  font-style: italic;
}
.ML__mathbf {
  font-family: KaTeX_Main;
  font-weight: bold;
}
/* Lowercase greek symbols should stick to math font when \\mathbf is applied 
   to match TeX idiosyncratic behavior */
.lcGreek.ML__mathbf {
  font-family: KaTeX_Math;
  font-weight: normal;
}
.ML__mathbfit {
  font-family: KaTeX_Math;
  font-weight: bold;
  font-style: italic;
}
.ML__ams {
  font-family: KaTeX_AMS;
}
/* Blackboard */
.ML__bb {
  font-family: KaTeX_AMS;
}
.ML__cal {
  font-family: KaTeX_Caligraphic;
}
.ML__frak {
  font-family: KaTeX_Fraktur;
}
.ML__tt {
  font-family: KaTeX_Typewriter;
}
.ML__script {
  font-family: KaTeX_Script;
}
.ML__sans {
  font-family: KaTeX_SansSerif;
}
.ML__series_ul {
  font-weight: 100;
}
.ML__series_el {
  font-weight: 100;
}
.ML__series_l {
  font-weight: 200;
}
.ML__series_sl {
  font-weight: 300;
}
.ML__series_sb {
  font-weight: 500;
}
.ML__bold,
.ML__boldsymbol {
  font-weight: 700;
}
.ML__series_eb {
  font-weight: 800;
}
.ML__series_ub {
  font-weight: 900;
}
.ML__series_uc {
  font-stretch: ultra-condensed;
}
.ML__series_ec {
  font-stretch: extra-condensed;
}
.ML__series_c {
  font-stretch: condensed;
}
.ML__series_sc {
  font-stretch: semi-condensed;
}
.ML__series_sx {
  font-stretch: semi-expanded;
}
.ML__series_x {
  font-stretch: expanded;
}
.ML__series_ex {
  font-stretch: extra-expanded;
}
.ML__series_ux {
  font-stretch: ultra-expanded;
}
.ML__it {
  font-style: italic;
}
.ML__shape_ol {
  -webkit-text-stroke: 1px black;
  text-stroke: 1px black;
  color: transparent;
}
.ML__shape_sc {
  font-variant: small-caps;
}
.ML__shape_sl {
  font-style: oblique;
}
/* First level emphasis */
.ML__emph {
  color: #bc2612;
}
/* Second level emphasis */
.ML__emph .ML__emph {
  color: #0c7f99;
}
.ML__highlight {
  color: #007cb2;
  background: #edd1b0;
}
.ML__center {
  text-align: center;
}
.ML__label_padding {
  padding: 0 0.5em;
}
.ML__frac-line {
  width: 100%;
  min-height: 1px;
}
.ML__frac-line:after {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  /* There's a bug since Chrome 62 where 
      sub-pixel border lines don't draw at some zoom 
      levels (110%, 90%). 
      Setting the min-height used to work around it, but that workaround
      broke in Chrome 84 or so.
      Setting the background (and the min-height) seems to work for now.
      */
  background: currentColor;
  box-sizing: content-box;
  /* Vuetify sets the box-sizing to inherit 
            causes the fraction line to not draw at all sizes (see #26) */
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt {
  display: inline-block;
}
.ML__sqrt-sign {
  display: inline-block;
  font-family: KaTeX_Main;
  position: relative;
}
.ML__sqrt-line {
  display: inline-block;
  height: 0.04em;
  width: 100%;
}
.ML__sqrt-line:before {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  background: currentColor;
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt-line:after {
  border-bottom-width: 1px;
  content: ' ';
  display: block;
  margin-top: -0.1em;
}
.ML__sqrt-index {
  margin-left: 0.27777778em;
  margin-right: -0.55555556em;
}
.ML__delim-size1 {
  font-family: KaTeX_Size1;
}
.ML__delim-size2 {
  font-family: KaTeX_Size2;
}
.ML__delim-size3 {
  font-family: KaTeX_Size3;
}
.ML__delim-size4 {
  font-family: KaTeX_Size4;
}
.ML__delim-mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.ML__delim-mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.ML__accent-body > span {
  font-family: KaTeX_Main;
  width: 0;
}
.ML__accent-vec > span {
  position: relative;
  left: 0.24em;
}
.ML__mathlive {
  display: inline-block;
  direction: ltr;
  text-align: left;
  text-indent: 0;
  text-rendering: auto;
  font-family: KaTeX_Main, 'Times New Roman', serif;
  font-style: normal;
  font-size-adjust: none;
  font-stretch: normal;
  font-variant-caps: normal;
  letter-spacing: normal;
  line-height: 1.2;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  text-shadow: none;
  -webkit-user-select: none;
  user-select: none;
  width: min-content;
}
.ML__mathlive .style-wrap {
  position: relative;
}
.ML__mathlive .mfrac,
.ML__mathlive .left-right {
  display: inline-block;
}
.ML__mathlive .vlist-t {
  display: inline-table;
  table-layout: fixed;
  border-collapse: collapse;
}
.ML__mathlive .vlist-r {
  display: table-row;
}
.ML__mathlive .vlist {
  display: table-cell;
  vertical-align: bottom;
  position: relative;
}
.ML__mathlive .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.ML__mathlive .vlist > span > span {
  display: inline-block;
}
.ML__mathlive .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.ML__mathlive .vlist-t2 {
  margin-right: -2px;
}
.ML__mathlive .vlist-s {
  display: table-cell;
  vertical-align: bottom;
  font-size: 1px;
  width: 2px;
  min-width: 2px;
}
.ML__mathlive .msubsup {
  text-align: left;
}
.ML__mathlive .negativethinspace {
  display: inline-block;
  margin-left: -0.16667em;
  height: 0.71em;
}
.ML__mathlive .thinspace {
  display: inline-block;
  width: 0.16667em;
  height: 0.71em;
}
.ML__mathlive .mediumspace {
  display: inline-block;
  width: 0.22222em;
  height: 0.71em;
}
.ML__mathlive .thickspace {
  display: inline-block;
  width: 0.27778em;
  height: 0.71em;
}
.ML__mathlive .enspace {
  display: inline-block;
  width: 0.5em;
  height: 0.71em;
}
.ML__mathlive .quad {
  display: inline-block;
  width: 1em;
  height: 0.71em;
}
.ML__mathlive .qquad {
  display: inline-block;
  width: 2em;
  height: 0.71em;
}
.ML__mathlive .llap,
.ML__mathlive .rlap {
  width: 0;
  position: relative;
  display: inline-block;
}
.ML__mathlive .llap > .inner,
.ML__mathlive .rlap > .inner {
  position: absolute;
}
.ML__mathlive .llap > .fix,
.ML__mathlive .rlap > .fix {
  display: inline-block;
}
.ML__mathlive .llap > .inner {
  right: 0;
}
.ML__mathlive .rlap > .inner {
  left: 0;
}
.ML__mathlive .rule {
  display: inline-block;
  border: solid 0;
  position: relative;
  box-sizing: border-box;
}
.ML__mathlive .overline .overline-line,
.ML__mathlive .underline .underline-line {
  width: 100%;
}
.ML__mathlive .overline .overline-line:before,
.ML__mathlive .underline .underline-line:before {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  content: '';
  display: block;
}
.ML__mathlive .overline .overline-line:after,
.ML__mathlive .underline .underline-line:after {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  min-height: thin;
  /* There's a bug since Chrome 62 where 
            sub-pixel border lines don't draw at some zoom 
            levels (110%, 90%). Setting the min-height seems to work around it.
            */
  content: '';
  display: block;
  margin-top: -1px;
}
.ML__mathlive .stretchy {
  display: block;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .stretchy:before,
.ML__mathlive .stretchy:after {
  content: '';
}
.ML__mathlive .stretchy svg {
  display: block;
  position: absolute;
  width: 100%;
  height: inherit;
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
}
.ML__mathlive .slice-1-of-2 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-2 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-3 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-3 {
  display: inline-flex;
  position: absolute;
  left: 25%;
  width: 50%;
  overflow: hidden;
}
.ML__mathlive .slice-3-of-3 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-1 {
  display: inline-flex;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .nulldelimiter {
  width: 0.12em;
  display: inline-block;
}
.ML__mathlive .op-group {
  display: inline-block;
}
.ML__mathlive .op-symbol {
  position: relative;
}
.ML__mathlive .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.ML__mathlive .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.ML__mathlive .accent > .vlist > span {
  text-align: center;
}
.ML__mathlive .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
  box-sizing: border-box;
}
.ML__mathlive .mtable .arraycolsep {
  display: inline-block;
}
.ML__mathlive .mtable .col-align-m > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.ML__mathlive .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.ML__error {
  display: inline-block;
  background-image: radial-gradient(ellipse at center, hsl(341, 100%, 40%), rgba(0, 0, 0, 0) 70%);
  background-color: hsla(341, 100%, 40%, 0.1);
  background-repeat: repeat-x;
  background-size: 3px 3px;
  padding-bottom: 3px;
  background-position: 0 100%;
}
.ML__error > .ML__error {
  background: transparent;
  padding: 0;
}
.ML__composition {
  background: #fff1c2;
  color: black;
  text-decoration: underline var(--caret-color-computed, var(--ML__caret-color));
}
.ML__placeholder {
  color: var(--placeholder-color, var(--ML__placeholder-color));
  opacity: var(--placeholder-opacity, 0.4);
  padding-left: 0.4ex;
  padding-right: 0.4ex;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}
.ML__notation {
  position: absolute;
  box-sizing: border-box;
}
.ML__container {
  min-height: auto !important;
}
.ML__prompt {
  border-radius: 2px;
}
.ML__editablePromptBox {
  outline: 1px solid #acacac;
  border-radius: 2px;
  z-index: -1;
}
.ML__focusedPromptBox {
  outline: highlight auto 1px;
}
.ML__lockedPromptBox {
  background-color: rgba(142, 142, 141, 0.4);
  z-index: -1;
}
.ML__correctPromptBox {
  outline: 1px solid var(--correct-color, var(--ML__correct-color));
  box-shadow: 0 0 5px var(--correct-color, var(--ML__correct-color));
}
.ML__incorrectPromptBox {
  outline: 1px solid var(--incorrect-color, var(--ML__incorrect-color));
  box-shadow: 0 0 5px var(--incorrect-color, var(--ML__incorrect-color));
}
`;
    function makeProxy(mf) {
      return {
        value: mf.model.getValue(),
        selectionIsCollapsed: mf.model.selectionIsCollapsed,
        canUndo: mf.canUndo(),
        canRedo: mf.canRedo()
      };
    }
    var VIRTUAL_KEYBOARD_MESSAGE = "mathlive#virtual-keyboard-message";
    function isVirtualKeyboardMessage(evt) {
      var _a3;
      if (evt.type !== "message")
        return false;
      const msg = evt;
      if (((_a3 = msg.data) == null ? void 0 : _a3.type) !== VIRTUAL_KEYBOARD_MESSAGE)
        return false;
      return true;
    }
    var VirtualKeyboardProxy = class {
      constructor() {
        this.targetOrigin = window.origin;
        this.originValidator = "none";
        window.addEventListener("message", this);
        this.sendMessage("proxy-created");
        this.listeners = {};
      }
      static get singleton() {
        if (!this._singleton)
          this._singleton = new VirtualKeyboardProxy();
        return this._singleton;
      }
      set alphabeticLayout(value) {
        this.sendMessage("update-setting", { alphabeticLayout: value });
      }
      set layouts(value) {
        this.sendMessage("update-setting", { layouts: value });
      }
      set actionToolbar(value) {
        this.sendMessage("update-setting", { actionToolbar: value });
      }
      set container(value) {
        throw new Error("Container inside an iframe cannot be changed");
      }
      show() {
        this.sendMessage("show");
      }
      hide() {
        this.sendMessage("hide");
      }
      get visible() {
        return this._boundingRect.height > 0;
      }
      set visible(value) {
        if (value)
          this.show();
        else
          this.hide();
      }
      get boundingRect() {
        return this._boundingRect;
      }
      executeCommand(command) {
        this.sendMessage("execute-command", { command });
        return true;
      }
      updateToolbar(mf) {
        this.sendMessage("update-toolbar", mf);
      }
      connect() {
        this.sendMessage("connect");
      }
      disconnect() {
        this.sendMessage("disconnect");
      }
      addEventListener(type, callback, _options) {
        if (!this.listeners[type])
          this.listeners[type] = /* @__PURE__ */ new Set();
        if (!this.listeners[type].has(callback))
          this.listeners[type].add(callback);
      }
      dispatchEvent(event) {
        if (!this.listeners[event.type] || this.listeners[event.type].size === 0)
          return true;
        this.listeners[event.type].forEach((x) => {
          if (typeof x === "function")
            x(event);
          else
            x == null ? void 0 : x.handleEvent(event);
        });
        return !event.defaultPrevented;
      }
      removeEventListener(type, callback, _options) {
        if (this.listeners[type])
          this.listeners[type].delete(callback);
      }
      handleEvent(evt) {
        if (isVirtualKeyboardMessage(evt)) {
          if (!validateOrigin(evt.origin, this.originValidator)) {
            throw new DOMException(
              `Message from unknown origin (${evt.origin}) cannot be handled`,
              "SecurityError"
            );
          }
          const { action } = evt.data;
          if (action === "execute-command") {
            const { command } = evt.data;
            const commandTarget = getCommandTarget(command);
            if (commandTarget === "virtual-keyboard")
              this.executeCommand(command);
            return;
          }
          if (action === "synchronize-proxy") {
            this._boundingRect = evt.data.boundingRect;
            return;
          }
          if (action === "geometry-changed") {
            this._boundingRect = evt.data.boundingRect;
            this.dispatchEvent(new Event("geometrychange"));
            return;
          }
        }
      }
      sendMessage(action, payload = {}) {
        if (!window.top) {
          throw new DOMException(
            `A frame does not have access to the top window and can‘t communicate with the keyboard. Review virtualKeyboardTargetOrigin and originValidator on the mathfield embedded in an iframe`,
            "SecurityError"
          );
        }
        window.top.postMessage(
          __spreadValues({
            type: VIRTUAL_KEYBOARD_MESSAGE,
            action
          }, payload),
          this.targetOrigin
        );
      }
    };
    function attachButtonHandlers(element, executeCommand, command) {
      if (command.default)
        element.dataset.command = JSON.stringify(command.default);
      if (command.alt)
        element.dataset.commandAlt = JSON.stringify(command.alt);
      if (command.shift)
        element.dataset.commandShift = JSON.stringify(command.shift);
      if (command.pressed)
        element.dataset.commandPressed = JSON.stringify(command.pressed);
      if (command.pressAndHold)
        element.dataset.commandPressAndHold = JSON.stringify(command.pressAndHold);
      let pressAndHoldTimer;
      on(element, "pointerdown:passive", (ev) => {
        if (ev.buttons !== 1)
          return;
        ev.stopPropagation();
        element.classList.add("is-pressed");
        const target = ev.target;
        if (target.hasPointerCapture(ev.pointerId))
          target.releasePointerCapture(ev.pointerId);
        const command2 = element.getAttribute("data-command-pressed");
        if (command2)
          executeCommand(JSON.parse(command2));
        const pressAndHoldCommand = element.getAttribute(
          "data-command-press-and-hold"
        );
        if (pressAndHoldCommand) {
          if (pressAndHoldTimer)
            clearTimeout(pressAndHoldTimer);
          pressAndHoldTimer = setTimeout(() => {
            if (element.classList.contains("is-pressed")) {
              element.classList.remove("is-pressed");
              element.classList.add("is-active");
              executeCommand(JSON.parse(pressAndHoldCommand));
            }
          }, 300);
        }
      });
      on(element, "pointerenter", (ev) => {
        const target = ev.target;
        if (target.hasPointerCapture(ev.pointerId))
          target.releasePointerCapture(ev.pointerId);
        if (ev.buttons === 1)
          element.classList.add("is-pressed");
      });
      on(element, "pointercancel", () => element.classList.remove("is-pressed"));
      on(element, "pointerleave", () => element.classList.remove("is-pressed"));
      on(element, "pointerup", (ev) => {
        element.classList.remove("is-pressed");
        element.classList.add("is-active");
        setTimeout(() => element.classList.remove("is-active"), 150);
        let command2 = null;
        if (!command2 && ev.altKey)
          command2 = element.getAttribute("data-command-alt");
        if (!command2 && ev.shiftKey)
          command2 = element.getAttribute("data-command-shift");
        if (!command2)
          command2 = element.getAttribute("data-command");
        if (command2)
          executeCommand(JSON.parse(command2));
        ev.stopPropagation();
        ev.preventDefault();
      });
    }
    var virtual_keyboard_default = `@layer ML_keyboard {
  :where(:root) {
    --keyboard-height: 0;
    --keyboard-accent-color: #0b579d;
    --keyboard-background: #cacfd7;
    --keyboard-border: #ddd;
    --keyboard-padding-horizontal: 0px;
    --keyboard-padding-top: 5px;
    --keyboard-padding-bottom: 0px;
    --keyboard-toolbar-text: #2c2e2f;
    --keyboard-toolbar-text-active: var(--keyboard-accent-color);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #eee;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: white;
    --keycap-background-hover: #f5f5f7;
    --keycap-background-active: white;
    --keycap-border: #e5e6e9;
    --keycap-border-bottom: #8d8f92;
    --keycap-text: #000;
    --keycap-text-active: #fff;
    --keycap-text-hover: #fff;
    --keycap-secondary-text: #000;
    --keycap-modifier-background: #b9bfc8;
    --keycap-modifier-background-hover: #a0a9b6;
    --keycap-modifier-text: #060707;
    --keycap-modifier-border: #c5c9d0;
    --keycap-modifier-border-bottom: #989da6;
    --keycap-height: 62px;
    --keycap-font-size: clamp(16px, 4cqw, 24px);
    --keycap-small-font-size: calc(var(--keycap-font-size) * 0.8);
    --keycap-extra-small-font-size: calc(var(--keycap-font-size) / 1.42);
    --variant-panel-background: #fff;
    --variant-keycap-text: var(--keycap-text, #000);
    --variant-keycap-text-active: #fff;
    --variant-keycap-background-active: var(--keyboard-accent-color);
    --variant-keycap-length: 70px;
    --variant-keycap-font-size: 30px;
    --variant-keycap-aside-font-size: 12px;
  }
  body > .ML__keyboard {
    position: fixed;
    --keyboard-padding-bottom: calc(var(--keyboard-padding-bottom) + env(safe-area-inset-bottom, 0));
  }
  body > .ML__keyboard.is-visible > .MLK__backdrop {
    box-shadow: 0 -5px 6px rgba(0, 0, 0, 0.08);
    border-top: 1px solid var(--keyboard-border);
    transition: 0.28s cubic-bezier(0, 0, 0.2, 1);
    transition-property: transform, opacity;
    transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
  }
  .ML__keyboard {
    position: relative;
    overflow: hidden;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    z-index: var(--keyboard-zindex, 105);
    pointer-events: none;
  }
  .MLK__backdrop {
    position: absolute;
    bottom: calc(-1 * var(--keyboard-height));
    width: 100%;
    height: var(--keyboard-height);
    box-sizing: border-box;
    padding-top: var(--keyboard-padding-top);
    padding-bottom: var(--keyboard-padding-bottom);
    padding-left: var(--keyboard-padding-horizontal);
    padding-right: var(--keyboard-padding-horizontal);
    opacity: 0;
    visibility: hidden;
    transform: translate(0, 0);
    background: var(--keyboard-background);
  }
  .ML__keyboard.is-visible > .MLK__backdrop {
    transform: translate(0, calc(-1 * var(--keyboard-height)));
    opacity: 1;
    visibility: visible;
  }
  .MLK__plate {
    position: absolute;
    bottom: 0;
    left: var(--keyboard-padding-horizontal);
    width: calc(100% - 2 * var(--keyboard-padding-horizontal));
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    container-type: inline-size;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    pointer-events: all;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-size: 16px;
    /* Size of toolbar labels */
    font-weight: 400;
    text-shadow: none;
  }
  .MLK__tex {
    font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__tex-math {
    font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__layer {
    display: none;
    outline: none;
  }
  .MLK__layer.is-visible {
    display: flex;
    flex-flow: column;
  }
  /* Keyboard layouts are made or rows of keys... */
  .MLK__rows {
    border: 0;
    border-collapse: separate;
    clear: both;
    margin: auto;
    display: flex;
    flex-flow: column;
    align-items: center;
    overflow-x: auto;
    touch-action: none;
    /* Keycap with (incl. margin) */
    --max-width: 102px;
    --margin: 6px;
    /* For the alignment of the text on some modifiers (e.g. shift) */
    /* Extra spacing between two adjacent keys */
  }
  .MLK__rows .small {
    font-size: 12px;
  }
  .MLK__rows .tex {
    font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__rows .tex-math {
    font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__rows .big-op {
    font-size: calc(1.25 * var(--keycap-font-size, 20px));
  }
  .MLK__rows .small {
    font-size: var(--keycap-small-font-size, 16px);
  }
  .MLK__rows .bottom {
    justify-content: flex-end;
  }
  .MLK__rows .left {
    align-items: flex-start;
    padding-left: 12px;
  }
  .MLK__rows .right {
    align-items: flex-end;
    padding-right: 12px;
  }
  .MLK__rows .w0 {
    width: 0;
  }
  .MLK__rows .w5 {
    width: calc(min(var(--max-width), 10cqw) / 2 - var(--margin));
  }
  .MLK__rows .w15 {
    width: calc(15 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .w20 {
    width: calc(20 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .w50 {
    width: calc(50 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .MLK__keycap.w50 {
    font-size: 80%;
    padding-top: 10px;
    font-weight: 100;
  }
  .MLK__rows .separator {
    background: transparent;
    border: none;
    pointer-events: none;
  }
  .MLK__rows .horizontal-rule {
    width: 100%;
    border-top: 1px solid var(--keycap-modifier-border-bottom);
  }
  .MLK__rows .ghost {
    background: transparent;
    border: none;
  }
  .MLK__rows .bigfnbutton {
    font-size: var(--keycap-extra-small-font-size, 14px);
  }
  .MLK__rows .modifier,
  .MLK__rows .action {
    color: var(--keycap-modifier-text);
    background: var(--keycap-modifier-background);
    border-color: var(--keycap-modifier-border);
    border-bottom-color: var(--keycap-modifier-border-bottom);
    font-size: 65%;
    font-weight: 100;
  }
  .MLK__rows .modifier:hover,
  .MLK__rows .action:hover {
    background: var(--keycap-modifier-background-hover);
  }
  .MLK__rows .modifier.selected,
  .MLK__rows .action.selected {
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__rows .modifier.selected:hover,
  .MLK__rows .action.selected:hover,
  .MLK__rows .modifier.selected:active,
  .MLK__rows .action.selected:active,
  .MLK__rows .modifier.selected.is-pressed,
  .MLK__rows .action.selected.is-pressed,
  .MLK__rows .modifier.selected.is-active,
  .MLK__rows .action.selected.is-active {
    color: white;
  }
  .MLK__rows .action.font-glyph,
  .MLK__rows .modifier.font-glyph {
    font-size: 2em;
  }
  .MLK__rows .warning {
    height: 25px;
    width: 25px;
    min-height: 25px;
    min-width: 25px;
    background: #cd0030;
    color: white;
    border-radius: 100%;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: -2px;
  }
  .MLK__rows .warning svg.svg-glyph {
    width: 16px;
    height: 16px;
  }
  .MLK__rows > ul {
    display: flex;
    flex-flow: row;
    width: 100%;
    list-style: none;
    margin: 0 0 var(--margin) 0;
    padding: 0;
  }
  .MLK__rows li {
    display: flex;
    flex-flow: column;
    align-items: center;
    justify-content: center;
    margin-right: var(--margin);
    width: calc(min(var(--max-width), 10cqw) - var(--margin));
    height: var(--keycap-height, 62px);
    box-sizing: border-box;
    padding: 0;
    vertical-align: top;
    text-align: center;
    float: left;
    color: var(--keycap-text);
    fill: currentColor;
    font-size: var(--keycap-font-size, 20px);
    background: var(--keycap-background);
    border: 1px solid var(--keycap-border);
    border-bottom-color: var(--keycap-border-bottom);
    border-radius: 5px;
    cursor: pointer;
    touch-action: none;
    /* Last key should be flush against the border */
    /* Keys with a variants panel */
    position: relative;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .MLK__rows li.horizontal-rule {
    margin-top: 1px;
    height: 3px;
  }
  .MLK__rows li:hover {
    background: var(--keycap-background-hover);
  }
  .MLK__rows li .ML__mathlive {
    pointer-events: none;
    touch-action: none;
  }
  .MLK__rows li:last-child {
    margin-right: 0;
  }
  .MLK__rows li svg.svg-glyph {
    margin: 8px 0;
    width: 20px;
    height: 20px;
  }
  .MLK__rows li svg.svg-glyph-lg {
    margin: 8px 0;
    width: 24px;
    height: 24px;
  }
  .MLK__rows li.MLK__tex-math {
    font-size: 25px;
  }
  .MLK__rows li.is-pressed {
    background: var(--keycap-background-active);
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__rows li.MLK__keycap.is-active,
  .MLK__rows li.action.is-active,
  .MLK__rows li.MLK__keycap.is-pressed,
  .MLK__rows li.action.is-pressed {
    z-index: calc(var(--keyboard-zindex, 105) - 5);
    background: var(--keyboard-accent-color);
    color: #fff;
  }
  .MLK__rows li.modifier.is-active {
    background: var(--keyboard-toolbar-text-active);
    color: var(--keycap-text-active);
  }
  .MLK__rows li small {
    color: var(--keycap-secondary-text);
  }
  .MLK__rows li aside {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-size: 10px;
    line-height: 10px;
    color: var(--keycap-secondary-text);
  }
  /* Add an attribute 'data-tooltip' to display a tooltip on hover.
Note there are a different set of tooltip rules for the keyboard toggle
(it's in a different CSS tree) */
  .MLK__tooltip {
    position: relative;
  }
  .MLK__tooltip::after {
    position: absolute;
    display: inline-table;
    content: attr(data-tooltip);
    top: inherit;
    bottom: 100%;
    width: max-content;
    max-width: 200px;
    padding: 8px 8px;
    background: #616161;
    color: #fff;
    text-align: center;
    z-index: 2;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    border-radius: 2px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-weight: 400;
    font-size: 12px;
    transition: all 0.15s cubic-bezier(0.4, 0, 1, 1) 1s;
    opacity: 0;
    transform: scale(0.5);
  }
  .MLK__tooltip:hover {
    position: relative;
  }
  .MLK__tooltip:hover::after {
    opacity: 1;
    transform: scale(1);
  }
  .MLK__toolbar {
    align-self: center;
    display: flex;
    flex-flow: row;
    justify-content: space-between;
    width: 100%;
    max-width: 996px;
    min-height: 32px;
    /* Icons for undo/redo, etc. */
  }
  .MLK__toolbar svg {
    height: 20px;
    width: 20px;
  }
  .MLK__toolbar > .left {
    position: relative;
    display: flex;
    justify-content: flex-start;
    flex-flow: row;
  }
  .MLK__toolbar > .right {
    display: flex;
    justify-content: flex-end;
    flex-flow: row;
  }
  .MLK__toolbar > div > div {
    /* "button" in the toolbar */
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--keyboard-toolbar-text);
    fill: currentColor;
    background: var(--keyboard-toolbar-background);
    font-size: 125%;
    padding: 4px 15px;
    cursor: pointer;
    width: max-content;
    min-width: 42px;
    min-height: 22px;
    border: none;
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 8px;
    padding-top: 8px;
    margin-top: 7px;
    margin-bottom: 8px;
    margin-left: 4px;
    margin-right: 4px;
    border-radius: 8px;
    box-shadow: none;
    border-bottom: 2px solid transparent;
  }
  .MLK__toolbar > div > div:not(.disabled):not(.selected):hover {
    background: var(--keyboard-toolbar-background-hover);
  }
  .MLK__toolbar > div > div.disabled svg,
  .MLK__toolbar > div > div.disabled:hover svg,
  .MLK__toolbar > div > div.disabled.is-pressed svg {
    color: var(--keyboard-toolbar-text);
    opacity: 0.2;
  }
  .MLK__toolbar > div > div:hover,
  .MLK__toolbar > div > div:active,
  .MLK__toolbar > div > div.is-pressed,
  .MLK__toolbar > div > div.is-active {
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__toolbar > div > div.selected {
    color: var(--keyboard-toolbar-text-active);
    background: var(--keyboard-toolbar-background-selected);
    border-radius: 0;
    border-bottom-color: var(--keyboard-toolbar-text-active);
    padding-bottom: 4px;
    margin-bottom: 12px;
  }
  /* This is the element that displays variants on press+hold */
  .MLK__variant-panel {
    visibility: hidden;
    position: fixed;
    bottom: auto;
    top: 0;
    box-sizing: content-box;
    transform: none;
    z-index: calc(var(--keyboard-zindex, 105) + 1);
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-content: center;
    touch-action: none;
    max-width: 286px;
    background: var(--variant-panel-background);
    text-align: center;
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
    transition: none;
  }
  .MLK__variant-panel.is-visible {
    visibility: visible;
  }
  .MLK__variant-panel.compact {
    --variant-keycap-length: 50px;
    --variant-keycap-font-size: 24px;
    --variant-keycap-aside-font-size: 10px;
  }
  .MLK__variant-panel ul {
    list-style: none;
    margin: 3px;
    padding: 0;
    display: flex;
    flex-flow: row wrap-reverse;
    justify-content: center;
  }
  .MLK__variant-panel li {
    display: flex;
    flex-flow: column;
    align-items: center;
    justify-content: center;
    font-size: var(--variant-keycap-font-size);
    height: var(--variant-keycap-length);
    width: var(--variant-keycap-length);
    box-sizing: border-box;
    margin: 0;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 5px;
    pointer-events: all;
    cursor: pointer;
    color: var(--variant-keycap-text);
    fill: currentColor;
  }
  @media (max-height: 412px) {
    .MLK__variant-panel li {
      font-size: 24px;
      height: 50px;
      width: 50px;
    }
  }
  .MLK__variant-panel li .ML__mathlive {
    pointer-events: none;
  }
  .MLK__variant-panel li:hover,
  .MLK__variant-panel li.is-pressed,
  .MLK__variant-panel li.is-active {
    background: var(--variant-keycap-background-active);
    color: var(--variant-keycap-text-active);
  }
  .MLK__variant-panel li.small {
    font-size: var(--keycap-small-font-size, 16px);
  }
  .MLK__variant-panel li.small-button {
    width: 42px;
    height: 42px;
    margin: 2px;
    background: #fbfbfb;
  }
  .MLK__variant-panel li.small-button:hover {
    background: var(--variant-keycap-background-active);
  }
  .MLK__variant-panel li.box > div,
  .MLK__variant-panel li.box > span {
    border: 1px dashed rgba(0, 0, 0, 0.24);
  }
  .MLK__variant-panel li .warning {
    min-height: 60px;
    min-width: 60px;
    background: #cd0030;
    color: white;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 5px;
  }
  .MLK__variant-panel li .warning:hover,
  .MLK__variant-panel li .warning.is-pressed,
  .MLK__variant-panel li .warning.is-active {
    background: red;
  }
  .MLK__variant-panel li .warning svg.svg-glyph {
    width: 50px;
    height: 50px;
  }
  .MLK__variant-panel li aside {
    font-size: var(--variant-keycap-aside-font-size);
    line-height: 12px;
    opacity: 0.78;
    padding-top: 2px;
  }
  /* @xs breakpoint: iPhone 5 */
  @container (max-width: 414px) {
    .MLK__variant-panel {
      max-width: 320px;
    }
    .MLK__toolbar > div > div {
      font-size: 100%;
      padding: 0;
      margin-left: 2px;
      margin-right: 2px;
    }
    .MLK__rows > ul {
      height: 42px;
    }
    .MLK__rows > ul > li {
      width: calc(10cqw - 2px);
      height: 42px;
      margin-right: 2px;
    }
    .MLK__rows .w5 {
      width: calc(5cqw - 2px);
    }
    .MLK__rows .w15 {
      width: calc(15cqw - 2px);
    }
    .MLK__rows .w20 {
      width: calc(20cqw - 2px);
    }
    .MLK__rows .w50 {
      width: calc(50cqw - 2px);
    }
    .MLK__rows .separator {
      width: 2px;
      min-width: 2px;
    }
    .MLK__rows .modifier,
    .MLK__rows .action {
      font-size: 65%;
    }
  }
  @container (max-width: 744px) {
    .MLK__toolbar > div > div {
      padding-left: 0;
      padding-right: 0;
    }
    .MLK__tooltip::after {
      padding: 8px 16px;
      font-size: 16px;
    }
    .MLK__rows .warning {
      height: 16px;
      width: 16px;
      min-height: 16px;
      min-width: 16px;
    }
    .MLK__rows .warning svg.svg-glyph {
      width: 14px;
      height: 14px;
    }
    .MLK__rows .action.font-glyph,
    .MLK__rows .modifier.font-glyph {
      font-size: 16px;
    }
    .MLK__rows .fnbutton {
      font-size: 16px;
    }
    .MLK__rows .bigfnbutton {
      font-size: calc(var(--keycap-extra-small-font-size, 14px) / 1.55);
    }
    .MLK__rows .small {
      font-size: 13px;
    }
    .MLK__rows aside {
      display: none;
    }
  }
  /* Medium breakpoint: larger phones */
  @container (max-width: 768px) {
    .ML__keyboard {
      --keycap-height: 42px;
    }
    .MLK__rows > ul > small {
      font-size: 14px;
    }
  }
  @container (max-width: 1444px) {
    .MLK__rows .if-wide {
      display: none;
    }
  }
  @media (prefers-color-scheme: dark) {
    .ML__keyboard {
      --keyboard-accent-color: hsl(212, 100%, 50%);
      --keyboard-background: #151515;
      --keyboard-border: transparent;
      --keyboard-toolbar-text: #e3e4e8;
      --keyboard-toolbar-text-active: hsl(212, 100%, 60%);
      --keyboard-toolbar-background: transparent;
      --keyboard-toolbar-background-hover: #303030;
      --keyboard-toolbar-background-selected: transparent;
      --keycap-background: #1f2022;
      --keycap-background-hover: #2f3032;
      --keycap-background-active: #2f3032;
      --keycap-border: transparent;
      --keycap-border-bottom: transparent;
      --keycap-text: #e3e4e8;
      --keycap-text-active: #000;
      --keycap-secondary-text: #e7ebee;
      --keycap-modifier-background: #3d4144;
      --keycap-modifier-background-hover: #4d5154;
      --keycap-modifier-text: #e7ebee;
      --keycap-modifier-border: transparent;
      --keycap-modifier-border-bottom: transparent;
      --variant-panel-background: #303030;
      --variant-keycap-text: var(--keycap-text);
      --variant-keycap-text-active: #fff;
    }
  }
  /* Same as the media query, but with a class */
  [theme='dark'] .ML__keyboard {
    --keyboard-accent-color: hsl(212, 100%, 50%);
    --keyboard-background: #151515;
    --keyboard-border: transparent;
    --keyboard-toolbar-text: #e3e4e8;
    --keyboard-toolbar-text-active: hsl(212, 100%, 60%);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #303030;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: #1f2022;
    --keycap-background-hover: #2f3032;
    --keycap-background-active: #2f3032;
    --keycap-border: transparent;
    --keycap-border-bottom: transparent;
    --keycap-text: #e3e4e8;
    --keycap-text-active: #000;
    --keycap-secondary-text: #e7ebee;
    --keycap-modifier-background: #3d4144;
    --keycap-modifier-background-hover: #4d5154;
    --keycap-modifier-text: #e7ebee;
    --keycap-modifier-border: transparent;
    --keycap-modifier-border-bottom: transparent;
    --variant-panel-background: #303030;
    --variant-keycap-text: var(--keycap-text);
    --variant-keycap-text-active: #fff;
  }
  [theme='light'] .ML__keyboard {
    --keyboard-accent-color: #0b579d;
    --keyboard-background: #cacfd7;
    --keyboard-border: #ddd;
    --keyboard-toolbar-text: #2c2e2f;
    --keyboard-toolbar-text-active: var(--keyboard-accent-color);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #eee;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: white;
    --keycap-background-hover: #f5f5f7;
    --keycap-background-active: white;
    --keycap-border: #e5e6e9;
    --keycap-border-bottom: #8d8f92;
    --keycap-text: #000;
    --keycap-text-active: #fff;
    --keycap-text-hover: #fff;
    --keycap-secondary-text: #000;
    --keycap-modifier-background: #a0a9b6;
    --keycap-modifier-background-hover: #949ead;
    --keycap-modifier-text: #060707;
    --keycap-modifier-border: #c5c9d0;
    --keycap-modifier-border-bottom: #989da6;
    --variant-panel-background: #fff;
    --variant-keycap-text: var(--keycap-text, #000);
    --variant-keycap-text-active: #fff;
    --variant-keycap-background-active: var(--keyboard-accent-color);
  }
}
`;
    function getFileUrl() {
      return "127.0.0.1:6806";
    }
    var gResolvedScriptUrl = null;
    var _a, _b;
    var gScriptUrl = ((_b = (_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.currentScript) == null ? void 0 : _b.src) || getFileUrl();
    async function resolveUrl(url) {
      if (/^(?:[a-z+]+:)?\/\//i.test(url))
        return new URL(url).href;
      if (gResolvedScriptUrl === null) {
        try {
          const response = await fetch(gScriptUrl, { method: "HEAD" });
          if (response.status === 200)
            gResolvedScriptUrl = response.url;
        } catch (e) {
          console.error(`Invalid URL "${url}" (relative to "${gScriptUrl}")`);
        }
      }
      return new URL(url, gResolvedScriptUrl != null ? gResolvedScriptUrl : gScriptUrl).href;
    }
    function makeFontFace(name, source, descriptors = {}) {
      return new FontFace(
        name,
        `url(${source}.woff2) format('woff2')`,
        descriptors
      );
    }
    var gFontsState = "not-loaded";
    async function reloadFonts() {
      gFontsState = "not-loaded";
      return loadFonts();
    }
    async function loadFonts() {
      var _a3;
      if (gFontsState !== "not-loaded")
        return;
      gFontsState = "loading";
      const useStaticFonts = (_a3 = getComputedStyle(document.documentElement).getPropertyValue(
        "--ML__static-fonts"
      )) != null ? _a3 : false;
      if (useStaticFonts) {
        gFontsState = "ready";
        return;
      }
      document.body.classList.remove("ML__fonts-did-not-load");
      if ("fonts" in document) {
        const fontFamilies = [
          "KaTeX_Main",
          "KaTeX_Math",
          "KaTeX_AMS",
          "KaTeX_Caligraphic",
          "KaTeX_Fraktur",
          "KaTeX_SansSerif",
          "KaTeX_Script",
          "KaTeX_Typewriter",
          "KaTeX_Size1",
          "KaTeX_Size2",
          "KaTeX_Size3",
          "KaTeX_Size4"
        ];
        const fontsInDocument = Array.from(document.fonts).map((f) => f.family);
        if (fontFamilies.every((x) => fontsInDocument.includes(x))) {
          gFontsState = "ready";
          return;
        }
        if (!window.MathfieldElement.fontsDirectory) {
          gFontsState = "not-loaded";
          return;
        }
        const fontsFolder = await resolveUrl(
          window.MathfieldElement.fontsDirectory
        );
        if (!fontsFolder) {
          document.body.classList.add("ML__fonts-did-not-load");
          gFontsState = "error";
          return;
        }
        const fonts = [
          ["KaTeX_Main-Regular"],
          ["KaTeX_Main-BoldItalic", { style: "italic", weight: "bold" }],
          ["KaTeX_Main-Bold", { weight: "bold" }],
          ["KaTeX_Main-Italic", { style: "italic" }],
          ["KaTeX_Math-Italic", { style: "italic" }],
          ["KaTeX_Math-BoldItalic", { style: "italic", weight: "bold" }],
          ["KaTeX_AMS-Regular"],
          ["KaTeX_Caligraphic-Regular"],
          ["KaTeX_Caligraphic-Bold", { weight: "bold" }],
          ["KaTeX_Fraktur-Regular"],
          ["KaTeX_Fraktur-Bold", { weight: "bold" }],
          ["KaTeX_SansSerif-Regular", { style: "italic" }],
          ["KaTeX_SansSerif-Bold", { weight: "bold" }],
          ["KaTeX_SansSerif-Italic", { style: "italic" }],
          ["KaTeX_Script-Regular"],
          ["KaTeX_Typewriter-Regular"],
          ["KaTeX_Size1-Regular"],
          ["KaTeX_Size2-Regular"],
          ["KaTeX_Size3-Regular"],
          ["KaTeX_Size4-Regular"]
        ].map(
          (x) => makeFontFace(
            x[0].replace(/-[a-zA-Z]+$/, ""),
            fontsFolder + "/" + x[0],
            x[1]
          )
        );
        try {
          const loadedFonts = await Promise.all(
            fonts.map((x) => {
              try {
                return x.load();
              } catch (e) {
              }
              return void 0;
            })
          );
          loadedFonts.forEach((font) => document.fonts.add(font));
          gFontsState = "ready";
          return;
        } catch (error) {
          console.error(
            `MathLive 0.90.9: The math fonts could not be loaded from "${fontsFolder}"`,
            { cause: error }
          );
          document.body.classList.add("ML__fonts-did-not-load");
        }
        gFontsState = "error";
      }
    }
    var LAYOUTS = {
      numeric: {
        label: "123",
        classes: "MLK__tex-math",
        tooltip: "keyboard.tooltip.numeric",
        layers: ["numeric"]
      },
      alphabetic: {
        label: "abc",
        classes: "MLK__tex-math",
        tooltip: "keyboard.tooltip.alphabetic",
        layers: ["lower-alphabetic", "upper-alphabetic"]
      },
      greek: {
        label: "&alpha;&beta;&gamma;",
        classes: "MLK__tex-math",
        tooltip: "keyboard.tooltip.greek",
        layers: ["lower-greek", "upper-greek"]
      },
      functions: {
        label: "f&thinsp;()",
        classes: "MLK__tex-math",
        tooltip: "keyboard.tooltip.functions",
        layers: ["functions"]
      },
      symbols: {
        label: "&infin;≠∈",
        classes: "MLK__tex-math",
        tooltip: "keyboard.tooltip.symbols",
        layers: ["symbols"]
      }
    };
    var SHIFTED_KEYS = {
      "\\varphi ": ["&Phi;", "\\Phi "],
      "\\varsigma ": ["&Sigma;", "\\Sigma "],
      "\\epsilon ": ["&#x0190;", '\\char"0190'],
      "\\rho ": ["&#x3A1", '\\char"3A1'],
      "\\tau ": ["&#x3A4;", '\\char"3A4'],
      "\\upsilon ": ["&Upsilon;", "\\Upsilon "],
      "\\theta ": ["&Theta;", "\\Theta "],
      "\\iota ": ["&Iota;", '\\char"399'],
      "\\omicron ": ["&#x039F;", '\\char"39F'],
      "\\pi ": ["&Pi;", "\\Pi "],
      "\\alpha ": ["&Alpha;", '\\char"391'],
      "\\sigma ": ["&Sigma;", "\\Sigma "],
      "\\delta ": ["&Delta;", "\\Delta "],
      "\\phi ": ["&#x03a6;", "\\Phi "],
      "\\gamma ": ["&Gamma;", "\\Gamma "],
      "\\eta ": ["&Eta;", '\\char"397'],
      "\\xi ": ["&Xi;", "\\Xi "],
      "\\kappa ": ["&Kappa;", '\\char"39A'],
      "\\lambda ": ["&Lambda;", "\\Lambda "],
      "\\zeta ": ["&Zeta;", '\\char"396'],
      "\\chi ": ["&Chi;", '\\char"3A7'],
      "\\psi ": ["&Psi;", "\\Psi "],
      "\\omega ": ["&Omega;", "\\Omega "],
      "\\beta ": ["&Beta;", '\\char"392'],
      "\\nu ": ["&Nu;", '\\char"39D'],
      "\\mu ": ["&Mu;", '\\char"39C']
    };
    var LAYERS = {
      "numeric": `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='x-var'><i>x</i></li>
    <li class='MLK__keycap MLK__tex' data-variants='n-var'><i>n</i></li>
    <li class='separator w5'></li>
    <row name='numpad-1'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='\\exponentialE' data-variants='ee'>e</li>
    <li class='MLK__keycap MLK__tex' data-latex='\\imaginaryI' data-variants='ii'>i</li>
    <li class='MLK__keycap MLK__tex' data-latex='\\pi' data-variants='numeric-pi'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-key='<' data-variants='<'>&lt;</li>
    <li class='MLK__keycap MLK__tex' data-key='>' data-variants='>'>&gt;</li>
    <li class='separator w5'></li>
    <row name='numpad-2'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='#@^{2}' data-latex='x^2'></li>
    <li class='MLK__keycap MLK__tex' data-variants='^' data-insert='#@^{#?}' data-latex='x^\\placeholder'></li>
    <li class='MLK__keycap MLK__tex small' data-insert='\\sqrt{#0}' data-latex='\\sqrt{#0}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='(' >(</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' >)</li>
    <li class='separator w5'></li>
    <row name='numpad-3'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap small' data-variants='int' data-latex='\\int_0^\\infty'></li>
    <li class='MLK__keycap' data-latex='\\forall' data-variants='logic' ></li>
    <li class='action font-glyph bottom right' data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  </ul>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>
    <li class='separator w5'></li>
    <row name='numpad-4'/>
    <li class='separator w5'></li>
    <arrows/>
  </ul>
</div>
    `,
      "lower-alphabetic": `
<div class='MLK__rows'>
  <ul>
    <row name='numpad-1' class='if-wide'/>
    <row name='lower-1' shift-layer='upper-alphabetic'/>
  </ul>
  <ul>
    <row name='numpad-2' class='if-wide'/>
    <row name='lower-2'  shift-layer='upper-alphabetic''/>
  </ul>
  <ul>
    <row name='numpad-3' class='if-wide'/>
    <row name='lower-3'  shift-layer='upper-alphabetic''/>
  </ul>
  <ul>
    <row name='numpad-4' class='if-wide'/>
    <li class='MLK__keycap' >;</li>
    <li class='MLK__keycap' >,</li>
    <li class='MLK__keycap w50' data-key=' ' data-variants='space'>&nbsp;</li>
    <arrows/>
  </ul>
</div>`,
      "upper-alphabetic": `<div class='MLK__rows'>
<ul>
  <row name='numpad-1' class='if-wide'/>
  <row name='upper-1'  shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-2' class='if-wide'/>
  <row name='upper-2' shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-3' class='if-wide'/>
  <row name='upper-3' shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-4' class='if-wide'/>
  <li class='MLK__keycap' >;</li>
  <li class='MLK__keycap' data-variants='.'>;</li>
  <li class='MLK__keycap w50' data-key=' '>&nbsp;</li>
  <arrows/>
</ul>
</div>`,
      "symbols": `
<div class='MLK__rows'>
  <ul>
    <row name='numpad-1' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\lbrace '>{</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rbrace '>}</li>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex small' data-variants='xleftarrows' data-latex='\\leftarrow' ></li>
    <li class='MLK__keycap MLK__tex small' data-variants='xrightarrows' data-latex='\\rightarrow' ></li>
    <li class='MLK__keycap MLK__tex' data-variants='overline' data-latex='\\overline{#@}' data-aside='overline'></li>
    <li class='MLK__keycap MLK__tex' data-variants='underline' data-latex='\\underline{#@}' data-aside='underline'></li>
    <li class='MLK__keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>
    <li class='MLK__keycap MLK__tex' data-variants='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>
    <li class='MLK__keycap MLK__tex' data-variants='infinity' data-insert='\\infty '>&#x221e;</li>

  </ul>
  <ul>
    <row name='numpad-2' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\lbrack '>[</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rbrack '>]</li>
    <li class='separator w5'></li>

    <li class='MLK__keycap MLK__tex' data-variants='in' data-insert='\\in '>&#x2208;</li>
    <li class='MLK__keycap MLK__tex' data-variants='!in' data-insert='\\notin '>&#x2209;</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>
    <li class='MLK__keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>

    <li class='MLK__keycap MLK__tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>

  </ul>
  <ul>
    <row name='numpad-3' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\langle '>&#x27e8;</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rangle '>&#x27e9;</li>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-variants='subset' data-insert='\\subset '>&#x2282;</li>
    <li class='MLK__keycap MLK__tex' data-variants='superset' data-insert='\\supset '>&#x2283;</li>

    <li class='MLK__keycap MLK__tex' data-variants='accents' data-insert='\\vec{#@}' data-latex='\\vec{#?}' data-aside='vector'></li>
    <li class='MLK__keycap MLK__tex' data-variants='absnorm' data-insert='\\left| #0 \\right|' data-latex='\\left| #? \\right|' data-aside='abs'></li>

    <li class='MLK__keycap MLK__tex' data-key='!' data-variants='!'>!<aside>factorial</aside></li>
    <li class='MLK__keycap' data-latex='^{\\prime} '><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>

    <li class='action font-glyph bottom right w15'
        data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
        data-shifted-command='"deleteAll"'
        data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
    ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>
  </ul>
  <ul>
    <row name='numpad-4' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-insert=','>,</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\colon '>:<aside>colon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\ne '>&#x2260;</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\pm '>&#x00b1;</li>
    <arrows/>
  </ul>
</div>`,
      "lower-greek": `
<div class='MLK__rows'>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\rho '><i>&rho;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\tau '><i>&tau;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\upsilon '><i>&upsilon;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\theta '><i>&theta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\iota '><i>&iota;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\omicron '>&omicron;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\pi '><i>&pi;</i></li>
  </ul>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command='["insert","\\\\char\\"391"]'><i>&alpha;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\sigma '><i>&sigma;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\delta '><i>&delta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\gamma '><i>&gamma;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\eta '><i>&eta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\xi '><i>&xi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\kappa '><i>&kappa;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\lambda '><i>&lambda;</i></li>
  </ul>
  <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\zeta '><i>&zeta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\chi '><i>&chi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\psi '><i>&psi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\omega '><i>&omega;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\beta '><i>&beta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\nu '><i>&nu;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\mu '><i>&mu;</i></li>
      <li class='action font-glyph bottom right w15'
          data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
          data-shifted-command='"deleteAll"'
          data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
      ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>
  </ul>
  <ul>
      <li class='MLK__keycap ' data-key=' '>&nbsp;</li>
      <li class='MLK__keycap'>,</li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>
      <arrows/>
  </ul>
</div>`,
      "upper-greek": `
<div class='MLK__rows'>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"0190'>&#x0190;<aside>epsilon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A1'>&#x3A1;<aside>rho</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A4'>&#x3A4;<aside>tau</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"399'>&Iota;<aside>iota</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39F'>&#x039F;<aside>omicron</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\char"391'>&#x391;<aside>alpha</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"397'>&Eta;<aside>eta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39A'>&Kappa;<aside>kappa</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>
  <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"396'>&Zeta;<aside>zeta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A7'>&Chi;<aside>chi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"392'>&Beta;<aside>beta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39D'>&Nu;<aside>nu</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39C'>&Mu;<aside>mu</aside></li>
    <li class='action font-glyph bottom right w15' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
<ul>
    <li class='separator'>&nbsp;</li>
    <li class='MLK__keycap'>.</li>
    <li class='MLK__keycap w50' data-key=' '>&nbsp;</li>
    <arrows/>
  </ul>
</div>`,
      "functions": `
<div class='MLK__rows'>
  <ul>
    <li class='fnbutton' data-insert='\\sin'></li>
    <li class='fnbutton' data-insert='\\sin^{-1}'></li>
    <li class='fnbutton' data-insert='\\ln'></li>
    <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{lcm}(#?)' data-latex='\\operatorname{lcm}()'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{ceil}(#?)' data-latex='\\operatorname{ceil}()'></li>
    <li class='bigfnbutton' data-insert='\\lim_{n\\to\\infty}'></li>
    <li class='bigfnbutton' data-insert='\\int'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{abs}(#?)' data-latex='\\operatorname{abs}()'></li>
  </ul>
  <ul>
    <li class='fnbutton' data-latex='\\cos'></li>
    <li class='fnbutton' data-latex='\\cos^{-1}'></li>
    <li class='fnbutton' data-latex='\\log'></li>
    <li class='fnbutton' data-latex='10^{#?}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{gcd}(#?)' data-latex='\\operatorname{gcd}()'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{floor}(#?)' data-latex='\\operatorname{floor}()'></li>
    <li class='bigfnbutton' data-latex='\\sum_{n\\mathop=0}^{\\infty}'></li>
    <li class='bigfnbutton' data-latex='\\int_{0}^{\\infty}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{sign}(#?)' data-latex='\\operatorname{sign}()'></li>
  </ul>
  <ul>
    <li class='fnbutton' data-latex='\\tan'></li>
    <li class='fnbutton' data-latex='\\tan^{-1}'></li>
    <li class='fnbutton' data-latex='\\log_{#?}'></li>
    <li class='fnbutton' data-latex='\\sqrt[#?]{#0}'></li>
    <li class='bigfnbutton' data-insert='#0 \\mod' data-latex='\\mod'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{round}(#?) ' data-latex='\\operatorname{round}()'></li>
    <li class='bigfnbutton' data-insert='\\prod_{n\\mathop=0}^{\\infty}' data-latex='{ \\prod_{n=0}^{\\infty}}'></li>
    <li class='bigfnbutton' data-insert='\\frac{\\differentialD #0}{\\differentialD x}'></li>
    <li class='action font-glyph bottom right' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  <ul>
    <li class='fnbutton'>(</li>
    <li class='fnbutton'>)</li>
    <li class='fnbutton' data-insert='^{#?}' data-latex='x^{#?}'></li>
    <li class='fnbutton' data-insert='_{#?}' data-latex='x_{#?}'></li>
    <li class='MLK__keycap w20 ' data-key=' '>&nbsp;</li>
    <arrows/>
  </ul>
</div>`,
      "style": `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"3"}]' data-latex='\\scriptsize\\text{small}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"5"}]' data-latex='\\scriptsize\\text{normal}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"9"}]' data-latex='\\huge\\text{big}'></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-latex='\\langle' data-command='["insert", "\\\\langle", {"smartFence":true}]'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"l"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"m"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"b"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"bx"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"sb"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"c"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"up"}]' data-latex='\\textup{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"it"}]' data-latex='\\textit{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"sl"}]' data-latex='\\textsl{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"sc"}]' data-latex='\\textsc{Ab}'></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-insert='\\emph{#@} ' data-latex='\\text{\\emph{emph}}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmr"}]' data-latex='\\textrm{Az}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmtt"}]' data-latex='\\texttt{Az}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmss"}]' data-latex='\\textsf{Az}'></li>

    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"bb"}]'  data-latex='\\mathbb{AZ}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"scr"}]'  data-latex='\\mathscr{AZ}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cal"}]' data-latex='\\mathcal{A1}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"frak"}]' data-latex='\\mathfrak{Az}'></li>
  </ul>
</div>`
    };
    var Scrim = class {
      /**
       * - If `options.preventOverlayClose` is false, the scrim is closed if the
       * user clicks on the scrim. That's the behavior for menus, for example.
       * When you need a fully modal situation until the user has made an
       * explicit choice (validating cookie usage, for example), set
       * `preventOverlayClose` to true.
       * - `onClose()` is called when the scrim is being closed
       * -
       */
      constructor(options) {
        var _a3, _b3;
        this.preventOverlayClose = (_a3 = options == null ? void 0 : options.preventOverlayClose) != null ? _a3 : false;
        this.translucent = (_b3 = options == null ? void 0 : options.translucent) != null ? _b3 : false;
        this.state = "closed";
      }
      get element() {
        if (this._element)
          return this._element;
        const element = document.createElement("div");
        element.setAttribute("role", "presentation");
        element.style.position = "fixed";
        element.style.contain = "content";
        element.style.top = "0";
        element.style.left = "0";
        element.style.right = "0";
        element.style.bottom = "0";
        element.style.zIndex = "var(--scrim-zindex, 10099)";
        element.style.outline = "none";
        if (this.translucent) {
          element.style.background = "rgba(255, 255, 255, .2)";
          element.style["backdropFilter"] = "contrast(40%)";
        } else
          element.style.background = "transparent";
        this._element = element;
        return element;
      }
      open(options) {
        var _a3;
        if (this.state !== "closed")
          return;
        this.state = "opening";
        this.savedActiveElement = deepActiveElement();
        const { element } = this;
        ((_a3 = options == null ? void 0 : options.root) != null ? _a3 : document.body).appendChild(element);
        element.addEventListener("click", this);
        document.addEventListener("touchmove", this, false);
        document.addEventListener("scroll", this, false);
        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        this.savedMarginRight = document.body.style.marginRight;
        this.savedOverflow = document.body.style.overflow;
        document.body.style.overflow = "hidden";
        const marginRight = Number.parseFloat(
          getComputedStyle(document.body).marginRight
        );
        document.body.style.marginRight = `${marginRight + scrollbarWidth}px`;
        if (options == null ? void 0 : options.child)
          element.append(options.child);
        this.state = "open";
      }
      close() {
        var _a3, _b3, _c2, _d2;
        if (this.state !== "open")
          return;
        this.state = "closing";
        if (typeof this.onClose === "function")
          this.onClose();
        const { element } = this;
        element.removeEventListener("click", this);
        document.removeEventListener("touchmove", this, false);
        document.removeEventListener("scroll", this, false);
        element.remove();
        document.body.style.overflow = (_a3 = this.savedOverflow) != null ? _a3 : "";
        document.body.style.marginRight = (_b3 = this.savedMarginRight) != null ? _b3 : "";
        if (deepActiveElement() !== this.savedActiveElement)
          (_d2 = (_c2 = this.savedActiveElement) == null ? void 0 : _c2.focus) == null ? void 0 : _d2.call(_c2);
        element.innerHTML = "";
        this.state = "closed";
      }
      handleEvent(ev) {
        if (!this.preventOverlayClose) {
          if (ev.target === this._element && ev.type === "click") {
            this.close();
            ev.preventDefault();
            ev.stopPropagation();
          } else if (ev.target === document && (ev.type === "touchmove" || ev.type === "scroll")) {
            this.close();
            ev.preventDefault();
            ev.stopPropagation();
          }
        }
      }
    };
    function deepActiveElement() {
      var _a3;
      let a = document.activeElement;
      while ((_a3 = a == null ? void 0 : a.shadowRoot) == null ? void 0 : _a3.activeElement)
        a = a.shadowRoot.activeElement;
      return a;
    }
    var gVariants = {
      "0-extended": [
        "\\emptyset",
        "\\varnothing",
        "\\infty",
        { latex: "#?_0", insert: "#@_0" },
        "\\circ",
        "\\bigcirc",
        "\\bullet"
      ],
      "0": ["\\varnothing", "\\infty"],
      "1": ["\\frac{1}{#0}", "\\times 10^{#?}"],
      "2": ["\\frac{1}{2}", "#@^2", "\\exponentialE"],
      "3": ["\\frac{1}{3}", "#@^3", "\\pi"],
      "4": ["\\frac{1}{4}", "#@^4"],
      "5": ["\\frac{1}{5}", "#@^5"],
      "6": ["\\frac{1}{6}", "#@^6"],
      "7": ["\\frac{1}{7}", "#@^7"],
      "8": ["\\frac{1}{8}", "#@^8"],
      "9": ["\\frac{1}{9}", "#@^9"],
      ".": [
        ".",
        ",",
        ";",
        "\\colon",
        { latex: ":", aside: "ratio" },
        { latex: "\\cdotp", aside: "center dot", class: "box" },
        { latex: "\\cdots", aside: "center ellipsis", class: "box" },
        { latex: "\\ldotp", aside: "low dot", class: "box" },
        { latex: "\\ldots", aside: "low ellipsis", class: "box" },
        { latex: "\\vdots", aside: "", class: "box" },
        { latex: "\\ddots", aside: "", class: "box" },
        "\\odot",
        "\\oslash",
        "\\circledcirc"
      ],
      "*": [
        "\\cdot",
        "\\ast",
        "\\star",
        { latex: "\\prod_{#0}^{#0}", class: "small" }
      ],
      "*-extended": [
        "\\cdot",
        "\\ast",
        "\\star",
        "\\bigstar",
        "\\ltimes",
        "\\rtimes",
        "\\rightthreetimes",
        "\\leftthreetimes",
        "\\intercal",
        "\\prod",
        { latex: "\\prod_{n\\mathop=0}^{\\infty}", class: "small" }
      ],
      "+-extended": [
        "\\pm",
        "\\mp",
        "\\sum",
        { latex: "\\sum_{n\\mathop=0}^{\\infty}", class: "small" },
        "\\dotplus",
        "\\oplus"
      ],
      "+": [{ latex: "\\sum_{#0}^{#0}", class: "small" }],
      "--extended": ["\\pm", "\\mp", "\\ominus", "\\vert #0  \\vert"],
      "-": ["\\pm"],
      "/-extended": ["\\divideontimes", "/", "\\div", "\\%"],
      "/": ["/", "\\div", "\\%"],
      "(": ["\\lbrack", "\\langle", "\\lfloor", "\\lceil", "\\lbrace"],
      ")": ["\\rbrack", "\\rangle", "\\rfloor", "\\rceil", "\\rbrace"],
      "(-extended": [
        "\\left( #0\\right)",
        "\\left[ #0\\right]",
        "\\left\\{ #0\\right\\}",
        "\\left\\langle #0\\right\\rangle",
        "\\lfloor",
        "\\llcorner",
        "(",
        "\\lbrack",
        "\\lvert",
        "\\lVert",
        "\\lgroup",
        "\\langle",
        "\\lceil",
        "\\ulcorner",
        "\\lmoustache",
        "\\lbrace"
      ],
      ")-extended": [
        "\\rfloor",
        "\\lrcorner",
        ")",
        "\\rbrack",
        "\\rvert",
        "\\rVert",
        "\\rgroup",
        "\\rangle",
        "\\rceil",
        "\\urcorner",
        "\\rmoustache",
        "\\rbrace"
      ],
      "=": [
        "\\neq",
        "\\equiv",
        "\\varpropto",
        "\\thickapprox",
        "\\lt",
        "\\gt",
        "\\le",
        "\\ge"
      ],
      "=-extended": [
        "\\cong",
        "\\asymp",
        "\\equiv",
        "\\differencedelta",
        "\\varpropto",
        "\\thickapprox",
        "\\approxeq",
        "\\thicksim",
        "\\backsim",
        "\\eqsim",
        "\\simeq",
        "\\Bumpeq",
        "\\bumpeq",
        "\\doteq",
        "\\Doteq",
        "\\fallingdotseq",
        "\\risingdotseq",
        "\\coloneq",
        "\\eqcirc",
        "\\circeq",
        "\\triangleq",
        "\\between"
      ],
      "!=": ["\\neq", "\\ncong", "", "\\nsim"],
      "<": [
        "\\leq",
        "\\leqq",
        "\\lneqq",
        "\\ll",
        "\\lessgtr",
        "\\nless",
        "\\nleq",
        "\\lesssim",
        "\\precsim",
        "\\prec",
        "\\nprec",
        "\\preccurlyeq",
        "\\lessdot"
      ],
      ">": [
        "\\geq",
        "\\geqq",
        "\\gneqq",
        "\\gg",
        "\\gtrless",
        "\\ngtr",
        "\\ngeq",
        "\\gtrsim",
        "\\succsim",
        "\\succ",
        "\\nsucc",
        "\\succcurlyeq",
        "\\gtrdot"
      ],
      "in": ["\\owns"],
      "!in": ["\\backepsilon"],
      "subset": ["\\subseteq", "\\nsubset", "\\nsubseteq"],
      "superset": ["\\supseteq", "\\nsupset", "\\nsupseteq"],
      "infinity": ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"],
      "numeric-pi": ["\\prod", "\\theta", "\\rho", "\\sin", "\\cos", "\\tan"],
      "ee": ["\\times 10^{#?}", "\\ln", "\\log_{10}", "\\log"],
      "^": ["_{#?}"],
      // Integrals
      "int": [
        { latex: "\\int_{#?}^{#?}", class: "small" },
        { latex: "\\int", class: "small" },
        { latex: "\\smallint", class: "small" },
        { latex: "\\iint", class: "small" },
        { latex: "\\iiint", class: "small" },
        { latex: "\\oint", class: "small" },
        { latex: "\\dfrac{\\rd}{\\rd x}", class: "small" },
        { latex: "\\frac{\\partial}{\\partial x}", class: "small" },
        "\\capitalDifferentialD",
        "\\rd",
        "\\partial"
      ],
      "nabla": ["\\nabla\\times", "\\nabla\\cdot", "\\nabla^{2}"],
      "!": ["!!", "\\Gamma", "\\Pi"],
      "accents": [
        "\\bar{#@}",
        "\\vec{#@}",
        "\\hat{#@}",
        "\\check{#@}",
        "\\dot{#@}",
        "\\ddot{#@}",
        "\\mathring{#@}",
        "\\breve{#@}",
        "\\acute{#@}",
        "\\tilde{#@}",
        "\\grave{#@}"
      ],
      "underline": [
        "\\underbrace{#@}",
        "\\underlinesegment{#@}",
        "\\underleftrightarrow{#@}",
        "\\underrightarrow{#@}",
        "\\underleftarrow{#@}",
        "\\undergroup{#@}"
      ],
      "overline": [
        "\\overbrace{#@}",
        "\\overlinesegment{#@}",
        "\\overleftrightarrow{#@}",
        "\\overrightarrow{#@}",
        "\\overleftarrow{#@}",
        "\\overgroup{#@}"
      ],
      "xleftarrows": [
        "\\xlongequal{#@}",
        "\\xleftrightarrow{#@}",
        "\\xLeftrightarrow{#@}",
        "\\xleftrightharpoons{#@}",
        "\\xLeftarrow{#@}",
        "\\xleftharpoonup{#@}",
        "\\xleftharpoondown{#@}",
        "\\xtwoheadleftarrow{#@}",
        "\\xhookleftarrow{#@}",
        "\\xtofrom{#@}",
        "\\xleftequilibrium{#@}",
        // From mhchem.sty package
        "\\xrightleftarrows{#@}"
        // From mhchem.sty package
      ],
      "xrightarrows": [
        "\\xrightarrow{#@}",
        "\\xlongequal{#@}",
        "\\xleftrightarrow{#@}",
        "\\xLeftrightarrow{#@}",
        "\\xleftrightharpoons{#@}",
        "\\xRightarrow{#@}",
        "\\xrightharpoonup{#@}",
        "\\xrightharpoondown{#@}",
        "\\xtwoheadrightarrow{#@}",
        "\\xrightleftharpoons{#@}",
        "\\xhookrightarrow{#@}",
        "\\xmapsto{#@}",
        "\\xrightequilibrium{#@}",
        // From mhchem.sty package
        "\\xrightleftarrows{#@}"
        // From mhchem.sty package
      ],
      // 'absnorm': [{latex:'\\lVert #@ \\rVert', aside:'norm'},
      //     {latex:'\\lvert #@ \\rvert', aside:'determinant'},
      //     {latex:'\\begin{cardinality} #@ \\end{cardinality}', aside:'cardinality'},
      //     {latex:'\\lvert #@ \\rvert', aside:'length'},
      //     {latex:'\\lvert #@ \\rvert', aside:'order'},
      // ],
      "A": [
        { latex: "\\aleph", aside: "aleph" },
        { latex: "\\forall", aside: "for all" }
      ],
      "a": [
        { latex: "\\aleph", aside: "aleph" },
        { latex: "\\forall", aside: "for all" }
      ],
      "b": [{ latex: "\\beth", aside: "beth" }],
      "B": [{ latex: "\\beth", aside: "beth" }],
      "c": [{ latex: "\\C", aside: "set of complex numbers" }],
      "d": [{ latex: "\\daleth", aside: "daleth" }],
      "D": [{ latex: "\\daleth", aside: "daleth" }],
      "e": [
        { latex: "\\exponentialE", aside: "exponential e" },
        { latex: "\\exists", aside: "there is" },
        { latex: "\\nexists", aside: "there isn’t" }
      ],
      "g": [{ latex: "\\gimel", aside: "gimel" }],
      "G": [{ latex: "\\gimel", aside: "gimel" }],
      "h": [
        { latex: "\\hbar", aside: "h bar" },
        { latex: "\\hslash", aside: "h slash" }
      ],
      "i": [{ latex: "\\imaginaryI", aside: "imaginary i" }],
      "j": [{ latex: "\\imaginaryJ", aside: "imaginary j" }],
      "l": [{ latex: "\\ell", aside: "ell" }],
      "n": [{ latex: "\\mathbb{N}", aside: "set of natural numbers" }],
      "p": [{ latex: "\\mathbb{P}", aside: "set of primes" }],
      "q": [{ latex: "\\mathbb{Q}", aside: "set of rational numbers" }],
      "r": [{ latex: "\\mathbb{R}", aside: "set of real numbers" }],
      "z": [{ latex: "\\mathbb{Z}", aside: "set of integers" }],
      "x-var": [
        "y",
        "z",
        "t",
        "r",
        { latex: "f(#?)", class: "small" },
        { latex: "g(#?)", class: "small" },
        "x^2",
        "x^n",
        "x_n",
        "x_{n+1}",
        "x_i",
        "x_{i+1}"
      ],
      "n-var": ["i", "j", "p", "k", "a", "u"],
      "ii": ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"],
      "logic": [
        { latex: "\\exists", aside: "there is" },
        { latex: "\\nexists", aside: "there isn’t" },
        { latex: "\\ni", aside: "such that" },
        { latex: "\\Colon", aside: "such that" },
        { latex: "\\implies", aside: "implies" },
        { latex: "\\impliedby", aside: "implied by" },
        { latex: "\\iff", aside: "if and only if" },
        { latex: "\\land", aside: "and" },
        { latex: "\\lor", aside: "or" },
        { latex: "\\oplus", aside: "xor" },
        { latex: "\\lnot", aside: "not" },
        { latex: "\\downarrow", aside: "nor" },
        { latex: "\\uparrow", aside: "nand" },
        { latex: "\\curlywedge", aside: "nor" },
        { latex: "\\bar\\curlywedge", aside: "nand" },
        // {latex:'\\barwedge', aside:'bar wedge'},
        // {latex:'\\curlyvee', aside:'curly vee'},
        // {latex:'\\veebar', aside:'vee bar'},
        { latex: "\\therefore", aside: "therefore" },
        { latex: "\\because", aside: "because" },
        { latex: "^\\biconditional", aside: "biconditional" },
        "\\leftrightarrow",
        "\\Leftrightarrow",
        "\\to",
        "\\models",
        "\\vdash",
        "\\gets",
        "\\dashv",
        "\\roundimplies"
      ],
      "set-operators": [
        "\\cap",
        "\\cup",
        "\\setminus",
        "\\smallsetminus",
        "\\complement"
      ],
      "set-relations": [
        "\\in",
        "\\notin",
        "\\ni",
        "\\owns",
        "\\subset",
        "\\supset",
        "\\subseteq",
        "\\supseteq",
        "\\subsetneq",
        "\\supsetneq",
        "\\varsubsetneq",
        "\\subsetneqq",
        "\\nsubset",
        "\\nsupset",
        "\\nsubseteq",
        "\\nsupseteq"
      ],
      "space": [
        {
          latex: '\\char"203A\\!\\char"2039',
          insert: "\\!",
          aside: "negative thin space<br>⁻³⧸₁₈ em"
        },
        {
          latex: '\\unicode{"203A}\\,\\unicode{"2039}',
          insert: "\\,",
          aside: "thin space<br>³⧸₁₈ em"
        },
        {
          latex: '\\unicode{"203A}\\:\\unicode{"2039}',
          insert: "\\:",
          aside: "medium space<br>⁴⧸₁₈ em"
        },
        {
          latex: '\\unicode{"203A}\\;\\unicode{"2039}',
          insert: "\\;",
          aside: "thick space<br>⁵⧸₁₈ em"
        },
        {
          latex: '\\unicode{"203A}\\ \\unicode{"2039}',
          insert: "\\ ",
          aside: "⅓ em"
        },
        {
          latex: '\\unicode{"203A}\\enspace\\unicode{"2039}',
          insert: "\\enspace",
          aside: "½ em"
        },
        {
          latex: '\\unicode{"203A}\\quad\\unicode{"2039}',
          insert: "\\quad",
          aside: "1 em"
        },
        {
          latex: '\\unicode{"203A}\\qquad\\unicode{"2039}',
          insert: "\\qquad",
          aside: "2 em"
        }
      ],
      // @todo could also delete to end
      "delete": [
        {
          label: '<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>',
          command: "deleteAll"
        }
      ],
      // @todo Tab: could turn on speech, visible keyboard...
      "->|": []
    };
    function showVariantsPanel(element, variantsId) {
      var _a3, _b3;
      const variants = getVariants(variantsId);
      const variantPanel = document.createElement("div");
      variantPanel.setAttribute("aria-hidden", "true");
      variantPanel.className = "ML__keyboard MLK__variant-panel";
      if (variants.length >= 14) {
        variantPanel.style.width = "236px";
      } else if (variants.length >= 7) {
        variantPanel.style.width = "286px";
      } else if (variants.length === 4 || variants.length === 2) {
        variantPanel.style.width = "146px";
      } else if (variants.length === 1) {
        variantPanel.style.width = "86px";
      } else {
        variantPanel.style.width = "146px";
      }
      variantPanel.style.height = "auto";
      let markup = "";
      for (const variant of variants) {
        markup += "<li";
        if (typeof variant === "string") {
          markup += ` data-latex="${variant.replace(
            /"/g,
            "&quot;"
          )}"'>${latexToMarkup(variant)}</li>`;
        } else {
          if (variant.latex)
            markup += ' data-latex="' + variant.latex.replace(/"/g, "&quot;") + '"';
          if (variant.insert) {
            markup += ' data-insert="' + variant.insert.replace(/"/g, "&quot;") + '"';
          }
          if (variant.command) {
            markup += ` data-command='${(typeof variant.command === "string" ? '"' + variant.command + '"' : JSON.stringify(variant.command)).replace(/"/g, "&quot;")}'`;
          }
          if (variant.aside)
            markup += ` data-aside="${variant.aside.replace(/"/g, "&quot;")}"`;
          if (variant.class)
            markup += ` data-classes="${variant.class}"`;
          markup += ">";
          markup += (_b3 = variant.label) != null ? _b3 : latexToMarkup((_a3 = variant.latex) != null ? _a3 : "");
          markup += "</li>";
        }
      }
      variantPanel.innerHTML = mathfield_element_default.createHTML(`<ul>${markup}</ul>`);
      const keyboard = VirtualKeyboard.singleton;
      if (!Scrim.scrim)
        Scrim.scrim = new Scrim();
      Scrim.scrim.open({ root: keyboard.container, child: variantPanel });
      makeKeycap(
        keyboard,
        [...variantPanel.querySelectorAll("li")],
        "performVariant"
      );
      const position = element == null ? void 0 : element.getBoundingClientRect();
      if (position) {
        if (position.top - variantPanel.clientHeight < 0) {
          variantPanel.style.width = "auto";
          if (variants.length <= 6)
            variantPanel.style.height = "56px";
          else if (variants.length <= 12)
            variantPanel.style.height = "108px";
          else if (variants.length <= 18)
            variantPanel.style.height = "205px";
          else
            variantPanel.classList.add("compact");
        }
        const left = Math.max(
          0,
          Math.min(
            window.innerWidth - variantPanel.offsetWidth,
            (position.left + position.right - variantPanel.offsetWidth) / 2
          )
        );
        const top = position.top - variantPanel.clientHeight + 5;
        variantPanel.style.transform = `translate(${left}px, ${top}px)`;
        variantPanel.classList.add("is-visible");
      }
      return false;
    }
    function hideVariantsPanel() {
      var _a3;
      const variantPanel = document.querySelector(
        ".MLK__variant-panel"
      );
      if (variantPanel) {
        variantPanel.classList.remove("is-visible");
        variantPanel.innerHTML = "";
      }
      (_a3 = Scrim.scrim) == null ? void 0 : _a3.close();
      return false;
    }
    function makeVariants(id) {
      if (id === "foreground-color") {
        const result = [];
        for (const color of Object.keys(FOREGROUND_COLORS)) {
          result.push({
            class: "small-button",
            label: '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' + FOREGROUND_COLORS[color] + '"></span>',
            command: ["applyStyle", { color }]
          });
        }
        return result;
      }
      if (id === "background-color") {
        const result = [];
        for (const color of Object.keys(BACKGROUND_COLORS)) {
          result.push({
            class: "small-button",
            label: '<span style="border-radius:50%;width:32px;height:32px; background:' + BACKGROUND_COLORS[color] + '"></span>',
            command: ["applyStyle", { backgroundColor: color }]
          });
        }
        return result;
      }
      return void 0;
    }
    function getVariants(id) {
      var _a3;
      if (!gVariants[id])
        gVariants[id] = (_a3 = makeVariants(id)) != null ? _a3 : [];
      return gVariants[id];
    }
    function setVariants(id, value) {
      gVariants[id] = value;
    }
    function unshiftKeyboardLayer() {
      hideVariantsPanel();
      const keycaps = VirtualKeyboard.singleton.element.querySelectorAll(
        ".MLK__layer.is-visible .MLK__keycap, .MLK__layer.is-visible .action"
      );
      if (keycaps) {
        for (const keycap of keycaps) {
          keycap.classList.remove("is-active");
          keycap.classList.remove("is-pressed");
          const content = keycap.getAttribute("data-unshifted-content");
          if (content) {
            keycap.innerHTML = MathfieldElement.createHTML(content);
            keycap.dataset.unshiftedContent = "";
          }
          const command = keycap.getAttribute("data-unshifted-command");
          if (command) {
            keycap.dataset.command = command;
            keycap.dataset.unshiftedCommand = "";
          }
        }
      }
      return false;
    }
    function jsonToCssProps(json) {
      if (typeof json === "string")
        return json;
      return Object.entries(json).map(([k, v]) => `${k}:${v} !important`).join(";");
    }
    function jsonToCss(json) {
      return Object.keys(json).map((k) => {
        return `${k} {${jsonToCssProps(json[k])}}`;
      }).join("");
    }
    function latexToMarkup(latex, arg) {
      if (!latex)
        return "";
      latex = latex.replace(/(^|[^\\])#@/g, "$1#?");
      const globalContext = defaultGlobalContext();
      const root = new Atom("root", globalContext);
      root.body = parseLatex(latex, globalContext, {
        parseMode: "math",
        args: arg != null ? arg : () => "\\placeholder{}"
      });
      const context = new Context(
        { registers: globalContext.registers },
        { fontSize: DEFAULT_FONT_SIZE },
        "displaystyle"
      );
      const box = coalesce(
        adjustInterAtomSpacing(
          new Box(root.render(context), { classes: "ML__base" }),
          context
        )
      );
      return makeStruts(box, { classes: "ML__mathlive" }).toMarkup();
    }
    function normalizeLayer(layer) {
      if (Array.isArray(layer))
        return layer.map((x) => normalizeLayer(x)).flat();
      if (typeof layer === "string" && LAYERS[layer])
        return normalizeLayer({ markup: LAYERS[layer], id: layer });
      let result;
      if (typeof layer === "string")
        result = { markup: layer };
      else
        result = layer;
      if (!result.id) {
        result.id = "ML__layer_" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      }
      return [result];
    }
    function normalizeLayout(layout) {
      if (typeof layout === "string")
        return normalizeLayout(LAYOUTS[layout]);
      if ("rows" in layout && Array.isArray(layout.rows)) {
        console.assert(
          !("layers" in layout),
          `MathLive 0.90.9: only provide either a "rows" or "layers" property, not both`
        );
        let hasShift = false;
        let hasEdit = false;
        for (const keycap of layout.rows.flat()) {
          const label = typeof keycap === "string" ? keycap : keycap.label;
          if (label === "[shift]")
            hasShift = true;
          if (["[undo]", "[redo]", "[cut]", "[copy]", "[paste]"].includes(label))
            hasEdit = true;
        }
        if (!("displayShiftedKeycaps" in layout) || layout.displayShiftedKeycaps === void 0)
          layout.displayShiftedKeycaps = hasShift;
        if (!("displayEditToolbar" in layout) || layout.displayEditToolbar === void 0)
          layout.displayEditToolbar = !hasEdit;
        return __spreadProps(__spreadValues({}, layout), {
          layers: normalizeLayer({ rows: layout.rows }),
          rows: void 0
        });
      }
      if ("markup" in layout && typeof layout.markup === "string") {
        return __spreadProps(__spreadValues({}, layout), {
          layers: normalizeLayer(layout.markup)
        });
      }
      const result = __spreadValues({}, layout);
      if ("layers" in layout)
        result.layers = normalizeLayer(layout.layers);
      if (!("displayEditToolbar" in layout) || layout.displayEditToolbar === void 0)
        result.displayEditToolbar = true;
      return result;
    }
    function makeLayoutsToolbar(keyboard, index) {
      var _a3, _b3;
      let markup = `<div class="left">`;
      if (keyboard.layouts.length > 1) {
        for (const [i, l] of keyboard.layouts.entries()) {
          const layout = l;
          const classes = [i === index ? "selected" : "layer-switch"];
          if (layout.tooltip)
            classes.push("MLK__tooltip");
          if (layout.classes)
            classes.push(...layout.classes.split(" "));
          markup += `<div class="${classes.join(" ")}"`;
          if (layout.tooltip) {
            markup += " data-tooltip='" + ((_a3 = localize(layout.tooltip)) != null ? _a3 : layout.tooltip) + "' ";
          }
          if (i !== index)
            markup += `data-layer="${layout.layers[0].id}"`;
          markup += `>${(_b3 = layout.label) != null ? _b3 : "untitled"}</div>`;
        }
      }
      markup += "</div>";
      return markup;
    }
    function makeActionToolbar(options, mathfield) {
      let result = "";
      const toolbarOptions = options.actionToolbar;
      if (toolbarOptions === "none")
        return "";
      const availableActions = [];
      if (mathfield.selectionIsCollapsed)
        availableActions.push("undo", "redo", "pasteFromClipboard");
      else {
        availableActions.push(
          "cutToClipboard",
          "copyToClipboard",
          "pasteFromClipboard"
        );
      }
      const actionsMarkup = {
        undo: `<div class='action ${mathfield.canUndo === false ? "disabled" : ""}'
          data-command='"undo"'
          data-tooltip='${localize("tooltip.undo")}'>
          <svg><use xlink:href='#svg-undo' /></svg>
      </div>`,
        redo: `<div class='action ${mathfield.canRedo === false ? "disabled" : ""}'
          data-command='"redo"'
          data-tooltip='${localize("tooltip.redo")}'>
          <svg><use xlink:href='#svg-redo' /></svg>
      </div>`,
        cutToClipboard: `
        <div class='action'
            data-command='"cutToClipboard"'
            data-tooltip='${localize("tooltip.cut to clipboard")}'>
            <svg><use xlink:href='#svg-cut' /></svg>
        </div>
    `,
        copyToClipboard: `
        <div class='action'
            data-command='"copyToClipboard"'
            data-tooltip='${localize("tooltip.copy to clipboard")}'>
            <svg><use xlink:href='#svg-copy' /></svg>
        </div>
    `,
        pasteFromClipboard: `
        <div class='action'
            data-command='"pasteFromClipboard"'
            data-tooltip='${localize("tooltip.paste from clipboard")}'>
            <svg><use xlink:href='#svg-paste' /></svg>
        </div>
    `
      };
      result += availableActions.map((action) => actionsMarkup[action]).join("");
      return result;
    }
    function makeKeycap(keyboard, elementList, chainedCommand) {
      var _a3, _b3;
      for (const element of elementList) {
        let html = element.innerHTML;
        if (!html) {
          if (element.getAttribute("data-label"))
            html = element.getAttribute("data-label").replace(/&quot;/g, '"');
          else if (element.getAttribute("data-latex")) {
            html = latexToMarkup(
              element.getAttribute("data-latex").replace(/&quot;/g, '"')
            );
          } else if (element.getAttribute("data-insert")) {
            html = latexToMarkup(
              element.getAttribute("data-insert").replace(/&quot;/g, '"')
            );
          }
          if (element.getAttribute("data-aside")) {
            html += `<aside>${element.getAttribute("data-aside").replace(/&quot;/g, '"')}</aside>`;
          }
          if (html)
            element.innerHTML = MathfieldElement.createHTML(html);
        }
        if (element.getAttribute("data-classes"))
          element.classList.add(element.getAttribute("data-classes"));
        const key = (_a3 = element.getAttribute("data-insert")) == null ? void 0 : _a3.replace(/&quot;/g, '"');
        if (key && SHIFTED_KEYS[key]) {
          element.dataset.shifted = SHIFTED_KEYS[key][0];
          element.dataset.shiftedCommand = JSON.stringify([
            "insertAndUnshiftKeyboardLayer",
            SHIFTED_KEYS[key][1]
          ]);
        }
        let selector = void 0;
        const command = element.getAttribute("data-command");
        if (command) {
          if (/^[a-zA-Z]+$/.test(command))
            selector = command;
          else {
            try {
              selector = JSON.parse(command);
            } catch (e) {
            }
          }
        } else if (element.getAttribute("data-insert")) {
          console.log(
            "insert keycap",
            element.getAttribute("data-insert"),
            "with latex",
            element.getAttribute("data-latex")
          );
          selector = [
            "insert",
            element.getAttribute("data-insert"),
            {
              focus: true,
              feedback: true,
              scrollIntoView: true,
              mode: "math",
              format: "latex",
              resetStyle: true
            }
          ];
        } else if (element.getAttribute("data-latex")) {
          selector = [
            "insert",
            element.getAttribute("data-latex"),
            {
              focus: true,
              feedback: true,
              scrollIntoView: true,
              mode: "math",
              format: "latex",
              resetStyle: true
            }
          ];
        } else {
          console.log("keycap fallback, key = ", element.getAttribute("data-key"));
          selector = [
            "typedText",
            (_b3 = element.getAttribute("data-key")) != null ? _b3 : element.textContent,
            { focus: true, feedback: true, simulateKeystroke: true }
          ];
        }
        if (selector) {
          if (chainedCommand)
            selector = [chainedCommand, selector];
          let handlers = { default: selector };
          const variantsId = element.getAttribute("data-variants");
          if (variantsId) {
            handlers = {
              default: selector,
              pressAndHold: ["showVariantsPanel", variantsId]
            };
          }
          attachButtonHandlers(
            element,
            (command2) => {
              if (Array.isArray(command2)) {
                if (command2[0] === "showVariantsPanel")
                  return showVariantsPanel(element, variantsId);
              }
              return keyboard.executeCommand(command2);
            },
            handlers
          );
        }
      }
    }
    function expandLayerMarkup(options, layer) {
      var _a3, _b3, _c2, _d2;
      const ROWS = {
        // First row should be 10 key wide
        // Second row should be 10 key wide
        // Third row should be 8.5 key wide
        // One row should have ^ (shift key) which is 1.5 key wide
        // One row should have ~ (delete key) which is .5 or 1.5 key wide
        qwerty: {
          "lower-1": "qwertyuiop",
          "lower-2": " asdfghjkl ",
          "lower-3": "^zxcvbnm~",
          "upper-1": "QWERTYUIOP",
          "upper-2": " ASDFGHJKL ",
          "upper-3": "^ZXCVBNM~",
          "numpad-1": "789/",
          "numpad-2": "456*",
          "numpad-3": "123-",
          "numpad-4": "0.=+"
        },
        azerty: {
          "lower-1": "azertyuiop",
          "lower-2": "qsdfghjklm",
          "lower-3": "^ wxcvbn ~",
          "upper-1": "AZERTYUIOP",
          "upper-2": "QSDFGHJKLM",
          "upper-3": "^ WXCVBN ~"
        },
        qwertz: {
          "lower-1": "qwertzuiop",
          "lower-2": " asdfghjkl ",
          "lower-3": "^yxcvbnm~",
          "upper-1": "QWERTZUIOP",
          "upper-2": " ASDFGHJKL",
          "upper-3": "^YXCVBNM~"
        },
        dvorak: {
          "lower-1": "^  pyfgcrl ",
          "lower-2": "aoeuidhtns",
          "lower-3": "qjkxbmwvz~",
          "upper-1": "^  PYFGCRL ",
          "upper-2": "AOEUIDHTNS",
          "upper-3": "QJKXBMWVZ~"
        },
        colemak: {
          "lower-1": " qwfpgjluy ",
          "lower-2": "arstdhneio",
          "lower-3": "^zxcvbkm~",
          "upper-1": " QWFPGNLUY ",
          "upper-2": "ARSTDHNEIO",
          "upper-3": "^ZXCVBKM~"
        }
      };
      let layoutName = options.alphabeticLayout;
      if (layoutName === "auto") {
        const activeLayout = getActiveKeyboardLayout();
        if (activeLayout)
          layoutName = activeLayout.virtualLayout;
        if (!layoutName || layoutName === "auto") {
          layoutName = (_a3 = {
            fr: "azerty",
            be: "azerty",
            al: "qwertz",
            ba: "qwertz",
            cz: "qwertz",
            de: "qwertz",
            hu: "qwertz",
            sk: "qwertz",
            ch: "qwertz"
          }[l10n.locale.slice(0, 2)]) != null ? _a3 : "qwerty";
        }
      }
      const layout = (_b3 = ROWS[layoutName]) != null ? _b3 : ROWS.qwerty;
      let result = layer;
      let row;
      result = result.replace(
        /<arrows\/>/g,
        `
        <li class='action' data-command='["performWithFeedback","moveToPreviousChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-left" /></svg>'
            data-shifted-command='["performWithFeedback","extendToPreviousChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-left' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","moveToNextChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-right" /></svg>'
            data-shifted-command='["performWithFeedback","extendToNextChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-right' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","commit"]'>
        <svg class="svg-glyph"><use xlink:href='#svg-commit' /></svg></li>`
      );
      let m = result.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
      while (m) {
        row = "";
        const attributesArray = m[2].match(/[a-zA-Z][a-zA-Z\d-]*=(['"])(.*?)\1/g);
        const attributes = {};
        if (attributesArray) {
          for (const attribute of attributesArray) {
            const m2 = attribute.match(/([a-zA-Z][a-zA-Z\d-]*)=(['"])(.*?)\2/);
            if (m2)
              attributes[m2[1]] = m2[3];
          }
        }
        let keys = layout[attributes.name];
        if (!keys)
          keys = ROWS.qwerty[attributes.name];
        if (!keys) {
          console.error(
            `MathLive 0.90.9: Unknown roman keyboard row:`,
            attributes.name
          );
        } else {
          for (const c of keys) {
            let cls = (_c2 = attributes.class) != null ? _c2 : "";
            if (cls)
              cls = ` ${cls}`;
            if (c === "~") {
              row += `<li class='action font-glyph bottom right `;
              row += keys.length - (keys.match(/ /g) || []).length / 2 === 10 ? "" : "w15";
              row += `' data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                        data-shifted-command='"deleteAll"'
                        data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
                        ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>`;
            } else if (c === " ") {
              row += "<li class='separator w5'></li>";
            } else if (c === "^") {
              row += `<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='` + attributes["shift-layer"] + `'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>`;
            } else if (c === "/")
              row += `<li class="MLK__keycap big-op ${cls}" data-variants="/" data-insert='\\frac{#@}{#?}'>&divide;</li>`;
            else if (c === "*")
              row += `<li class="MLK__keycap big-op ${cls}" data-variants="*" data-insert='\\times '>&times;</li>`;
            else if (c === "-")
              row += `<li class="MLK__keycap  big-op ${cls}" data-variants="-" data-key='-'>&#x2212;</li>`;
            else if (c === ".") {
              row += "<li class='MLK__keycap big-op " + cls + `' data-variants='.' data-command='"insertDecimalSeparator"'>` + ((_d2 = options["decimalSeparator"]) != null ? _d2 : ".") + "</li>";
            } else if (c === "+")
              row += `<li class="MLK__keycap big-op ${cls}" data-variants="+" data-key="+">+</li>`;
            else if (c === "=")
              row += `<li class="MLK__keycap big-op ${cls}" data-variants="=" data-key="=">=</li>`;
            else
              row += `<li class="MLK__keycap ${cls}" data-variants="${c}">${c}</li>`;
          }
        }
        result = result.replace(new RegExp(m[1] + m[2] + m[3]), row);
        m = result.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
      }
      return result;
    }
    var gCoreStylesheet;
    var gVirtualKeyboardStylesheet;
    var gVirtualKeyboardStylesheetHash;
    function injectStylesheets() {
      if (!gVirtualKeyboardStylesheet) {
        if (!gVirtualKeyboardStylesheetHash) {
          gVirtualKeyboardStylesheetHash = hashCode(
            virtual_keyboard_default
          ).toString(36);
        }
        gVirtualKeyboardStylesheet = inject2(
          null,
          virtual_keyboard_default,
          gVirtualKeyboardStylesheetHash
        );
      }
      if (!gCoreStylesheet) {
        gCoreStylesheet = inject2(
          null,
          core_default,
          hashCode(core_default).toString(36)
        );
        void loadFonts();
      }
    }
    function releaseStylesheets() {
      gCoreStylesheet == null ? void 0 : gCoreStylesheet.release();
      gCoreStylesheet = null;
      gVirtualKeyboardStylesheet == null ? void 0 : gVirtualKeyboardStylesheet.release();
      gVirtualKeyboardStylesheet = null;
    }
    var SVG_ICONS = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">

<symbol id="svg-delete-backward" viewBox="0 0 576 512">
  <path d="M432.1 208.1L385.9 256L432.1 303C442.3 312.4 442.3 327.6 432.1 336.1C423.6 346.3 408.4 346.3 399 336.1L352 289.9L304.1 336.1C295.6 346.3 280.4 346.3 271 336.1C261.7 327.6 261.7 312.4 271 303L318.1 256L271 208.1C261.7 199.6 261.7 184.4 271 175C280.4 165.7 295.6 165.7 304.1 175L352 222.1L399 175C408.4 165.7 423.6 165.7 432.1 175C442.3 184.4 442.3 199.6 432.1 208.1V208.1zM512 64C547.3 64 576 92.65 576 128V384C576 419.3 547.3 448 512 448H205.3C188.3 448 172 441.3 160 429.3L9.372 278.6C3.371 272.6 0 264.5 0 256C0 247.5 3.372 239.4 9.372 233.4L160 82.75C172 70.74 188.3 64 205.3 64L512 64zM528 128C528 119.2 520.8 112 512 112H205.3C201 112 196.9 113.7 193.9 116.7L54.63 256L193.9 395.3C196.9 398.3 201 400 205.3 400H512C520.8 400 528 392.8 528 384V128z"/>
</symbol>

<symbol id="svg-shift" viewBox="0 0 384 512">
  <path d="M2.438 252.3C7.391 264.2 19.06 272 32 272h80v160c0 26.51 21.49 48 48 48h64C250.5 480 272 458.5 272 432v-160H352c12.94 0 24.61-7.797 29.56-19.75c4.953-11.97 2.219-25.72-6.938-34.88l-160-176C208.4 35.13 200.2 32 192 32S175.6 35.13 169.4 41.38l-160 176C.2188 226.5-2.516 240.3 2.438 252.3zM192 86.63L313.4 224H224v208H160V224H70.63L192 86.63z"/>
</symbol>

<symbol id="svg-commit" viewBox="0 0 512 512">
  <path d="M135 432.1l-128-128C2.344 300.3 0 294.2 0 288s2.344-12.28 7.031-16.97l128-128c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L81.94 264H464v-208C464 42.75 474.8 32 488 32S512 42.75 512 56V288c0 13.25-10.75 24-24 24H81.94l87.03 87.03c9.375 9.375 9.375 24.56 0 33.94S144.4 442.3 135 432.1z"/>
</symbol>

<symbol id="svg-command" viewBox="0 0 640 512">
  <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>
</symbol>

<symbol id="svg-undo" viewBox="0 0 512 512">
  <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>
</symbol>
<symbol id="svg-redo" viewBox="0 0 512 512">
  <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>
</symbol>
<symbol id="svg-arrow-left" viewBox="0 0 320 512">
  <path d="M206.7 464.6l-183.1-191.1C18.22 267.1 16 261.1 16 256s2.219-11.97 6.688-16.59l183.1-191.1c9.152-9.594 24.34-9.906 33.9-.7187c9.625 9.125 9.938 24.37 .7187 33.91L73.24 256l168 175.4c9.219 9.5 8.906 24.78-.7187 33.91C231 474.5 215.8 474.2 206.7 464.6z"/>
</symbol>
<symbol id="svg-arrow-right" viewBox="0 0 320 512">
  <path d="M113.3 47.41l183.1 191.1c4.469 4.625 6.688 10.62 6.688 16.59s-2.219 11.97-6.688 16.59l-183.1 191.1c-9.152 9.594-24.34 9.906-33.9 .7187c-9.625-9.125-9.938-24.38-.7187-33.91l168-175.4L78.71 80.6c-9.219-9.5-8.906-24.78 .7187-33.91C88.99 37.5 104.2 37.82 113.3 47.41z"/>
</symbol>
<symbol id="svg-tab" viewBox="0 0 448 512">
  <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>
</symbol>
<symbol id="svg-paste" viewBox="0 0 512 512"><path d="M160 32c11.6 0 21.3 8.2 23.5 19.2C185 58.6 191.6 64 199.2 64H208c8.8 0 16 7.2 16 16V96H96V80c0-8.8 7.2-16 16-16h8.8c7.6 0 14.2-5.4 15.7-12.8C138.7 40.2 148.4 32 160 32zM64 64h2.7C65 69 64 74.4 64 80V96c0 17.7 14.3 32 32 32H224c17.7 0 32-14.3 32-32V80c0-5.6-1-11-2.7-16H256c17.7 0 32 14.3 32 32h32c0-35.3-28.7-64-64-64H210.6c-9-18.9-28.3-32-50.6-32s-41.6 13.1-50.6 32H64C28.7 32 0 60.7 0 96V384c0 35.3 28.7 64 64 64H192V416H64c-17.7 0-32-14.3-32-32V96c0-17.7 14.3-32 32-32zM288 480c-17.7 0-32-14.3-32-32V192c0-17.7 14.3-32 32-32h96v56c0 22.1 17.9 40 40 40h56V448c0 17.7-14.3 32-32 32H288zM416 165.3L474.7 224H424c-4.4 0-8-3.6-8-8V165.3zM448 512c35.3 0 64-28.7 64-64V235.9c0-12.7-5.1-24.9-14.1-33.9l-59.9-59.9c-9-9-21.2-14.1-33.9-14.1H288c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H448z"/></symbol>
<symbol id="svg-cut" viewBox="0 0 512 512"><path d="M485.6 444.2L333.6 314.9C326.9 309.2 326.1 299.1 331.8 292.4C337.5 285.6 347.6 284.8 354.4 290.5L506.4 419.8C513.1 425.5 513.9 435.6 508.2 442.4C502.5 449.1 492.4 449.9 485.6 444.2zM485.7 67.76C492.5 62.07 502.5 62.94 508.2 69.69C513.9 76.45 513.1 86.55 506.3 92.24L208.5 343.1C218.3 359.7 224 379.2 224 400C224 461.9 173.9 512 112 512C50.14 512 0 461.9 0 400C0 338.1 50.14 288 112 288C141.5 288 168.4 299.4 188.4 318.1L262.2 256L188.4 193.9C168.4 212.6 141.5 224 112 224C50.14 224 0 173.9 0 112C0 50.14 50.14 0 112 0C173.9 0 224 50.14 224 112C224 132.8 218.3 152.3 208.5 168.9L287 235.1L485.7 67.76zM32 112C32 156.2 67.82 192 112 192C156.2 192 192 156.2 192 112C192 67.82 156.2 32 112 32C67.82 32 32 67.82 32 112zM112 480C156.2 480 192 444.2 192 400C192 355.8 156.2 320 112 320C67.82 320 32 355.8 32 400C32 444.2 67.82 480 112 480z"/></symbol>
<symbol id="svg-copy" viewBox="0 0 512 512"><path d="M272 416C263.2 416 256 423.2 256 432V448c0 17.67-14.33 32-32 32H64c-17.67 0-32-14.33-32-32V192c0-17.67 14.33-32 32-32h112C184.8 160 192 152.8 192 144C192 135.2 184.8 128 176 128H63.99c-35.35 0-64 28.65-64 64l.0098 256C0 483.3 28.65 512 64 512h160c35.35 0 64-28.65 64-64v-16C288 423.2 280.8 416 272 416zM502.6 86.63l-77.25-77.25C419.4 3.371 411.2 0 402.7 0H288C252.7 0 224 28.65 224 64v256c0 35.35 28.65 64 64 64h160c35.35 0 64-28.65 64-64V109.3C512 100.8 508.6 92.63 502.6 86.63zM416 45.25L466.7 96H416V45.25zM480 320c0 17.67-14.33 32-32 32h-160c-17.67 0-32-14.33-32-32V64c0-17.67 14.33-32 32-32h96l.0026 64c0 17.67 14.33 32 32 32H480V320z"/>
</symbol>
<symbol id="svg-angle-double-right" viewBox="0 0 320 512">
  <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>
</symbol>
<symbol id="svg-angle-double-left" viewBox="0 0 320 512">
  <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>
</symbol>
<symbol id="svg-trash" viewBox="0 0 448 512">
  <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>
</symbol>
<symbol id="svg-keyboard-down" viewBox="0 0 576 512"><path d="M64 48c-8.8 0-16 7.2-16 16V240c0 8.8 7.2 16 16 16H512c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H64zM0 64C0 28.7 28.7 0 64 0H512c35.3 0 64 28.7 64 64V240c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zM159 359c9.4-9.4 24.6-9.4 33.9 0l95 95 95-95c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9L305 505c-4.5 4.5-10.6 7-17 7s-12.5-2.5-17-7L159 393c-9.4-9.4-9.4-24.6 0-33.9zm1-167c0-8.8 7.2-16 16-16H400c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V192zM120 88h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H120c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H200c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H280c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H360c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H440c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16z"/></symbol>
</svg>`;
    function makeKeyboardElement(keyboard) {
      var _a3;
      injectStylesheets();
      const result = document.createElement("div");
      result.className = "ML__keyboard";
      const plate = document.createElement("div");
      plate.className = "MLK__plate";
      plate.innerHTML = MathfieldElement.createHTML(
        SVG_ICONS + keyboard.layouts.map((x, i) => makeLayout(keyboard, x, i)).join("")
      );
      const backdrop = document.createElement("div");
      backdrop.className = "MLK__backdrop";
      backdrop.appendChild(plate);
      result.appendChild(backdrop);
      const toolbars = result.querySelectorAll(".ML__edit-toolbar");
      if (toolbars) {
        for (const toolbar of toolbars) {
          toolbar.addEventListener("click", (ev) => {
            var _a4, _b3;
            let target = ev.target;
            let command = "";
            while (target && !command) {
              command = (_a4 = target == null ? void 0 : target.getAttribute("data-command")) != null ? _a4 : "";
              target = (_b3 = target == null ? void 0 : target.parentElement) != null ? _b3 : null;
            }
            if (command)
              keyboard.executeCommand(JSON.parse(command));
          });
        }
      }
      const keycaps = result.querySelectorAll(
        ".MLK__keycap, .action, .fnbutton, .bigfnbutton"
      );
      for (const keycap of keycaps) {
        keycap.id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      }
      makeKeycap(keyboard, [...keycaps]);
      const elementList = result.querySelectorAll(".layer-switch");
      for (const element of elementList) {
        if (element.classList.contains("shift")) {
          attachButtonHandlers(
            element,
            (command) => keyboard.executeCommand(command),
            {
              // When the modifier is initially pressed, we will shift the labels
              // (if available)
              pressed: "shiftKeyboardLayer",
              // If the key is released before a delay, we switch to the target layer
              default: ["switchKeyboardLayer", element.getAttribute("data-layer")]
            }
          );
        } else {
          attachButtonHandlers(
            element,
            (command) => keyboard.executeCommand(command),
            {
              default: ["switchKeyboardLayer", element.getAttribute("data-layer")]
            }
          );
        }
      }
      const layerElements = result.querySelectorAll(".MLK__layer");
      console.assert(layerElements.length > 0, "No virtual keyboards available");
      for (const x of layerElements)
        x.addEventListener("mousedown", (evt) => evt.preventDefault());
      (_a3 = layerElements[0]) == null ? void 0 : _a3.classList.add("is-visible");
      return result;
    }
    function makeLayout(keyboard, layout, index) {
      const markup = [];
      if (!("layers" in layout))
        return "";
      for (const layer of layout.layers) {
        markup.push(
          `<div tabindex="-1" class="MLK__layer" data-layer="${layer.id}">`
        );
        markup.push(`<div class='MLK__toolbar' role='toolbar'>`);
        markup.push(makeLayoutsToolbar(keyboard, index));
        if (layout.displayEditToolbar)
          markup.push(`<div class="ML__edit-toolbar right"></div>`);
        markup.push(`</div>`);
        markup.push(
          expandLayerMarkup(
            keyboard,
            markupLayer(layer, {
              displayShiftedKeycaps: layout.displayShiftedKeycaps
            })
          )
        );
        markup.push("</div>");
      }
      return markup.join("");
    }
    function markupLayer(layer, options) {
      var _a3, _b3, _c2;
      if (typeof layer === "string")
        return layer;
      let layerMarkup = "";
      if (typeof layer.styles === "string")
        layerMarkup += `<style>${layer.styles}</style>`;
      else if (typeof layer.styles === "object")
        layerMarkup += `<style>${jsonToCss(layer.styles)}</style>`;
      if (layer.backdrop)
        layerMarkup += `<div class='${layer.backdrop}'>`;
      if (layer.container)
        layerMarkup += `<div class='${layer.container}'>`;
      if (layer.rows) {
        layerMarkup += `<div class='MLK__rows'>`;
        for (const row of layer.rows) {
          layerMarkup += `<ul>`;
          for (let keycap of row) {
            layerMarkup += `<li`;
            keycap = expandKeycap(keycap, options);
            let cls = (_a3 = keycap.class) != null ? _a3 : "";
            if (keycap.layer && !/layer-switch/.test(cls))
              cls += " layer-switch";
            if (cls && !/separator/.test(cls))
              cls += " MLK__keycap";
            if (!/\bw[0-9]+\b/.test(cls) && keycap.width) {
              cls += (_b3 = { 0: " w0", 0.5: " w5", 1.5: " w15", 2: " w20", 5: " w50" }[keycap.width]) != null ? _b3 : "";
            }
            layerMarkup += ` class="${cls || "MLK__keycap"}"`;
            if (keycap.key)
              layerMarkup += ` data-key="${keycap.key}"`;
            if (keycap.tooltip)
              layerMarkup += ` data-tooltip="${keycap.tooltip}"`;
            if (keycap.command) {
              if (typeof keycap.command === "string")
                layerMarkup += ` data-command='"${keycap.command}"'`;
              else {
                layerMarkup += ` data-command='`;
                layerMarkup += JSON.stringify(keycap.command);
                layerMarkup += `'`;
              }
            }
            if (keycap.insert)
              layerMarkup += ` data-insert="${keycap.insert}"`;
            if (keycap.latex)
              layerMarkup += ` data-latex="${keycap.latex}"`;
            if (keycap.aside)
              layerMarkup += ` data-aside="${keycap.aside}"`;
            if (keycap.variants) {
              if (typeof keycap.variants !== "string") {
                const keysetId = Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
                setVariants(keysetId, keycap.variants);
                layerMarkup += ` data-variants="${keysetId}"`;
              } else
                layerMarkup += ` data-variants="${keycap.variants}"`;
            }
            if (keycap.shifted)
              layerMarkup += ` data-shifted="${keycap.shifted}"`;
            if (keycap.shiftedCommand)
              layerMarkup += ` data-shifted-command="${keycap.shiftedCommand}"`;
            if (keycap.layer)
              layerMarkup += ` data-layer="${keycap.layer}"`;
            layerMarkup += `>${// eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            keycap.label || latexToMarkup((_c2 = keycap.latex) != null ? _c2 : "")}</li>`;
          }
          layerMarkup += `</ul>`;
        }
        layerMarkup += `</div>`;
      } else if (layer.markup)
        layerMarkup += layer.markup;
      if (layer.container)
        layerMarkup += "</div>";
      if (layer.backdrop)
        layerMarkup += "</div>";
      return layerMarkup;
    }
    var KEYCAP_SHORTCUTS = {
      "[left]": {
        class: "action",
        command: ["performWithFeedback", "moveToPreviousChar"],
        shifted: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-left /></svg>",
        shiftedCommand: ["performWithFeedback", "extendToPreviousChar"],
        label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-left /></svg>"
      },
      "[right]": {
        class: "action",
        command: ["performWithFeedback", "moveToNextChar"],
        shifted: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-right /></svg>",
        shiftedCommand: ["performWithFeedback", "extendToNextChar"],
        label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-right /></svg>"
      },
      "[return]": {
        class: "action",
        command: ["performWithFeedback", "commit"],
        width: 1.5,
        label: "<svg class=svg-glyph><use xlink:href=#svg-commit /></svg>"
      },
      "[hr]": {
        class: "separator horizontal-rule"
      },
      "[hide-keyboard]": {
        class: "action",
        command: ["performWithFeedback", "hideVirtualKeyboard"],
        width: 1.5,
        label: "<svg class=svg-glyph-lg><use xlink:href=#svg-keyboard-down /></svg>"
      },
      "[.]": {
        class: "big-op",
        variants: ".",
        command: "insertDecimalSeparator"
      },
      "[+]": { class: "big-op", variants: "+", latex: "+", label: "+" },
      "[-]": { class: "big-op", variants: "-", latex: "-", label: "&#x2212;" },
      "[/]": {
        class: "big-op",
        variants: "/",
        latex: "\\frac{#@}{#?}",
        label: "&divide;"
      },
      "[*]": {
        class: "big-op",
        variants: "*",
        latex: "\\times",
        label: "&times;"
      },
      "[=]": { class: "big-op", variants: "=", latex: "=", label: "=" },
      "[backspace]": {
        class: "action font-glyph bottom right",
        width: 1.5,
        command: ["performWithFeedback", "deleteBackward"],
        label: "<svg class=svg-glyph><use xlink:href=#svg-delete-backward /></svg>",
        shifted: "<span class=warning><svg class=svg-glyph><use xlink:href=#svg-trash /></svg></span",
        shiftedCommand: "deleteAll",
        variants: "delete"
      },
      "[undo]": {
        class: "ghost",
        command: "undo",
        label: "<svg class=svg-glyph><use xlink:href=#svg-undo /></svg>",
        tooltip: localize("tooltip.undo")
      },
      "[redo]": {
        class: "ghost",
        command: "redo",
        label: "<svg class=svg-glyph><use xlink:href=#svg-redo /></svg>"
      },
      "[(]": { variants: "(", latex: "(" },
      "[)]": { variants: ")", latex: ")" },
      "[0]": { variants: "0", latex: "0", label: "0" },
      "[1]": { variants: "1", latex: "1", label: "1" },
      "[2]": { variants: "2", latex: "2", label: "2" },
      "[3]": { variants: "3", latex: "3", label: "3" },
      "[4]": { variants: "4", latex: "4", label: "4" },
      "[5]": { variants: "5", latex: "5", label: "5" },
      "[6]": { variants: "6", latex: "6", label: "6" },
      "[7]": { variants: "7", latex: "7", label: "7" },
      "[8]": { variants: "8", latex: "8", label: "8" },
      "[9]": { variants: "9", latex: "9", label: "9" },
      "[separator-5]": { class: "separator", width: 0.5 },
      "[separator]": { class: "separator" },
      "[separator-10]": { class: "separator" },
      "[separator-15]": { class: "separator", width: 1.5 },
      "[separator-20]": { class: "separator", width: 2 },
      "[separator-50]": { class: "separator", width: 5 },
      "[shift]": {
        class: "shift modifier font-glyph bottom left layer-switch",
        width: 1.5,
        // layer: attributes['shift-layer'],
        label: "<svg class=svg-glyph><use xlink:href=#svg-shift /></svg>"
      },
      "[foreground-color]": {
        variants: "foreground-color",
        command: ["applyStyle", { color: "red" }],
        label: "<span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'>"
      },
      "[background-color]": {
        variants: "background-color",
        command: ["applyStyle", { backgroundColor: "yellow" }],
        label: "<span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span>"
      }
    };
    function expandKeycap(keycap, options = {}) {
      var _a3;
      if (typeof keycap === "string") {
        if (!KEYCAP_SHORTCUTS[keycap])
          return { latex: keycap };
        keycap = { label: keycap };
      }
      if ("label" in keycap && keycap.label && KEYCAP_SHORTCUTS[keycap.label]) {
        const shortcut = __spreadProps(__spreadValues(__spreadValues({}, KEYCAP_SHORTCUTS[keycap.label]), keycap), {
          label: KEYCAP_SHORTCUTS[keycap.label].label
        });
        if (shortcut.command === "insertDecimalSeparator")
          shortcut.label = (_a3 = MathfieldElement.decimalSeparator) != null ? _a3 : ".";
        if (!options.displayShiftedKeycaps) {
          delete shortcut.shifted;
          delete shortcut.shiftedCommand;
        }
        return shortcut;
      }
      return keycap;
    }
    var VirtualKeyboard = class {
      constructor() {
        this.originalContainerBottomPadding = null;
        var _a3, _b3, _c2;
        this.targetOrigin = window.origin;
        this.originValidator = "none";
        this._alphabeticLayout = "auto";
        this.layouts = ["default"];
        this._actionToolbar = "default";
        this._container = (_b3 = (_a3 = window.document) == null ? void 0 : _a3.body) != null ? _b3 : null;
        this._visible = false;
        this._dirty = true;
        this.observer = new ResizeObserver((_entries) => {
          var _a4, _b4;
          const h = this.boundingRect.height;
          if (this.container === document.body) {
            (_a4 = this._element) == null ? void 0 : _a4.style.setProperty(
              "--keyboard-height",
              `calc(${h}px + env(safe-area-inset-bottom, 0))`
            );
            const keyboardHeight = h - 1;
            this.container.style.paddingBottom = this.originalContainerBottomPadding ? `calc(${this.originalContainerBottomPadding} + ${keyboardHeight}px)` : `${keyboardHeight}px`;
          } else
            (_b4 = this._element) == null ? void 0 : _b4.style.setProperty("--keyboard-height", `${h}px`);
          this.dispatchEvent(new Event("geometrychange"));
          this.sendMessage("geometry-changed", { boundingRect: this.boundingRect });
        });
        this.listeners = {};
        (_c2 = window.top) == null ? void 0 : _c2.addEventListener("message", this);
        document.body.addEventListener("focusin", (event) => {
          var _a4;
          const target = event.target;
          if ((target == null ? void 0 : target.isConnected) && ((_a4 = target.tagName) == null ? void 0 : _a4.toLowerCase()) === "math-field" && isTouchCapable()) {
            const mf = target;
            if (mf.mathVirtualKeyboardPolicy === "auto" && !mf.readOnly)
              this.show();
          }
        });
        document.addEventListener("focusout", () => {
          setTimeout(() => {
            var _a4, _b4, _c3;
            let target = document.activeElement;
            let focusedMathfield = false;
            while (target) {
              if (((_a4 = target.tagName) == null ? void 0 : _a4.toLowerCase()) === "math-field") {
                focusedMathfield = true;
                break;
              }
              target = (_c3 = (_b4 = target.shadowRoot) == null ? void 0 : _b4.activeElement) != null ? _c3 : null;
            }
            if (!focusedMathfield)
              this.hide();
          }, 300);
        });
      }
      get alphabeticLayout() {
        return this._alphabeticLayout;
      }
      set alphabeticLayout(value) {
        this._alphabeticLayout = value;
        this.rebuild();
      }
      get layouts() {
        return this._layouts;
      }
      set layouts(value) {
        const layouts = Array.isArray(value) ? [...value] : [value];
        const defaultIndex = layouts.findIndex((x) => x === "default");
        if (defaultIndex >= 0) {
          layouts.splice(
            defaultIndex,
            1,
            "numeric",
            "functions",
            "symbols",
            "alphabetic",
            "greek"
          );
        }
        this._layouts = layouts.map((x) => normalizeLayout(x));
        this.rebuild();
      }
      get actionToolbar() {
        return this._actionToolbar;
      }
      set actionToolbar(value) {
        this._actionToolbar = value;
        this.rebuild();
      }
      get container() {
        return this._container;
      }
      set container(value) {
        this._container = value;
        this.rebuild();
      }
      static get singleton() {
        if (!this._singleton)
          this._singleton = new VirtualKeyboard();
        return this._singleton;
      }
      addEventListener(type, callback, _options) {
        if (!this.listeners[type])
          this.listeners[type] = /* @__PURE__ */ new Set();
        if (!this.listeners[type].has(callback))
          this.listeners[type].add(callback);
      }
      dispatchEvent(event) {
        if (!this.listeners[event.type] || this.listeners[event.type].size === 0)
          return true;
        this.listeners[event.type].forEach((x) => {
          if (typeof x === "function")
            x(event);
          else
            x == null ? void 0 : x.handleEvent(event);
        });
        return !event.defaultPrevented;
      }
      removeEventListener(type, callback, _options) {
        if (this.listeners[type])
          this.listeners[type].delete(callback);
      }
      get element() {
        return this._element;
      }
      set element(val) {
        var _a3;
        if (this._element === val)
          return;
        (_a3 = this._element) == null ? void 0 : _a3.remove();
        this._element = val;
      }
      get visible() {
        return this._visible;
      }
      set visible(val) {
        if (val)
          this.show();
        else
          this.hide();
      }
      get boundingRect() {
        var _a3;
        if (!this._visible)
          return new DOMRect();
        const plate = (_a3 = this._element) == null ? void 0 : _a3.getElementsByClassName("MLK__plate")[0];
        if (plate)
          return plate.getBoundingClientRect();
        return new DOMRect();
      }
      rebuild() {
        var _a3;
        if (this._dirty || !this._element)
          return;
        this._dirty = true;
        let currentLayoutId = "";
        const currentLayout2 = this._element.querySelector(".MLK__layer.is-visible");
        if (currentLayout2)
          currentLayoutId = (_a3 = currentLayout2.getAttribute("data-layer")) != null ? _a3 : "";
        requestAnimationFrame(() => {
          var _a4;
          this._dirty = false;
          if (this._element) {
            this._element.remove();
            this._element = void 0;
          }
          if (this.visible) {
            this.buildAndAttachElement();
            const newActive = this.element.querySelector(
              `.MLK__layer[data-layer="${currentLayoutId}"]`
            );
            if (newActive) {
              (_a4 = this.element.querySelector(
                ".MLK__layer.is-visible"
              )) == null ? void 0 : _a4.classList.remove("is-visible");
              newActive.classList.add("is-visible");
            }
            this.element.classList.add("is-visible");
          }
        });
      }
      show() {
        if (this._visible)
          return;
        const container = this.container;
        if (!container)
          return;
        if (!this.stateWillChange(true))
          return;
        if (!this._element)
          this.buildAndAttachElement();
        if (!this._visible) {
          const plate = this._element.getElementsByClassName(
            "MLK__plate"
          )[0];
          if (plate)
            this.observer.observe(plate);
          if (container === window.document.body) {
            const padding = container.style.paddingBottom;
            this.originalContainerBottomPadding = padding;
            const keyboardHeight = plate.offsetHeight - 1;
            container.style.paddingBottom = padding ? `calc(${padding} + ${keyboardHeight}px)` : `${keyboardHeight}px`;
          }
          window.addEventListener("mouseup", this);
          window.addEventListener("blur", this);
        }
        requestAnimationFrame(() => {
          var _a3;
          (_a3 = this._element) == null ? void 0 : _a3.classList.add("is-visible");
          this.focus();
          this._visible = true;
          this.stateChanged();
        });
      }
      hide() {
        var _a3;
        const container = this.container;
        if (!container)
          return;
        if (!this._visible)
          return;
        if (!this.stateWillChange(false))
          return;
        if (this._element) {
          const plate = this._element.getElementsByClassName("MLK__plate")[0];
          if (plate)
            this.observer.unobserve(plate);
          window.removeEventListener("mouseup", this);
          window.removeEventListener("blur", this);
          hideVariantsPanel();
          this._visible = false;
          releaseStylesheets();
          (_a3 = this._element) == null ? void 0 : _a3.remove();
          this._element = void 0;
          if (this.originalContainerBottomPadding !== null)
            container.style.paddingBottom = this.originalContainerBottomPadding;
        }
        this._visible = false;
        this.stateChanged();
      }
      get height() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.element) == null ? void 0 : _a3.offsetHeight) != null ? _b3 : 0;
      }
      buildAndAttachElement() {
        var _a3;
        console.assert(!this.element);
        this.element = makeKeyboardElement(this);
        on(this.element, "mousedown", () => this.focus());
        (_a3 = this.container) == null ? void 0 : _a3.appendChild(this.element);
      }
      handleEvent(evt) {
        if (isVirtualKeyboardMessage(evt)) {
          if (!validateOrigin(evt.origin, this.originValidator)) {
            throw new DOMException(
              `Message from unknown origin (${evt.origin}) cannot be handled`,
              "SecurityError"
            );
          }
          const { action } = evt.data;
          if (action === "execute-command") {
            const { command } = evt.data;
            this.connectedMathfieldWindow = evt.source;
            const commandTarget = getCommandTarget(command);
            if (commandTarget !== "virtual-keyboard" && window === window.parent)
              return;
            this.executeCommand(command);
            return;
          }
          if (action === "connect") {
            this.connectedMathfieldWindow = evt.source;
            return;
          }
          if (action === "disconnect") {
            this.connectedMathfieldWindow = void 0;
            return;
          }
          if (action === "show") {
            this.connectedMathfieldWindow = evt.source;
            this.show();
            return;
          }
          if (action === "hide") {
            this.connectedMathfieldWindow = evt.source;
            this.hide();
            return;
          }
          if (action === "update-setting") {
            if (evt.data.alphabeticLayout)
              this.alphabeticLayout = evt.data.alphabeticLayout;
            if (evt.data.layouts)
              this.layouts = evt.data.layouts;
            if (evt.data.actionToolbar)
              this.actionToolbar = evt.data.actionToolbar;
            return;
          }
          if (action === "proxy-created") {
            this.sendMessage("synchronize-proxy", {
              boundingRect: this.boundingRect,
              alphabeticLayout: this._alphabeticLayout,
              layouts: this._layouts,
              actionToolbar: this._actionToolbar
            });
            return;
          }
        }
        if (!this._element)
          return;
        switch (evt.type) {
          case "mouseup":
          case "blur":
            document.body.style.userSelect = "";
            unshiftKeyboardLayer();
            break;
        }
      }
      sendMessage(action, payload = {}) {
        var _a3;
        (_a3 = this.connectedMathfieldWindow) == null ? void 0 : _a3.postMessage(
          __spreadValues({
            type: VIRTUAL_KEYBOARD_MESSAGE,
            action
          }, payload),
          this.targetOrigin
        );
      }
      stateWillChange(visible) {
        const defaultNotPrevented = this.dispatchEvent(
          new CustomEvent("before-virtual-keyboard-toggle", {
            detail: { visible },
            bubbles: true,
            cancelable: true,
            composed: true
          })
        );
        return defaultNotPrevented;
      }
      stateChanged() {
        this.dispatchEvent(new Event("virtual-keyboard-toggle"));
        this.sendMessage("geometry-changed", {
          boundingRect: this.boundingRect
        });
      }
      /**
       * @category Focus
       */
      focus() {
        this.sendMessage("focus");
      }
      /**
       * @category Focus
       */
      blur() {
        this.sendMessage("blur");
      }
      updateToolbar(mf) {
        var _a3;
        const toolbars = (_a3 = this._element) == null ? void 0 : _a3.querySelectorAll(".ML__edit-toolbar");
        if (!toolbars)
          return;
        for (const toolbar of toolbars)
          toolbar.innerHTML = makeActionToolbar(this, mf);
      }
      connect() {
        this.connectedMathfieldWindow = window;
      }
      disconnect() {
        this.connectedMathfieldWindow = void 0;
      }
      executeCommand(command) {
        let selector;
        let args = [];
        if (isArray2(command)) {
          selector = command[0];
          args = command.slice(1);
        } else
          selector = command;
        selector = selector.replace(
          /-\w/g,
          (m) => m[1].toUpperCase()
        );
        if (getCommandTarget(command) === "virtual-keyboard")
          return COMMANDS[selector].fn(...args);
        this.sendMessage("execute-command", { command });
        return false;
      }
      dispose() {
        window.removeEventListener("mouseup", this);
        window.removeEventListener("blur", this);
        window.removeEventListener("message", this);
      }
    };
    if (isBrowser() && !("mathVirtualKeyboard" in window)) {
      if (window === window["top"]) {
        const kbd = VirtualKeyboard.singleton;
        Object.defineProperty(window, "mathVirtualKeyboard", {
          get: () => kbd
        });
      } else {
        Object.defineProperty(window, "mathVirtualKeyboard", {
          get: () => VirtualKeyboardProxy.singleton
        });
      }
    }
    function selectionDidChange(model) {
      var _a3;
      if (typeof ((_a3 = model.listeners) == null ? void 0 : _a3.onSelectionDidChange) === "function" && !model.suppressChangeNotifications) {
        model.suppressChangeNotifications = true;
        model.listeners.onSelectionDidChange(model);
        model.suppressChangeNotifications = false;
      }
      window.mathVirtualKeyboard.updateToolbar(makeProxy(model.mathfield));
    }
    function contentWillChange(model, options = {}) {
      var _a3;
      if (model.suppressChangeNotifications || !model.mathfield.host)
        return true;
      model.suppressChangeNotifications = true;
      const result = model.mathfield.host.dispatchEvent(
        new InputEvent("beforeinput", __spreadProps(__spreadValues({}, options), {
          // To work around a bug in WebKit/Safari (the inputType property gets stripped), include the inputType as the 'data' property. (see #1843)
          data: options.data ? options.data : (_a3 = options.inputType) != null ? _a3 : "",
          cancelable: true,
          bubbles: true,
          composed: true
        }))
      );
      model.suppressChangeNotifications = false;
      return result;
    }
    function contentDidChange(model, options) {
      var _a3;
      if (model.suppressChangeNotifications || !model.mathfield.host)
        return;
      model.suppressChangeNotifications = true;
      model.mathfield.host.dispatchEvent(
        new InputEvent("input", __spreadProps(__spreadValues({}, options), {
          // To work around a bug in WebKit/Safari (the inputType property gets stripped), include the inputType as the 'data' property. (see #1843)
          data: options.data ? options.data : (_a3 = options.inputType) != null ? _a3 : "",
          bubbles: true,
          composed: true
        }))
      );
      model.suppressChangeNotifications = false;
    }
    var LatexModeEditor = class extends ModeEditor {
      constructor() {
        super("latex");
      }
      createAtom(command, context, _style) {
        return new LatexAtom(command, context);
      }
      onPaste(mathfield, data) {
        var _a3;
        if (!data)
          return false;
        const text = typeof data === "string" ? data : (_a3 = data.getData("text/x-latex")) != null ? _a3 : data.getData("text/plain");
        if (text && contentWillChange(mathfield.model, {
          inputType: "insertFromPaste",
          data: text
        })) {
          mathfield.snapshot();
          if (this.insert(mathfield.model, text)) {
            contentDidChange(mathfield.model, { inputType: "insertFromPaste" });
            requestUpdate(mathfield);
          }
          return true;
        }
        return false;
      }
      insert(model, text, options) {
        if (!contentWillChange(model, { data: text, inputType: "insertText" }))
          return false;
        if (!options)
          options = {};
        if (!options.insertionMode)
          options.insertionMode = "replaceSelection";
        if (!options.selectionMode)
          options.selectionMode = "placeholder";
        const { suppressChangeNotifications } = model;
        if (options.suppressChangeNotifications)
          model.suppressChangeNotifications = true;
        const savedSuppressChangeNotifications = model.suppressChangeNotifications;
        model.suppressChangeNotifications = true;
        if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
          model.deleteAtoms(range(model.selection));
        else if (options.insertionMode === "replaceAll") {
          model.root.setChildren([], "body");
          model.position = 0;
        } else if (options.insertionMode === "insertBefore")
          model.collapseSelection("backward");
        else if (options.insertionMode === "insertAfter")
          model.collapseSelection("forward");
        const newAtoms = [];
        for (const c of text) {
          if (COMMAND_MODE_CHARACTERS.test(c))
            newAtoms.push(new LatexAtom(c, model.mathfield));
        }
        let cursor = model.at(model.position);
        if (cursor instanceof LatexGroupAtom)
          cursor = cursor.lastChild;
        if (!(cursor.parent instanceof LatexGroupAtom)) {
          const group = new LatexGroupAtom("", model.mathfield);
          cursor.parent.addChildAfter(group, cursor);
          cursor = group.firstChild;
        }
        const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
        model.suppressChangeNotifications = savedSuppressChangeNotifications;
        if (options.selectionMode === "before")
          ;
        else if (options.selectionMode === "item")
          model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
        else if (lastNewAtom)
          model.position = model.offsetOf(lastNewAtom);
        contentDidChange(model, { data: text, inputType: "insertText" });
        model.suppressChangeNotifications = suppressChangeNotifications;
        return true;
      }
    };
    function getLatexGroup(model) {
      return model.atoms.find((x) => x instanceof LatexGroupAtom);
    }
    function getLatexGroupBody(model) {
      var _a3, _b3;
      const atom = model.atoms.find((x) => x instanceof LatexGroupAtom);
      if (!atom)
        return [];
      return (_b3 = (_a3 = atom.body) == null ? void 0 : _a3.filter((x) => x instanceof LatexAtom)) != null ? _b3 : [];
    }
    function getCommandSuggestionRange(model, options) {
      var _a3;
      let start = 0;
      let found = false;
      const last = Number.isFinite(options == null ? void 0 : options.before) ? (_a3 = options == null ? void 0 : options.before) != null ? _a3 : 0 : model.lastOffset;
      while (start <= last && !found) {
        const atom = model.at(start);
        found = atom instanceof LatexAtom && atom.isSuggestion;
        if (!found)
          start++;
      }
      if (!found)
        return [void 0, void 0];
      let end = start;
      let done = false;
      while (end <= last && !done) {
        const atom = model.at(end);
        done = !(atom instanceof LatexAtom && atom.isSuggestion);
        if (!done)
          end++;
      }
      return [start - 1, end - 1];
    }
    new LatexModeEditor();
    function removeSuggestion(mathfield) {
      const group = getLatexGroupBody(mathfield.model).filter(
        (x) => x.isSuggestion
      );
      if (group.length === 0)
        return;
      mathfield.model.position = mathfield.model.offsetOf(group[0].leftSibling);
      for (const atom of group)
        atom.parent.removeChild(atom);
    }
    function updateAutocomplete(mathfield, options) {
      var _a3;
      const { model } = mathfield;
      removeSuggestion(mathfield);
      for (const atom2 of getLatexGroupBody(model))
        atom2.isError = false;
      if (!model.selectionIsCollapsed) {
        hidePopover(mathfield);
        return;
      }
      const command = [];
      let atom = model.at(model.position);
      while (atom && atom instanceof LatexAtom && /^[a-zA-Z\*]$/.test(atom.value))
        atom = atom.leftSibling;
      if (atom && atom instanceof LatexAtom && atom.value === "\\") {
        command.push(atom);
        atom = atom.rightSibling;
        while (atom && atom instanceof LatexAtom && /^[a-zA-Z\*]$/.test(atom.value)) {
          command.push(atom);
          atom = atom.rightSibling;
        }
      }
      const commandString = command.map((x) => x.value).join("");
      const suggestions = commandString ? suggest(mathfield, commandString) : [];
      if (suggestions.length === 0) {
        if (/^\\[a-zA-Z\*]+$/.test(commandString)) {
          command.forEach((x) => {
            x.isError = true;
          });
        }
        hidePopover(mathfield);
        return;
      }
      mathfield.suggestionIndex = (_a3 = options == null ? void 0 : options.atIndex) != null ? _a3 : 0;
      if (mathfield.suggestionIndex < 0)
        mathfield.suggestionIndex = suggestions.length - 1;
      const suggestion = suggestions[mathfield.suggestionIndex % suggestions.length];
      if (suggestion !== commandString) {
        const lastAtom = command[command.length - 1];
        lastAtom.parent.addChildrenAfter(
          [...suggestion.slice(commandString.length - suggestion.length)].map(
            (x) => new LatexAtom(x, mathfield, { isSuggestion: true })
          ),
          lastAtom
        );
        requestUpdate(mathfield);
      }
      showPopover(mathfield, suggestions);
    }
    function acceptCommandSuggestion(model) {
      const [from, to] = getCommandSuggestionRange(model, {
        before: model.position
      });
      if (from === void 0 || to === void 0)
        return false;
      let result = false;
      model.getAtoms([from, to]).forEach((x) => {
        if (x.isSuggestion) {
          x.isSuggestion = false;
          result = true;
        }
      });
      return result;
    }
    function complete(mathfield, completion = "accept", options) {
      var _a3, _b3;
      hidePopover(mathfield);
      const latexGroup = getLatexGroup(mathfield.model);
      if (!latexGroup)
        return false;
      if (completion === "accept-suggestion") {
        const suggestions = getLatexGroupBody(mathfield.model).filter(
          (x) => x.isSuggestion
        );
        if (suggestions.length === 0)
          return false;
        for (const suggestion of suggestions)
          suggestion.isSuggestion = false;
        mathfield.model.position = mathfield.model.offsetOf(
          suggestions[suggestions.length - 1]
        );
        return true;
      }
      const body = getLatexGroupBody(mathfield.model).filter(
        (x) => !x.isSuggestion
      );
      const latex = body.map((x) => x.value).join("");
      const newPos = latexGroup.leftSibling;
      latexGroup.parent.removeChild(latexGroup);
      mathfield.model.position = mathfield.model.offsetOf(newPos);
      mathfield.mode = (_a3 = options == null ? void 0 : options.mode) != null ? _a3 : "math";
      if (completion === "reject")
        return true;
      ModeEditor.insert("math", mathfield.model, latex, {
        selectionMode: ((_b3 = options == null ? void 0 : options.selectItem) != null ? _b3 : false) ? "item" : "placeholder",
        format: "latex"
      });
      mathfield.snapshot();
      mathfield.model.announce("replacement");
      return true;
    }
    var POPOVER_STYLESHEET_HASH = void 0;
    var gPopoverStylesheet = null;
    var gCoreStylesheet2 = null;
    function latexToMarkup2(mf, latex) {
      const root = new Atom("root", mf);
      root.body = parseLatex(latex, mf, { parseMode: "math" });
      const context = new Context(
        { registers: mf.registers },
        { fontSize: DEFAULT_FONT_SIZE },
        "displaystyle"
      );
      const box = coalesce(
        adjustInterAtomSpacing(
          new Box(root.render(context), { classes: "ML__base" }),
          context
        )
      );
      return makeStruts(box, { classes: "ML__mathlive" }).toMarkup();
    }
    function showPopover(mf, suggestions) {
      if (suggestions.length === 0 || mf.options.popoverPolicy === "off") {
        hidePopover(mf);
        return;
      }
      suggestions = suggestions.slice(0, 10);
      let template = "<ul>";
      for (const suggestion of suggestions) {
        const command = suggestion;
        const commandMarkup = latexToMarkup2(mf, suggestion);
        const keybinding = getKeybindingsForCommand(mf.keybindings, command).join(
          "<br>"
        );
        template += `<li role="button" data-command="${command}"><span class="ML__popover__latex">${command}</span><span class="ML__popover__command">${commandMarkup}</span>`;
        if (keybinding)
          template += `<span class="ML__popover__keybinding">${keybinding}</span>`;
        template += "</li>";
      }
      template += "</ul>";
      mf.popover = createPopover(mf, template);
      const elements = mf.popover.querySelectorAll("ul li");
      for (const element of elements) {
        element.addEventListener("pointerdown", (ev) => ev.preventDefault());
        element.addEventListener("click", (_ev) => {
          complete(mf, "reject");
          ModeEditor.insert("math", mf.model, element.dataset.command, {
            selectionMode: "placeholder",
            format: "latex"
          });
          mf.dirty = true;
          mf.scrollIntoView();
          mf.focus();
        });
      }
      setTimeout(() => {
        const caretPoint = getCaretPoint(mf.field);
        if (caretPoint)
          setPopoverPosition(mf, caretPoint);
        if (mf.popover) {
          mf.popover.classList.add("is-visible");
          mf.popoverVisible = true;
        }
      }, 32);
    }
    function updatePopoverPosition(mf, options) {
      var _a3;
      if (!mf.element || mf.element.mathfield !== mf)
        return;
      if (!mf.popover || !mf.popoverVisible)
        return;
      if (options == null ? void 0 : options.deferred) {
        setTimeout(() => updatePopoverPosition(mf), 100);
        return;
      }
      if (((_a3 = mf.model.at(mf.model.position)) == null ? void 0 : _a3.type) !== "latex")
        hidePopover(mf);
      else {
        const caretPoint = getCaretPoint(mf.field);
        if (caretPoint)
          setPopoverPosition(mf, caretPoint);
      }
    }
    function setPopoverPosition(mf, position) {
      throwIfNotInBrowser();
      if (!mf.popover || !mf.popoverVisible)
        return;
      const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
      const screenWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
      const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
      const scrollbarHeight = window.innerHeight - document.documentElement.clientHeight;
      const virtualkeyboardHeight = window.mathVirtualKeyboard.boundingRect.height;
      if (position.x + mf.popover.offsetWidth / 2 > screenWidth - scrollbarWidth) {
        mf.popover.style.left = `${screenWidth - mf.popover.offsetWidth - scrollbarWidth}px`;
      } else if (position.x - mf.popover.offsetWidth / 2 < 0)
        mf.popover.style.left = "0";
      else
        mf.popover.style.left = `${position.x - mf.popover.offsetWidth / 2}px`;
      if (position.y + mf.popover.offsetHeight + 5 > screenHeight - scrollbarHeight - virtualkeyboardHeight) {
        mf.popover.classList.add("ML__popover--reverse-direction");
        mf.popover.style.top = `${position.y - position.height - mf.popover.offsetHeight - 5}px`;
      } else {
        mf.popover.classList.remove("ML__popover--reverse-direction");
        mf.popover.style.top = `${position.y + 5}px`;
      }
    }
    function hidePopover(mf) {
      mf.suggestionIndex = 0;
      mf.popoverVisible = false;
      if (mf.popover) {
        mf.popover.classList.remove("is-visible");
        mf.popover.innerHTML = "";
      }
    }
    function createPopover(mf, html) {
      if (mf.popover) {
        mf.popover.innerHTML = window.MathfieldElement.createHTML(html);
        return mf.popover;
      }
      mf.popover = getSharedElement("mathlive-popover-panel");
      if (POPOVER_STYLESHEET_HASH === void 0)
        POPOVER_STYLESHEET_HASH = hashCode(popover_default).toString(36);
      gPopoverStylesheet = inject2(
        null,
        popover_default,
        POPOVER_STYLESHEET_HASH
      );
      gCoreStylesheet2 = inject2(
        null,
        core_default,
        hashCode(core_default).toString(36)
      );
      mf.popover.innerHTML = window.MathfieldElement.createHTML(html);
      return mf.popover;
    }
    function disposePopover(mf) {
      releaseSharedElement(mf.popover);
      if (gPopoverStylesheet)
        gPopoverStylesheet.release();
      if (gCoreStylesheet2)
        gCoreStylesheet2.release();
      delete mf.popover;
    }
    function hash(latex) {
      let result = 0;
      for (let i = 0; i < latex.length; i++) {
        result = result * 31 + latex.charCodeAt(i);
        result = result | 0;
      }
      return Math.abs(result);
    }
    function requestUpdate(mathfield, options) {
      if (mathfield.dirty)
        return;
      mathfield.dirty = true;
      requestAnimationFrame(() => {
        if (isValidMathfield(mathfield) && mathfield.dirty) {
          mathfield.atomBoundsCache = /* @__PURE__ */ new Map();
          render(mathfield, options);
          mathfield.atomBoundsCache = void 0;
        }
      });
    }
    function makeBox(mathfield, renderOptions) {
      var _a3;
      renderOptions = renderOptions != null ? renderOptions : {};
      const context = new Context(
        {
          registers: mathfield.registers,
          atomIdsSettings: {
            // Using the hash as a seed for the ID
            // keeps the IDs the same until the content of the field changes.
            seed: renderOptions.forHighlighting ? hash(
              Atom.serialize(mathfield.model.root, {
                expandMacro: false,
                defaultMode: mathfield.options.defaultMode
              })
            ) : "random",
            // The `groupNumbers` flag indicates that extra boxes should be generated
            // to represent group of atoms, for example, a box to group
            // consecutive digits to represent a number.
            groupNumbers: (_a3 = renderOptions.forHighlighting) != null ? _a3 : false
          }
        },
        {
          fontSize: DEFAULT_FONT_SIZE,
          letterShapeStyle: mathfield.options.letterShapeStyle
        },
        mathfield.options.defaultMode === "inline-math" ? "textstyle" : "displaystyle"
      );
      const base = mathfield.model.root.render(context);
      const wrapper = makeStruts(adjustInterAtomSpacing(base, context), {
        classes: mathfield.hasEditablePrompts ? "ML__mathlive ML__prompting" : "ML__mathlive",
        attributes: {
          // Sometimes Google Translate kicks in an attempts to 'translate' math
          // This doesn't work very well, so turn off translate
          "translate": "no",
          // Hint to screen readers to not attempt to read this <span>.
          // They should use instead the 'aria-label' attribute.
          "aria-hidden": "true"
        }
      });
      return wrapper;
    }
    function contentMarkup(mathfield, renderOptions) {
      const { model } = mathfield;
      model.root.caret = "";
      model.root.isSelected = false;
      model.root.containsCaret = true;
      for (const atom of model.atoms) {
        atom.caret = "";
        atom.isSelected = false;
        atom.containsCaret = false;
      }
      const hasFocus = mathfield.isSelectionEditable && mathfield.hasFocus();
      if (model.selectionIsCollapsed)
        model.at(model.position).caret = hasFocus ? mathfield.mode : "";
      else {
        const atoms = model.getAtoms(model.selection, { includeChildren: true });
        for (const atom of atoms)
          atom.isSelected = true;
      }
      if (hasFocus) {
        let ancestor = model.at(model.position).parent;
        while (ancestor) {
          ancestor.containsCaret = true;
          ancestor = ancestor.parent;
        }
      }
      const box = makeBox(mathfield, renderOptions);
      return window.MathfieldElement.createHTML(box.toMarkup());
    }
    function render(mathfield, renderOptions) {
      var _a3;
      if (!isValidMathfield(mathfield))
        return;
      renderOptions != null ? renderOptions : renderOptions = {};
      const toggle = (_a3 = mathfield.element) == null ? void 0 : _a3.querySelector(
        "[part=virtual-keyboard-toggle]"
      );
      if (toggle)
        toggle.style.display = mathfield.hasEditableContent ? "flex" : "none";
      const field = mathfield.field;
      const hasFocus = mathfield.isSelectionEditable && mathfield.hasFocus();
      const isFocused = field.classList.contains("ML__focused");
      if (isFocused && !hasFocus)
        field.classList.remove("ML__focused");
      else if (!isFocused && hasFocus)
        field.classList.add("ML__focused");
      field.innerHTML = contentMarkup(mathfield, renderOptions);
      mathfield.fieldContent = field.getElementsByClassName(
        "ML__mathlive"
      )[0];
      renderSelection(mathfield, renderOptions.interactive);
      mathfield.dirty = false;
    }
    function renderSelection(mathfield, interactive) {
      const field = mathfield.field;
      if (!field)
        return;
      for (const element of field.querySelectorAll(
        ".ML__selection, .ML__contains-highlight"
      ))
        element.remove();
      if (!mathfield.hasFocus())
        return;
      if (!(interactive != null ? interactive : false) && gFontsState !== "error" && gFontsState !== "ready") {
        setTimeout(() => {
          if (gFontsState === "ready")
            renderSelection(mathfield);
          else
            setTimeout(() => renderSelection(mathfield), 128);
        }, 32);
      }
      const model = mathfield.model;
      const supposedWidth = parseFloat(getComputedStyle(field).width);
      const actualWidth = field.getBoundingClientRect().width;
      let scaleFactor = actualWidth / supposedWidth;
      scaleFactor = isNaN(scaleFactor) ? 1 : scaleFactor;
      if (model.selectionIsCollapsed) {
        setTimeout(() => updatePopoverPosition(mathfield), 32);
        let atom = model.at(model.position);
        while (atom && !(atom.containsCaret && atom.displayContainsHighlight))
          atom = atom.parent;
        if ((atom == null ? void 0 : atom.containsCaret) && atom.displayContainsHighlight) {
          const bounds = adjustForScrolling(
            mathfield,
            getAtomBounds(mathfield, atom)
          );
          if (bounds) {
            bounds.left /= scaleFactor;
            bounds.right /= scaleFactor;
            bounds.top /= scaleFactor;
            bounds.bottom /= scaleFactor;
            const element = document.createElement("div");
            element.classList.add("ML__contains-highlight");
            element.style.position = "absolute";
            element.style.left = `${bounds.left}px`;
            element.style.top = `${bounds.top}px`;
            element.style.width = `${Math.ceil(bounds.right - bounds.left)}px`;
            element.style.height = `${Math.ceil(bounds.bottom - bounds.top - 1)}px`;
            field.insertBefore(element, field.childNodes[0]);
          }
        }
        return;
      }
      for (const x of unionRects(
        getSelectionBounds(mathfield, { excludeAtomsWithBackground: true })
      )) {
        x.left /= scaleFactor;
        x.right /= scaleFactor;
        x.top /= scaleFactor;
        x.bottom /= scaleFactor;
        const selectionElement = document.createElement("div");
        selectionElement.classList.add("ML__selection");
        selectionElement.style.position = "absolute";
        selectionElement.style.left = `${x.left}px`;
        selectionElement.style.top = `${x.top}px`;
        selectionElement.style.width = `${Math.ceil(x.right - x.left)}px`;
        selectionElement.style.height = `${Math.ceil(x.bottom - x.top - 1)}px`;
        field.insertBefore(selectionElement, field.childNodes[0]);
      }
    }
    function unionRects(rects) {
      let result = [];
      for (const rect of rects) {
        let found = false;
        for (const rect2 of result) {
          if (rect.left === rect2.left && rect.right === rect2.right && rect.top === rect2.top && rect.bottom === rect2.bottom) {
            found = true;
            break;
          }
        }
        if (!found)
          result.push(rect);
      }
      rects = result;
      result = [];
      for (const rect of rects) {
        let count = 0;
        for (const rect2 of rects) {
          if (rect.left >= rect2.left && rect.right <= rect2.right && rect.top >= rect2.top && rect.bottom <= rect2.bottom) {
            count += 1;
            if (count > 1)
              break;
          }
        }
        if (count === 1)
          result.push(rect);
      }
      return result;
    }
    var HAPTIC_FEEDBACK_DURATION = 3;
    var COMMANDS = {};
    function register2(commands, options) {
      options = options != null ? options : { target: "mathfield", canUndo: false };
      for (const selector of Object.keys(commands)) {
        console.assert(!COMMANDS[selector], "Selector already defined: ", selector);
        COMMANDS[selector] = __spreadProps(__spreadValues({}, options), { fn: commands[selector] });
      }
    }
    function getCommandTarget(command) {
      var _a3;
      let selector;
      selector = isArray2(command) ? command[0] : command;
      selector = selector.replace(
        /-\w/g,
        (m) => m[1].toUpperCase()
      );
      return (_a3 = COMMANDS[selector]) == null ? void 0 : _a3.target;
    }
    function perform(mathfield, command) {
      var _a3, _b3;
      if (!command)
        return false;
      let selector;
      let args = [];
      let handled = false;
      let dirty = false;
      if (isArray2(command)) {
        selector = command[0];
        args = command.slice(1);
      } else
        selector = command;
      selector = selector.replace(
        /-\w/g,
        (m) => m[1].toUpperCase()
      );
      const commandTarget = (_a3 = COMMANDS[selector]) == null ? void 0 : _a3.target;
      if (commandTarget === "model") {
        if (!mathfield.isSelectionEditable && /^(paste|cut|insert|delete|transpose|add)/.test(selector)) {
          mathfield.model.announce("plonk");
          return false;
        }
        if (/^(delete|transpose|add)/.test(selector) && selector !== "deleteBackward")
          mathfield.flushInlineShortcutBuffer();
        if (/^(delete|transpose|add)/.test(selector) && mathfield.mode !== "latex") {
          mathfield.popUndoStack();
          mathfield.snapshot();
        }
        if (mathfield.mode === "latex" && !/^(complete)/.test(selector))
          removeSuggestion(mathfield);
        COMMANDS[selector].fn(mathfield.model, ...args);
        if (mathfield.mode !== "latex" && /^(delete|transpose|add)/.test(selector))
          mathfield.snapshot();
        if (mathfield.mode === "latex")
          updateAutocomplete(mathfield);
        dirty = true;
        handled = true;
      } else if (commandTarget === "virtual-keyboard") {
        dirty = (_b3 = window.mathVirtualKeyboard.executeCommand(command)) != null ? _b3 : false;
        handled = true;
      } else if (COMMANDS[selector]) {
        if (/^(undo|redo)/.test(selector))
          mathfield.flushInlineShortcutBuffer();
        dirty = COMMANDS[selector].fn(mathfield, ...args);
        handled = true;
      } else
        throw new Error(`Unknown command "${selector}"`);
      if (commandTarget !== "virtual-keyboard") {
        if (!mathfield.model.selectionIsCollapsed || /^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(
          selector
        )) {
          mathfield.flushInlineShortcutBuffer();
          mathfield.style = {};
        }
      }
      if (dirty)
        requestUpdate(mathfield);
      return handled;
    }
    function performWithFeedback(mathfield, selector) {
      mathfield.focus();
      if (mathfield_element_default.keypressVibration && canVibrate())
        navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
      selector = selector.replace(
        /-\w/g,
        (m) => m[1].toUpperCase()
      );
      if (selector === "moveToNextPlaceholder" || selector === "moveToPreviousPlaceholder" || selector === "complete")
        window.MathfieldElement.playSound("return");
      else if (selector === "deleteBackward" || selector === "deleteForward" || selector === "deletePreviousWord" || selector === "deleteNextWord" || selector === "deleteToGroupStart" || selector === "deleteToGroupEnd" || selector === "deleteToMathFieldStart" || selector === "deleteToMathFieldEnd")
        window.MathfieldElement.playSound("delete");
      else
        window.MathfieldElement.playSound("keypress");
      const result = mathfield.executeCommand(selector);
      mathfield.scrollIntoView();
      return result;
    }
    register2({
      performWithFeedback: (mathfield, command) => performWithFeedback(mathfield, command)
    });
    function nextSuggestion(mathfield) {
      updateAutocomplete(mathfield, { atIndex: mathfield.suggestionIndex + 1 });
      return false;
    }
    function previousSuggestion(mathfield) {
      updateAutocomplete(mathfield, { atIndex: mathfield.suggestionIndex - 1 });
      return false;
    }
    register2(
      {
        complete,
        nextSuggestion,
        previousSuggestion
      },
      { target: "mathfield", category: "autocomplete" }
    );
    function speakableText(prefix, atoms) {
      return prefix + atomToSpeakableText(atoms);
    }
    register2(
      {
        speak: (mathfield, scope, options) => {
          return speak(mathfield, scope, options);
        }
      },
      { target: "mathfield", category: "speech" }
    );
    function speak(mathfield, scope, speakOptions) {
      var _a3, _b3;
      speakOptions = speakOptions != null ? speakOptions : { withHighlighting: false };
      const { model } = mathfield;
      function getAtoms(scope2) {
        let result = null;
        switch (scope2) {
          case "all":
            result = model.root;
            break;
          case "selection":
            result = model.getAtoms(model.selection);
            break;
          case "left": {
            result = model.getAtoms(
              model.offsetOf(model.at(model.position).leftSibling),
              model.position
            );
            break;
          }
          case "right": {
            result = model.getAtoms(
              model.position,
              model.offsetOf(model.at(model.position).rightSibling)
            );
            break;
          }
          case "group":
            result = model.getAtoms(model.getSiblingsRange(model.position));
            break;
          case "parent": {
            const { parent } = model.at(model.position);
            if (parent && parent.type !== "root")
              result = parent;
            else
              result = model.root;
            break;
          }
          default:
            result = model.root;
        }
        return result;
      }
      function getFailedSpeech(scope2) {
        let result = "";
        switch (scope2) {
          case "all":
            console.log("Internal failure: speak all failed");
            break;
          case "selection":
            result = "no selection";
            break;
          case "left":
            result = "at start";
            break;
          case "right":
            result = "at end";
            break;
          case "group":
            console.log("Internal failure: speak group failed");
            break;
          case "parent":
            result = "no parent";
            break;
          default:
            console.log('unknown speak_ param value: "' + scope2 + '"');
            break;
        }
        return result;
      }
      const atoms = getAtoms(scope);
      if (atoms === null) {
        (_b3 = (_a3 = window.MathfieldElement).speakHook) == null ? void 0 : _b3.call(_a3, getFailedSpeech(scope));
        return false;
      }
      if (speakOptions.withHighlighting || window.MathfieldElement.speechEngine === "amazon") {
        window.MathfieldElement.textToSpeechMarkup = window.sre && window.MathfieldElement.textToSpeechRules === "sre" ? "ssml_step" : "ssml";
      }
      const text = atomToSpeakableText(atoms);
      if (isBrowser() && speakOptions.withHighlighting) {
        globalMathLive().readAloudMathField = mathfield;
        render(mathfield, { forHighlighting: true });
        if (window.MathfieldElement.readAloudHook)
          window.MathfieldElement.readAloudHook(mathfield.field, text);
      } else if (window.MathfieldElement.speakHook)
        window.MathfieldElement.speakHook(text);
      return false;
    }
    function defaultSpeakHook(text) {
      var _a3, _b3;
      if (!isBrowser()) {
        console.log("Speak:", text);
        return;
      }
      if (!window.MathfieldElement.speechEngine || window.MathfieldElement.speechEngine === "local") {
        const utterance = new SpeechSynthesisUtterance(text);
        window.speechSynthesis.speak(utterance);
      } else if (window.MathfieldElement.speechEngine === "amazon") {
        if (!("AWS" in window)) {
          console.error(
            `MathLive 0.90.9: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk`
          );
        } else {
          const polly = new window.AWS.Polly({ apiVersion: "2016-06-10" });
          const parameters = {
            OutputFormat: "mp3",
            VoiceId: (_a3 = window.MathfieldElement.speechEngineVoice) != null ? _a3 : "Joanna",
            Engine: [
              "Amy",
              "Emma",
              "Brian",
              "Ivy",
              "Joanna",
              "Kendra",
              "Kimberly",
              "Salli",
              "Joey",
              "Justin",
              "Matthew"
            ].includes((_b3 = window.MathfieldElement.speechEngineVoice) != null ? _b3 : "Joanna") ? "neural" : "standard",
            // SampleRate: '24000',
            Text: text,
            TextType: "ssml"
            // SpeechMarkTypes: ['ssml]'
          };
          polly.synthesizeSpeech(parameters, (err, data) => {
            if (err) {
              console.trace(
                `MathLive 0.90.9: \`polly.synthesizeSpeech()\` error: ${err}`
              );
            } else if (data == null ? void 0 : data.AudioStream) {
              const uInt8Array = new Uint8Array(data.AudioStream);
              const blob = new Blob([uInt8Array.buffer], { type: "audio/mpeg" });
              const url = URL.createObjectURL(blob);
              const audioElement = new Audio(url);
              audioElement.play().catch((error) => console.log(error));
            } else
              console.log("polly.synthesizeSpeech():", data);
          });
        }
      } else if (window.MathfieldElement.speechEngine === "google") {
        console.error(
          `MathLive 0.90.9: The Google speech engine is not supported yet. Please come again.`
        );
      }
    }
    function relationName(atom) {
      let result = void 0;
      if (atom.parent.type === "prompt") {
        if (atom.treeBranch === "body")
          result = "prompt";
      } else if (atom.treeBranch === "body") {
        result = {
          enclose: "cross out",
          leftright: "delimiter",
          surd: "square root",
          root: "math field",
          mop: "operator",
          // E.g. `\operatorname`, a `mop` with a body
          first: "first"
        }[atom.type];
      } else if (atom.parent.type === "genfrac") {
        if (atom.treeBranch === "above")
          return "numerator";
        if (atom.treeBranch === "below")
          return "denominator";
      } else if (atom.parent.type === "surd") {
        if (atom.treeBranch === "above")
          result = "index";
      } else if (atom.treeBranch === "superscript")
        result = "superscript";
      else if (atom.treeBranch === "subscript")
        result = "subscript";
      if (!result)
        console.log("unknown relationship");
      return result != null ? result : "parent";
    }
    function defaultAnnounceHook(mathfield, action, previousPosition, atoms) {
      let liveText = "";
      if (action === "plonk") {
        window.MathfieldElement.playSound("plonk");
        mathfield.flushInlineShortcutBuffer();
      } else if (action === "delete")
        liveText = speakableText("deleted: ", atoms);
      else if (action === "focus" || action.includes("move")) {
        liveText = getRelationshipAsSpokenText(mathfield.model, previousPosition) + (mathfield.model.selectionIsCollapsed ? "" : "selected: ") + getNextAtomAsSpokenText(mathfield.model);
      } else if (action === "replacement") {
        liveText = speakableText("", mathfield.model.at(mathfield.model.position));
      } else if (action === "line") {
        const label = speakableText("", mathfield.model.root);
        mathfield.keyboardDelegate.setAriaLabel(label);
      } else
        liveText = atoms ? speakableText(action + " ", atoms) : action;
      if (liveText) {
        const ariaLiveChangeHack = mathfield.ariaLiveText.textContent.includes(
          " "
        ) ? "   " : "   ";
        mathfield.ariaLiveText.textContent = liveText + ariaLiveChangeHack;
      }
    }
    function getRelationshipAsSpokenText(model, previousOffset) {
      if (Number.isNaN(previousOffset))
        return "";
      const previous = model.at(previousOffset);
      if (!previous)
        return "";
      if (previous.treeDepth <= model.at(model.position).treeDepth)
        return "";
      let result = "";
      let ancestor = previous.parent;
      const newParent = model.at(model.position).parent;
      while (ancestor !== model.root && ancestor !== newParent) {
        result += `out of ${relationName(ancestor)};`;
        ancestor = ancestor.parent;
      }
      return result;
    }
    function getNextAtomAsSpokenText(model) {
      if (!model.selectionIsCollapsed)
        return speakableText("", model.getAtoms(model.selection));
      let result = "";
      const cursor = model.at(model.position);
      const relation = relationName(cursor);
      if (cursor.isFirstSibling)
        result = (relation ? "start of " + relation : "unknown") + ": ";
      if (cursor.isLastSibling) {
        if (!cursor.isFirstSibling)
          result += relation ? "end of " + relation : "unknown";
      } else
        result += speakableText("", cursor);
      return result;
    }
    var ModelPrivate = class {
      constructor(options, listeners, target) {
        this.options = options;
        this._selection = { ranges: [[0, 0]], direction: "none" };
        this._anchor = 0;
        this._position = 0;
        this.mathfield = target;
        this.suppressChangeNotifications = false;
        this.root = new Atom("root", target, {
          mode: options.mode
        });
        this.root.body = [];
        this.setListeners(listeners);
      }
      get atoms() {
        return this.root.children;
      }
      /**
       * The selection, accounting for the common ancestors
       */
      get selection() {
        return this._selection;
      }
      set selection(value) {
        this.setSelection(value);
      }
      setSelection(arg1, arg2) {
        if (!this.mathfield.contentEditable && this.mathfield.userSelect === "none")
          return false;
        return this.deferNotifications({ selection: true }, () => {
          var _a3, _b3, _c2;
          const value = this.normalizeSelection(arg1, arg2);
          if (value === void 0)
            throw new TypeError("Invalid selection");
          if (value.ranges.length === 1 && value.ranges[0][0] === value.ranges[0][1]) {
            const pos = value.ranges[0][0];
            if (!this.mathfield.dirty && !((_a3 = this.at(pos)) == null ? void 0 : _a3.parentPrompt) && this.mathfield.hasEditablePrompts) {
              if ((_b3 = this.at(pos - 1)) == null ? void 0 : _b3.parentPrompt) {
                this._anchor = this.normalizeOffset(pos - 1);
                this._position = this._anchor;
                this._selection = this.normalizeSelection(this._anchor);
                return true;
              }
              if ((_c2 = this.at(pos + 1)) == null ? void 0 : _c2.parentPrompt) {
                this._anchor = this.normalizeOffset(pos + 1);
                this._position = this._anchor;
                this._selection = this.normalizeSelection(this._anchor);
                return true;
              }
              this._anchor = 0;
              this._position = 0;
              this._selection = { ranges: [[0, 0]] };
              return false;
            }
            this._anchor = pos;
            this._position = pos;
            this._selection = value;
            return false;
          }
          const selRange = range(value);
          if (value.direction === "backward")
            [this._position, this._anchor] = selRange;
          else
            [this._anchor, this._position] = selRange;
          const first = this.at(selRange[0] + 1);
          const last = this.at(selRange[1]);
          const commonAncestor = Atom.commonAncestor(first, last);
          if ((commonAncestor == null ? void 0 : commonAncestor.type) === "array" && first.parent === commonAncestor && last.parent === commonAncestor) {
            this._selection = { ranges: [selRange], direction: value.direction };
          } else
            this._selection = { ranges: [selRange], direction: value.direction };
          console.assert(this._position >= 0 && this._position <= this.lastOffset);
          return false;
        });
      }
      setPositionHandlingPlaceholder(pos) {
        var _a3, _b3, _c2;
        if (((_a3 = this.at(pos)) == null ? void 0 : _a3.type) === "placeholder") {
          this.setSelection(pos - 1, pos);
        } else if (((_c2 = (_b3 = this.at(pos)) == null ? void 0 : _b3.rightSibling) == null ? void 0 : _c2.type) === "placeholder") {
          this.setSelection(pos, pos + 1);
        } else
          this.position = pos;
      }
      getState() {
        return {
          content: this.root.toJson(),
          selection: this.selection
        };
      }
      setState(state, options) {
        var _a3;
        const wasSuppressing = this.suppressChangeNotifications;
        this.suppressChangeNotifications = (_a3 = options == null ? void 0 : options.suppressChangeNotifications) != null ? _a3 : true;
        let changeOption = {};
        if ((options == null ? void 0 : options.type) === "undo")
          changeOption = { inputType: "historyUndo" };
        if ((options == null ? void 0 : options.type) === "redo")
          changeOption = { inputType: "historyRedo" };
        if (contentWillChange(this, changeOption)) {
          this.root = fromJson(state.content, this.mathfield);
          this.selection = state.selection;
          contentDidChange(this, changeOption);
        }
        this.suppressChangeNotifications = wasSuppressing;
      }
      /**
       * The "focus" or "cursor" (i.e. not the anchor) a.k.a the insertion point
       * or caret: where things are going to be inserted next.
       *
       */
      get position() {
        return this._position;
      }
      set position(value) {
        this.setSelection(value, value);
      }
      /**
       * The offset from which the selection is extended
       */
      get anchor() {
        return this._anchor;
      }
      get selectionIsCollapsed() {
        return this._anchor === this._position;
      }
      get selectionIsPlaceholder() {
        if (Math.abs(this._anchor - this._position) === 1) {
          return this.at(Math.max(this._anchor, this._position)).type === "placeholder";
        }
        return false;
      }
      collapseSelection(direction = "forward") {
        if (this._anchor === this._position)
          return false;
        if (direction === "backward")
          this.position = Math.min(this._anchor, this._position);
        else
          this.position = Math.max(this._anchor, this._position);
        return true;
      }
      get lastOffset() {
        return this.atoms.length - 1;
      }
      at(index) {
        return this.atoms[index];
      }
      offsetOf(atom) {
        return this.atoms.indexOf(atom);
      }
      getSiblingsRange(offset) {
        const atom = this.at(offset);
        const { parent } = atom;
        if (!parent)
          return [0, this.lastOffset];
        const branch = atom.parent.branch(atom.treeBranch);
        return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
      }
      getBranchRange(offset, branchName) {
        const branch = this.at(offset).branch(branchName);
        return [this.offsetOf(branch[0]), this.offsetOf(branch[branch.length - 1])];
      }
      getAtoms(arg1, arg2, arg3) {
        let options = arg3 != null ? arg3 : {};
        if (isSelection(arg1)) {
          options = arg2 != null ? arg2 : {};
          if (arg1.ranges.length > 1) {
            return arg1.ranges.reduce(
              (acc, range2) => [...acc, ...this.getAtoms(range2, options)],
              []
            );
          }
          arg1 = arg1.ranges[0];
        }
        let start;
        let end;
        if (isOffset(arg1)) {
          start = arg1;
          if (!isOffset(arg2))
            return [];
          end = arg2;
        } else {
          [start, end] = arg1;
          options = arg2 != null ? arg2 : {};
        }
        if (!Number.isFinite(start))
          return [];
        if (options.includeChildren === void 0)
          options.includeChildren = false;
        if (start < 0)
          start = this.lastOffset - start + 1;
        if (end < 0)
          end = this.lastOffset - end + 1;
        const first = Math.min(start, end) + 1;
        const last = Math.max(start, end);
        if (first === 1 && last === this.lastOffset) {
          return [this.root];
        }
        let result = [];
        for (let i = first; i <= last; i++) {
          const atom = this.atoms[i];
          if (atomIsInRange(this, atom, first, last))
            result.push(atom);
        }
        if (!options.includeChildren) {
          result = result.filter((atom) => {
            let ancestorIncluded = false;
            let { parent } = atom;
            while (parent && !ancestorIncluded) {
              ancestorIncluded = atomIsInRange(this, parent, first, last);
              parent = parent.parent;
            }
            return !ancestorIncluded;
          });
        }
        return result;
      }
      /**
       * Unlike `getAtoms()`, the argument here is an index
       * Return all the atoms, in order, starting at startingIndex
       * then looping back at the beginning
       */
      getAllAtoms(startingIndex = 0) {
        const result = [];
        const last = this.lastOffset;
        for (let i = startingIndex; i <= last; i++)
          result.push(this.atoms[i]);
        for (let i = 0; i < startingIndex; i++)
          result.push(this.atoms[i]);
        return result;
      }
      findAtom(filter, startingIndex = 0, direction = "forward") {
        if (direction === "forward") {
          const last = this.lastOffset;
          for (let i = startingIndex; i <= last; i++)
            if (filter(this.atoms[i]))
              return this.atoms[i];
          for (let i = 0; i < startingIndex; i++)
            if (filter(this.atoms[i]))
              return this.atoms[i];
          return void 0;
        }
        for (let i = startingIndex; i >= 0; i--)
          if (filter(this.atoms[i]))
            return this.atoms[i];
        for (let i = this.lastOffset; i < startingIndex; i--)
          if (filter(this.atoms[i]))
            return this.atoms[i];
        return void 0;
      }
      /** Remove the specified atoms from the tree.
       * **WARNING** upon return the selection may now be invalid
       */
      extractAtoms(range2) {
        let result = this.getAtoms(range2);
        if (result.length === 1 && result[0].type === "root") {
          result = result[0].children;
        }
        for (const child of result)
          child.parent.removeChild(child);
        return result;
      }
      deleteAtoms(range2) {
        this.extractAtoms(range2);
        this.position = range2[0];
      }
      atomToString(atom, inFormat) {
        const format = inFormat != null ? inFormat : "latex";
        if (format.startsWith("latex")) {
          return Mode.serialize([atom], {
            expandMacro: format === "latex-expanded",
            skipStyles: format === "latex-unstyled",
            defaultMode: this.mathfield.options.defaultMode
          });
        }
        if (format === "math-ml")
          return toMathML(atom);
        if (format === "spoken")
          return atomToSpeakableText(atom);
        if (format === "spoken-text") {
          const saveTextToSpeechMarkup = window.MathfieldElement.textToSpeechMarkup;
          window.MathfieldElement.textToSpeechMarkup = "";
          const result = atomToSpeakableText(atom);
          window.MathfieldElement.textToSpeechMarkup = saveTextToSpeechMarkup;
          return result;
        }
        if (format === "spoken-ssml" || format === "spoken-ssml-with-highlighting") {
          const saveTextToSpeechMarkup = window.MathfieldElement.textToSpeechMarkup;
          window.MathfieldElement.textToSpeechMarkup = "ssml";
          const result = atomToSpeakableText(atom);
          window.MathfieldElement.textToSpeechMarkup = saveTextToSpeechMarkup;
          return result;
        }
        if (format === "math-json") {
          if (!window.MathfieldElement.computeEngine) {
            if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
              console.error(
                'The CortexJS Compute Engine library is not available.\nLoad the library, for example with:\nimport "https://unpkg.com/@cortex-js/compute-engine?module"'
              );
            }
            return '["Error", "compute-engine-not-available"]';
          }
          try {
            const expr = window.MathfieldElement.computeEngine.parse(
              Atom.serialize(atom, { expandMacro: false, defaultMode: "math" })
            );
            return JSON.stringify(expr.json);
          } catch (e) {
            return JSON.stringify(["Error", `'${e.toString()}'`]);
          }
        }
        if (format === "ascii-math")
          return atomToAsciiMath(atom);
        console.error(`MathLive 0.90.9: Unknown format "${format}`);
        return "";
      }
      getValue(arg1, arg2, arg3) {
        if (arg1 === void 0)
          return this.atomToString(this.root, "latex");
        if (typeof arg1 === "string")
          return this.atomToString(this.root, arg1);
        let ranges;
        let format;
        if (isOffset(arg1) && isOffset(arg2)) {
          ranges = [this.normalizeRange([arg1, arg2])];
          format = arg3 != null ? arg3 : "latex";
        } else if (isRange(arg1)) {
          ranges = [this.normalizeRange(arg1)];
          format = arg2;
        } else if (isSelection(arg1)) {
          ranges = arg1.ranges;
          format = arg2;
        } else {
          ranges = [];
          format = "latex";
        }
        if (format.startsWith("latex")) {
          const options = {
            expandMacro: format === "latex-expanded",
            skipStyles: format === "latex-unstyled",
            defaultMode: this.mathfield.options.defaultMode
          };
          return joinLatex(
            ranges.map((range2) => Atom.serialize(this.getAtoms(range2), options))
          );
        }
        return ranges.map(
          (range2) => this.getAtoms(range2).map((atom) => this.atomToString(atom, format)).join("")
        ).join("");
      }
      /**
       * Method called in response to a user interaction
       */
      extendSelection(direction) {
        let anchor = this._anchor;
        if (direction === "forward") {
          let pos2 = this._position;
          do {
            let atom = this.at(pos2 + 1);
            if (atom == null ? void 0 : atom.inCaptureSelection) {
              while (!atom.captureSelection)
                atom = atom.parent;
              pos2 = this.offsetOf(atom == null ? void 0 : atom.lastChild) + 1;
            } else
              pos2 += 1;
          } while (pos2 <= this.lastOffset && this.at(pos2).isFirstSibling);
          if (pos2 === anchor - 1 && this.at(anchor).type === "first")
            pos2 = anchor;
          return this.extendSelectionTo(anchor, pos2);
        }
        let pos = this._position - 1;
        if (pos < 0)
          return false;
        while (pos >= 0 && this.at(pos).isLastSibling) {
          let atom = this.at(pos);
          if (atom == null ? void 0 : atom.inCaptureSelection) {
            while (!atom.captureSelection)
              atom = atom.parent;
            pos = this.offsetOf(atom.firstChild) - 1;
          } else
            pos -= 1;
        }
        if (pos < 0)
          pos = 0;
        if (pos === anchor + 1 && this.at(pos).type === "first")
          anchor = pos;
        return this.extendSelectionTo(anchor, pos);
      }
      /**
       * Unlike `setSelection`, this method is intended to be used in response
       * to a user action, and it performs various adjustments to result
       * in a more intuitive selection.
       * For example:
       * - when all the children of an atom are selected, the atom
       * become selected.
       * - this method will *not* change the anchor, but may result
       * in a selection whose boundary is outside the anchor
       */
      extendSelectionTo(anchor, position) {
        if (!this.mathfield.contentEditable && this.mathfield.userSelect === "none")
          return false;
        return this.deferNotifications({ selection: true }, () => {
          const range2 = this.normalizeRange([anchor, position]);
          let [start, end] = range2;
          let { parent } = this.at(end);
          if (parent) {
            if (parent.type === "genfrac" || parent.type === "msubsup") {
              while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
                end = this.offsetOf(parent);
                parent = parent.parent;
              }
            }
          }
          parent = this.at(start).parent;
          while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
            start = this.offsetOf(parent.leftSibling);
            parent = parent.parent;
          }
          parent = this.at(end).parent;
          if ((parent == null ? void 0 : parent.type) === "genfrac") {
            while (parent !== this.root && childrenInRange(this, parent, [start, end])) {
              end = this.offsetOf(parent);
              console.assert(end >= 0);
              parent = parent.parent;
            }
          }
          this._position = this.normalizeOffset(position);
          this._selection = {
            ranges: [[start, end]],
            direction: "none"
          };
        });
      }
      setListeners(listeners) {
        this.listeners = listeners;
      }
      /**
       * This method is called to provide feedback when using a screen reader
       * or other assistive device, for example when changing the selection or
       * moving the insertion point.
       *
       * It can also be used with the 'plonk' command to provide an audible
       * feedback when a command is not possible.
       *
       * This method should not be called from other methods of the model
       * (such as `setSelection`) as these methods can also be called
       * programmatically and a feedback in these case would be innapropriate,
       * however they should be called from functions called as a result of a user
       * action, such as the functions in `commands.ts`
       */
      announce(command, previousPosition, atoms = []) {
        var _a3, _b3;
        const result = (_b3 = (_a3 = this.mathfield.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("announce", {
            detail: { command, previousPosition, atoms },
            cancelable: true,
            bubbles: true,
            composed: true
          })
        )) != null ? _b3 : true;
        if (result)
          defaultAnnounceHook(this.mathfield, command, previousPosition, atoms);
      }
      // Suppress notification while scope is executed,
      // then notify of content change, and selection change (if actual change)
      deferNotifications(options, f) {
        const oldSelection = this._selection;
        const oldAnchor = this._anchor;
        const oldPosition = this._position;
        const saved = this.suppressChangeNotifications;
        this.suppressChangeNotifications = true;
        const previousCounter = this.root.changeCounter;
        f();
        const contentChanged = this.root.changeCounter !== previousCounter;
        const selectionChanged = oldAnchor !== this._anchor || oldPosition !== this._position || compareSelection(this._selection, oldSelection) === "different";
        this.suppressChangeNotifications = saved;
        if (options.content && contentChanged)
          contentDidChange(this, { inputType: options.type });
        if (options.selection && selectionChanged)
          selectionDidChange(this);
        return contentChanged || selectionChanged;
      }
      normalizeOffset(value) {
        if (value > 0)
          value = Math.min(value, this.lastOffset);
        else if (value < 0)
          value = this.lastOffset + value + 1;
        return value;
      }
      /**
       * Ensure that the range is valid and canonical, i.e.
       * - start <= end
       * - collapsed = start === end
       * - start >= 0, end >=0
       */
      normalizeRange(range2) {
        let [start, end] = range2;
        start = this.normalizeOffset(start);
        end = this.normalizeOffset(end);
        return start < end ? [start, end] : [end, start];
      }
      normalizeSelection(value, value2) {
        var _a3;
        let result = void 0;
        if (isOffset(value)) {
          const offset = this.normalizeOffset(value);
          if (isOffset(value2)) {
            const offset2 = this.normalizeOffset(value2);
            result = offset <= offset2 ? { ranges: [[offset, offset2]], direction: "none" } : {
              ranges: [[offset2, offset]],
              direction: "backward"
            };
          } else
            result = { ranges: [[offset, offset]], direction: "none" };
        } else if (isRange(value)) {
          const start = this.normalizeOffset(value[0]);
          const end = this.normalizeOffset(value[1]);
          result = start <= end ? { ranges: [[start, end]], direction: "none" } : { ranges: [[end, start]], direction: "backward" };
        } else if (isSelection(value)) {
          result = {
            ranges: value.ranges.map((x) => this.normalizeRange(x)),
            direction: (_a3 = value.direction) != null ? _a3 : "none"
          };
        }
        console.assert(result !== void 0);
        return result;
      }
    };
    function atomIsInRange(model, atom, first, last) {
      const offset = model.offsetOf(atom);
      if (offset < first || offset > last)
        return false;
      if (!atom.hasChildren)
        return true;
      const firstOffset = model.offsetOf(atom.firstChild);
      if (firstOffset >= first && firstOffset <= last) {
        const lastOffset = model.offsetOf(atom.lastChild);
        if (lastOffset >= first && lastOffset <= last)
          return true;
      }
      return false;
    }
    function childrenInRange(model, atom, range2) {
      if (!(atom == null ? void 0 : atom.hasChildren))
        return false;
      const [start, end] = range2;
      const first = model.offsetOf(atom.firstChild);
      const last = model.offsetOf(atom.lastChild);
      if (first >= start && first <= end && last >= first && last <= end)
        return true;
      return false;
    }
    function addCell(model, where) {
      let atom = model.at(model.position);
      while (atom && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
        atom = atom.parent;
      if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && (atom == null ? void 0 : atom.parent) instanceof ArrayAtom) {
        const arrayAtom = atom.parent;
        let pos;
        switch (where) {
          case "after row":
            arrayAtom.addRowAfter(atom.treeBranch[0]);
            pos = model.offsetOf(arrayAtom.getCell(atom.treeBranch[0] + 1, 0)[0]);
            break;
          case "after column":
            if (arrayAtom.maxColumns <= arrayAtom.colCount) {
              model.announce("plonk");
              return;
            }
            arrayAtom.addColumnAfter(atom.treeBranch[1]);
            pos = model.offsetOf(
              arrayAtom.getCell(atom.treeBranch[0], atom.treeBranch[1] + 1)[0]
            );
            break;
          case "before row":
            arrayAtom.addRowBefore(atom.treeBranch[0]);
            pos = model.offsetOf(arrayAtom.getCell(atom.treeBranch[0] - 1, 0)[0]);
            break;
          case "before column":
            if (arrayAtom.maxColumns <= arrayAtom.colCount) {
              model.announce("plonk");
              return;
            }
            arrayAtom.addColumnBefore(atom.treeBranch[1]);
            pos = model.offsetOf(
              arrayAtom.getCell(atom.treeBranch[0], atom.treeBranch[1] - 1)[0]
            );
            break;
        }
        model.setSelection(pos, pos + 1);
      }
    }
    function addRowAfter(model) {
      if (!contentWillChange(model, { inputType: "insertText" }))
        return false;
      addCell(model, "after row");
      contentDidChange(model, { inputType: "insertText" });
      return true;
    }
    function addRowBefore(model) {
      if (!contentWillChange(model, { inputType: "insertText" }))
        return false;
      addCell(model, "before row");
      contentDidChange(model, { inputType: "insertText" });
      return true;
    }
    function addColumnAfter(model) {
      if (!contentWillChange(model, { inputType: "insertText" }))
        return false;
      addCell(model, "after column");
      contentDidChange(model, { inputType: "insertText" });
      return true;
    }
    function addColumnBefore(model) {
      if (!contentWillChange(model, { inputType: "insertText" }))
        return false;
      addCell(model, "before column");
      contentDidChange(model, { inputType: "insertText" });
      return true;
    }
    function removeCell(model, where) {
      let atom = model.at(model.position);
      while (atom && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
        atom = atom.parent;
      if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && (atom == null ? void 0 : atom.parent) instanceof ArrayAtom) {
        const arrayAtom = atom.parent;
        const treeBranch = atom.treeBranch;
        let pos;
        switch (where) {
          case "row":
            if (arrayAtom.rowCount > 1) {
              arrayAtom.removeRow(treeBranch[0]);
              const cell = arrayAtom.getCell(
                Math.max(0, treeBranch[0] - 1),
                treeBranch[1]
              );
              pos = model.offsetOf(cell[cell.length - 1]);
            }
            break;
          case "column":
            if (arrayAtom.colCount > arrayAtom.minColumns) {
              arrayAtom.removeColumn(treeBranch[1]);
              const cell = arrayAtom.getCell(
                treeBranch[0],
                Math.max(0, treeBranch[1] - 1)
              );
              pos = model.offsetOf(cell[cell.length - 1]);
            }
            break;
        }
        if (pos)
          model.setPositionHandlingPlaceholder(pos);
      }
    }
    function removeRow(model) {
      if (!contentWillChange(model, { inputType: "deleteContent" }))
        return false;
      removeCell(model, "row");
      contentDidChange(model, { inputType: "deleteContent" });
      return true;
    }
    function removeColumn(model) {
      if (!contentWillChange(model, { inputType: "deleteContent" }))
        return false;
      removeCell(model, "column");
      contentDidChange(model, { inputType: "deleteContent" });
      return true;
    }
    register2(
      {
        addRowAfter,
        addColumnAfter,
        addRowBefore,
        addColumnBefore,
        removeRow,
        removeColumn
      },
      { target: "model", category: "array-edit" }
    );
    function onDelete(model, direction, atom, branch) {
      var _a3, _b3, _c2, _d2, _e, _f;
      const parent = atom.parent;
      if (parent && atom instanceof LeftRightAtom) {
        const atStart = !branch && direction === "forward" || branch === "body" && direction === "backward";
        let pos = atStart ? model.offsetOf(atom.firstChild) : model.offsetOf(atom.lastChild);
        if (atStart) {
          if (atom.rightDelim !== "?" && atom.rightDelim !== ".") {
            atom.leftDelim = ".";
            atom.isDirty = true;
          } else {
            parent.addChildrenAfter(atom.removeBranch("body"), atom);
            parent.removeChild(atom);
            pos--;
          }
        } else {
          if (atom.leftDelim !== "?" && atom.leftDelim !== ".") {
            atom.rightDelim = ".";
            atom.isDirty = true;
          } else {
            parent.addChildrenAfter(atom.removeBranch("body"), atom);
            parent.removeChild(atom);
            pos--;
          }
        }
        model.position = pos;
        return true;
      }
      if (parent && atom.type === "surd") {
        if (direction === "forward" && !branch || direction === "backward" && branch === "body") {
          const pos = atom.leftSibling;
          if (atom.hasChildren)
            parent.addChildrenAfter(atom.removeBranch("body"), atom);
          parent.removeChild(atom);
          model.position = model.offsetOf(pos);
        } else if (direction === "forward" && branch === "body") {
          model.position = model.offsetOf(atom);
        } else if (!branch && direction === "backward") {
          if (atom.hasChildren)
            model.position = model.offsetOf(atom.lastChild);
          else {
            model.position = Math.max(0, model.offsetOf(atom) - 1);
            parent.removeChild(atom);
          }
        } else if (branch === "above") {
          if (atom.hasEmptyBranch("above"))
            atom.removeBranch("above");
          if (direction === "backward") {
            model.position = model.offsetOf(atom.leftSibling);
          } else {
            model.position = model.offsetOf(atom.body[0]);
          }
        }
        return true;
      }
      if (parent && (atom.type === "box" || atom.type === "enclose")) {
        const pos = branch && direction === "backward" || !branch && direction === "forward" ? atom.leftSibling : atom.lastChild;
        parent.addChildrenAfter(atom.removeBranch("body"), atom);
        parent.removeChild(atom);
        model.position = model.offsetOf(pos);
        return true;
      }
      if (atom.type === "genfrac" || atom.type === "overunder") {
        if (!branch) {
          if (atom.type === "overunder" && atom.hasEmptyBranch("body"))
            return false;
          if (atom.type === "genfrac" && atom.hasEmptyBranch("below") && atom.hasEmptyBranch("above"))
            return false;
          model.position = model.offsetOf(
            direction === "forward" ? atom.firstChild : atom.lastChild
          );
          return true;
        }
        const firstBranch = atom.context.fractionNavigationOrder === "numerator-denominator" ? "above" : "below";
        const secondBranch = firstBranch === "above" ? "below" : "above";
        if (parent && (direction === "forward" && branch === firstBranch || direction === "backward" && branch === secondBranch)) {
          const first = atom.removeBranch(firstBranch);
          const second = atom.removeBranch(secondBranch);
          parent.addChildrenAfter([...first, ...second], atom);
          parent.removeChild(atom);
          model.position = model.offsetOf(
            first.length > 0 ? first[first.length - 1] : second[0]
          );
          return true;
        }
        if (direction === "backward")
          model.position = model.offsetOf(atom.leftSibling);
        else
          model.position = model.offsetOf(atom);
        return true;
      }
      if (atom.isExtensibleSymbol || atom.type === "msubsup") {
        if (!branch && direction === "forward")
          return false;
        if (!branch) {
          if (atom.subscript || atom.superscript) {
            const pos = direction === "forward" ? (_c2 = (_a3 = atom.superscript) == null ? void 0 : _a3[0]) != null ? _c2 : (_b3 = atom.subscript) == null ? void 0 : _b3[0] : (_f = (_d2 = atom.subscript) == null ? void 0 : _d2[0].lastSibling) != null ? _f : (_e = atom.superscript) == null ? void 0 : _e[0].lastSibling;
            if (pos)
              model.position = model.offsetOf(pos);
            return true;
          }
          return false;
        }
        if (branch && atom.hasEmptyBranch(branch))
          atom.removeBranch(branch);
        if (!atom.hasChildren) {
          const pos = direction === "forward" ? model.offsetOf(atom) : Math.max(0, model.offsetOf(atom) - 1);
          atom.parent.removeChild(atom);
          model.position = pos;
          return true;
        }
        if (branch === "superscript") {
          if (direction === "backward") {
            const pos = model.offsetOf(atom.firstChild) - 1;
            console.assert(pos >= 0);
            model.position = pos;
          } else if (atom.subscript)
            model.position = model.offsetOf(atom.subscript[0]);
          else
            model.position = model.offsetOf(atom);
        } else if (branch === "subscript") {
          if (direction === "backward" && atom.superscript) {
            model.position = model.offsetOf(atom.superscript[0].lastSibling);
          } else if (direction === "backward") {
            model.position = model.offsetOf(atom.firstChild) - 1;
          } else {
            model.position = model.offsetOf(atom);
          }
        }
        return true;
      }
      if ((parent == null ? void 0 : parent.type) === "genfrac" && !branch && atom.type !== "first") {
        let pos = model.offsetOf(atom.leftSibling);
        parent.removeChild(atom);
        if (parent.hasEmptyBranch("above") && parent.hasEmptyBranch("below")) {
          pos = model.offsetOf(parent.leftSibling);
          parent.parent.removeChild(parent);
          model.announce("delete", void 0, [parent]);
          model.position = pos;
          return true;
        }
        model.announce("delete", void 0, [atom]);
        model.position = pos;
        return true;
      }
      return false;
    }
    function deleteBackward(model) {
      if (!model.mathfield.isSelectionEditable)
        return false;
      if (!contentWillChange(model, { inputType: "deleteContentBackward" }))
        return false;
      if (!model.selectionIsCollapsed)
        return deleteRange(model, range(model.selection), "deleteContentBackward");
      return model.deferNotifications(
        { content: true, selection: true, type: "deleteContentBackward" },
        () => {
          let target = model.at(model.position);
          if (target && onDelete(model, "backward", target))
            return;
          if (target == null ? void 0 : target.isFirstSibling) {
            if (onDelete(model, "backward", target.parent, target.treeBranch))
              return;
            target = null;
          }
          if (!target) {
            model.announce("plonk");
            return;
          }
          model.position = model.offsetOf(target.leftSibling);
          target.parent.removeChild(target);
          model.announce("delete", void 0, [target]);
        }
      );
    }
    function deleteForward(model) {
      if (!model.mathfield.isSelectionEditable)
        return false;
      if (!contentWillChange(model, { inputType: "deleteContentForward" }))
        return false;
      if (!model.selectionIsCollapsed)
        return deleteRange(model, range(model.selection), "deleteContentForward");
      return model.deferNotifications(
        { content: true, selection: true, type: "deleteContentForward" },
        () => {
          var _a3, _b3;
          let target = model.at(model.position).rightSibling;
          if (target && onDelete(model, "forward", target))
            return;
          if (!target) {
            target = model.at(model.position);
            if (target.isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch))
              return;
            target = void 0;
          } else if (model.at(model.position).isLastSibling && onDelete(model, "forward", target.parent, target.treeBranch))
            return;
          if (model.position === model.lastOffset || !target) {
            model.announce("plonk");
            return;
          }
          target.parent.removeChild(target);
          let sibling = (_a3 = model.at(model.position)) == null ? void 0 : _a3.rightSibling;
          while ((sibling == null ? void 0 : sibling.type) === "msubsup") {
            sibling.parent.removeChild(sibling);
            sibling = (_b3 = model.at(model.position)) == null ? void 0 : _b3.rightSibling;
          }
          model.announce("delete", void 0, [target]);
        }
      );
    }
    function deleteRange(model, range2, type) {
      const result = model.getAtoms(range2);
      if (result.length > 0 && result[0].parent) {
        let firstChild = result[0].parent.firstChild;
        if (firstChild.type === "first")
          firstChild = firstChild.rightSibling;
        const lastChild = result[result.length - 1].parent.lastChild;
        let firstSelected = result[0];
        if (firstSelected.type === "first")
          firstSelected = firstSelected.rightSibling;
        const lastSelected = result[result.length - 1];
        if (firstSelected === firstChild && lastSelected === lastChild) {
          const parent = result[0].parent;
          if (parent.type !== "root" && parent.type !== "prompt") {
            range2 = [
              model.offsetOf(parent.leftSibling),
              model.offsetOf(parent.rightSibling)
            ];
          }
        }
        if (result.length === 1 && result[0].type === "placeholder" && result[0].parent.type === "genfrac") {
          const genfrac = result[0].parent;
          const branch = result[0].treeBranch === "below" ? "above" : "below";
          const pos = model.offsetOf(genfrac.leftSibling);
          return model.deferNotifications(
            { content: true, selection: true, type },
            () => {
              var _a3, _b3;
              const numer = genfrac.removeBranch(branch);
              if (!(numer.length === 1 && numer[0].type === "placeholder")) {
                const lastAtom = genfrac.parent.addChildrenAfter(numer, genfrac);
                (_a3 = genfrac.parent) == null ? void 0 : _a3.removeChild(genfrac);
                model.position = model.offsetOf(lastAtom);
              } else {
                (_b3 = genfrac.parent) == null ? void 0 : _b3.removeChild(genfrac);
                model.position = Math.max(0, pos);
              }
            }
          );
        }
      }
      return model.deferNotifications(
        { content: true, selection: true, type },
        () => model.deleteAtoms(range2)
      );
    }
    function updateComposition(model, s) {
      const cursor = model.at(model.position);
      if (cursor.type === "composition") {
        cursor.value = s;
      } else {
        const { caret } = cursor;
        cursor.caret = "";
        const atom = new CompositionAtom(s, model.mathfield, { mode: cursor.mode });
        atom.caret = caret;
        cursor.parent.addChildAfter(atom, cursor);
        model.position += 1;
      }
    }
    function removeComposition(model) {
      const cursor = model.at(model.position);
      if (cursor.type === "composition") {
        cursor.parent.removeChild(cursor);
        model.position -= 1;
      }
    }
    function getMode(model, offset) {
      const atom = model.at(offset);
      let result;
      if (atom) {
        result = atom.mode;
        let ancestor = atom.parent;
        while (!result && ancestor) {
          if (ancestor)
            result = ancestor.mode;
          ancestor = ancestor.parent;
        }
      }
      return result;
    }
    function applyStyleToUnstyledAtoms(atom, style) {
      if (!atom || !style)
        return;
      if (isArray2(atom)) {
        atom.forEach((x) => applyStyleToUnstyledAtoms(x, style));
      } else if (typeof atom === "object") {
        if (!atom.style.color && !atom.style.backgroundColor && !atom.style.fontFamily && !atom.style.fontShape && !atom.style.fontSeries && !atom.style.fontSize && !atom.style.variant && !atom.style.variantStyle) {
          atom.applyStyle(style);
          applyStyleToUnstyledAtoms(atom.body, style);
          applyStyleToUnstyledAtoms(atom.above, style);
          applyStyleToUnstyledAtoms(atom.below, style);
          applyStyleToUnstyledAtoms(atom.subscript, style);
          applyStyleToUnstyledAtoms(atom.superscript, style);
        }
      }
    }
    function applyStyle2(model, range2, style, options) {
      function everyStyle(property, value) {
        for (const atom of atoms)
          if (atom.style[property] !== value)
            return false;
        return true;
      }
      range2 = model.normalizeRange(range2);
      if (range2[0] === range2[1])
        return false;
      const atoms = model.getAtoms(range2, { includeChildren: true });
      if (options.operation === "toggle") {
        if (style.color && everyStyle("color", style.color)) {
          style.color = "none";
          style.verbatimColor = void 0;
        }
        if (style.backgroundColor && everyStyle("backgroundColor", style.backgroundColor)) {
          style.backgroundColor = "none";
          style.verbatimBackgroundColor = void 0;
        }
        if (style.fontFamily && everyStyle("fontFamily", style.fontFamily)) {
          style.fontFamily = "none";
        }
        if (style.fontSeries && everyStyle("fontSeries", style.fontSeries)) {
          style.fontSeries = "auto";
        }
        if (style.fontShape && everyStyle("fontShape", style.fontShape)) {
          style.fontShape = "auto";
        }
        if (style.fontSize && everyStyle("fontSize", style.fontSize)) {
          style.fontSize = DEFAULT_FONT_SIZE;
        }
      }
      for (const atom of atoms)
        atom.applyStyle(style);
      return true;
    }
    var mathfield_default = "@keyframes ML__caret-blink {\n  0%,\n  100% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n}\n.ML__caret:after {\n  content: '';\n  border: none;\n  border-radius: 2px;\n  border-right: 2px solid var(--caret-color, var(--ML__caret-color));\n  margin-right: -2px;\n  position: relative;\n  left: -1px;\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__text-caret:after {\n  content: '';\n  border: none;\n  border-radius: 1px;\n  border-right: 1px solid var(--caret-color, var(--ML__caret-color));\n  margin-right: -1px;\n  position: relative;\n  left: 0;\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__latex-caret:after {\n  content: '_';\n  border: none;\n  margin-right: 0;\n  margin-right: calc(-1ex - 2px);\n  position: relative;\n  color: var(--caret-color, var(--ML__caret-color));\n  animation: ML__caret-blink 1.05s step-end forwards infinite;\n}\n.ML__container {\n  display: inline-flex;\n  flex-flow: row;\n  justify-content: space-between;\n  align-items: flex-end;\n  min-height: 39px;\n  /* Need some room for the virtual keyboard toggle */\n  width: 100%;\n  /* Encourage browsers to consider allocating a hardware accelerated\n   layer for this element. */\n  isolation: isolate;\n  /* Prevent the browser from trying to interpret touch gestures in the field */\n  /* \"Disabling double-tap to zoom removes the need for browsers to\n        delay the generation of click events when the user taps the screen.\" */\n  touch-action: none;\n  --ML__selection-background-color: hsl(var(--hue, 212), 97%, 85%);\n  --ML__text-highlight-background-color: hsla(var(--hue, 212), 40%, 50%, 0.1);\n  --ML__contains-highlight-background-color: hsl(var(--hue, 212), 40%, 95%);\n  --ML__selection-color: currentColor;\n  --ML__caret-color: hsl(var(--hue, 212), 40%, 49%);\n  --ML__smart-fence-color: currentColor;\n  --ML__latex-color: var(--primary, hsl(var(--hue, 212), 40%, 50%));\n  --ML__correct-color: #10a000;\n  --ML__incorrect-color: #a01b00;\n  --ML__placeholder-color: hsl(var(--hue, 212), 40%, 49%);\n}\n/* This is the actual field content (formula) */\n.ML__content {\n  display: flex;\n  align-items: center;\n  align-self: center;\n  position: relative;\n  overflow: hidden;\n  padding: 2px 0 2px 1px;\n  width: 100%;\n}\n.ML__virtual-keyboard-toggle {\n  box-sizing: border-box;\n  display: flex;\n  align-self: center;\n  align-items: center;\n  flex-shrink: 0;\n  flex-direction: column;\n  justify-content: center;\n  width: 34px;\n  height: 34px;\n  padding: 0;\n  margin-right: 4px;\n  cursor: pointer;\n  /* Avoid some weird blinking with :hover */\n  border-radius: 8px;\n  border: 1px solid transparent;\n  transition: background 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);\n  color: var(--primary, hsl(var(--hue, 212), 40%, 50%));\n  fill: currentColor;\n  background: transparent;\n}\n.ML__virtual-keyboard-toggle:hover {\n  background: hsla(0, 0%, 70%, 0.3);\n  color: #333;\n  fill: currentColor;\n}\n.ML__virtual-keyboard-toggle > span {\n  display: flex;\n  align-self: center;\n  align-items: center;\n}\n/* The invisible element used to capture keyboard events. We're just trying\n really hard to make sure it doesn't show. */\n.ML__keyboard-sink {\n  display: inline-block;\n  resize: none;\n  outline: none;\n  border: none;\n  /* Need these for Microsoft Edge */\n  position: fixed;\n  clip: rect(0 0 0 0);\n  /* Need this to prevent iOS Safari from auto-zooming */\n  font-size: 1em;\n  font-family: KaTeX_Main;\n}\n.ML__focused .ML__text {\n  background: var(--highlight-text, var(--ML__text-highlight-background-color));\n}\n/* When using smartFence, the anticipated closing fence is displayed\nwith this style */\n.ML__smart-fence__close {\n  opacity: var(--smart-fence-opacity, 0.5);\n  color: var(--smart-fence-color, var(--ML__smart-fence-color));\n}\n.ML__focused .ML__selection {\n  background: var(--selection-background-color-focused, var(--selection-background-color, var(--ML__selection-background-color))) !important;\n}\n.ML__focused .ML__selected,\n.ML__focused .ML__selected .ML__contains-caret,\n.ML__focused .ML__selected .ML__smart-fence__close,\n.ML__focused .ML__selected .ML__placeholder {\n  color: var(--selection-color-focused, var(--selection-color, var(--ML__selection-color))) !important;\n}\n.ML__selection {\n  box-sizing: border-box;\n  background: var(--selection-background-color, var(--ML__selection-background-color)) !important;\n}\n.ML__selected,\n.ML__selected .ML__contains-caret,\n.ML__selected .ML__smart-fence__close,\n.ML__selected .ML__placeholder {\n  color: var(--selection-color, var(--ML__selection-color));\n  opacity: 1;\n}\n.ML__contains-caret.ML__close,\n.ML__contains-caret.ML__open,\n.ML__contains-caret > .ML__close,\n.ML__contains-caret > .ML__open,\n.ML__contains-caret .ML__sqrt-sign,\n.ML__contains-caret .ML__sqrt-line {\n  color: var(--caret-color, var(--ML__caret-color));\n}\n.ML__contains-highlight {\n  background: var(--contains-highlight-backround-color, var(--ML__contains-highlight));\n  box-sizing: border-box;\n}\n.ML__latex {\n  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;\n  font-weight: 400;\n  color: var(--latex-color, var(--ML__latex-color));\n}\n.ML__suggestion {\n  opacity: 0.5;\n}\n.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover {\n  background: hsl(var(--hue, 212), 25%, 35%);\n  color: #fafafa;\n  fill: currentColor;\n}\n.ML__virtual-keyboard-toggle:focus {\n  outline: none;\n  border-radius: 8px;\n  border: 2px solid var(--primary, hsl(var(--hue, 212), 40%, 50%));\n}\n.ML__virtual-keyboard-toggle.is-pressed,\n.ML__virtual-keyboard-toggle.is-active:hover,\n.ML__virtual-keyboard-toggle.is-active {\n  background: hsl(var(--hue, 212), 25%, 35%);\n  color: #fafafa;\n  fill: currentColor;\n}\n/* This class is used to implement the `\\mathtip` and `\\texttip` commands\n   For UI elements, see `[data-ML__tooltip]`\n*/\n.ML__tooltip-container {\n  position: relative;\n  transform: scale(0);\n}\n.ML__tooltip-container .ML__tooltip-content {\n  position: fixed;\n  display: inline-table;\n  visibility: hidden;\n  z-index: 2;\n  width: max-content;\n  max-width: 400px;\n  padding: 12px 12px;\n  border-radius: 8px;\n  background: #616161;\n  color: #fff;\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n  opacity: 0;\n  transition: opacity 0.15s cubic-bezier(0.4, 0, 1, 1);\n}\n.ML__tooltip-container .ML__tooltip-content .ML__text {\n  white-space: normal;\n}\n.ML__tooltip-container .ML__tooltip-content .ML__base {\n  display: contents;\n}\n.ML__tooltip-container:hover .ML__tooltip-content {\n  visibility: visible;\n  opacity: 1;\n  font-size: 0.75em;\n  transform: scale(1) translate(0, 3em);\n}\n/* Add an attribute 'data-ML__tooltip' to automatically show a\n   tooltip over a element on hover.\n   Use 'data-position=\"top\"' to place the tooltip above the\n   element rather than below.\n   Use 'data-delay' to delay the triggering of the tooltip.\n*/\n[data-ML__tooltip] {\n  position: relative;\n}\n[data-ML__tooltip][data-placement='top']::after {\n  top: inherit;\n  bottom: 100%;\n}\n[data-ML__tooltip]::after {\n  content: attr(data-ML__tooltip);\n  position: absolute;\n  display: none;\n  z-index: 2;\n  right: 110%;\n  left: calc(100% + 8px);\n  width: max-content;\n  max-width: 200px;\n  padding: 8px 8px;\n  border-radius: 2px;\n  background: #616161;\n  color: #fff;\n  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);\n  text-align: center;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-weight: 400;\n  font-size: 12px;\n  /* Phone */\n  opacity: 0;\n  transform: scale(0.5);\n  transition: all 0.15s cubic-bezier(0.4, 0, 1, 1);\n}\n@media only screen and (max-width: 767px) {\n  [data-ML__tooltip]::after {\n    padding: 8px 16px;\n    font-size: 16px;\n  }\n}\n:not(.tracking) [data-ML__tooltip]:hover {\n  position: relative;\n}\n:not(.tracking) [data-ML__tooltip]:hover::after {\n  visibility: visible;\n  display: inline-table;\n  opacity: 1;\n  transform: scale(1);\n}\n[data-ML__tooltip][data-delay]::after {\n  transition-delay: 0s;\n}\n[data-ML__tooltip][data-delay]:hover::after {\n  transition-delay: 1s;\n  /* attr(data-delay); Should work. But doesn't. */\n}\n";
    var PRINTABLE_KEYCODE = /* @__PURE__ */ new Set([
      "Backquote",
      // Japanese keyboard: hankaku/zenkaku/kanji key, which is non-printable
      "Digit0",
      "Digit1",
      "Digit2",
      "Digit3",
      "Digit4",
      "Digit5",
      "Digit6",
      "Digit7",
      "Digit8",
      "Digit9",
      "Minus",
      "Equal",
      "IntlYen",
      // Japanese Keyboard. Russian keyboard: \/
      "KeyQ",
      // AZERTY keyboard: labeled 'a'
      "KeyW",
      // AZERTY keyboard: labeled 'z'
      "KeyE",
      "KeyR",
      "KeyT",
      "KeyY",
      // QWERTZ keyboard: labeled 'z'
      "KeyU",
      "KeyI",
      "KeyO",
      "KeyP",
      "BracketLeft",
      "BracketRight",
      // On the Windows Swedish keyboard, this is the `¨` key, which is a dead key
      "Backslash",
      // May be labeled #~ on UK 102 keyboard
      "KeyA",
      // AZERTY keyboard: labeled 'q'
      "KeyS",
      "KeyD",
      "KeyF",
      "KeyG",
      "KeyH",
      "KeyJ",
      "KeyK",
      "KeyL",
      "Semicolon",
      "Quote",
      "IntlBackslash",
      // QWERTZ keyboard '><'
      "KeyZ",
      // AZERTY: 'w', QWERTZ: 'y'
      "KeyX",
      "KeyC",
      "KeyV",
      "KeyB",
      "KeyN",
      "KeyM",
      "Comma",
      "Period",
      "Slash",
      "IntlRo",
      // Japanese keyboard '\ろ'
      "Space",
      "Numpad0",
      "Numpad1",
      "Numpad2",
      "Numpad3",
      "Numpad4",
      "Numpad5",
      "Numpad6",
      "Numpad7",
      "Numpad8",
      "Numpad9",
      "NumpadAdd",
      "NumpadComma",
      "NumpadDecimal",
      "NumpadDivide",
      "NumpadEqual",
      "NumpadHash",
      "NumpadMultiply",
      "NumpadParenLeft",
      "NumpadParenRight",
      "NumpadStar",
      "NumpadSubstract"
    ]);
    function mightProducePrintableCharacter(evt) {
      if (evt.ctrlKey || evt.metaKey)
        return false;
      if (["Dead", "Process"].includes(evt.key))
        return false;
      if (evt.code === "")
        return true;
      return PRINTABLE_KEYCODE.has(evt.code);
    }
    function keyboardEventToString(evt) {
      evt = normalizeKeyboardEvent(evt);
      const modifiers = [];
      if (evt.ctrlKey)
        modifiers.push("ctrl");
      if (evt.metaKey)
        modifiers.push("meta");
      if (evt.altKey)
        modifiers.push("alt");
      if (evt.shiftKey)
        modifiers.push("shift");
      if (modifiers.length === 0)
        return "[" + evt.code + "]";
      modifiers.push("[" + evt.code + "]");
      return modifiers.join("+");
    }
    function delegateKeyboardEvents(keyboardSink, element, handlers) {
      let keydownEvent = null;
      let keypressEvent = null;
      let compositionInProgress = false;
      let focusInProgress = false;
      let blurInProgress = false;
      keyboardSink.addEventListener(
        "keydown",
        (event) => {
          if (compositionInProgress || event.key === "Process" || event.code === "CapsLock" || /(Control|Meta|Alt|Shift)(Left|Right)/.test(event.code)) {
            keydownEvent = null;
            return;
          }
          keydownEvent = event;
          keypressEvent = null;
          if (!handlers.onKeystroke(keyboardEventToString(event), event))
            keydownEvent = null;
          else
            keyboardSink.textContent = "";
        },
        true
      );
      keyboardSink.addEventListener(
        "keypress",
        (event) => {
          if (compositionInProgress)
            return;
          if (keydownEvent && keypressEvent)
            handlers.onKeystroke(keyboardEventToString(keydownEvent), keydownEvent);
          keypressEvent = event;
        },
        true
      );
      keyboardSink.addEventListener(
        "compositionstart",
        (event) => {
          keyboardSink.textContent = "";
          compositionInProgress = true;
          handlers.onCompositionStart(event.data);
        },
        true
      );
      keyboardSink.addEventListener(
        "compositionupdate",
        (ev) => {
          if (!compositionInProgress)
            return;
          handlers.onCompositionUpdate(ev.data);
        },
        true
      );
      keyboardSink.addEventListener(
        "compositionend",
        (ev) => {
          keyboardSink.textContent = "";
          if (!compositionInProgress)
            return;
          compositionInProgress = false;
          handlers.onCompositionEnd(ev.data);
        },
        true
      );
      keyboardSink.addEventListener(
        "beforeinput",
        (ev) => ev.stopImmediatePropagation()
      );
      keyboardSink.addEventListener("input", (ev) => {
        var _a3;
        if (compositionInProgress)
          return;
        keyboardSink.textContent = "";
        if (ev.inputType === "insertCompositionText")
          return;
        if (ev.inputType === "insertFromPaste") {
          ev.preventDefault();
          ev.stopPropagation();
          return;
        }
        handlers.onInput((_a3 = ev.data) != null ? _a3 : "");
        ev.preventDefault();
        ev.stopPropagation();
      });
      keyboardSink.addEventListener(
        "paste",
        (event) => {
          keyboardSink.focus();
          keyboardSink.textContent = "";
          if (!handlers.onPaste(event))
            event.preventDefault();
          event.stopImmediatePropagation();
        },
        true
      );
      keyboardSink.addEventListener("cut", (ev) => handlers.onCut(ev), true);
      keyboardSink.addEventListener("copy", (ev) => handlers.onCopy(ev), true);
      keyboardSink.addEventListener(
        "blur",
        (event) => {
          var _a3, _b3, _c2, _d2;
          if (((_b3 = (_a3 = event["relatedTarget"]) == null ? void 0 : _a3["_mathfield"]) == null ? void 0 : _b3["element"]) === element) {
            keyboardSink.focus();
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          const scrimState = (_c2 = Scrim.scrim) == null ? void 0 : _c2.state;
          if (scrimState === "open" || scrimState === "opening") {
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          if (event.relatedTarget === event.target.getRootNode().host) {
            event.preventDefault();
            event.stopPropagation();
            return;
          }
          if (blurInProgress || focusInProgress)
            return;
          blurInProgress = true;
          keydownEvent = null;
          keypressEvent = null;
          (_d2 = handlers.onBlur) == null ? void 0 : _d2.call(handlers);
          blurInProgress = false;
        },
        true
      );
      keyboardSink.addEventListener(
        "focus",
        (_evt) => {
          var _a3;
          if (blurInProgress || focusInProgress)
            return;
          focusInProgress = true;
          (_a3 = handlers.onFocus) == null ? void 0 : _a3.call(handlers);
          focusInProgress = false;
        },
        true
      );
      return {
        cancelComposition: () => {
          if (!compositionInProgress)
            return;
          keyboardSink.blur();
          requestAnimationFrame(() => keyboardSink.focus());
        },
        blur: () => {
          if (typeof keyboardSink.blur === "function")
            keyboardSink.blur();
        },
        focus: () => {
          if (!focusInProgress && typeof keyboardSink.focus === "function")
            keyboardSink.focus();
        },
        hasFocus: () => {
          return deepActiveElement2() === keyboardSink;
        },
        setAriaLabel: (value) => keyboardSink.setAttribute("aria-label", value),
        setValue: (value) => {
          var _a3;
          keyboardSink.textContent = value;
          keyboardSink.style.top = `-1000px`;
          (_a3 = window.getSelection()) == null ? void 0 : _a3.selectAllChildren(keyboardSink);
        },
        moveTo: (x, y) => {
          keyboardSink.style.top = `${y}px`;
          keyboardSink.style.left = `${x}px`;
        }
      };
    }
    function deepActiveElement2() {
      var _a3;
      let a = document.activeElement;
      while ((_a3 = a == null ? void 0 : a.shadowRoot) == null ? void 0 : _a3.activeElement)
        a = a.shadowRoot.activeElement;
      return a;
    }
    function eventToChar(evt) {
      var _a3;
      if (!evt)
        return "";
      let result;
      if (evt.key === "Unidentified") {
        if (evt.target)
          result = evt.target.value;
      }
      result = (_a3 = result != null ? result : evt.key) != null ? _a3 : evt.code;
      if (/^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(
        result
      ))
        result = "";
      return result;
    }
    var UndoManager = class {
      // Index pointing to the current record in the undo/redo stack
      constructor(model) {
        this.recording = false;
        this.canCoalesce = false;
        this.model = model;
        this.reset();
      }
      // Maximum number of undo/redo states
      get maximumDepth() {
        return 1e3;
      }
      reset() {
        this.stack = [];
        this.index = -1;
      }
      startRecording() {
        this.recording = true;
      }
      canUndo() {
        return this.index > 0;
      }
      canRedo() {
        return this.index !== this.stack.length - 1;
      }
      undo() {
        if (!this.canUndo())
          return false;
        this.model.setState(this.stack[this.index - 1], {
          suppressChangeNotifications: false,
          type: "undo"
        });
        this.index -= 1;
        this.canCoalesce = false;
        return true;
      }
      redo() {
        if (!this.canRedo())
          return false;
        this.index += 1;
        this.model.setState(this.stack[this.index], {
          suppressChangeNotifications: false,
          type: "redo"
        });
        this.canCoalesce = false;
        return true;
      }
      pop() {
        if (!this.canUndo())
          return;
        this.index -= 1;
        this.stack.pop();
      }
      /**
       * Push a snapshot of the content and selection of the mathfield onto the
       * undo stack so that it can potentially be reverted to later.
       *
       * **Return** `true` if the undo state changed
       */
      snapshot() {
        if (!this.recording)
          return false;
        this.stack.splice(this.index + 1, this.stack.length - this.index - 1);
        this.stack.push(this.model.getState());
        this.index++;
        if (this.stack.length > this.maximumDepth)
          this.stack.shift();
        this.canCoalesce = false;
        return true;
      }
      snapshotAndCoalesce() {
        if (!this.recording)
          return false;
        if (this.canCoalesce)
          this.pop();
        const result = this.snapshot();
        this.canCoalesce = true;
        return result;
      }
    };
    function moveAfterParent(model) {
      const previousPosition = model.position;
      const parent = model.at(previousPosition).parent;
      if (!parent || parent.type === "root") {
        model.announce("plonk");
        return false;
      }
      model.position = model.offsetOf(parent);
      model.announce("move", previousPosition);
      return true;
    }
    function superscriptDepth(model) {
      let result = 0;
      let atom = model.at(model.position);
      let wasSuperscript = false;
      while (atom) {
        if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))
          result += 1;
        if (!atom.hasEmptyBranch("superscript"))
          wasSuperscript = true;
        else if (!atom.hasEmptyBranch("subscript"))
          wasSuperscript = false;
        atom = atom.parent;
      }
      return wasSuperscript ? result : 0;
    }
    function subscriptDepth(model) {
      let result = 0;
      let atom = model.at(model.position);
      let wasSubscript = false;
      while (atom) {
        if (!atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript"))
          result += 1;
        if (!atom.hasEmptyBranch("superscript"))
          wasSubscript = false;
        else if (!atom.hasEmptyBranch("subscript"))
          wasSubscript = true;
        atom = atom.parent;
      }
      return wasSubscript ? result : 0;
    }
    function moveToSuperscript(model) {
      var _a3;
      model.collapseSelection();
      if (superscriptDepth(model) >= model.mathfield.options.scriptDepth[1]) {
        model.announce("plonk");
        return false;
      }
      let target = model.at(model.position);
      if (target.subsupPlacement === void 0) {
        if (((_a3 = target.rightSibling) == null ? void 0 : _a3.type) !== "msubsup") {
          target.parent.addChildAfter(
            new SubsupAtom(model.mathfield, { style: target.computedStyle }),
            target
          );
        }
        target = target.rightSibling;
      }
      target.createBranch("superscript");
      model.setSelection(
        model.getSiblingsRange(model.offsetOf(target.superscript[0]))
      );
      return true;
    }
    function moveToSubscript(model) {
      var _a3;
      model.collapseSelection();
      if (subscriptDepth(model) >= model.mathfield.options.scriptDepth[0]) {
        model.announce("plonk");
        return false;
      }
      let target = model.at(model.position);
      if (target.subsupPlacement === void 0) {
        if (((_a3 = model.at(model.position + 1)) == null ? void 0 : _a3.type) !== "msubsup") {
          target.parent.addChildAfter(
            new SubsupAtom(model.mathfield, {
              style: model.at(model.position).computedStyle
            }),
            target
          );
        }
        target = model.at(model.position + 1);
      }
      target.createBranch("subscript");
      model.setSelection(
        model.getSiblingsRange(model.offsetOf(target.subscript[0]))
      );
      return true;
    }
    function getTabbableElements() {
      function tabbable(element) {
        const regularTabbables = [];
        const orderedTabbables = [];
        const candidates = [
          ...element.querySelectorAll(`input, select, textarea, a[href], button,
        [tabindex], audio[controls], video[controls],
        [contenteditable]:not([contenteditable="false"]), details>summary`)
        ].filter(isNodeMatchingSelectorTabbable);
        candidates.forEach((candidate, i) => {
          const candidateTabindex = getTabindex(candidate);
          if (candidateTabindex === 0)
            regularTabbables.push(candidate);
          else {
            orderedTabbables.push({
              documentOrder: i,
              tabIndex: candidateTabindex,
              node: candidate
            });
          }
        });
        return orderedTabbables.sort(
          (a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex
        ).map((a) => a.node).concat(regularTabbables);
      }
      function isNodeMatchingSelectorTabbable(element) {
        if (!isNodeMatchingSelectorFocusable(element) || isNonTabbableRadio(element) || getTabindex(element) < 0)
          return false;
        return true;
      }
      function isNodeMatchingSelectorFocusable(node) {
        if (node.disabled || node.type === "hidden" && node.tagName.toUpperCase() === "INPUT" || isHidden(node))
          return false;
        return true;
      }
      function getTabindex(node) {
        var _a3;
        const tabindexAttr = Number.parseInt(
          (_a3 = node.getAttribute("tabindex")) != null ? _a3 : "NaN",
          10
        );
        if (!Number.isNaN(tabindexAttr))
          return tabindexAttr;
        if (node.contentEditable === "true")
          return 0;
        if ((node.nodeName === "AUDIO" || node.nodeName === "VIDEO") && node.getAttribute("tabindex") === null)
          return 0;
        return node.tabIndex;
      }
      function isNonTabbableRadio(node) {
        return node.tagName.toUpperCase() === "INPUT" && node.type === "radio" && !isTabbableRadio(node);
      }
      function getCheckedRadio(nodes, form) {
        for (const node of nodes)
          if (node.checked && node.form === form)
            return node;
        return null;
      }
      function isTabbableRadio(node) {
        var _a3;
        if (!node.name)
          return true;
        const radioScope = (_a3 = node.form) != null ? _a3 : node.ownerDocument;
        const radioSet = radioScope.querySelectorAll(
          'input[type="radio"][name="' + node.name + '"]'
        );
        const checked = getCheckedRadio(radioSet, node.form);
        return !checked || checked === node;
      }
      function isHidden(element) {
        if (!isBrowser() || element === document.activeElement || element.contains(document.activeElement))
          return false;
        if (getComputedStyle(element).visibility === "hidden")
          return true;
        const bounds = element.getBoundingClientRect();
        if (bounds.width === 0 || bounds.height === 0)
          return true;
        while (element) {
          if (getComputedStyle(element).display === "none")
            return true;
          element = element.parentElement;
        }
        return false;
      }
      if (!isBrowser())
        return [];
      return tabbable(document.body);
    }
    function leap(model, dir, callHooks = true) {
      var _a3, _b3;
      const dist = dir === "forward" ? 1 : -1;
      if (model.at(model.anchor).type === "placeholder")
        move(model, dir);
      let origin;
      const parentPrompt = model.at(model.anchor).parentPrompt;
      if (parentPrompt) {
        if (dir === "forward")
          origin = model.offsetOf(parentPrompt) + 1;
        else
          origin = model.offsetOf(parentPrompt.leftSibling);
      } else
        origin = Math.max(model.position + dist, 0);
      const target = model.findAtom(
        (atom) => atom.type === "placeholder" || atom.type === "prompt" || !model.mathfield.readOnly && atom.treeDepth > 2 && atom.isFirstSibling && atom.isLastSibling,
        origin,
        dir
      );
      if (!target || dir === "forward" && model.offsetOf(target) < origin || dir === "backward" && model.offsetOf(target) > origin) {
        const handled = !callHooks || !((_b3 = (_a3 = model.mathfield.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("move-out", {
            detail: { direction: dir },
            cancelable: true,
            bubbles: true,
            composed: true
          })
        )) != null ? _b3 : true);
        if (handled) {
          model.announce("plonk");
          return false;
        }
        const tabbable = getTabbableElements();
        if (!document.activeElement || tabbable.length <= 1) {
          model.announce("plonk");
          return false;
        }
        let index = tabbable.indexOf(document.activeElement) + dist;
        if (index < 0)
          index = tabbable.length - 1;
        if (index >= tabbable.length)
          index = 0;
        tabbable[index].focus();
        return true;
      }
      const previousPosition = model.position;
      if (target.type === "prompt") {
        model.setSelection(
          model.offsetOf(target.firstChild),
          model.offsetOf(target.lastChild)
        );
      } else {
        const newPosition = model.offsetOf(target);
        if (target.type === "placeholder")
          model.setSelection(newPosition - 1, newPosition);
        else
          model.position = newPosition;
      }
      model.announce("move", previousPosition);
      return true;
    }
    register2(
      {
        moveToOpposite: (model) => {
          const OPPOSITE_RELATIONS = {
            superscript: "subscript",
            subscript: "superscript",
            above: "below",
            below: "above"
          };
          const cursor = model.at(model.position);
          const { parent } = cursor;
          if (!parent) {
            model.announce("plonk");
            return false;
          }
          const relation = cursor.treeBranch;
          let oppositeRelation;
          if (typeof relation === "string")
            oppositeRelation = OPPOSITE_RELATIONS[relation];
          if (!oppositeRelation) {
            if (!cursor.subsupPlacement)
              return moveToSuperscript(model);
            return moveToSubscript(model);
          }
          if (!parent.branch(oppositeRelation)) {
            parent.createBranch(oppositeRelation);
          }
          return model.setSelection(
            model.getBranchRange(model.offsetOf(parent), oppositeRelation)
          );
        },
        moveBeforeParent: (model) => {
          const { parent } = model.at(model.position);
          if (!parent) {
            model.announce("plonk");
            return false;
          }
          model.position = model.offsetOf(parent);
          return true;
        },
        moveAfterParent: (model) => moveAfterParent(model),
        moveToNextPlaceholder: (model) => leap(model, "forward"),
        moveToPreviousPlaceholder: (model) => leap(model, "backward"),
        moveToNextChar: (model) => move(model, "forward"),
        moveToPreviousChar: (model) => move(model, "backward"),
        moveUp: (model) => move(model, "upward"),
        moveDown: (model) => move(model, "downward"),
        moveToNextWord: (model) => skip(model, "forward"),
        moveToPreviousWord: (model) => skip(model, "backward"),
        moveToGroupStart: (model) => {
          const pos = model.offsetOf(model.at(model.position).firstSibling);
          if (pos === model.position) {
            model.announce("plonk");
            return false;
          }
          model.position = pos;
          return true;
        },
        moveToGroupEnd: (model) => {
          const pos = model.offsetOf(model.at(model.position).lastSibling);
          if (pos === model.position) {
            model.announce("plonk");
            return false;
          }
          model.position = pos;
          return true;
        },
        moveToMathfieldStart: (model) => {
          if (model.position === 0) {
            model.announce("plonk");
            return false;
          }
          model.position = 0;
          return true;
        },
        moveToMathfieldEnd: (model) => {
          if (model.position === model.lastOffset) {
            model.announce("plonk");
            return false;
          }
          model.position = model.lastOffset;
          return true;
        },
        moveToSuperscript: (model) => moveToSuperscript(model),
        moveToSubscript: (model) => moveToSubscript(model)
      },
      { target: "model", category: "selection-anchor" }
    );
    function convertLastAtomsToText(model, count, until) {
      if (typeof count === "function") {
        until = count;
        count = Infinity;
      }
      if (count === void 0)
        count = Infinity;
      let i = model.position;
      let done = false;
      let text = "";
      while (!done) {
        const atom = model.at(i);
        done = count === 0 || atom === void 0 || atom.mode !== "math" || !(/mord|textord|mpunct/.test(atom.type) || atom.type === "mop" && /[a-zA-Z]+/.test(atom.value)) || !atom.hasEmptyBranch("superscript") || !atom.hasEmptyBranch("subscript") || typeof until === "function" && !until(atom);
        if (!done) {
          atom.mode = "text";
          atom.command = atom.value;
          atom.verbatimLatex = void 0;
          text += atom.value;
        }
        i -= 1;
        count -= 1;
      }
      contentDidChange(model, { data: text, inputType: "insertText" });
    }
    function convertLastAtomsToMath(model, count, until) {
      if (typeof count === "function") {
        until = count;
        count = Infinity;
      }
      if (count === void 0)
        count = Infinity;
      let i = model.position;
      let done = false;
      const data = [];
      while (!done) {
        const atom = model.at(i);
        done = count === 0 || !atom || atom.isFirstSibling || atom.mode !== "text" || atom.value === " " || until && !until(atom);
        if (!done) {
          data.push(atom.serialize({ defaultMode: "math" }));
          atom.mode = "math";
        }
        i -= 1;
        count -= 1;
      }
      removeIsolatedSpace(model);
      contentDidChange(model, { data: joinLatex(data), inputType: "insertText" });
    }
    function removeIsolatedSpace(model) {
      var _a3;
      let i = model.position - 1;
      while (i >= 0 && ((_a3 = model.at(i)) == null ? void 0 : _a3.mode) === "math")
        i -= 1;
      if (i < 0)
        return;
      if (model.at(i).mode === "text" && model.at(i).value === " " && model.at(i - 1).mode === "math") {
        model.at(i - 1).parent.removeChild(model.at(i - 1));
        const save = model.suppressChangeNotifications;
        model.suppressChangeNotifications = true;
        model.position -= 1;
        model.suppressChangeNotifications = save;
        contentDidChange(model, { inputType: "deleteContent" });
      }
    }
    function getTextBeforePosition(model) {
      let result = "";
      let i = model.position;
      let done = false;
      while (!done) {
        const atom = model.at(i);
        done = !(atom && (atom.mode === "text" || atom.mode === "math" && /mord|textord|mpunct/.test(atom.type)));
        if (!done)
          result = atom.value + result;
        i -= 1;
      }
      return result;
    }
    function smartMode(mathfield, keystroke, evt) {
      if (mathfield.smartModeSuppressed)
        return false;
      const { model } = mathfield;
      if (!model.at(model.position).isLastSibling)
        return false;
      if (!evt || !mightProducePrintableCharacter(evt))
        return false;
      const c = eventToChar(evt);
      if (!model.selectionIsCollapsed) {
        if (mathfield.mode === "text") {
          if (/[/_^]/.test(c))
            return true;
        }
        return false;
      }
      const context = getTextBeforePosition(model) + c;
      if (mathfield.mode === "text") {
        if (keystroke === "Esc" || /[/\\]/.test(c)) {
          return true;
        }
        if (/[\^_]/.test(c)) {
          if (/(^|\s)[a-zA-Z][^_]$/.test(context)) {
            convertLastAtomsToMath(model, 1);
          }
          return true;
        }
        const lFence = { ")": "(", "}": "{", "]": "[" }[c];
        const { parent } = model.at(model.position);
        if (lFence && parent instanceof LeftRightAtom && parent.leftDelim === lFence)
          return true;
        if (/(^|[^a-zA-Z])(a|I) $/.test(context)) {
          return false;
        }
        if (/[$€£₤₺¥¤฿¢₡₧₨₹₩₱]/u.test(c)) {
          return true;
        }
        if (/(^|[^a-zA-Z'’])[a-zA-Z] $/.test(context)) {
          convertLastAtomsToMath(model, 1);
          return false;
        }
        if (/\D\.[^\d\s]$/.test(context)) {
          convertLastAtomsToMath(model, 1);
          const atom = model.at(model.position);
          atom.value = "⋅";
          atom.style.variant = "normal";
          atom.command = "\\cdot";
          atom.verbatimLatex = void 0;
          contentDidChange(model, { data: "\\cdot", inputType: "insertText" });
          return true;
        }
        if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(context)) {
          convertLastAtomsToMath(model, 1);
          return true;
        }
        if (/\.\d$/.test(context)) {
          convertLastAtomsToMath(model, 1);
          return true;
        }
        if (/\([\d+\-.]$/.test(context)) {
          convertLastAtomsToMath(model, 1);
          return true;
        }
        if (/\([a-z][,;]$/.test(context)) {
          convertLastAtomsToMath(model, 2);
          return true;
        }
        if (/[\d+\-=><*|]$/.test(c)) {
          removeIsolatedSpace(model);
          return true;
        }
      } else {
        if (keystroke === "[Space]") {
          convertLastAtomsToText(
            model,
            void 0,
            (a) => /[a-z][:,;.]$/.test(a.value)
          );
          return true;
        }
        if (/[a-zA-Z]{3,}$/.test(context) && !/(dxd|abc|xyz|uvw)$/.test(context)) {
          convertLastAtomsToText(model, void 0, (a) => /[a-zA-Z]/.test(a.value));
          return true;
        }
        if (/(^|\W)(if)$/i.test(context)) {
          convertLastAtomsToText(model, 1);
          return true;
        }
        if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(
          context
        ) && !/(αβγ)$/.test(context)) {
          convertLastAtomsToText(
            model,
            void 0,
            (a) => /(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(
              a.value
            )
          );
          return true;
        }
        if (c === "?") {
          return true;
        }
        if (c === "." && !/[\d-+]\.$/.test(context)) {
          return true;
        }
      }
      return false;
    }
    var keystroke_caption_default = "/* The element that displays the keys as the user type them */\n#mathlive-keystroke-caption-panel {\n  visibility: hidden;\n  /*min-width: 160px;*/\n  /*background-color: rgba(97, 97, 200, .95);*/\n  background: var(--secondary, hsl(var(--hue, 212), 19%, 26%));\n  border-color: var(--secondary-border, hsl(0, 0%, 91%));\n  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);\n  text-align: center;\n  border-radius: 6px;\n  padding: 16px;\n  position: absolute;\n  z-index: 1;\n  display: flex;\n  flex-direction: row-reverse;\n  justify-content: center;\n  --keystroke: white;\n  --on-keystroke: #555;\n  --keystroke-border: #f7f7f7;\n}\n@media (prefers-color-scheme: dark) {\n  body:not([theme='light']) #mathlive-keystroke-caption-panel {\n    --keystroke: hsl(var(--hue, 212), 50%, 30%);\n    --on-keystroke: hsl(0, 0%, 98%);\n    --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n  }\n}\nbody[theme='dark'] #mathlive-keystroke-caption-panel {\n  --keystroke: hsl(var(--hue, 212), 50%, 30%);\n  --on-keystroke: hsl(0, 0%, 98%);\n  --keystroke-border: hsl(var(--hue, 212), 50%, 25%);\n}\n#mathlive-keystroke-caption-panel > span {\n  min-width: 14px;\n  /*height: 8px;*/\n  margin: 0 8px 0 0;\n  padding: 4px;\n  background-color: var(--keystroke);\n  color: var(--on-keystroke);\n  fill: currentColor;\n  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\n  font-size: 1em;\n  border-radius: 6px;\n  border: 2px solid var(--keystroke-border);\n  /*box-shadow: 0 7px 14px rgba(0,0,0,0.25), 0 5px 5px rgba(0,0,0,0.22);*/\n}\n";
    var KEYSTROKE_CAPTION_STYLESHEET_HASH = void 0;
    var gKeystrokeCaptionStylesheet = null;
    var gCoreStylesheet3 = null;
    function showKeystroke(mathfield, keystroke) {
      if (!mathfield.isSelectionEditable || !mathfield.keystrokeCaptionVisible)
        return;
      const vb = createKeystrokeCaption(mathfield);
      const bounds = mathfield.element.getBoundingClientRect();
      vb.style.left = `${bounds.left}px`;
      vb.style.top = `${bounds.top - 64}px`;
      vb.innerHTML = window.MathfieldElement.createHTML(
        "<span>" + (getKeybindingMarkup(keystroke) || keystroke) + "</span>" + vb.innerHTML
      );
      vb.style.visibility = "visible";
      setTimeout(() => {
        if (vb.childNodes.length > 0)
          vb.childNodes[vb.childNodes.length - 1].remove();
        if (vb.childNodes.length === 0)
          vb.style.visibility = "hidden";
      }, 3e3);
    }
    function toggleKeystrokeCaption(mathfield) {
      mathfield.keystrokeCaptionVisible = !mathfield.keystrokeCaptionVisible;
      if (!mathfield.keystrokeCaptionVisible) {
        if (mathfield.keystrokeCaption)
          mathfield.keystrokeCaption.style.visibility = "hidden";
      } else {
        mathfield.keystrokeCaption = createKeystrokeCaption(mathfield);
        mathfield.keystrokeCaption.innerHTML = "";
      }
      return false;
    }
    function createKeystrokeCaption(mf) {
      if (mf.keystrokeCaption)
        return mf.keystrokeCaption;
      mf.keystrokeCaption = getSharedElement("mathlive-keystroke-caption-panel");
      if (KEYSTROKE_CAPTION_STYLESHEET_HASH === void 0) {
        KEYSTROKE_CAPTION_STYLESHEET_HASH = hashCode(
          keystroke_caption_default
        ).toString(36);
      }
      gKeystrokeCaptionStylesheet = inject2(
        null,
        keystroke_caption_default,
        KEYSTROKE_CAPTION_STYLESHEET_HASH
      );
      gCoreStylesheet3 = inject2(
        null,
        core_default,
        hashCode(core_default).toString(36)
      );
      return mf.keystrokeCaption;
    }
    function disposeKeystrokeCaption(mf) {
      releaseSharedElement(mf.keystrokeCaption);
      if (gKeystrokeCaptionStylesheet)
        gKeystrokeCaptionStylesheet.release();
      if (gCoreStylesheet3)
        gCoreStylesheet3.release();
      delete mf.keystrokeCaption;
    }
    var MathModeEditor = class extends ModeEditor {
      constructor() {
        super("math");
      }
      onPaste(mathfield, data) {
        if (!data)
          return false;
        if (!contentWillChange(mathfield.model, {
          data: typeof data === "string" ? data : null,
          dataTransfer: typeof data === "string" ? null : data,
          inputType: "insertFromPaste"
        }))
          return false;
        let text = "";
        let format = "auto";
        let json = typeof data !== "string" ? data.getData("application/json+mathlive") : "";
        if (json) {
          try {
            const atomJson = JSON.parse(json);
            if (atomJson && Array.isArray(atomJson)) {
              mathfield.snapshot();
              const atoms = fromJson(atomJson, mathfield);
              const { model } = mathfield;
              if (!model.selectionIsCollapsed)
                model.deleteAtoms(range(model.selection));
              const cursor = model.at(model.position);
              if (cursor.parent instanceof ArrayAtom) {
                console.assert(cursor.treeBranch !== void 0);
                const columns = [];
                let buffer2 = [];
                if (atoms[0].type === "first")
                  atoms.shift();
                if (atoms[atoms.length - 1].type === "first")
                  atoms.pop();
                for (const atom of atoms) {
                  if (atom.type === "first" && buffer2.length > 0) {
                    columns.push(buffer2);
                    buffer2 = [atom];
                  } else
                    buffer2.push(atom);
                }
                if (buffer2.length > 0)
                  columns.push(buffer2);
                let currentRow = Number(cursor.treeBranch[0]);
                let currentColumn = Number(cursor.treeBranch[1]);
                const maxColumns = cursor.parent.maxColumns;
                while (cursor.parent.colCount - currentColumn < columns.length && cursor.parent.colCount < maxColumns)
                  cursor.parent.addColumn();
                cursor.parent.addChildrenAfter(columns[0], cursor);
                for (let i = 1; i < columns.length; i++) {
                  currentColumn++;
                  if (currentColumn >= maxColumns) {
                    currentColumn = 0;
                    cursor.parent.addRowAfter(currentRow);
                    currentRow++;
                  }
                  cursor.parent.setCell(currentRow, currentColumn, columns[i]);
                }
              } else {
                cursor.parent.addChildrenAfter(
                  atoms.filter((a) => a.type !== "first"),
                  cursor
                );
              }
              model.position = model.offsetOf(atoms[atoms.length - 1]);
              contentDidChange(model, { inputType: "insertFromPaste" });
              requestUpdate(mathfield);
              return true;
            }
          } catch (e) {
          }
        }
        json = typeof data !== "string" ? data.getData("application/json") : "";
        if (json && window.MathfieldElement.computeEngine) {
          try {
            const expr = JSON.parse(json);
            if (typeof expr === "object" && "latex" in expr && expr.latex)
              text = expr.latex;
            if (!text) {
              const box = window.MathfieldElement.computeEngine.box(expr);
              if (box && !box.has("Error"))
                text = box.latex;
            }
            if (!text)
              format = "latex";
          } catch (e) {
          }
        }
        if (!text && typeof data !== "string") {
          text = data.getData("application/x-latex");
          if (text)
            format = "latex";
        }
        if (!text)
          text = typeof data === "string" ? data : data.getData("text/plain");
        if (text) {
          mathfield.snapshot();
          let wasLatex;
          [wasLatex, text] = trimModeShiftCommand(text);
          if (format === "auto" && wasLatex)
            format = "latex";
          if (this.insert(mathfield.model, text, { format }))
            requestUpdate(mathfield);
          return true;
        }
        return false;
      }
      insert(model, input, options) {
        var _a3, _b3;
        const data = typeof input === "string" ? input : (_b3 = (_a3 = window.MathfieldElement.computeEngine) == null ? void 0 : _a3.box(input).latex) != null ? _b3 : "";
        if (!options.suppressChangeNotifications && !contentWillChange(model, { data, inputType: "insertText" }))
          return false;
        if (!options.insertionMode)
          options.insertionMode = "replaceSelection";
        if (!options.selectionMode)
          options.selectionMode = "placeholder";
        if (!options.format)
          options.format = "auto";
        if (!model.mathfield.smartFence) {
          if (options.insertionMode !== "replaceAll") {
            const { parent: parent2 } = model.at(model.position);
            if (parent2 instanceof LeftRightAtom && parent2.rightDelim === "?" && model.at(model.position).isLastSibling && typeof input === "string" && /^[)}\]|]$/.test(input)) {
              parent2.isDirty = true;
              parent2.rightDelim = input;
              model.position += 1;
              selectionDidChange(model);
              contentDidChange(model, { data, inputType: "insertText" });
              return true;
            }
          }
        } else if (model.selectionIsCollapsed && typeof input === "string" && insertSmartFence(model, input, options.style))
          return true;
        const { suppressChangeNotifications } = model;
        if (options.suppressChangeNotifications)
          model.suppressChangeNotifications = true;
        const contentWasChanging = model.suppressChangeNotifications;
        model.suppressChangeNotifications = true;
        const args = {};
        args[0] = options.insertionMode === "replaceAll" ? "" : model.getValue(model.selection, "latex-unstyled");
        args["?"] = "\\placeholder{}";
        args["@"] = args["?"];
        if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
          model.deleteAtoms(range(model.selection));
        else if (options.insertionMode === "replaceAll") {
          model.root.setChildren([], "body");
          model.position = 0;
        } else if (options.insertionMode === "insertBefore")
          model.collapseSelection("backward");
        else if (options.insertionMode === "insertAfter")
          model.collapseSelection("forward");
        if (!model.at(model.position).isLastSibling && model.at(model.position + 1).type === "placeholder") {
          model.deleteAtoms([model.position, model.position + 1]);
        } else if (model.at(model.position).type === "placeholder") {
          model.deleteAtoms([model.position - 1, model.position]);
        }
        if (args[0]) {
          args["@"] = args[0];
        } else if (typeof input === "string" && /(^|[^\\])#@/.test(input)) {
          const offset = getImplicitArgOffset(model);
          if (offset >= 0) {
            args["@"] = model.getValue(offset, model.position, "latex-unstyled");
            model.deleteAtoms([offset, model.position]);
          }
        }
        if (!args[0])
          args[0] = args["?"];
        let usedArg = false;
        const argFunction = (arg) => {
          usedArg = true;
          return args[arg];
        };
        const [format, newAtoms] = convertStringToAtoms(
          model,
          input,
          argFunction,
          options
        );
        if (!newAtoms)
          return false;
        const { parent } = model.at(model.position);
        if (format !== "latex" && model.options.removeExtraneousParentheses && parent instanceof LeftRightAtom && parent.leftDelim === "(" && parent.hasEmptyBranch("body") && newAtoms.length === 1 && newAtoms[0].type === "genfrac") {
          const newParent = parent.parent;
          const branch = parent.treeBranch;
          newParent.removeChild(parent);
          newParent.setChildren(newAtoms, branch);
        }
        const hadEmptyBody = parent.hasEmptyBranch("body");
        const cursor = model.at(model.position);
        cursor.parent.addChildrenAfter(newAtoms, cursor);
        if (format === "latex" && typeof input === "string") {
          if (parent.type === "root" && hadEmptyBody && !usedArg)
            parent.verbatimLatex = input;
        }
        model.suppressChangeNotifications = contentWasChanging;
        const lastNewAtom = newAtoms[newAtoms.length - 1];
        if (options.selectionMode === "placeholder") {
          const placeholder = newAtoms.flatMap((x) => [x, ...x.children]).find((x) => x.type === "placeholder");
          if (placeholder) {
            const placeholderOffset = model.offsetOf(placeholder);
            model.setSelection(placeholderOffset - 1, placeholderOffset);
            model.announce("move");
          } else if (lastNewAtom) {
            model.position = model.offsetOf(lastNewAtom);
          }
        } else if (options.selectionMode === "before")
          ;
        else if (options.selectionMode === "after") {
          if (lastNewAtom)
            model.position = model.offsetOf(lastNewAtom);
        } else if (options.selectionMode === "item")
          model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
        contentDidChange(model, { data, inputType: "insertText" });
        model.suppressChangeNotifications = suppressChangeNotifications;
        return true;
      }
    };
    function convertStringToAtoms(model, s, args, options) {
      var _a3;
      let format = void 0;
      let result = [];
      if (typeof s !== "string" || options.format === "math-json") {
        const ce = window.MathfieldElement.computeEngine;
        if (!ce)
          return ["math-json", []];
        [format, s] = ["latex", ce.box(s).latex];
        result = parseLatex(s, model.mathfield, { parseMode: "math" });
      } else if (typeof s === "string" && options.format === "ascii-math") {
        [format, s] = parseMathString(s, {
          format: "ascii-math",
          inlineShortcuts: model.mathfield.options.inlineShortcuts
        });
        result = parseLatex(s, model.mathfield, { parseMode: "math" });
        if (format !== "latex" && model.options.removeExtraneousParentheses)
          simplifyParen(result);
      } else if (options.format === "auto" || ((_a3 = options.format) == null ? void 0 : _a3.startsWith("latex"))) {
        if (options.format === "auto") {
          [format, s] = parseMathString(s, {
            format: "auto",
            inlineShortcuts: model.mathfield.options.inlineShortcuts
          });
        }
        if (options.format === "latex")
          [, s] = trimModeShiftCommand(s);
        result = parseLatex(s, model.mathfield, { parseMode: "math", args });
        if (options.format !== "latex" && model.options.removeExtraneousParentheses)
          simplifyParen(result);
      }
      applyStyleToUnstyledAtoms(result, options.style);
      return [format != null ? format : "latex", result];
    }
    function removeParen(atoms) {
      if (!atoms)
        return null;
      console.assert(atoms[0].type === "first");
      if (atoms.length > 1)
        return null;
      const atom = atoms[0];
      if (atom instanceof LeftRightAtom && atom.leftDelim === "(" && atom.rightDelim === ")")
        return atom.removeBranch("body");
      return null;
    }
    function simplifyParen(atoms) {
      if (!atoms)
        return;
      for (let i = 0; atoms[i]; i++) {
        const atom = atoms[i];
        if (atom instanceof LeftRightAtom && atom.leftDelim === "(") {
          let genFracCount = 0;
          let genFracIndex = 0;
          let nonGenFracCount = 0;
          for (let j = 0; atom.body[j]; j++) {
            if (atom.body[j].type === "genfrac") {
              genFracCount++;
              genFracIndex = j;
            }
            nonGenFracCount++;
          }
          if (nonGenFracCount === 0 && genFracCount === 1) {
            atoms[i] = atom.body[genFracIndex];
          }
        }
      }
      for (const atom of atoms) {
        for (const branch of atom.branches) {
          if (!atom.hasEmptyBranch(branch)) {
            simplifyParen(atom.branch(branch));
            const newChildren = removeParen(atom.branch(branch));
            if (newChildren)
              atom.setChildren(newChildren, branch);
          }
        }
        if (atom instanceof ArrayAtom)
          for (const x of atom.cells)
            simplifyParen(x);
      }
    }
    function getImplicitArgOffset(model) {
      let atom = model.at(model.position);
      if (atom.mode === "text") {
        while (!atom.isFirstSibling && atom.mode === "text")
          atom = atom.leftSibling;
        return model.offsetOf(atom);
      }
      const atomAtCursor = atom;
      let afterDelim = false;
      if (atom.type === "mclose") {
        const delim = LEFT_DELIM[atom.value];
        while (!atom.isFirstSibling && !(atom.type === "mopen" && atom.value === delim))
          atom = atom.leftSibling;
        if (!atom.isFirstSibling)
          atom = atom.leftSibling;
        afterDelim = true;
      } else if (atom.type === "leftright") {
        atom = atom.leftSibling;
        afterDelim = true;
      }
      if (afterDelim) {
        while (!atom.isFirstSibling && (atom.isFunction || isImplicitArg(atom)))
          atom = atom.leftSibling;
      } else {
        const delimiterStack = [];
        while (!atom.isFirstSibling && (isImplicitArg(atom) || delimiterStack.length > 0)) {
          if (atom.type === "mclose")
            delimiterStack.unshift(atom.value);
          if (atom.type === "mopen" && delimiterStack.length > 0 && atom.value === LEFT_DELIM[delimiterStack[0]])
            delimiterStack.shift();
          atom = atom.leftSibling;
        }
      }
      if (atomAtCursor === atom)
        return -1;
      return model.offsetOf(atom);
    }
    function isImplicitArg(atom) {
      if (/^(mord|surd|msubsup|leftright|mop|mclose)$/.test(atom.type)) {
        if (atom.isExtensibleSymbol)
          return false;
        if (atom.isFunction)
          return false;
        return true;
      }
      return false;
    }
    function isValidClose(open, close) {
      if (!open)
        return true;
      if (["(", "{", "[", "\\lbrace", "\\lparen", "\\{", "\\lbrack"].includes(open)) {
        return [")", "}", "]", "\\rbrace", "\\rparen", "\\}", "\\rbrack"].includes(
          close
        );
      }
      return RIGHT_DELIM[open] === close;
    }
    function insertSmartFence(model, fence, style) {
      console.assert(model.selectionIsCollapsed);
      const atom = model.at(model.position);
      const { parent } = atom;
      if (fence === "{" || fence === "\\{")
        fence = "\\lbrace";
      if (fence === "}" || fence === "\\}")
        fence = "\\rbrace";
      if (fence === "[")
        fence = "\\lbrack";
      if (fence === "]")
        fence = "\\rbrack";
      if (/\||\\vert|\\Vert|\\mvert|\\mid/.test(fence)) {
        let delims = parent instanceof LeftRightAtom ? parent.leftDelim + parent.rightDelim : "";
        if (delims === "\\lbrace\\rbrace")
          delims = "{}";
        if (delims === "\\{\\}")
          delims = "{}";
        if (delims === "\\lparen\\rparen")
          delims = "()";
        if (delims === "{}") {
          ModeEditor.insert("math", model, "\\,\\middle" + fence + "\\, ", {
            format: "latex",
            style
          });
          return true;
        }
      }
      const rDelim = RIGHT_DELIM[fence];
      if (rDelim) {
        if (parent instanceof LeftRightAtom && parent.firstChild === atom && // At first child
        (parent.leftDelim === "?" || parent.leftDelim === ".")) {
          parent.leftDelim = fence;
          parent.isDirty = true;
          return true;
        }
        if (!(parent instanceof LeftRightAtom)) {
          let sibling = atom;
          while (sibling) {
            if (sibling.type === "mclose" && sibling.value === rDelim)
              break;
            sibling = sibling.rightSibling;
          }
          if (sibling) {
            const body = model.extractAtoms([
              model.offsetOf(atom),
              model.offsetOf(sibling)
            ]);
            body.shift();
            body.pop();
            parent.addChildrenAfter(
              [
                new LeftRightAtom("left...right", body, parent.context, {
                  leftDelim: fence,
                  rightDelim: rDelim
                })
              ],
              atom
            );
            model.position = model.offsetOf(parent.firstChild);
            contentDidChange(model, { data: fence, inputType: "insertText" });
            return true;
          }
        }
        if (!(parent instanceof LeftRightAtom && parent.leftDelim === "|")) {
          ModeEditor.insert("math", model, `\\left${fence}\\right?`, {
            format: "latex",
            style
          });
          if (atom.lastSibling.type !== "first") {
            const lastSiblingOffset = model.offsetOf(atom.lastSibling);
            const content = model.extractAtoms([model.position, lastSiblingOffset]);
            model.at(model.position).body = content;
            model.position -= 1;
          }
          return true;
        }
      }
      let targetLeftDelim = "";
      for (const delim of Object.keys(RIGHT_DELIM))
        if (fence === RIGHT_DELIM[delim])
          targetLeftDelim = delim;
      if (targetLeftDelim) {
        let sibling = atom;
        while (sibling) {
          if (sibling.type === "mopen" && sibling.value === targetLeftDelim) {
            const insertAfter = sibling.leftSibling;
            const body = model.extractAtoms([
              model.offsetOf(sibling.leftSibling),
              model.offsetOf(atom)
            ]);
            body.shift();
            const result = new LeftRightAtom(
              "left...right",
              body,
              parent.context,
              {
                leftDelim: targetLeftDelim,
                rightDelim: fence
              }
            );
            parent.addChildrenAfter([result], insertAfter);
            model.position = model.offsetOf(result);
            contentDidChange(model, { data: fence, inputType: "insertText" });
            return true;
          }
          sibling = sibling.leftSibling;
        }
        if (parent instanceof LeftRightAtom && atom.isLastSibling && isValidClose(parent.leftDelim, fence)) {
          parent.isDirty = true;
          parent.rightDelim = fence;
          model.position += 1;
          contentDidChange(model, { data: fence, inputType: "insertText" });
          return true;
        }
        const firstSibling = model.offsetOf(atom.firstSibling);
        let i;
        for (i = model.position; i >= firstSibling; i--) {
          const atom2 = model.at(i);
          if (atom2 instanceof LeftRightAtom && atom2.rightDelim === "?" && isValidClose(atom2.leftDelim, fence))
            break;
        }
        const match = model.at(i);
        if (i >= firstSibling && match instanceof LeftRightAtom) {
          match.rightDelim = fence;
          match.addChildren(
            model.extractAtoms([i, model.position]),
            atom.treeBranch
          );
          model.position = i;
          contentDidChange(model, { data: fence, inputType: "insertText" });
          return true;
        }
        if (parent instanceof LeftRightAtom && parent.rightDelim === "?" && isValidClose(parent.leftDelim, fence)) {
          parent.isDirty = true;
          parent.rightDelim = fence;
          parent.parent.addChildren(
            model.extractAtoms([model.position, model.offsetOf(atom.lastSibling)]),
            parent.treeBranch
          );
          model.position = model.offsetOf(parent);
          contentDidChange(model, { data: fence, inputType: "insertText" });
          return true;
        }
        const grandparent = parent.parent;
        if (grandparent instanceof LeftRightAtom && grandparent.rightDelim === "?" && model.at(model.position).isLastSibling) {
          model.position = model.offsetOf(grandparent);
          return insertSmartFence(model, fence, style);
        }
        return false;
      }
      return false;
    }
    new MathModeEditor();
    function onKeystroke(mathfield, keystroke, evt) {
      var _a3, _b3, _c2, _d2;
      const { model } = mathfield;
      validateKeyboardLayout(evt);
      const activeLayout = getActiveKeyboardLayout();
      if (mathfield.keyboardLayout !== activeLayout.id) {
        mathfield.keyboardLayout = activeLayout.id;
        mathfield._keybindings = void 0;
      }
      clearTimeout(mathfield.inlineShortcutBufferFlushTimer);
      mathfield.inlineShortcutBufferFlushTimer = 0;
      showKeystroke(mathfield, keystroke);
      if (evt.defaultPrevented) {
        mathfield.flushInlineShortcutBuffer();
        return false;
      }
      let shortcut;
      let selector = "";
      let stateIndex;
      if (mathfield.isSelectionEditable) {
        if (mathfield.mode === "math") {
          if (keystroke === "[Backspace]") {
            mathfield.inlineShortcutBuffer.pop();
            mathfield.flushInlineShortcutBuffer({ defer: true });
          } else if (!mightProducePrintableCharacter(evt)) {
            mathfield.flushInlineShortcutBuffer();
          } else {
            const c = eventToChar(evt);
            const keystrokes = [
              ...(_b3 = (_a3 = mathfield.inlineShortcutBuffer[mathfield.inlineShortcutBuffer.length - 1]) == null ? void 0 : _a3.keystrokes) != null ? _b3 : [],
              c
            ];
            mathfield.inlineShortcutBuffer.push({
              state: model.getState(),
              keystrokes,
              leftSiblings: getLeftSiblings(mathfield)
            });
            let i = 0;
            let candidate = "";
            while (!shortcut && i < keystrokes.length) {
              stateIndex = mathfield.inlineShortcutBuffer.length - (keystrokes.length - i);
              candidate = keystrokes.slice(i).join("");
              shortcut = getInlineShortcut(
                mathfield.inlineShortcutBuffer[stateIndex].leftSiblings,
                candidate,
                mathfield.options.inlineShortcuts
              );
              if (!shortcut && /^[a-zA-Z][a-zA-Z0-9]+?([_\^][a-zA-Z0-9\*\+\-]+?)?$/.test(candidate))
                shortcut = mathfield.options.onInlineShortcut(mathfield, candidate);
              i += 1;
            }
            mathfield.flushInlineShortcutBuffer({ defer: true });
          }
        }
        if (mathfield.options.smartMode) {
          const previousMode = mathfield.mode;
          if (shortcut) {
            mathfield.mode = "math";
          } else if (smartMode(mathfield, keystroke, evt)) {
            mathfield.mode = { math: "text", text: "math" }[mathfield.mode];
            selector = "";
          }
          if (mathfield.mode !== previousMode) {
            if (!((_c2 = mathfield.host) == null ? void 0 : _c2.dispatchEvent(
              new Event("mode-change", {
                bubbles: true,
                composed: true,
                cancelable: true
              })
            )))
              mathfield.mode = previousMode;
          }
        }
      }
      if (!shortcut) {
        if (!selector) {
          selector = getCommandForKeybinding(
            mathfield.keybindings,
            mathfield.mode,
            keystroke
          );
        }
        if (!selector && (keystroke === "[Enter]" || keystroke === "[Return]")) {
          let result = false;
          if (contentWillChange(model, { inputType: "insertLineBreak" })) {
            if (mathfield.host) {
              result = !mathfield.host.dispatchEvent(
                new Event("change", { bubbles: true, composed: true })
              );
            }
            if (!result) {
              if (evt.preventDefault) {
                evt.preventDefault();
                evt.stopPropagation();
              }
            }
            contentDidChange(model, { inputType: "insertLineBreak" });
          }
          return result;
        }
        if (!selector && mathfield.mode === "math") {
          if (keystroke === "[Space]") {
            mathfield.adoptStyle = "none";
            mathfield.flushInlineShortcutBuffer();
            if (mathfield.options.mathModeSpace) {
              mathfield.snapshot();
              ModeEditor.insert("math", model, mathfield.options.mathModeSpace, {
                format: "latex"
              });
              selector = "";
              mathfield.dirty = true;
              mathfield.scrollIntoView();
              if (evt.preventDefault) {
                evt.preventDefault();
                evt.stopPropagation();
              }
              return false;
            }
            const nextSibling = model.at(model.position + 1);
            const previousSibling = model.at(model.position - 1);
            if ((nextSibling == null ? void 0 : nextSibling.mode) === "text" || (previousSibling == null ? void 0 : previousSibling.mode) === "text") {
              mathfield.snapshot();
              ModeEditor.insert("text", model, " ");
              mathfield.dirty = true;
              mathfield.scrollIntoView();
              return true;
            }
          }
          if (((_d2 = model.at(model.position)) == null ? void 0 : _d2.isDigit()) && window.MathfieldElement.decimalSeparator === "," && eventToChar(evt) === ",")
            selector = "insertDecimalSeparator";
        }
      }
      if (!shortcut && !selector)
        return true;
      const child = model.at(Math.max(model.position, model.anchor));
      const { parent } = child;
      if (selector === "moveAfterParent" && (parent == null ? void 0 : parent.type) === "leftright" && child.isLastSibling && mathfield.options.smartFence && insertSmartFence(model, ".", mathfield.style)) {
        selector = "";
        requestUpdate(mathfield);
      }
      mathfield.keyboardDelegate.cancelComposition();
      if (selector)
        mathfield.executeCommand(selector);
      else if (shortcut) {
        const style = __spreadValues(__spreadValues({}, model.at(model.position).computedStyle), mathfield.style);
        if (!/^\\({|}|\[|]|@|#|\$|%|&|\^|_|backslash)$/.test(shortcut)) {
          const saveMode = mathfield.mode;
          ModeEditor.insert(mathfield.mode, model, eventToChar(evt), {
            suppressChangeNotifications: true,
            style
          });
          mathfield.snapshot();
          model.setState(mathfield.inlineShortcutBuffer[stateIndex].state);
          mathfield.mode = saveMode;
        }
        model.deferNotifications(
          {
            content: true,
            selection: true,
            data: shortcut != null ? shortcut : null,
            type: "insertText"
          },
          () => {
            ModeEditor.insert(mathfield.mode, model, shortcut, {
              format: "latex",
              style
            });
            removeIsolatedSpace(mathfield.model);
            if (shortcut.endsWith(" ")) {
              mathfield.mode = "text";
              ModeEditor.insert("text", model, " ", { style });
            }
            if (!model.selectionIsCollapsed)
              mathfield.flushInlineShortcutBuffer();
            return true;
          }
        );
        mathfield.snapshot();
        mathfield.dirty = true;
        model.announce("replacement");
      }
      mathfield.scrollIntoView();
      if (evt.preventDefault)
        evt.preventDefault();
      return false;
    }
    function onInput(mathfield, text, options) {
      var _a3;
      const { model } = mathfield;
      if (!mathfield.isSelectionEditable) {
        model.announce("plonk");
        return;
      }
      options = options != null ? options : {};
      if (options.focus)
        mathfield.focus();
      if (options.feedback)
        window.MathfieldElement.playSound("keypress");
      if (typeof options.mode === "string")
        mathfield.switchMode(options.mode);
      if (options.simulateKeystroke) {
        const c = text.charAt(0);
        const ev = new KeyboardEvent("keypress", { key: c });
        if (!onKeystroke(mathfield, c, ev))
          return;
      }
      const atom = model.at(model.position);
      const rightSibling = atom.rightSibling;
      const style = __spreadValues(__spreadValues({}, atom.computedStyle), mathfield.style);
      if (!model.selectionIsCollapsed) {
        model.deleteAtoms(range(model.selection));
        mathfield.snapshot();
      }
      const graphemes = splitGraphemes(text);
      if (mathfield.mode === "latex") {
        model.deferNotifications(
          { content: true, selection: true, data: text, type: "insertText" },
          () => {
            removeSuggestion(mathfield);
            for (const c of graphemes)
              ModeEditor.insert("latex", model, c);
            updateAutocomplete(mathfield);
          }
        );
      } else if (mathfield.mode === "text")
        for (const c of graphemes)
          ModeEditor.insert("text", model, c, { style });
      else if (mathfield.mode === "math") {
        for (const c of graphemes) {
          let selector = {
            "^": "moveToSuperscript",
            "_": "moveToSubscript",
            " ": "moveAfterParent"
          }[c];
          if (c === " " && mathfield.options.mathModeSpace)
            selector = ["insert", mathfield.options.mathModeSpace];
          if (selector)
            mathfield.executeCommand(selector);
          else if (/\d/.test(c) && mathfield.options.smartSuperscript && atom.treeBranch === "superscript" && ((_a3 = atom.parent) == null ? void 0 : _a3.type) !== "mop" && atom.hasNoSiblings) {
            ModeEditor.insert("math", model, c, { style });
            moveAfterParent(model);
          } else {
            if (mathfield.adoptStyle !== "none") {
              const sibling = mathfield.adoptStyle === "left" ? atom : rightSibling;
              if ((sibling == null ? void 0 : sibling.type) === "mord" && /[a-zA-Z]/.test(sibling.value) && /[a-zA-Z]/.test(c)) {
                if (sibling.style.variant)
                  style.variant = sibling.style.variant;
                if (sibling.style.variantStyle)
                  style.variantStyle = sibling.style.variantStyle;
              }
            }
            ModeEditor.insert("math", model, c, { style });
          }
        }
      }
      mathfield.snapshotAndCoalesce();
      mathfield.dirty = true;
      mathfield.scrollIntoView();
    }
    function getLeftSiblings(mf) {
      const model = mf.model;
      const result = [];
      let atom = model.at(Math.min(model.position, model.anchor));
      while (atom.type !== "first") {
        result.push(atom);
        atom = atom.leftSibling;
      }
      return result;
    }
    register2({
      undo: (mathfield) => {
        complete(mathfield, "accept");
        mathfield.undo();
        return true;
      },
      redo: (mathfield) => {
        complete(mathfield, "accept");
        mathfield.redo();
        return true;
      },
      scrollIntoView: (mathfield) => {
        mathfield.scrollIntoView();
        return true;
      },
      scrollToStart: (mathfield) => {
        mathfield.field.scroll(0, 0);
        return true;
      },
      scrollToEnd: (mathfield) => {
        const fieldBounds = mathfield.field.getBoundingClientRect();
        mathfield.field.scroll(fieldBounds.left - window.scrollX, 0);
        return true;
      },
      toggleKeystrokeCaption,
      plonk: (mathfield) => {
        mathfield.model.announce("plonk");
        return true;
      },
      switchMode: (mathfield, mode, prefix, suffix) => {
        mathfield.switchMode(mode, prefix, suffix);
        return true;
      },
      insert: (mathfield, s, options) => mathfield.insert(s, options),
      typedText: (mathfield, text, options) => {
        onInput(mathfield, text, options);
        return true;
      },
      insertDecimalSeparator: (mathfield) => {
        if (mathfield.mode === "math" && window.MathfieldElement.decimalSeparator === ",") {
          const model = mathfield.model;
          const child = model.at(Math.max(model.position, model.anchor));
          if (child.isDigit()) {
            mathfield.snapshot();
            mathfield.insert("{,}", { format: "latex" });
            return true;
          }
        }
        mathfield.insert(".");
        return true;
      },
      // A 'commit' command is used to simulate pressing the return/enter key,
      // e.g. when using a virtual keyboard
      commit: (mathfield) => {
        var _a3;
        if (contentWillChange(mathfield.model, { inputType: "insertLineBreak" })) {
          (_a3 = mathfield.host) == null ? void 0 : _a3.dispatchEvent(
            new Event("change", { bubbles: true, composed: true })
          );
          contentDidChange(mathfield.model, { inputType: "insertLineBreak" });
        }
        return true;
      }
    });
    register2(
      {
        copyToClipboard: (mathfield) => {
          mathfield.focus();
          if (mathfield.model.selectionIsCollapsed)
            mathfield.select();
          if ("queryCommandSupported" in document && document.queryCommandSupported("copy"))
            document.execCommand("copy");
          else {
            mathfield.element.querySelector(".ML__keyboard-sink").dispatchEvent(
              new ClipboardEvent("copy", {
                bubbles: true,
                composed: true
              })
            );
          }
          return false;
        },
        cutToClipboard: (mathfield) => {
          mathfield.focus();
          if ("queryCommandSupported" in document && document.queryCommandSupported("cut"))
            document.execCommand("cut");
          else {
            mathfield.element.querySelector(".ML__keyboard-sink").dispatchEvent(
              new ClipboardEvent("cut", {
                bubbles: true,
                composed: true
              })
            );
          }
          return true;
        },
        pasteFromClipboard: (mathfield) => {
          mathfield.focus();
          if ("queryCommandSupported" in document && document.queryCommandSupported("paste"))
            document.execCommand("paste");
          else {
            navigator.clipboard.readText().then((text) => {
              if (text && contentWillChange(mathfield.model, {
                inputType: "insertFromPaste",
                data: text
              })) {
                mathfield.snapshot();
                if (mathfield.insert(text)) {
                  contentDidChange(mathfield.model, {
                    inputType: "insertFromPaste"
                  });
                  requestUpdate(mathfield);
                }
              } else
                mathfield.model.announce("plonk");
            });
          }
          return true;
        }
      },
      { target: "mathfield", category: "clipboard" }
    );
    function applyStyle3(mathfield, inStyle) {
      mathfield.flushInlineShortcutBuffer();
      const style = validateStyle(mathfield, inStyle);
      const { model } = mathfield;
      if (model.selectionIsCollapsed) {
        if (mathfield.style.fontSeries && style.fontSeries === mathfield.style.fontSeries)
          style.fontSeries = "auto";
        if (style.fontShape && style.fontShape === mathfield.style.fontShape)
          style.fontShape = "auto";
        if (style.color && style.color === mathfield.style.color)
          style.color = "none";
        if (style.backgroundColor && style.backgroundColor === mathfield.style.backgroundColor)
          style.backgroundColor = "none";
        if (style.fontSize && style.fontSize === mathfield.style.fontSize)
          style.fontSize = "auto";
        mathfield.style = __spreadValues(__spreadValues({}, mathfield.style), style);
      } else {
        mathfield.model.deferNotifications(
          { content: true, type: "insertText" },
          () => {
            model.selection.ranges.forEach(
              (range2) => applyStyle2(model, range2, style, { operation: "toggle" })
            );
            mathfield.snapshot();
          }
        );
      }
      return true;
    }
    register2({ applyStyle: applyStyle3 }, { target: "mathfield" });
    function validateStyle(mathfield, style) {
      var _a3, _b3, _c2, _d2, _e, _f;
      const result = {};
      if (typeof style.color === "string") {
        result.verbatimColor = style.color;
        result.color = (_a3 = mathfield.colorMap(style.color)) != null ? _a3 : "none";
      }
      if (typeof style.backgroundColor === "string") {
        result.verbatimBackgroundColor = style.backgroundColor;
        result.backgroundColor = (_b3 = mathfield.backgroundColorMap(style.backgroundColor)) != null ? _b3 : "none";
      }
      if (typeof style.fontFamily === "string")
        result.fontFamily = style.fontFamily;
      if (typeof style.series === "string")
        result.fontSeries = style.series;
      if (typeof style.fontSeries === "string")
        result.fontSeries = style.fontSeries.toLowerCase();
      if (result.fontSeries) {
        result.fontSeries = (_c2 = {
          bold: "b",
          medium: "m",
          normal: "m"
        }[result.fontSeries]) != null ? _c2 : result.fontSeries;
      }
      if (typeof style.shape === "string")
        result.fontShape = style.shape;
      if (typeof style.fontShape === "string")
        result.fontShape = style.fontShape.toLowerCase();
      if (result.fontShape) {
        result.fontShape = (_d2 = {
          italic: "it",
          up: "n",
          upright: "n",
          normal: "n"
        }[result.fontShape]) != null ? _d2 : result.fontShape;
      }
      const size2 = (_e = style.size) != null ? _e : style.fontSize;
      if (typeof size2 === "number")
        result.fontSize = Math.max(1, Math.min(10, size2));
      else if (typeof size2 === "string") {
        result.fontSize = (_f = {
          size1: 1,
          size2: 2,
          size3: 3,
          size4: 4,
          size5: 5,
          size6: 6,
          size7: 7,
          size8: 8,
          size9: 9,
          size10: 10
        }[size2.toLowerCase()]) != null ? _f : {
          tiny: 1,
          scriptsize: 2,
          footnotesize: 3,
          small: 4,
          normal: 5,
          normalsize: 5,
          large: 6,
          Large: 7,
          LARGE: 8,
          huge: 9,
          Huge: 10
        }[size2];
      }
      return result;
    }
    function selectGroup(model) {
      var _a3, _b3, _c2, _d2, _e, _f;
      if (getMode(model, model.position) === "text") {
        let start = Math.min(model.anchor, model.position);
        let end = Math.max(model.anchor, model.position);
        let done = false;
        while (!done && start > 0) {
          const atom = model.at(start);
          if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value))
            start -= 1;
          else
            done = true;
        }
        done = false;
        while (!done && end <= model.lastOffset) {
          const atom = model.at(end);
          if (atom.mode === "text" && LETTER_AND_DIGITS.test(atom.value))
            end += 1;
          else
            done = true;
        }
        if (done)
          end -= 1;
        if (start >= end) {
          model.setSelection(end - 1, end);
          return true;
        }
        model.setSelection(start, end);
      } else {
        const atom = model.at(model.position);
        if (atom.isDigit()) {
          let start = Math.min(model.anchor, model.position);
          let end = Math.max(model.anchor, model.position);
          while ((_a3 = model.at(start)) == null ? void 0 : _a3.isDigit())
            start -= 1;
          while ((_b3 = model.at(end)) == null ? void 0 : _b3.isDigit())
            end += 1;
          model.setSelection(start, end - 1);
        } else {
          if (atom.style.variant || atom.style.variantStyle) {
            let start = Math.min(model.anchor, model.position);
            let end = Math.max(model.anchor, model.position);
            let x = (_c2 = model.at(start)) == null ? void 0 : _c2.style;
            while (x && x.variant === atom.style.variant && x.variantStyle === atom.style.variantStyle) {
              start -= 1;
              x = (_d2 = model.at(start)) == null ? void 0 : _d2.style;
            }
            x = (_e = model.at(end)) == null ? void 0 : _e.style;
            while (x && x.variant === atom.style.variant && x.variantStyle === atom.style.variantStyle) {
              end += 1;
              x = (_f = model.at(end)) == null ? void 0 : _f.style;
            }
            model.setSelection(start, end - 1);
          } else {
            model.setSelection(
              model.offsetOf(atom.firstSibling),
              model.offsetOf(atom.lastSibling)
            );
          }
        }
      }
      return true;
    }
    register2(
      {
        selectGroup: (model) => {
          const result = selectGroup(model);
          if (!result)
            model.announce("plonk");
          return result;
        },
        selectAll: (model) => model.setSelection(0, model.lastOffset),
        extendSelectionForward: (model) => {
          const result = model.extendSelection("forward");
          if (!result)
            model.announce("plonk");
          return result;
        },
        extendSelectionBackward: (model) => {
          const result = model.extendSelection("backward");
          if (!result)
            model.announce("plonk");
          return result;
        },
        extendToNextWord: (model) => skip(model, "forward", { extend: true }),
        extendToPreviousWord: (model) => skip(model, "backward", { extend: true }),
        extendSelectionUpward: (model) => move(model, "upward", { extend: true }),
        extendSelectionDownward: (model) => move(model, "downward", { extend: true }),
        /**
         * Extend the selection until the next boundary is reached. A boundary
         * is defined by an atom of a different type (mbin, mord, etc...)
         * than the current focus. For example, in "1234+x=y", if the focus is between
         * "1" and "2", invoking `extendToNextBoundary_` would extend the selection
         * to "234".
         */
        extendToNextBoundary: (model) => skip(model, "forward", { extend: true }),
        /**
         * Extend the selection until the previous boundary is reached. A boundary
         * is defined by an atom of a different type (mbin, mord, etc...)
         * than the current focus. For example, in "1+23456", if the focus is between
         * "5" and "6", invoking `extendToPreviousBoundary` would extend the selection
         * to "2345".
         */
        extendToPreviousBoundary: (model) => skip(model, "backward", { extend: true }),
        extendToGroupStart: (model) => {
          const result = model.setSelection(
            model.anchor,
            model.offsetOf(model.at(model.position).firstSibling)
          );
          if (!result)
            model.announce("plonk");
          return result;
        },
        extendToGroupEnd: (model) => {
          const result = model.setSelection(
            model.anchor,
            model.offsetOf(model.at(model.position).lastSibling)
          );
          if (!result)
            model.announce("plonk");
          return result;
        },
        extendToMathFieldStart: (model) => {
          const result = model.setSelection(model.anchor, 0);
          if (!result)
            model.announce("plonk");
          return result;
        },
        extendToMathFieldEnd: (model) => {
          const result = model.setSelection(model.anchor, model.lastOffset);
          if (!result)
            model.announce("plonk");
          return result;
        }
      },
      { target: "model", category: "selection-extend" }
    );
    var gLastTap = null;
    var gTapCount = 0;
    function isPointerEvent(evt) {
      return evt instanceof PointerEvent;
    }
    function onPointerDown(mathfield, evt) {
      var _a3;
      mathfield.atomBoundsCache = /* @__PURE__ */ new Map();
      const that = mathfield;
      let anchor;
      let trackingPointer = false;
      let dirty = "none";
      if (evt.buttons > 1)
        return;
      let scrollLeft = false;
      let scrollRight = false;
      const anchorX = evt.clientX;
      const anchorY = evt.clientY;
      const anchorTime = Date.now();
      const field = that.field;
      const scrollInterval = setInterval(() => {
        if (scrollLeft)
          field.scroll({ top: 0, left: field.scrollLeft - 16 });
        else if (scrollRight)
          field.scroll({ top: 0, left: field.scrollLeft + 16 });
      }, 32);
      function endPointerTracking(evt2) {
        if ("PointerEvent" in window) {
          off(field, "pointermove", onPointerMove);
          off(
            field,
            "pointerup pointercancel",
            endPointerTracking
          );
          if (evt2 instanceof PointerEvent)
            field.releasePointerCapture(evt2.pointerId);
        } else {
          off(window, "mousemove", onPointerMove);
          off(window, "mouseup blur", endPointerTracking);
        }
        trackingPointer = false;
        clearInterval(scrollInterval);
        mathfield.element.classList.remove("tracking");
        if (evt2)
          evt2.preventDefault();
      }
      function onPointerMove(evt2) {
        if (!that.hasFocus()) {
          endPointerTracking(null);
          return;
        }
        const x = evt2.clientX;
        const y = evt2.clientY;
        const hysteresis = isPointerEvent(evt2) && evt2.pointerType === "touch" ? 20 : 5;
        if (Date.now() < anchorTime + 500 && Math.abs(anchorX - x) < hysteresis && Math.abs(anchorY - y) < hysteresis) {
          evt2.preventDefault();
          evt2.stopPropagation();
          return;
        }
        const fieldBounds = field.getBoundingClientRect();
        scrollRight = x > fieldBounds.right;
        scrollLeft = x < fieldBounds.left;
        let actualAnchor = anchor;
        if (isPointerEvent(evt2)) {
          if (!evt2.isPrimary) {
            actualAnchor = offsetFromPoint(that, evt2.clientX, evt2.clientY, {
              bias: 0
            });
          }
        }
        const focus = offsetFromPoint(that, x, y, {
          bias: x <= anchorX ? x === anchorX ? 0 : -1 : 1
        });
        if (actualAnchor >= 0 && focus >= 0) {
          that.model.extendSelectionTo(actualAnchor, focus);
          requestUpdate(mathfield);
        }
        evt2.preventDefault();
        evt2.stopPropagation();
      }
      if (gLastTap && Math.abs(gLastTap.x - anchorX) < 5 && Math.abs(gLastTap.y - anchorY) < 5 && Date.now() < gLastTap.time + 500) {
        gTapCount += 1;
        gLastTap.time = anchorTime;
      } else {
        gLastTap = {
          x: anchorX,
          y: anchorY,
          time: anchorTime
        };
        gTapCount = 1;
      }
      const bounds = field.getBoundingClientRect();
      if (anchorX >= bounds.left && anchorX <= bounds.right && anchorY >= bounds.top && anchorY <= bounds.bottom) {
        if (!mathfield.hasFocus()) {
          dirty = "none";
          mathfield.focus({ scrollIntoView: false });
        }
        mathfield.flushInlineShortcutBuffer();
        mathfield.smartModeSuppressed = false;
        mathfield.adoptStyle = "left";
        anchor = offsetFromPoint(mathfield, anchorX, anchorY, {
          bias: 0
        });
        if (anchor >= 0) {
          mathfield.element.classList.add("tracking");
          if (evt.shiftKey) {
            const wasCollapsed = mathfield.model.selectionIsCollapsed;
            mathfield.model.extendSelectionTo(mathfield.model.anchor, anchor);
            if (acceptCommandSuggestion(mathfield.model) || wasCollapsed)
              dirty = "all";
            else
              dirty = "selection";
          } else if (mathfield.model.at(anchor).type === "placeholder") {
            mathfield.model.setSelection(anchor - 1, anchor);
            dirty = "selection";
          } else if (((_a3 = mathfield.model.at(anchor).rightSibling) == null ? void 0 : _a3.type) === "placeholder") {
            mathfield.model.setSelection(anchor, anchor + 1);
            dirty = "selection";
          } else {
            mathfield.model.position = anchor;
            if (acceptCommandSuggestion(mathfield.model))
              dirty = "all";
            else
              dirty = "selection";
          }
          mathfield.style = {};
          if (evt.detail === 3 || gTapCount > 2) {
            endPointerTracking(evt);
            if (evt.detail === 3 || gTapCount === 3) {
              mathfield.model.selection = {
                ranges: [[0, mathfield.model.lastOffset]]
              };
              dirty = "all";
            }
          } else if (!trackingPointer) {
            trackingPointer = true;
            if ("PointerEvent" in window) {
              on(field, "pointermove", onPointerMove);
              on(
                field,
                "pointerup pointercancel",
                endPointerTracking
              );
              if (evt instanceof PointerEvent)
                field.setPointerCapture(evt.pointerId);
            } else {
              on(window, "blur", endPointerTracking);
              on(window, "mousemove", onPointerMove);
              on(window, "mouseup", endPointerTracking);
            }
            if (evt.detail === 2 || gTapCount === 2) {
              selectGroup(mathfield.model);
              dirty = "all";
            }
          }
        }
      } else
        gLastTap = null;
      if (dirty !== "none") {
        if (mathfield.model.selectionIsCollapsed)
          dirty = "all";
        requestUpdate(mathfield);
      }
      evt.preventDefault();
    }
    function distance(x, y, r) {
      if (x >= r.left && x <= r.right && y >= r.top && y <= r.bottom)
        return 0;
      const dx = x - (r.left + r.right) / 2;
      const dy = y - (r.top + r.bottom) / 2;
      return dx * dx + dy * dy;
    }
    function nearestAtomFromPointRecursive(mathfield, cache, atom, x, y) {
      if (!atom.id)
        return [Infinity, null];
      if (cache.has(atom.id))
        return cache.get(atom.id);
      const bounds = getAtomBounds(mathfield, atom);
      if (!bounds)
        return [Infinity, null];
      let result = [
        Infinity,
        null
      ];
      if (atom.hasChildren && !atom.captureSelection && x >= bounds.left && x <= bounds.right) {
        for (const child of atom.children) {
          const r = nearestAtomFromPointRecursive(mathfield, cache, child, x, y);
          if (r[0] <= result[0])
            result = r;
        }
      }
      if (!result[1])
        result = [distance(x, y, bounds), atom];
      cache.set(atom.id, result);
      return result;
    }
    function nearestAtomFromPoint(mathfield, x, y) {
      const [, atom] = nearestAtomFromPointRecursive(
        mathfield,
        /* @__PURE__ */ new Map(),
        mathfield.model.root,
        x,
        y
      );
      return atom;
    }
    function offsetFromPoint(mathfield, x, y, options) {
      var _a3, _b3;
      const bounds = (_a3 = mathfield.fieldContent) == null ? void 0 : _a3.getBoundingClientRect();
      if (!bounds)
        return 0;
      if (x > bounds.right || y > bounds.bottom + 8)
        return mathfield.model.lastOffset;
      if (x < bounds.left || y < bounds.top - 8)
        return 0;
      options = options != null ? options : {};
      options.bias = (_b3 = options.bias) != null ? _b3 : 0;
      let atom = nearestAtomFromPoint(mathfield, x, y);
      const parents = [];
      let parent = atom;
      while (parent) {
        parents.unshift(parent);
        parent = parent.parent;
      }
      for (const x2 of parents) {
        if (x2.captureSelection) {
          atom = x2;
          break;
        }
      }
      let result = mathfield.model.offsetOf(atom);
      if (result < 0)
        return -1;
      if (atom.leftSibling) {
        if (options.bias === 0 && atom.type !== "placeholder") {
          const bounds2 = getAtomBounds(mathfield, atom);
          if (bounds2 && x < (bounds2.left + bounds2.right) / 2)
            result = mathfield.model.offsetOf(atom.leftSibling);
        } else if (options.bias < 0)
          result = mathfield.model.offsetOf(atom.leftSibling);
      }
      return result;
    }
    var TextModeEditor = class extends ModeEditor {
      constructor() {
        super("text");
      }
      onPaste(mathfield, data) {
        if (!data)
          return false;
        const text = typeof data === "string" ? data : data.getData("text/plain");
        if (text && contentWillChange(mathfield.model, {
          inputType: "insertFromPaste",
          data: text
        })) {
          mathfield.snapshot();
          if (this.insert(mathfield.model, text)) {
            contentDidChange(mathfield.model, { inputType: "insertFromPaste" });
            requestUpdate(mathfield);
          }
          return true;
        }
        return false;
      }
      insert(model, text, options = {}) {
        if (!contentWillChange(model, { data: text, inputType: "insertText" }))
          return false;
        if (!options.insertionMode)
          options.insertionMode = "replaceSelection";
        if (!options.selectionMode)
          options.selectionMode = "placeholder";
        if (!options.format)
          options.format = "auto";
        const { suppressChangeNotifications } = model;
        if (options.suppressChangeNotifications)
          model.suppressChangeNotifications = true;
        const contentWasChanging = model.suppressChangeNotifications;
        model.suppressChangeNotifications = true;
        if (options.insertionMode === "replaceSelection" && !model.selectionIsCollapsed)
          model.deleteAtoms(range(model.selection));
        else if (options.insertionMode === "replaceAll") {
          model.root.setChildren([], "body");
          model.position = 0;
        } else if (options.insertionMode === "insertBefore")
          model.collapseSelection("backward");
        else if (options.insertionMode === "insertAfter")
          model.collapseSelection("forward");
        const newAtoms = convertStringToAtoms2(text, model.mathfield);
        applyStyleToUnstyledAtoms(newAtoms, options.style);
        if (!newAtoms)
          return false;
        const cursor = model.at(model.position);
        const lastNewAtom = cursor.parent.addChildrenAfter(newAtoms, cursor);
        model.suppressChangeNotifications = contentWasChanging;
        if (options.selectionMode === "before")
          ;
        else if (options.selectionMode === "item")
          model.setSelection(model.anchor, model.offsetOf(lastNewAtom));
        else if (lastNewAtom)
          model.position = model.offsetOf(lastNewAtom);
        contentDidChange(model, { data: text, inputType: "insertText" });
        model.suppressChangeNotifications = suppressChangeNotifications;
        return true;
      }
    };
    function convertStringToAtoms2(s, context) {
      s = s.replace(/\\/g, "\\textbackslash ");
      s = s.replace(/#/g, "\\#");
      s = s.replace(/\$/g, "\\$");
      s = s.replace(/%/g, "\\%");
      s = s.replace(/&/g, "\\&");
      s = s.replace(/_/g, "\\_");
      s = s.replace(/{/g, "\\textbraceleft ");
      s = s.replace(/}/g, "\\textbraceright ");
      s = s.replace(/\^/g, "\\textasciicircum ");
      s = s.replace(/~/g, "\\textasciitilde ");
      s = s.replace(/£/g, "\\textsterling ");
      return parseLatex(s, context, { parseMode: "text" });
    }
    new TextModeEditor();
    var CORE_STYLESHEET_HASH = void 0;
    var MATHFIELD_STYLESHEET_HASH = void 0;
    var DEFAULT_KEYBOARD_TOGGLE_GLYPH = `<svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg>`;
    var MathfieldPrivate = class {
      /**
       *
       * - `options.computeEngine`: An instance of a `ComputeEngine`. It is used to parse and serialize
       * LaTeX strings, using the information contained in the dictionaries
       * of the Compute Engine to determine, for example, which symbols are
       * numbers or which are functions, and therefore correctly interpret
       * `bf(x)` as `b \\times f(x)`.
       *
       * If no instance is provided, a new default one is created.
       *
       * @param element - The DOM element that this mathfield is attached to.
       * Note that `element.mathfield` is this object.
       */
      constructor(element, options) {
        this.focusBlurInProgress = false;
        this.stylesheets = [];
        var _a3;
        this.options = update(
          __spreadProps(__spreadValues({}, getDefault()), { registers: getDefaultRegisters(this) }),
          options
        );
        if (options.eventSink)
          this.host = options.eventSink;
        this.element = element;
        element.mathfield = this;
        if (!CORE_STYLESHEET_HASH)
          CORE_STYLESHEET_HASH = hashCode(core_default).toString(36);
        this.stylesheets.push(
          inject2(element, core_default, CORE_STYLESHEET_HASH)
        );
        if (!MATHFIELD_STYLESHEET_HASH)
          MATHFIELD_STYLESHEET_HASH = hashCode(mathfield_default).toString(36);
        this.stylesheets.push(
          inject2(element, mathfield_default, MATHFIELD_STYLESHEET_HASH)
        );
        this.blurred = true;
        this.keystrokeCaptionVisible = false;
        this.popoverVisible = false;
        this.suggestionIndex = 0;
        this.inlineShortcutBuffer = [];
        this.inlineShortcutBufferFlushTimer = 0;
        this.mode = effectiveMode(this.options);
        this.smartModeSuppressed = false;
        this.style = {};
        this.adoptStyle = "left";
        if (this.options.defaultMode === "inline-math")
          this.element.classList.add("ML__is-inline");
        else
          this.element.classList.remove("ML__is-inline");
        this.dirty = false;
        this.model = new ModelPrivate(
          {
            mode: effectiveMode(this.options),
            macros: this.options.macros,
            removeExtraneousParentheses: this.options.removeExtraneousParentheses
          },
          {
            onSelectionDidChange: () => this._onSelectionDidChange()
          },
          this
        );
        this.undoManager = new UndoManager(this.model);
        let elementText = (_a3 = options.value) != null ? _a3 : this.element.textContent;
        if (elementText)
          elementText = elementText.trim();
        if (elementText) {
          ModeEditor.insert("math", this.model, elementText, {
            insertionMode: "replaceAll",
            selectionMode: "after",
            format: "latex",
            suppressChangeNotifications: true
          });
        }
        const markup = [];
        markup.push(
          `<span contenteditable=true aria-multiline=false part=keyboard-sink class=ML__keyboard-sink autocapitalize=off autocomplete=off autocorrect=off spellcheck=false inputmode=none tabindex=0></span>`
        );
        markup.push(
          '<span part=container class=ML__container aria-hidden=true  style="visibility:hidden">'
        );
        markup.push("<span part=content class=ML__content>");
        markup.push(contentMarkup(this));
        markup.push("</span>");
        markup.push(
          `<div part=virtual-keyboard-toggle class=ML__virtual-keyboard-toggle role=button ${this.hasEditableContent ? "" : 'style="display:none;"'}data-ML__tooltip="${localize("tooltip.toggle virtual keyboard")}">`
        );
        markup.push(DEFAULT_KEYBOARD_TOGGLE_GLYPH);
        markup.push("</div>");
        markup.push("</span>");
        markup.push("<span class=ML__sr-only>");
        markup.push(
          "<span role=status aria-live=assertive aria-atomic=true></span>"
        );
        markup.push("</span>");
        this.element.innerHTML = window.MathfieldElement.createHTML(
          markup.join("")
        );
        if (!this.element.children) {
          console.error(
            `%cMathLive 0.90.9: Something went wrong and the mathfield could not be created.%c
If you are using Vue, this may be because you are using the runtime-only build of Vue. Make sure to include \`runtimeCompiler: true\` in your Vue configuration. There may a warning from Vue in the log above.`,
            "color:red;font-family:system-ui;font-size:1.2rem;font-weight:bold",
            "color:inherit;font-family:system-ui;font-size:inherit;font-weight:inherit"
          );
          return;
        }
        this.field = this.element.querySelector("[part=content]");
        this.field.addEventListener(
          "click",
          (evt) => evt.stopImmediatePropagation(),
          { capture: false }
        );
        this.field.addEventListener("wheel", this, { passive: false });
        if ("PointerEvent" in window)
          this.field.addEventListener("pointerdown", this);
        else
          this.field.addEventListener("mousedown", this);
        attachButtonHandlers(
          this.element.querySelector(
            "[part=virtual-keyboard-toggle]"
          ),
          (command) => this.executeCommand(command),
          {
            default: "toggleVirtualKeyboard",
            shift: "toggleVirtualKeyboardShift"
          }
        );
        this.ariaLiveText = this.element.querySelector("[role=status]");
        this.keyboardDelegate = delegateKeyboardEvents(
          this.element.querySelector(".ML__keyboard-sink"),
          this.element,
          {
            onFocus: () => this.onFocus(),
            onBlur: () => this.onBlur(),
            onInput: (text) => onInput(this, text),
            onKeystroke: (keystroke, event) => onKeystroke(this, keystroke, event),
            onCompositionStart: (composition) => this.onCompositionStart(composition),
            onCompositionUpdate: (composition) => this.onCompositionUpdate(composition),
            onCompositionEnd: (composition) => this.onCompositionEnd(composition),
            onCut: (ev) => {
              if (!this.isSelectionEditable) {
                this.model.announce("plonk");
                return;
              }
              if (contentWillChange(this.model, { inputType: "deleteByCut" })) {
                this.snapshot();
                ModeEditor.onCopy(this, ev);
                deleteRange(this.model, range(this.model.selection), "deleteByCut");
                requestUpdate(this);
              }
            },
            onCopy: (ev) => ModeEditor.onCopy(this, ev),
            onPaste: (ev) => {
              let result = this.isSelectionEditable;
              if (result) {
                result = ModeEditor.onPaste(
                  this.model.at(this.model.position).mode,
                  this,
                  ev.clipboardData
                );
              }
              if (!result)
                this.model.announce("plonk");
              ev.preventDefault();
              ev.stopPropagation();
              return result;
            }
          }
        );
        window.addEventListener("resize", this);
        if (window === window.top) {
          window.addEventListener(
            "blur",
            () => {
              if (isValidMathfield(this) && this.hasFocus()) {
                window.addEventListener(
                  "focus",
                  (evt) => {
                    if (evt.target === window && isValidMathfield(this))
                      this.focus();
                  },
                  { once: true }
                );
              }
            },
            { capture: true }
          );
        }
        this.undoManager.startRecording();
        this.undoManager.snapshot();
        if (gFontsState !== "ready")
          document.fonts.ready.then(() => renderSelection(this));
        element.querySelector(".ML__container").style.removeProperty("visibility");
      }
      connectToVirtualKeyboard() {
        if (this.connectedToVirtualKeyboard)
          return;
        this.connectedToVirtualKeyboard = true;
        window.addEventListener("message", this);
        window.mathVirtualKeyboard.connect();
        window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
      }
      disconnectFromVirtualKeyboard() {
        if (!this.connectedToVirtualKeyboard)
          return;
        window.removeEventListener("message", this);
        window.mathVirtualKeyboard.disconnect();
        this.connectedToVirtualKeyboard = false;
      }
      /** Global Context.
       * These properties are accessed by the atom instances for rendering/layout
       */
      get colorMap() {
        return (name) => {
          var _a3;
          let result = void 0;
          if (typeof ((_a3 = this.options) == null ? void 0 : _a3.colorMap) === "function")
            result = this.options.colorMap(name);
          if (!result)
            result = defaultColorMap(name);
          return result;
        };
      }
      get backgroundColorMap() {
        return (name) => {
          var _a3;
          let result = void 0;
          if (typeof ((_a3 = this.options) == null ? void 0 : _a3.backgroundColorMap) === "function")
            result = this.options.backgroundColorMap(name);
          if (!result && typeof this.options.colorMap === "function")
            result = this.options.colorMap(name);
          if (!result)
            result = defaultBackgroundColorMap(name);
          return result;
        };
      }
      get fractionNavigationOrder() {
        return window.MathfieldElement.fractionNavigationOrder;
      }
      get placeholderSymbol() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.placeholderSymbol) != null ? _b3 : "▢";
      }
      get smartFence() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.smartFence) != null ? _b3 : false;
      }
      get readOnly() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.readOnly) != null ? _b3 : false;
      }
      get disabled() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.host) == null ? void 0 : _a3["disabled"]) != null ? _b3 : false;
      }
      // This reflects the contenteditable attribute.
      // Use hasEditableContent instead to take into account readonly and disabled
      // states.
      get contentEditable() {
        var _a3;
        return ((_a3 = this.host) == null ? void 0 : _a3.getAttribute("contenteditable")) !== "false";
      }
      // This reflect the `user-select` CSS property
      get userSelect() {
        if (!this.host)
          return "";
        const style = getComputedStyle(this.host);
        return style.getPropertyValue("user-select") || style.getPropertyValue("-webkit-user-select");
      }
      // Use to hide/show the virtual keyboard toggle. If false, no point in
      // showing  the toggle.
      get hasEditableContent() {
        if (this.disabled || !this.contentEditable)
          return false;
        return !this.readOnly || this.hasEditablePrompts;
      }
      get hasEditablePrompts() {
        return this.readOnly && !this.disabled && this.contentEditable && this.model.findAtom(
          (a) => a.type === "prompt" && !a.locked
        ) !== void 0;
      }
      /** Returns true if the selection is editable:
       * - mathfield is not disabled, and has contentEditable
       * - if mathfield is readonly, the current selection is in a prompt which is editable (not locked)
       */
      get isSelectionEditable() {
        if (this.disabled || !this.contentEditable)
          return false;
        if (!this.readOnly)
          return true;
        const anchor = this.model.at(this.model.anchor);
        const cursor = this.model.at(this.model.position);
        const ancestor = Atom.commonAncestor(anchor, cursor);
        if (ancestor == null ? void 0 : ancestor.parentPrompt)
          return true;
        return false;
      }
      get letterShapeStyle() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.letterShapeStyle) != null ? _b3 : "tex";
      }
      get registers() {
        var _a3, _b3;
        return (_b3 = (_a3 = this.options) == null ? void 0 : _a3.registers) != null ? _b3 : {};
      }
      getDefinition(token, parseMode = "math") {
        return defaultGetDefinition(token, parseMode);
      }
      getMacro(token) {
        return getMacroDefinition(
          token,
          this.options.macros
        );
      }
      get keybindings() {
        var _a3, _b3;
        if (this._keybindings)
          return this._keybindings;
        const [keybindings, errors] = normalizeKeybindings(
          this.options.keybindings,
          (_a3 = getActiveKeyboardLayout()) != null ? _a3 : DEFAULT_KEYBOARD_LAYOUT
        );
        if (((_b3 = getActiveKeyboardLayout()) == null ? void 0 : _b3.score) > 0) {
          this._keybindings = keybindings;
          if (errors.length > 0) {
            console.error(
              `MathLive 0.90.9: Invalid keybindings for current keyboard layout`,
              errors
            );
          }
        }
        return keybindings;
      }
      setOptions(config) {
        this.options = update(this.options, config);
        this.model.setListeners({
          onSelectionDidChange: (_sender) => this._onSelectionDidChange()
        });
        this.model.options.macros = this.options.macros;
        this._keybindings = void 0;
        if (this.options.defaultMode === "inline-math")
          this.element.classList.add("ML__is-inline");
        else
          this.element.classList.remove("ML__is-inline");
        if (this.options.readOnly) {
          if (this.hasFocus() && window.mathVirtualKeyboard.visible)
            this.executeCommand("hideVirtualKeyboard");
        }
        const content = Atom.serialize(this.model.root, {
          expandMacro: false,
          defaultMode: this.options.defaultMode
        });
        if ("macros" in config || this.model.getValue() !== content) {
          ModeEditor.insert("math", this.model, content, {
            insertionMode: "replaceAll",
            selectionMode: "after",
            format: "latex",
            suppressChangeNotifications: true
          });
        }
        requestUpdate(this);
      }
      getOptions(keys) {
        return get2(this.options, keys);
      }
      getOption(key) {
        return get2(this.options, key);
      }
      /*
       * handleEvent is a function invoked when an event is registered with an
       * object.
       * The name is defined by `addEventListener()` and cannot be changed.
       * This pattern is used to be able to release bound event handlers,
       * (event handlers that need access to `this`) as the `bind()` function
       * would create a new function that would have to be kept track of
       * to be able to properly remove the event handler later.
       */
      handleEvent(evt) {
        var _a3;
        if (!isValidMathfield(this))
          return;
        if (isVirtualKeyboardMessage(evt)) {
          if (!validateOrigin(evt.origin, (_a3 = this.options.originValidator) != null ? _a3 : "none")) {
            throw new DOMException(
              `Message from unknown origin (${evt.origin}) cannot be handled`,
              "SecurityError"
            );
          }
          const { action } = evt.data;
          if (action === "execute-command") {
            const command = evt.data.command;
            if (getCommandTarget(command) === "virtual-keyboard")
              return;
            this.executeCommand(command);
          } else if (action === "update-state")
            ;
          else if (action === "focus")
            this.focus();
          else if (action === "blur")
            this.blur();
          return;
        }
        switch (evt.type) {
          case "focus":
            this.onFocus();
            break;
          case "blur":
            this.onBlur();
            break;
          case "mousedown":
            onPointerDown(this, evt);
            break;
          case "pointerdown":
            onPointerDown(this, evt);
            break;
          case "resize":
            if (this.resizeTimer)
              cancelAnimationFrame(this.resizeTimer);
            this.resizeTimer = requestAnimationFrame(
              () => isValidMathfield(this) && this.onResize()
            );
            break;
          case "wheel":
            this.onWheel(evt);
            break;
          default:
            console.warn("Unexpected event type", evt.type);
        }
      }
      dispose() {
        if (!isValidMathfield(this))
          return;
        this.disconnectFromVirtualKeyboard();
        const element = this.element;
        delete this.element;
        delete element.mathfield;
        element.innerHTML = this.model.getValue();
        element.removeEventListener("pointerdown", this);
        element.removeEventListener("mousedown", this);
        element.removeEventListener("focus", this);
        element.removeEventListener("blur", this);
        window.removeEventListener("resize", this);
        window.removeEventListener("blur", this, { capture: true });
        delete this.ariaLiveText;
        delete this.field;
        delete this.fieldContent;
        disposePopover(this);
        disposeKeystrokeCaption(this);
        this.stylesheets.forEach((x) => x == null ? void 0 : x.release());
      }
      flushInlineShortcutBuffer(options) {
        options != null ? options : options = { defer: false };
        if (!options.defer) {
          this.inlineShortcutBuffer = [];
          clearTimeout(this.inlineShortcutBufferFlushTimer);
          this.inlineShortcutBufferFlushTimer = 0;
          return;
        }
        if (this.options.inlineShortcutTimeout > 0) {
          clearTimeout(this.inlineShortcutBufferFlushTimer);
          this.inlineShortcutBufferFlushTimer = setTimeout(
            () => this.flushInlineShortcutBuffer(),
            this.options.inlineShortcutTimeout
          );
        }
      }
      executeCommand(command) {
        if (getCommandTarget(command) === "virtual-keyboard") {
          this.focus({ scrollIntoView: false });
          window.mathVirtualKeyboard.executeCommand(command);
          requestAnimationFrame(
            () => window.mathVirtualKeyboard.updateToolbar(makeProxy(this))
          );
          return false;
        }
        return perform(this, command);
      }
      get errors() {
        return validateLatex(this.model.getValue(), this);
      }
      getValue(arg1, arg2, arg3) {
        return this.model.getValue(arg1, arg2, arg3);
      }
      setValue(value, options) {
        var _a3;
        options = options != null ? options : { mode: "math" };
        if (options.insertionMode === void 0)
          options.insertionMode = "replaceAll";
        if (options.format === void 0 || options.format === "auto")
          options.format = "latex";
        let mode = "math";
        if (options.mode === void 0 || options.mode === "auto")
          mode = (_a3 = getMode(this.model, this.model.position)) != null ? _a3 : "math";
        if (ModeEditor.insert(mode, this.model, value, options)) {
          this.undoManager.snapshot();
          requestUpdate(this);
        }
      }
      get expression() {
        const ce = window.MathfieldElement.computeEngine;
        if (!ce) {
          console.error(
            `MathLive 0.90.9:  no compute engine available. Make sure the Compute Engine library is loaded.`
          );
          return null;
        }
        return ce.box(ce.parse(this.model.getValue()));
      }
      /** Make sure the caret is visible within the matfield.
       * If the mathfield is inside a mathfield element, make sure the mathfield
       * element is visible in the page
       */
      scrollIntoView() {
        var _a3;
        if (!this.element)
          return;
        (_a3 = this.host) == null ? void 0 : _a3.scrollIntoView({ block: "nearest", inline: "nearest" });
        if (this.dirty)
          render(this, { interactive: true });
        const fieldBounds = this.field.getBoundingClientRect();
        let caretPoint = null;
        if (this.model.selectionIsCollapsed)
          caretPoint = getCaretPoint(this.field);
        else {
          const selectionBounds = getSelectionBounds(this);
          if (selectionBounds.length > 0) {
            let maxRight = -Infinity;
            let minTop = -Infinity;
            for (const r of selectionBounds) {
              if (r.right > maxRight)
                maxRight = r.right;
              if (r.top < minTop)
                minTop = r.top;
            }
            caretPoint = {
              x: maxRight + fieldBounds.left - this.field.scrollLeft,
              y: minTop + fieldBounds.top - this.field.scrollTop,
              height: 0
            };
          }
        }
        if (this.host && caretPoint) {
          const hostBounds = this.host.getBoundingClientRect();
          const y = caretPoint.y;
          let top = this.host.scrollTop;
          if (y < hostBounds.top)
            top = y - hostBounds.top + this.host.scrollTop;
          else if (y > hostBounds.bottom)
            top = y - hostBounds.bottom + this.host.scrollTop + caretPoint.height;
          this.host.scroll({ top, left: 0 });
        }
        if (caretPoint) {
          const x = caretPoint.x - window.scrollX;
          let left = this.field.scrollLeft;
          if (x < fieldBounds.left)
            left = x - fieldBounds.left + this.field.scrollLeft - 20;
          else if (x > fieldBounds.right)
            left = x - fieldBounds.right + this.field.scrollLeft + 20;
          this.field.scroll({
            top: this.field.scrollTop,
            // should always be 0
            left
          });
        }
      }
      insert(s, options) {
        if (typeof s !== "string")
          return false;
        if (s.length === 0 && ((options == null ? void 0 : options.insertionMode) === "insertBefore" || (options == null ? void 0 : options.insertionMode) === "insertAfter"))
          return false;
        if (s.length === 0 && this.model.selectionIsCollapsed)
          return false;
        this.flushInlineShortcutBuffer();
        options = options != null ? options : { mode: "math" };
        if (options.focus)
          this.focus();
        if (options.feedback) {
          if (MathfieldElement.keypressVibration && canVibrate())
            navigator.vibrate(HAPTIC_FEEDBACK_DURATION);
          window.MathfieldElement.playSound("keypress");
        }
        if (options.scrollIntoView)
          this.scrollIntoView();
        if (s === "\\\\") {
          addRowAfter(this.model);
        } else if (s === "&")
          addColumnAfter(this.model);
        else {
          const savedStyle = this.style;
          ModeEditor.insert(this.mode, this.model, s, __spreadValues({
            style: this.model.at(this.model.position).computedStyle
          }, options));
          if (options.resetStyle)
            this.style = savedStyle;
        }
        this.undoManager.snapshot();
        requestUpdate(this);
        return true;
      }
      switchMode(mode, prefix = "", suffix = "") {
        var _a3;
        if (this.mode === mode || this.readOnly || !this.contentEditable || this.disabled)
          return;
        if (!((_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new Event("mode-change", {
            bubbles: true,
            composed: true,
            cancelable: true
          })
        )))
          return;
        const currentMode = this.mode;
        const { model } = this;
        model.deferNotifications(
          {
            content: Boolean(suffix) || Boolean(prefix),
            selection: true,
            type: "insertText"
          },
          () => {
            let contentChanged = false;
            this.flushInlineShortcutBuffer();
            this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(mode);
            if (prefix && mode !== "latex") {
              const atoms = parseLatex(prefix, this, { parseMode: mode });
              model.collapseSelection("forward");
              const cursor = model.at(model.position);
              model.position = model.offsetOf(
                cursor.parent.addChildrenAfter(atoms, cursor)
              );
              contentChanged = true;
            }
            this.mode = mode;
            if (mode === "latex") {
              let wasCollapsed = model.selectionIsCollapsed;
              complete(this, "accept");
              let latex;
              let cursor = model.at(model.position);
              if (wasCollapsed)
                latex = "\\";
              else {
                const selRange = range(model.selection);
                latex = this.model.getValue(selRange, "latex");
                const extractedAtoms = this.model.extractAtoms(selRange);
                if (extractedAtoms.length === 1 && extractedAtoms[0] instanceof PlaceholderAtom) {
                  latex = prefix;
                  wasCollapsed = true;
                }
                cursor = model.at(selRange[0]);
              }
              const atom = new LatexGroupAtom(latex, this);
              cursor.parent.addChildAfter(atom, cursor);
              if (wasCollapsed)
                model.position = model.offsetOf(atom.lastChild);
              else {
                model.setSelection(
                  model.offsetOf(atom.firstChild),
                  model.offsetOf(atom.lastChild)
                );
              }
            } else {
              getLatexGroupBody(model).forEach((x) => {
                x.isError = false;
              });
            }
            if (suffix) {
              const atoms = parseLatex(suffix, this, { parseMode: currentMode });
              model.collapseSelection("forward");
              const cursor = model.at(model.position);
              model.position = model.offsetOf(
                cursor.parent.addChildrenAfter(atoms, cursor)
              );
              contentChanged = true;
            }
            requestUpdate(this);
            return contentChanged;
          }
        );
        this.mode = mode;
      }
      hasFocus() {
        return !this.blurred;
      }
      focus(options) {
        var _a3;
        if (!this.hasFocus()) {
          this.keyboardDelegate.focus();
          this.connectToVirtualKeyboard();
          this.model.announce("line");
        }
        if ((_a3 = options == null ? void 0 : options.scrollIntoView) != null ? _a3 : true)
          this.scrollIntoView();
      }
      blur() {
        this.disconnectFromVirtualKeyboard();
        if (!this.hasFocus())
          return;
        this.keyboardDelegate.blur();
      }
      select() {
        this.model.selection = { ranges: [[0, this.model.lastOffset]] };
      }
      applyStyle(inStyle, inOptions = {}) {
        var _a3, _b3;
        const options = {
          operation: "set",
          suppressChangeNotifications: false
        };
        if (isRange(inOptions))
          options.range = inOptions;
        else {
          options.range = inOptions.range;
          options.suppressChangeNotifications = (_a3 = inOptions.suppressChangeNotifications) != null ? _a3 : false;
        }
        const style = validateStyle(this, inStyle);
        const operation = (_b3 = options.operation) != null ? _b3 : "set";
        this.model.deferNotifications(
          { content: !options.suppressChangeNotifications, type: "insertText" },
          () => {
            if (options.range === void 0) {
              for (const range2 of this.model.selection.ranges)
                applyStyle2(this.model, range2, style, { operation });
            } else
              applyStyle2(this.model, options.range, style, { operation });
          }
        );
        requestUpdate(this);
      }
      getCaretPoint() {
        const caretOffset = getCaretPoint(this.field);
        return caretOffset ? { x: caretOffset.x, y: caretOffset.y } : null;
      }
      setCaretPoint(x, y) {
        const newPosition = offsetFromPoint(this, x, y, { bias: 0 });
        if (newPosition < 0)
          return false;
        const previousPosition = this.model.position;
        this.model.position = newPosition;
        this.model.announce("move", previousPosition);
        requestUpdate(this);
        return true;
      }
      getPrompt(id) {
        const prompt = this.model.findAtom(
          (a) => a.type === "prompt" && a.placeholderId === id
        );
        console.assert(
          prompt !== void 0,
          `MathLive 0.90.9:  no prompts with matching ID found`
        );
        return prompt;
      }
      getPromptValue(id, format) {
        const prompt = this.getPrompt(id);
        if (!prompt) {
          console.error(`MathLive 0.90.9: unknown prompt ${id}`);
          return "";
        }
        const first = this.model.offsetOf(prompt.firstChild);
        const last = this.model.offsetOf(prompt.lastChild);
        return this.model.getValue(first, last, format);
      }
      getPrompts(filter) {
        return this.model.getAllAtoms().filter((a) => {
          if (a.type !== "prompt")
            return false;
          if (!filter)
            return true;
          if (filter.id && a.placeholderId !== filter.id)
            return false;
          if (filter.locked && a.locked !== filter.locked)
            return false;
          if (filter.correctness === "undefined" && a.correctness)
            return false;
          if (filter.correctness && a.correctness !== filter.correctness)
            return false;
          return true;
        }).map((a) => a.placeholderId);
      }
      setPromptValue(id, value, insertOptions) {
        if (value !== void 0) {
          const prompt = this.getPrompt(id);
          if (!prompt) {
            console.error(`MathLive 0.90.9: unknown prompt ${id}`);
            return;
          }
          const branchRange = this.model.getBranchRange(
            this.model.offsetOf(prompt),
            "body"
          );
          this.model.setSelection(branchRange);
          this.insert(value, __spreadProps(__spreadValues({}, insertOptions), {
            insertionMode: "replaceSelection"
          }));
        }
        if (insertOptions == null ? void 0 : insertOptions.suppressChangeNotifications)
          this.valueOnFocus = this.getValue();
        requestUpdate(this);
      }
      setPromptState(id, state, locked) {
        const prompt = this.getPrompt(id);
        if (!prompt) {
          console.error(`MathLive 0.90.9: unknown prompt ${id}`);
          return;
        }
        if (state === "undefined")
          prompt.correctness = void 0;
        else if (typeof state === "string")
          prompt.correctness = state;
        if (typeof locked === "boolean") {
          prompt.locked = locked;
          prompt.captureSelection = locked;
        }
        requestUpdate(this);
      }
      getPromptState(id) {
        const prompt = this.getPrompt(id);
        if (!prompt) {
          console.error(`MathLive 0.90.9: unknown prompt ${id}`);
          return [void 0, true];
        }
        return [prompt.correctness, prompt.locked];
      }
      canUndo() {
        return this.undoManager.canUndo();
      }
      canRedo() {
        return this.undoManager.canRedo();
      }
      popUndoStack() {
        this.undoManager.pop();
      }
      snapshot() {
        var _a3;
        if (this.undoManager.snapshot()) {
          window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
          (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
            new CustomEvent("undo-state-change", {
              bubbles: true,
              composed: true,
              detail: { type: "snapshot" }
            })
          );
        }
      }
      snapshotAndCoalesce() {
        var _a3;
        if (this.undoManager.snapshotAndCoalesce()) {
          window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
          (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
            new CustomEvent("undo-state-change", {
              bubbles: true,
              composed: true,
              detail: { type: "snapshot" }
            })
          );
        }
      }
      undo() {
        var _a3;
        if (!this.undoManager.undo())
          return;
        window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
        (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("undo-state-change", {
            bubbles: true,
            composed: true,
            detail: { type: "undo" }
          })
        );
      }
      redo() {
        var _a3;
        if (!this.undoManager.redo())
          return;
        window.mathVirtualKeyboard.updateToolbar(makeProxy(this));
        (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
          new CustomEvent("undo-state-change", {
            bubbles: true,
            composed: true,
            detail: { type: "undo" }
          })
        );
      }
      resetUndo() {
        var _a3;
        (_a3 = this.undoManager) == null ? void 0 : _a3.reset();
      }
      _onSelectionDidChange() {
        var _a3, _b3;
        const model = this.model;
        this.keyboardDelegate.setValue(
          this.model.getValue(this.model.selection, "latex-expanded")
        );
        {
          const cursor = model.at(model.position);
          const newMode = (_a3 = cursor.mode) != null ? _a3 : effectiveMode(this.options);
          if (this.mode !== newMode) {
            if (this.mode === "latex") {
              complete(this, "accept", { mode: newMode });
              model.position = model.offsetOf(cursor);
            } else
              this.switchMode(newMode);
          }
        }
        (_b3 = this.host) == null ? void 0 : _b3.dispatchEvent(
          new Event("selection-change", {
            bubbles: true,
            composed: true
          })
        );
      }
      onFocus() {
        if (this.focusBlurInProgress || !this.blurred)
          return;
        this.focusBlurInProgress = true;
        this.blurred = false;
        this.keyboardDelegate.focus();
        render(this, { interactive: true });
        this.valueOnFocus = this.model.getValue();
        if (this.hasEditablePrompts && !this.model.at(this.model.anchor).parentPrompt)
          this.executeCommand("moveToNextPlaceholder");
        this.focusBlurInProgress = false;
      }
      onBlur() {
        var _a3, _b3, _c2;
        if (this.focusBlurInProgress || this.blurred)
          return;
        this.focusBlurInProgress = true;
        this.blurred = true;
        this.ariaLiveText.textContent = "";
        complete(this, "accept");
        if (this.model.getValue() !== this.valueOnFocus) {
          (_a3 = this.host) == null ? void 0 : _a3.dispatchEvent(
            new Event("change", { bubbles: true, composed: true })
          );
        }
        this.disconnectFromVirtualKeyboard();
        (_b3 = this.host) == null ? void 0 : _b3.dispatchEvent(
          new Event("blur", {
            bubbles: false,
            // DOM 'focus' and 'blur' don't bubble
            composed: true
          })
        );
        (_c2 = this.host) == null ? void 0 : _c2.dispatchEvent(
          new UIEvent("focusout", {
            bubbles: true,
            // unlike 'blur', focusout does bubble
            composed: true
          })
        );
        requestUpdate(this);
        this.focusBlurInProgress = false;
      }
      onCompositionStart(_composition) {
        this.model.deleteAtoms(range(this.model.selection));
        const caretPoint = getCaretPoint(this.field);
        if (!caretPoint)
          return;
        requestAnimationFrame(() => {
          render(this);
          this.keyboardDelegate.moveTo(
            caretPoint.x,
            caretPoint.y - caretPoint.height
          );
        });
      }
      onCompositionUpdate(composition) {
        updateComposition(this.model, composition);
        requestUpdate(this);
      }
      onCompositionEnd(composition) {
        removeComposition(this.model);
        onInput(this, composition, {
          simulateKeystroke: true
        });
      }
      onResize() {
        updatePopoverPosition(this);
      }
      onWheel(ev) {
        const wheelDelta = 5 * ev.deltaX;
        if (!Number.isFinite(wheelDelta) || wheelDelta === 0)
          return;
        const field = this.field;
        if (wheelDelta < 0 && field.scrollLeft === 0)
          return;
        if (wheelDelta > 0 && field.offsetWidth + field.scrollLeft >= field.scrollWidth)
          return;
        field.scrollBy({ top: 0, left: wheelDelta });
        ev.preventDefault();
        ev.stopPropagation();
      }
      getHTMLElement(atom) {
        var _a3;
        let target = atom;
        while (!target.id && target.hasChildren)
          target = atom.children[0];
        if (target.id) {
          return (_a3 = this.fieldContent) == null ? void 0 : _a3.querySelector(
            `[data-atom-id="${target.id}"]`
          );
        }
        throw new TypeError("Could not get an ID from atom");
      }
    };
    function wordBoundaryOffset(model, offset, direction) {
      if (model.at(offset).mode !== "text")
        return offset;
      const dir = direction === "backward" ? -1 : 1;
      let result;
      if (LETTER_AND_DIGITS.test(model.at(offset).value)) {
        let i = offset;
        let match;
        do {
          match = model.at(i).mode === "text" && LETTER_AND_DIGITS.test(model.at(i).value);
          i += dir;
        } while (model.at(i) && match);
        result = model.at(i) ? i - 2 * dir : i - dir;
      } else if (/\s/.test(model.at(offset).value)) {
        let i = offset;
        while (model.at(i) && model.at(i).mode === "text" && /\s/.test(model.at(i).value))
          i += dir;
        if (!model.at(i)) {
          result = i - dir;
        } else {
          let match = true;
          do {
            match = model.at(i).mode === "text" && !/\s/.test(model.at(i).value);
            i += dir;
          } while (model.at(i) && match);
          result = model.at(i) ? i - 2 * dir : i - dir;
        }
      } else {
        let i = offset;
        while (model.at(i) && model.at(i).mode === "text" && !/\s/.test(model.at(i).value))
          i += dir;
        result = model.at(i) ? i : i - dir;
        let match = true;
        while (model.at(i) && match) {
          match = model.at(i).mode === "text" && /\s/.test(model.at(i).value);
          if (match)
            result = i;
          i += dir;
        }
        result = model.at(i) ? i - 2 * dir : i - dir;
      }
      return result - (dir > 0 ? 0 : 1);
    }
    function skip(model, direction, options) {
      var _a3, _b3, _c2, _d2, _e, _f, _g;
      const previousPosition = model.position;
      if (!((_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false))
        model.collapseSelection(direction);
      let atom = model.at(model.position);
      if (direction === "forward") {
        if (atom.type === "msubsup") {
          atom = atom.rightSibling;
          if (!atom)
            atom = model.at(model.position + 1);
        } else
          atom = model.at(model.position + 1);
      }
      if (!atom) {
        model.announce("plonk");
        return false;
      }
      let offset = model.offsetOf(atom);
      if (atom instanceof TextAtom) {
        offset = wordBoundaryOffset(model, offset, direction);
      } else if (atom instanceof LatexAtom) {
        if (atom.isSuggestion) {
          console.assert(direction === "forward");
          while (atom && atom instanceof LatexAtom) {
            atom.isSuggestion = false;
            offset = model.offsetOf(atom);
            atom = atom.rightSibling;
          }
        } else if (direction === "forward") {
          atom = atom.rightSibling;
          if (!atom || !(atom instanceof LatexAtom)) {
            model.announce("plonk");
            return false;
          }
          while (atom && atom instanceof LatexAtom && /[a-zA-Z\*]/.test(atom.value)) {
            offset = model.offsetOf(atom);
            atom = atom.rightSibling;
          }
        } else {
          atom = atom.leftSibling;
          if (!atom || !(atom instanceof LatexAtom)) {
            model.announce("plonk");
            return false;
          }
          while (atom && atom instanceof LatexAtom && /[a-zA-Z\*]/.test(atom.value)) {
            offset = model.offsetOf(atom);
            atom = atom.leftSibling;
          }
        }
      } else if (direction === "forward" && atom.type === "mopen") {
        let level = 0;
        do {
          if (atom.type === "mopen")
            level += 1;
          else if (atom.type === "mclose")
            level -= 1;
          atom = atom.rightSibling;
        } while (!atom.isLastSibling && level !== 0);
        offset = model.offsetOf(atom.leftSibling);
      } else if (direction === "backward" && atom.type === "mclose") {
        let level = 0;
        do {
          if (atom.type === "mopen")
            level += 1;
          else if (atom.type === "mclose")
            level -= 1;
          atom = atom.leftSibling;
        } while (!atom.isFirstSibling && level !== 0);
        offset = model.offsetOf(atom);
      } else if (direction === "backward") {
        if (atom.type === "first") {
          while (offset > 0 && atom.type === "first") {
            offset -= 1;
            atom = model.at(offset);
          }
        } else {
          const type = atom.type;
          if (atom.type === "msubsup") {
            offset = model.offsetOf(model.at(offset).leftSibling);
          }
          offset -= 1;
          let nextType = (_b3 = model.at(offset)) == null ? void 0 : _b3.type;
          while (offset >= 0 && nextType === type) {
            if (((_c2 = model.at(offset)) == null ? void 0 : _c2.type) === "msubsup")
              offset = model.offsetOf(model.at(offset).leftSibling);
            else
              offset -= 1;
            nextType = model.at(offset).type;
          }
        }
      } else {
        const { type } = atom;
        let nextType = (_d2 = model.at(offset)) == null ? void 0 : _d2.type;
        const { lastOffset } = model;
        while (offset <= lastOffset && (nextType === type || nextType === "msubsup")) {
          while (((_e = model.at(offset).rightSibling) == null ? void 0 : _e.type) === "msubsup")
            offset = model.offsetOf(model.at(offset).rightSibling);
          offset += 1;
          nextType = (_f = model.at(offset)) == null ? void 0 : _f.type;
        }
        offset -= 1;
      }
      if ((_g = options == null ? void 0 : options.extend) != null ? _g : false) {
        if (!model.setSelection(model.anchor, offset)) {
          model.announce("plonk");
          return false;
        }
      } else {
        if (offset === model.position) {
          model.announce("plonk");
          return false;
        }
        model.position = offset;
      }
      model.announce("move", previousPosition);
      return true;
    }
    function move(model, direction, options) {
      var _a3, _b3, _c2, _d2, _e, _f;
      options = options != null ? options : { extend: false };
      model.mathfield.adoptStyle = direction === "backward" ? "right" : "left";
      if (direction !== "forward") {
        const [from, to] = getCommandSuggestionRange(model);
        if (from !== void 0 && to !== void 0)
          model.deleteAtoms([from, to]);
      }
      if (direction === "upward")
        return moveUpward(model, options);
      if (direction === "downward")
        return moveDownward(model, options);
      const previousPosition = model.position;
      if (options.extend)
        return model.extendSelection(direction);
      if (model.selectionIsPlaceholder) {
        model.collapseSelection(direction);
        return move(model, direction);
      }
      const handleDeadEnd = () => {
        var _a4, _b4;
        let result = true;
        if (!model.suppressChangeNotifications) {
          result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
            new CustomEvent("move-out", {
              detail: { direction },
              cancelable: true,
              bubbles: true,
              composed: true
            })
          )) != null ? _b4 : true;
        }
        if (result)
          model.announce("plonk");
        return result;
      };
      if (!model.collapseSelection(direction)) {
        let pos = model.position + (direction === "forward" ? 1 : -1);
        let atom = model.at(pos);
        if (pos >= 0 && pos <= model.lastOffset) {
          if (direction === "forward") {
            if (model.mathfield.hasEditablePrompts && !model.at(pos).parentPrompt) {
              const nextAtoms = model.getAtoms(pos, -1).map((a) => [a, ...a.children]).flat();
              const nextPrompts = nextAtoms.filter(
                (p2) => p2.type === "prompt" && !p2.captureSelection
              );
              const nextPrompt = nextPrompts[0];
              if (!nextPrompt)
                return handleDeadEnd();
              pos = model.offsetOf(nextPrompt) - 1;
            } else if (atom.inCaptureSelection) {
              while (!atom.captureSelection)
                atom = atom.parent;
              pos = model.offsetOf(atom);
            } else if (!atom.isFirstSibling && atom.isLastSibling && ((_a3 = atom.parent) == null ? void 0 : _a3.skipBoundary)) {
              if (pos + 1 === model.lastOffset)
                pos = pos + 1;
              else {
                model.position = pos;
                return move(model, "forward", options);
              }
            } else if (((_b3 = atom.parent) == null ? void 0 : _b3.skipBoundary) && ((_c2 = atom.rightSibling) == null ? void 0 : _c2.isLastSibling))
              pos += 2;
            else if (((_d2 = atom.parent) == null ? void 0 : _d2.skipBoundary) && atom.type === "first")
              pos += 1;
            else if (atom instanceof LatexAtom && atom.isSuggestion)
              atom.isSuggestion = false;
          } else if (direction === "backward") {
            if (model.mathfield.hasEditablePrompts && !model.at(pos).parentPrompt) {
              const previousAtoms = model.getAtoms(0, pos).map((a) => [a, ...a.children]).flat();
              const previousPrompts = previousAtoms.filter(
                (p2) => p2.type === "prompt" && !p2.captureSelection
              );
              const previousPrompt = previousPrompts[previousPrompts.length - 1];
              if (!previousPrompt)
                return handleDeadEnd();
              pos = model.offsetOf(previousPrompt) - 1;
            } else if ((_e = atom.parent) == null ? void 0 : _e.inCaptureSelection) {
              while (!atom.captureSelection)
                atom = atom.parent;
              pos = Math.max(0, model.offsetOf(atom.leftSibling));
            } else if (atom.skipBoundary) {
              pos = Math.max(0, model.position - 2);
            } else if (((_f = atom.parent) == null ? void 0 : _f.skipBoundary) && atom.type === "first")
              pos = Math.max(0, model.position - 2);
          }
        }
        if (pos < 0 || pos > model.lastOffset)
          return handleDeadEnd();
        model.setPositionHandlingPlaceholder(pos);
      }
      model.announce("move", previousPosition);
      return true;
    }
    function getClosestAtomToXPosition(mathfield, search, x) {
      let prevX = Infinity;
      let i = 0;
      for (; i < search.length; i++) {
        const toX = getLocalDOMRect(mathfield.getHTMLElement(search[i])).right;
        const abs = Math.abs(x - toX);
        if (abs <= prevX) {
          prevX = abs;
        } else {
          break;
        }
      }
      return search[i - 1];
    }
    function moveToClosestAtomVertically(model, fromAtom, toAtoms, extend2, direction) {
      const editableAtoms = toAtoms.filter(
        (a) => !model.mathfield.hasEditableContent || a.type === "prompt" && !a.captureSelection
      );
      const fromX = getLocalDOMRect(model.mathfield.getHTMLElement(fromAtom)).right;
      const targetSelection = model.offsetOf(
        getClosestAtomToXPosition(model.mathfield, editableAtoms, fromX)
      ) - (model.mathfield.hasEditableContent ? 1 : 0);
      if (extend2) {
        const [left, right] = model.selection.ranges[0];
        let newSelection;
        const cmp = direction === "up" ? left : right;
        if (targetSelection < cmp) {
          newSelection = {
            ranges: [[targetSelection, right]],
            direction: "backward"
          };
        } else {
          newSelection = {
            ranges: [[left, targetSelection]],
            direction: "forward"
          };
        }
        model.setSelection(newSelection);
      } else {
        model.setPositionHandlingPlaceholder(targetSelection);
      }
      model.announce(`move ${direction}`);
    }
    function moveUpward(model, options) {
      var _a3, _b3;
      const extend2 = (_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false;
      if (!extend2)
        model.collapseSelection("backward");
      const handleDeadEnd = () => {
        var _a4, _b4;
        let result = true;
        if (!model.suppressChangeNotifications) {
          result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
            new CustomEvent("move-out", {
              detail: { direction: "upward" },
              cancelable: true,
              bubbles: true,
              composed: true
            })
          )) != null ? _b4 : true;
        }
        model.announce(result ? "plonk" : "line");
        return result;
      };
      const baseAtom = model.at(model.position);
      let atom = baseAtom;
      while (atom && atom.treeBranch !== "below" && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
        atom = atom.parent;
      if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && atom.parent instanceof ArrayAtom) {
        const arrayAtom = atom.parent;
        if (atom.treeBranch[0] < 1)
          return handleDeadEnd();
        const rowAbove = atom.treeBranch[0] - 1;
        const aboveCell = arrayAtom.array[rowAbove][atom.treeBranch[1]];
        const cellHasPrompt = aboveCell.some(
          (a) => a.type === "prompt" && !a.captureSelection
        );
        if (!cellHasPrompt && model.mathfield.hasEditableContent)
          return handleDeadEnd();
        moveToClosestAtomVertically(model, baseAtom, aboveCell, extend2, "up");
      } else if (atom) {
        const branch = (_b3 = atom.parent.branch("above")) != null ? _b3 : atom.parent.createBranch("above");
        const branchHasPrompt = branch.some(
          (a) => a.type === "prompt" && a.placeholderId
        );
        if (!branchHasPrompt && model.mathfield.hasEditableContent)
          return handleDeadEnd();
        moveToClosestAtomVertically(model, baseAtom, branch, extend2, "up");
      } else
        return handleDeadEnd();
      return true;
    }
    function moveDownward(model, options) {
      var _a3, _b3;
      const extend2 = (_a3 = options == null ? void 0 : options.extend) != null ? _a3 : false;
      if (!extend2)
        model.collapseSelection("forward");
      const handleDeadEnd = () => {
        var _a4, _b4;
        let result = true;
        if (!model.suppressChangeNotifications) {
          result = (_b4 = (_a4 = model.mathfield.host) == null ? void 0 : _a4.dispatchEvent(
            new CustomEvent("move-out", {
              detail: { direction: "downward" },
              cancelable: true,
              bubbles: true,
              composed: true
            })
          )) != null ? _b4 : true;
        }
        model.announce(result ? "plonk" : "line");
        return result;
      };
      const baseAtom = model.at(model.position);
      let atom = baseAtom;
      while (atom && atom.treeBranch !== "above" && !(Array.isArray(atom.treeBranch) && atom.parent instanceof ArrayAtom))
        atom = atom.parent;
      if (Array.isArray(atom == null ? void 0 : atom.treeBranch) && atom.parent instanceof ArrayAtom) {
        const arrayAtom = atom.parent;
        if (atom.treeBranch[0] + 1 > arrayAtom.array.length - 1)
          return handleDeadEnd();
        const rowBelow = atom.treeBranch[0] + 1;
        const belowCell = arrayAtom.array[rowBelow][atom.treeBranch[1]];
        const cellHasPrompt = belowCell.some(
          (a) => a.type === "prompt" && !a.captureSelection
        );
        if (!cellHasPrompt && model.mathfield.hasEditableContent)
          return handleDeadEnd();
        moveToClosestAtomVertically(model, baseAtom, belowCell, extend2, "down");
      } else if (atom) {
        const branch = (_b3 = atom.parent.branch("below")) != null ? _b3 : atom.parent.createBranch("below");
        const branchHasPrompt = branch.some((a) => a.type === "prompt");
        if (!branchHasPrompt && model.mathfield.hasEditableContent)
          return handleDeadEnd();
        moveToClosestAtomVertically(model, baseAtom, branch, extend2, "down");
      } else
        return handleDeadEnd();
      return true;
    }
    register2(
      {
        deleteAll: (model) => contentWillChange(model, { inputType: "deleteContent" }) && deleteRange(model, [0, -1], "deleteContent"),
        deleteForward: (model) => deleteForward(model),
        deleteBackward: (model) => deleteBackward(model),
        deleteNextWord: (model) => contentWillChange(model, { inputType: "deleteWordForward" }) && deleteRange(
          model,
          [model.anchor, wordBoundaryOffset(model, model.position, "forward")],
          "deleteWordForward"
        ),
        deletePreviousWord: (model) => contentWillChange(model, { inputType: "deleteWordBackward" }) && deleteRange(
          model,
          [model.anchor, wordBoundaryOffset(model, model.position, "backward")],
          "deleteWordBackward"
        ),
        deleteToGroupStart: (model) => contentWillChange(model, { inputType: "deleteSoftLineBackward" }) && deleteRange(
          model,
          [model.anchor, model.offsetOf(model.at(model.position).firstSibling)],
          "deleteSoftLineBackward"
        ),
        deleteToGroupEnd: (model) => contentWillChange(model, { inputType: "deleteSoftLineForward" }) && deleteRange(
          model,
          [model.anchor, model.offsetOf(model.at(model.position).lastSibling)],
          "deleteSoftLineForward"
        ),
        deleteToMathFieldStart: (model) => contentWillChange(model, { inputType: "deleteHardLineBackward" }) && deleteRange(model, [model.anchor, 0], "deleteHardLineBackward"),
        deleteToMathFieldEnd: (model) => contentWillChange(model, { inputType: "deleteHardLineForward" }) && deleteRange(model, [model.anchor, -1], "deleteHardLineForward")
      },
      { target: "model", category: "delete" }
    );
    function removeHighlight(element) {
      if (!element)
        return;
      element.classList.remove("ML__highlight");
      if (element.children)
        for (const child of element.children)
          removeHighlight(child);
    }
    function highlightAtomID(element, atomID) {
      var _a3;
      if (!element)
        return;
      if (!atomID || ((_a3 = element.dataset) == null ? void 0 : _a3.atomId) === atomID) {
        element.classList.add("ML__highlight");
        if (element.children && element.children.length > 0) {
          [...element.children].forEach((x) => {
            if (x instanceof HTMLElement)
              highlightAtomID(x);
          });
        }
      } else {
        element.classList.remove("ML__highlight");
        if (element.children && element.children.length > 0) {
          [...element.children].forEach((x) => {
            if (x instanceof HTMLElement)
              highlightAtomID(x, atomID);
          });
        }
      }
    }
    function defaultReadAloudHook(element, text) {
      var _a3;
      if (!isBrowser())
        return;
      if (window.MathfieldElement.speechEngine !== "amazon") {
        console.error(
          `MathLive 0.90.9: Use Amazon TTS Engine for synchronized highlighting`
        );
        if (typeof window.MathfieldElement.speakHook === "function")
          window.MathfieldElement.speakHook(text);
        return;
      }
      if (!window.AWS) {
        console.error(
          `MathLive 0.90.9: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk`
        );
        return;
      }
      const polly = new window.AWS.Polly({ apiVersion: "2016-06-10" });
      const parameters = {
        OutputFormat: "json",
        VoiceId: (_a3 = window.MathfieldElement.speechEngineVoice) != null ? _a3 : "Joanna",
        Engine: "standard",
        // The neural engine does not appear to support ssml marks
        Text: text,
        TextType: "ssml",
        SpeechMarkTypes: ["ssml"]
      };
      globalMathLive().readAloudElement = element;
      polly.synthesizeSpeech(parameters, (err, data) => {
        if (err) {
          console.trace(
            `MathLive 0.90.9: \`polly.synthesizeSpeech()\` error: ${err}`
          );
          return;
        }
        if (!(data == null ? void 0 : data.AudioStream)) {
          console.log("polly.synthesizeSpeech():", data);
          return;
        }
        const response = new TextDecoder("utf-8").decode(
          new Uint8Array(data.AudioStream)
        );
        globalMathLive().readAloudMarks = response.split("\n").map((x) => x ? JSON.parse(x) : {});
        globalMathLive().readAloudTokens = [];
        for (const mark of globalMathLive().readAloudMarks)
          if (mark.value)
            globalMathLive().readAloudTokens.push(mark.value);
        globalMathLive().readAloudCurrentMark = "";
        parameters.OutputFormat = "mp3";
        parameters.SpeechMarkTypes = [];
        polly.synthesizeSpeech(parameters, (err2, data2) => {
          if (err2) {
            console.trace(
              `MathLive 0.90.9: \`polly.synthesizeSpeech("${text}") error:${err2}`
            );
            return;
          }
          if (!(data2 == null ? void 0 : data2.AudioStream))
            return;
          const uInt8Array = new Uint8Array(data2.AudioStream);
          const blob = new Blob([uInt8Array.buffer], {
            type: "audio/mpeg"
          });
          const url = URL.createObjectURL(blob);
          const global2 = globalMathLive();
          if (!global2.readAloudAudio) {
            global2.readAloudAudio = new Audio();
            global2.readAloudAudio.addEventListener("ended", () => {
              const mathfield = global2.readAloudMathField;
              global2.readAloudStatus = "ended";
              document.body.dispatchEvent(
                new Event("read-aloud-status-change", {
                  bubbles: true,
                  composed: true
                })
              );
              if (mathfield) {
                render(mathfield);
                global2.readAloudElement = null;
                global2.readAloudMathField = null;
                global2.readAloudTokens = [];
                global2.readAloudMarks = [];
                global2.readAloudCurrentMark = "";
              } else
                removeHighlight(global2.readAloudElement);
            });
            global2.readAloudAudio.addEventListener("timeupdate", () => {
              let value = "";
              const target = global2.readAloudAudio.currentTime * 1e3 + 100;
              for (const mark of global2.readAloudMarks)
                if (mark.time < target)
                  value = mark.value;
              if (global2.readAloudCurrentMark !== value) {
                global2.readAloudCurrentToken = value;
                if (value && value === global2.readAloudFinalToken)
                  global2.readAloudAudio.pause();
                else {
                  global2.readAloudCurrentMark = value;
                  highlightAtomID(
                    global2.readAloudElement,
                    global2.readAloudCurrentMark
                  );
                }
              }
            });
          } else
            global2.readAloudAudio.pause();
          global2.readAloudAudio.src = url;
          global2.readAloudStatus = "playing";
          document.body.dispatchEvent(
            new Event("read-aloud-status-change", {
              bubbles: true,
              composed: true
            })
          );
          global2.readAloudAudio.play();
        });
      });
    }
    if (!isBrowser()) {
      console.error(
        `MathLive 0.90.9: this version of the MathLive library is for use in the browser. A subset of the API is available on the server side in the "mathlive-ssr" library. If using server side rendering (with React for example) you may want to do a dynamic import of the MathLive library inside a \`useEffect()\` call.`
      );
    }
    var MATHFIELD_TEMPLATE = isBrowser() ? document.createElement("template") : null;
    if (MATHFIELD_TEMPLATE) {
      MATHFIELD_TEMPLATE.innerHTML = `<style>
  :host { display: inline-block; background-color: field; color: fieldtext; border-width: 1px; border-style: solid; border-color: #acacac; border-radius: 2px; padding:4px; pointer-events: none;}
  :host([hidden]) { display: none; }
  :host([disabled]), :host([disabled]:focus), :host([disabled]:focus-within) { outline: none; opacity:  .5; }
  :host(:focus), :host(:focus-within) {
    outline: Highlight auto 1px;    /* For Firefox */
    outline: -webkit-focus-ring-color auto 1px;
  }
  </style>
  <span style="pointer-events:auto"></span><slot style="display:none"></slot>`;
    }
    var gDeferredState = /* @__PURE__ */ new WeakMap();
    var AUDIO_FEEDBACK_VOLUME = 0.5;
    var DEPRECATED_OPTIONS = {
      letterShapeStyle: "mf.letterShapeStyle = ...",
      horizontalSpacingScale: 'Removed. Use `"thinmuskip"`, `"medmuskip"`, and `"thickmuskip"` registers ',
      macros: "mf.macros = ...",
      registers: "mf.registers = ...",
      backgroundColorMap: "mf.backgroundColorMap = ...",
      colorMap: "mf.colorMap = ...",
      enablePopover: "mf.popoverPolicy = ...",
      mathModeSpace: "mf.mathModeSpace = ...",
      placeholderSymbol: "mf.placeholderSymbol = ...",
      readOnly: "mf.readOnly = ...",
      removeExtraneousParentheses: "mf.removeExtraneousParentheses = ...",
      scriptDepth: "mf.scriptDepth = ...",
      smartFence: "mf.smartFence = ...",
      smartMode: "mf.smartMode = ...",
      smartSuperscript: "mf.smartSuperscript = ...",
      inlineShortcutTimeout: "mf.inlineShortcutTimeout = ...",
      inlineShortcuts: "mf.inlineShortcuts = ...",
      keybindings: "mf.keybindings = ...",
      virtualKeyboardMode: "mf.mathVirtualKeyboardPolicy = ...",
      customVirtualKeyboardLayers: "mathVirtualKeyboard.layers = ...",
      customVirtualKeyboards: "mathVirtualKeyboard.layouts = ...",
      keypressSound: "mathVirtualKeyboard.keypressSound = ...",
      keypressVibration: "mathVirtualKeyboard.keypressVibration = ...",
      plonkSound: "mathVirtualKeyboard.plonkSound = ...",
      virtualKeyboardContainer: "mathVirtualKeyboard.container = ...",
      virtualKeyboardLayout: "mathVirtualKeyboard.alphabeticLayout = ...",
      virtualKeyboardTheme: "No longer supported",
      virtualKeyboardToggleGlyph: "No longer supported",
      virtualKeyboardToolbar: "mathVirtualKeyboard.actionToolbar = ...",
      virtualKeyboards: "Use `mathVirtualKeyboard.layouts`",
      speechEngine: "`MathfieldElement.speechEngine`",
      speechEngineRate: "`MathfieldElement.speechEngineRate`",
      speechEngineVoice: "`MathfieldElement.speechEngineVoice`",
      textToSpeechMarkup: "`MathfieldElement.textToSpeechMarkup`",
      textToSpeechRules: "`MathfieldElement.textToSpeechRules`",
      textToSpeechRulesOptions: "`MathfieldElement.textToSpeechRulesOptions`",
      readAloudHook: "`MathfieldElement.readAloudHook`",
      speakHook: "`MathfieldElement.speakHook`",
      computeEngine: "`MathfieldElement.computeEngine`",
      fontsDirectory: "`MathfieldElement.fontsDirectory`",
      soundsDirectory: "`MathfieldElement.soundsDirectory`",
      createHTML: "`MathfieldElement.createHTML`",
      onExport: "`MathfieldElement.onExport`",
      onInlineShortcut: "`MathfieldElement.onInlineShortcut`",
      locale: "MathfieldElement.locale = ...",
      strings: "MathfieldElement.strings = ...",
      decimalSeparator: "MathfieldElement.decimalSeparator = ...",
      fractionNavigationOrder: "MathfieldElement.fractionNavigationOrder = ..."
    };
    var _MathfieldElement = class extends HTMLElement {
      /**
           * To create programmatically a new mathfield use:
           *
           ```javascript
          let mfe = new MathfieldElement();
      
          // Set initial value and options
          mfe.value = "\\frac{\\sin(x)}{\\cos(x)}";
      
          // Options can be set either as an attribute (for simple options)...
          mfe.setAttribute("letter-shape-style", "french");
      
          // ... or using properties
          mfe.letterShapeStyle = "french";
      
          // Attach the element to the DOM
          document.body.appendChild(mfe);
          ```
          */
      constructor(options) {
        super();
        if (options) {
          const warnings = [];
          for (const key of Object.keys(options)) {
            if (DEPRECATED_OPTIONS[key]) {
              if (DEPRECATED_OPTIONS[key].startsWith("mf.")) {
                if (!DEPRECATED_OPTIONS[key].startsWith(`mf.${key}`)) {
                  const newName = DEPRECATED_OPTIONS[key].match(/([a-zA-Z]+) =/);
                  warnings.push(
                    `Option \`${key}\` has been renamed \`${newName[1]}\``
                  );
                } else {
                  warnings.push(
                    `Option \`${key}\` cannot be used as a constructor option. Use ${DEPRECATED_OPTIONS[key]}`
                  );
                }
              } else {
                warnings.push(
                  `Option \`${key}\` cannot be used as a constructor option. Use ${DEPRECATED_OPTIONS[key]}`
                );
              }
            } else
              warnings.push(`Unexpected option \`${key}\``);
          }
          if (warnings.length > 0) {
            console.group(
              `%cMathLive 0.90.9: %cInvalid Options`,
              "color:#12b; font-size: 1.1rem",
              "color:#db1111; font-size: 1.1rem"
            );
            console.warn(
              `Some of the options passed to \`new MathFieldElement(...)\` are invalid. 
          See https://cortexjs.io/mathlive/changelog/ for details.`
            );
            for (const warning of warnings)
              console.warn(warning);
            console.groupEnd();
          }
        }
        if (isElementInternalsSupported()) {
          this._internals = this.attachInternals();
          this._internals["role"] = "math";
          this._internals.ariaLabel = "math input field";
          this._internals.ariaMultiLine = "false";
        }
        this.attachShadow({ mode: "open", delegatesFocus: true });
        this.shadowRoot.append(MATHFIELD_TEMPLATE.content.cloneNode(true));
        const slot = this.shadowRoot.querySelector("slot:not([name])");
        this._slotValue = slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim();
        if (options)
          this._setOptions(options);
      }
      static get formAssociated() {
        return isElementInternalsSupported();
      }
      /**
       * Private lifecycle hooks
       * @internal
       */
      static get optionsAttributes() {
        return {
          "default-mode": "string",
          "letter-shape-style": "string",
          "popover-policy": "string",
          "math-mode-space": "string",
          "read-only": "boolean",
          "remove-extraneous-parentheses": "on/off",
          "smart-fence": "on/off",
          "smart-mode": "on/off",
          "smart-superscript": "on/off",
          "inline-shortcut-timeout": "string",
          "script-depth": "string",
          "virtual-keyboard-target-origin": "string",
          "math-virtual-keyboard-policy": "string"
        };
      }
      /**
       * Custom elements lifecycle hooks
       * @internal
       */
      static get observedAttributes() {
        return [
          ...Object.keys(this.optionsAttributes),
          "contenteditable",
          // Global attribute
          "disabled",
          // Global attribute
          "readonly",
          // A semi-global attribute (not all standard elements support it, but some do)
          "read-only"
          // Alternate spelling for `readonly`
        ];
      }
      /**
       * A URL fragment pointing to the directory containing the fonts
       * necessary to render a formula.
       *
       * These fonts are available in the `/dist/fonts` directory of the SDK.
       *
       * Customize this value to reflect where you have copied these fonts,
       * or to use the CDN version.
       *
       * The default value is `"./fonts"`. Use `null` to prevent
       * any fonts from being loaded.
       *
       * Changing this setting after the mathfield has been created will have
       * no effect.
       *
       * ```javascript
       * {
       *      // Use the CDN version
       *      fontsDirectory: ''
       * }
       * ```
       *
       * ```javascript
       * {
       *      // Use a directory called "fonts", located next to the
       *      // `mathlive.js` (or `mathlive.mjs`) file.
       *      fontsDirectory: './fonts'
       * }
       * ```
       *
       * ```javascript
       * {
       *      // Use a directory located at the root of your website
       *      fontsDirectory: 'https://example.com/fonts'
       * }
       * ```
       *
       */
      static get fontsDirectory() {
        return this._fontsDirectory;
      }
      static set fontsDirectory(value) {
        this._fontsDirectory = value;
        reloadFonts();
      }
      /**
       * A URL fragment pointing to the directory containing the optional
       * sounds used to provide feedback while typing.
       *
       * Some default sounds are available in the `/dist/sounds` directory of the SDK.
       *
       * Use `null` to prevent any sound from being loaded.
       *
       */
      static get soundsDirectory() {
        return this._soundsDirectory;
      }
      static set soundsDirectory(value) {
        this._soundsDirectory = value;
        this.audioBuffers = {};
      }
      /**
       * When a key on the virtual keyboard is pressed, produce a short audio
       * feedback.
       *
       * If the property is set to a `string`, the same sound is played in all
       * cases. Otherwise, a distinct sound is played:
       *
       * -   `delete` a sound played when the delete key is pressed
       * -   `return` ... when the return/tab key is pressed
       * -   `spacebar` ... when the spacebar is pressed
       * -   `default` ... when any other key is pressed. This property is required,
       *     the others are optional. If they are missing, this sound is played as
       *     well.
       *
       * The value of the properties should be either a string, the name of an
       * audio file in the `soundsDirectory` directory or `null` to suppress the sound.
       */
      static get keypressSound() {
        return this._keypressSound;
      }
      static set keypressSound(value) {
        var _a3, _b3, _c2;
        this.audioBuffers = {};
        if (value === null) {
          this._keypressSound = {
            spacebar: null,
            return: null,
            delete: null,
            default: null
          };
        } else if (typeof value === "string") {
          this._keypressSound = {
            spacebar: value,
            return: value,
            delete: value,
            default: value
          };
        } else if (typeof value === "object" && "default" in value) {
          this._keypressSound = {
            spacebar: (_a3 = value.spacebar) != null ? _a3 : value.default,
            return: (_b3 = value.return) != null ? _b3 : value.default,
            delete: (_c2 = value.delete) != null ? _c2 : value.default,
            default: value.default
          };
        }
      }
      static get plonkSound() {
        return this._plonkSound;
      }
      static set plonkSound(value) {
        this.audioBuffers = {};
        this._plonkSound = value;
      }
      static get audioContext() {
        if (!this._audioContext)
          this._audioContext = new AudioContext();
        return this._audioContext;
      }
      // @todo https://github.com/microsoft/TypeScript/issues/30024
      /**
       * Indicates which speech engine to use for speech output.
       *
       * Use `local` to use the OS-specific TTS engine.
       *
       * Use `amazon` for Amazon Text-to-Speech cloud API. You must include the
       * AWS API library and configure it with your API key before use.
       *
       * **See**
       * {@link https://cortexjs.io/mathlive/guides/speech/ | Guide: Speech}
       */
      static get speechEngine() {
        return this._speechEngine;
      }
      static set speechEngine(value) {
        this._speechEngine = value;
      }
      /**
       * Sets the speed of the selected voice.
       *
       * One of `x-slow`, `slow`, `medium`, `fast`, `x-fast` or a value as a
       * percentage.
       *
       * Range is `20%` to `200%` For example `200%` to indicate a speaking rate
       * twice the default rate.
       */
      static get speechEngineRate() {
        return this._speechEngineRate;
      }
      static set speechEngineRate(value) {
        this._speechEngineRate = value;
      }
      /**
       * Indicates the voice to use with the speech engine.
       *
       * This is dependent on the speech engine. For Amazon Polly, see here:
       * https://docs.aws.amazon.com/polly/latest/dg/voicelist.html
       *
       */
      static get speechEngineVoice() {
        return this._speechEngineVoice;
      }
      static set speechEngineVoice(value) {
        this._speechEngineVoice = value;
      }
      /**
       * The markup syntax to use for the output of conversion to spoken text.
       *
       * Possible values are `ssml` for the SSML markup or `mac` for the macOS
       * markup, i.e. `&#91;&#91;ltr&#93;&#93;`.
       *
       */
      static get textToSpeechMarkup() {
        return this._textToSpeechMarkup;
      }
      static set textToSpeechMarkup(value) {
        this._textToSpeechMarkup = value;
      }
      /**
       * Specify which set of text to speech rules to use.
       *
       * A value of `mathlive` indicates that the simple rules built into MathLive
       * should be used.
       *
       * A value of `sre` indicates that the Speech Rule Engine from Volker Sorge
       * should be used.
       *
       * **(Caution)** SRE is not included or loaded by MathLive. For this option to
       * work SRE should be loaded separately.
       *
       * **See**
       * {@link https://cortexjs.io/mathlive/guides/speech/ | Guide: Speech}
       */
      static get textToSpeechRules() {
        return this._textToSpeechRules;
      }
      static set textToSpeechRules(value) {
        this._textToSpeechRules = value;
      }
      /**
       * A set of key/value pairs that can be used to configure the speech rule
       * engine.
       *
       * Which options are available depends on the speech rule engine in use.
       * There are no options available with MathLive's built-in engine. The
       * options for the SRE engine are documented
       * {@link https://github.com/zorkow/speech-rule-engine | here}
       */
      static get textToSpeechRulesOptions() {
        return this._textToSpeechRulesOptions;
      }
      static set textToSpeechRulesOptions(value) {
        this._textToSpeechRulesOptions = value;
      }
      /**
       * The locale (language + region) to use for string localization.
       *
       * If none is provided, the locale of the browser is used.
       *
       */
      static get locale() {
        return l10n.locale;
      }
      static set locale(value) {
        if (value === "auto")
          value = navigator.language.slice(0, 5);
        l10n.locale = value;
      }
      /**
       * The symbol used to separate the integer part from the fractional part of a
       * number.
       *
       * When `","` is used, the corresponding LaTeX string is `{,}`, in order
       * to ensure proper spacing (otherwise an extra gap is displayed after the
       * comma).
       *
       * This affects:
       * - what happens when the `,` key is pressed (if `decimalSeparator` is
       * `","`, the `{,}` LaTeX string is inserted when following some digits)
       * - the label and behavior of the "." key in the default virtual keyboard
       *
       * **Default**: `"."`
       */
      static get decimalSeparator() {
        return this._decimalSeparator;
      }
      static set decimalSeparator(value) {
        this._decimalSeparator = value;
        if (this._computeEngine) {
          this._computeEngine.latexOptions.decimalMarker = this.decimalSeparator === "," ? "{,}" : ".";
        }
      }
      /**
      * An object whose keys are a locale string, and whose values are an object of
      * string identifier to localized string.
      *
      * **Example**
      *
      ```json
      {
        "fr-CA": {
            "tooltip.undo": "Annuler",
            "tooltip.redo": "Refaire",
        }
      }
      ```
      *
      * This will override the default localized strings.
      */
      static get strings() {
        return l10n.strings;
      }
      static set strings(value) {
        l10n.merge(value);
      }
      /**
       * A custom compute engine instance. If none is provided, a default one is
       * used. If `null` is specified, no compute engine is used.
       */
      static get computeEngine() {
        var _a3, _b3;
        if (this._computeEngine === void 0) {
          const ComputeEngineCtor = (_a3 = window[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : _a3.ComputeEngine;
          if (ComputeEngineCtor)
            this._computeEngine = new ComputeEngineCtor();
          else {
            console.error(
              `MathLive 0.90.9: The CortexJS Compute Engine library is not available.
          
          Load the library, for example with:
          
          import "https://unpkg.com/@cortex-js/compute-engine?module"`
            );
          }
          if (this._computeEngine && this.decimalSeparator === ",")
            this._computeEngine.latexOptions.decimalMarker = "{,}";
        }
        return (_b3 = this._computeEngine) != null ? _b3 : null;
      }
      static set computeEngine(value) {
        this._computeEngine = value;
      }
      static async loadSound(sound) {
        delete this.audioBuffers[sound];
        let soundFile = "";
        switch (sound) {
          case "keypress":
            soundFile = this._keypressSound.default;
            break;
          case "return":
            soundFile = this._keypressSound.return;
            break;
          case "spacebar":
            soundFile = this._keypressSound.spacebar;
            break;
          case "delete":
            soundFile = this._keypressSound.delete;
            break;
          case "plonk":
            soundFile = this.plonkSound;
            break;
        }
        if (typeof soundFile !== "string")
          return;
        soundFile = soundFile.trim();
        const soundsDirectory = this.soundsDirectory;
        if (soundsDirectory === void 0 || soundsDirectory === null || soundsDirectory === "null" || soundFile === "none" || soundFile === "null")
          return;
        const response = await fetch(
          await resolveUrl(`${soundsDirectory}/${soundFile}`)
        );
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
        this.audioBuffers[sound] = audioBuffer;
      }
      static async playSound(name) {
        if (!this.audioBuffers[name])
          await this.loadSound(name);
        if (!this.audioBuffers[name])
          return;
        const soundSource = this.audioContext.createBufferSource();
        soundSource.buffer = this.audioBuffers[name];
        const gainNode = this.audioContext.createGain();
        gainNode.gain.value = AUDIO_FEEDBACK_VOLUME;
        soundSource.connect(gainNode).connect(this.audioContext.destination);
        soundSource.start();
      }
      onPointerDown() {
        window.addEventListener(
          "pointerup",
          (evt) => {
            var _a3;
            if (evt.target === this && !((_a3 = this._mathfield) == null ? void 0 : _a3.disabled)) {
              this.dispatchEvent(
                new MouseEvent("click", {
                  altKey: evt.altKey,
                  button: evt.button,
                  buttons: evt.buttons,
                  clientX: evt.clientX,
                  clientY: evt.clientY,
                  ctrlKey: evt.ctrlKey,
                  metaKey: evt.metaKey,
                  movementX: evt.movementX,
                  movementY: evt.movementY,
                  relatedTarget: evt.relatedTarget,
                  screenX: evt.screenX,
                  screenY: evt.screenY,
                  shiftKey: evt.shiftKey
                })
              );
            }
          },
          { once: true }
        );
      }
      getPromptValue(placeholderId) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPromptValue(placeholderId)) != null ? _b3 : "";
      }
      /** Return the id of the prompts matching the filter */
      getPrompts(filter) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPrompts(filter)) != null ? _b3 : [];
      }
      addEventListener(type, listener, options) {
        return super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
      }
      get form() {
        var _a3;
        return (_a3 = this._internals) == null ? void 0 : _a3["form"];
      }
      get name() {
        var _a3;
        return (_a3 = this.getAttribute("name")) != null ? _a3 : "";
      }
      get type() {
        return this.localName;
      }
      get mode() {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.mode) != null ? _b3 : "math";
      }
      set mode(value) {
        if (!this._mathfield)
          return;
        this._mathfield.mode = value;
      }
      /**
         * If the Compute Engine library is available, return a boxed MathJSON expression representing the value of the mathfield.
         *
         * To load the Compute Engine library, use:
         * ```js
      import 'https://unpkg.com/@cortex-js/compute-engine?module';
      ```
         *
         */
      get expression() {
        if (!this._mathfield)
          return void 0;
        if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
          console.error(
            `MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
          );
        }
        return this._mathfield.expression;
      }
      set expression(mathJson) {
        var _a3, _b3;
        if (!this._mathfield)
          return;
        const latex = (_b3 = (_a3 = _MathfieldElement.computeEngine) == null ? void 0 : _a3.box(mathJson).latex) != null ? _b3 : null;
        if (latex !== null)
          this._mathfield.setValue(latex);
        if (!window[Symbol.for("io.cortexjs.compute-engine")]) {
          console.error(
            `MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
          );
        }
      }
      get errors() {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.errors) != null ? _b3 : [];
      }
      _getOptions(keys) {
        if (this._mathfield)
          return get2(this._mathfield.options, keys);
        if (!gDeferredState.has(this))
          return null;
        return get2(
          update(getDefault(), gDeferredState.get(this).options),
          keys
        );
      }
      getOptions(keys) {
        console.warn(
          `%cMathLive 0.90.9: %cDeprecated Usage%c
      \`mf.getOptions()\` is deprecated. Read the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`,
          "color:#12b; font-size: 1.1rem",
          "color:#db1111; font-size: 1.1rem",
          "color: inherit, font-size: 1rem"
        );
        if (this._mathfield)
          return get2(this._mathfield.options, keys);
        if (!gDeferredState.has(this))
          return null;
        return get2(
          update(getDefault(), gDeferredState.get(this).options),
          keys
        );
      }
      /** @internal */
      reflectAttributes() {
        const defaultOptions = getDefault();
        const options = this._getOptions();
        Object.keys(_MathfieldElement.optionsAttributes).forEach((x) => {
          const prop = toCamelCase(x);
          if (_MathfieldElement.optionsAttributes[x] === "on/off") {
            if (defaultOptions[prop] !== options[prop])
              this.setAttribute(x, options[prop] ? "on" : "off");
            else
              this.removeAttribute(x);
          } else if (defaultOptions[prop] !== options[prop]) {
            if (_MathfieldElement.optionsAttributes[x] === "boolean") {
              if (options[prop]) {
                this.setAttribute(x, "");
              } else {
                this.removeAttribute(x);
              }
            } else {
              if (typeof options[prop] === "string" || typeof options[prop] === "number")
                this.setAttribute(x, options[prop].toString());
            }
          }
        });
      }
      /**
       *  @category Options
       * @deprecated
       */
      getOption(key) {
        console.warn(
          `%cMathLive 0.90.9: %cDeprecated Usage%c
      \`mf.getOption()\` is deprecated. Read the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`,
          "color:#12b; font-size: 1.1rem",
          "color:#db1111; font-size: 1.1rem",
          "color: inherit, font-size: 1rem"
        );
        return this._getOptions([key])[key];
      }
      /** @internal */
      _getOption(key) {
        return this._getOptions([key])[key];
      }
      /** @internal */
      _setOptions(options) {
        if (this._mathfield)
          this._mathfield.setOptions(options);
        else if (gDeferredState.has(this)) {
          const mergedOptions = __spreadValues(__spreadValues({}, gDeferredState.get(this).options), options);
          gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
            selection: { ranges: mergedOptions.readOnly ? [[0, 0]] : [[0, -1]] },
            options: mergedOptions
          }));
        } else {
          gDeferredState.set(this, {
            value: void 0,
            selection: { ranges: [[0, 0]] },
            options
          });
        }
        this.reflectAttributes();
      }
      /**
       *  @category Options
       * @deprecated
       */
      setOptions(options) {
        console.group(
          `%cMathLive 0.90.9: %cDeprecated Usage`,
          "color:#12b; font-size: 1.1rem",
          "color:#db1111; font-size: 1.1rem"
        );
        console.warn(
          ` \`mf.setOptions()\` is deprecated. Set the property directly on the mathfield instead.
      See https://cortexjs.io/mathlive/changelog/ for details.`
        );
        for (const key of Object.keys(options)) {
          if (DEPRECATED_OPTIONS[key]) {
            console.warn(
              `\`mf.setOptions({${key}:...})\` -> ${DEPRECATED_OPTIONS[key]}`
            );
          }
        }
        console.groupEnd();
        this._setOptions(options);
      }
      /**
       * @inheritdoc Mathfield.executeCommand
       */
      executeCommand(command) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.executeCommand(command)) != null ? _b3 : false;
      }
      getValue(arg1, arg2, arg3) {
        var _a3, _b3;
        if (this._mathfield)
          return this._mathfield.model.getValue(arg1, arg2, arg3);
        if (gDeferredState.has(this)) {
          let start;
          let end;
          let format = void 0;
          if (isSelection(arg1)) {
            [start, end] = arg1.ranges[0];
            format = arg2;
          } else if (isRange(arg1)) {
            [start, end] = arg1;
            format = arg2;
          } else if (isOffset(arg1) && isOffset(arg2)) {
            start = arg1;
            end = arg2;
            format = arg3;
          } else {
            start = 0;
            end = -1;
            format = arg1;
          }
          if ((format === void 0 || format === "latex") && start === 0 && end === -1)
            return (_b3 = (_a3 = gDeferredState.get(this).value) != null ? _a3 : this.textContent) != null ? _b3 : "";
        }
        return "";
      }
      /**
       * @inheritdoc Mathfield.setValue
       * @category Accessing and changing the content
       */
      setValue(value, options) {
        if (this._mathfield && value !== void 0) {
          if (!options)
            options = { suppressChangeNotifications: true };
          this._mathfield.setValue(value, options);
          return;
        }
        if (gDeferredState.has(this)) {
          const options2 = gDeferredState.get(this).options;
          gDeferredState.set(this, {
            value,
            selection: {
              ranges: options2.readOnly ? [[0, 0]] : [[0, -1]],
              direction: "forward"
            },
            options: options2
          });
          return;
        }
        const attrOptions = getOptionsFromAttributes(this);
        gDeferredState.set(this, {
          value,
          selection: {
            ranges: attrOptions.readOnly ? [[0, 0]] : [[0, -1]],
            direction: "forward"
          },
          options: attrOptions
        });
      }
      /**
       * @inheritdoc Mathfield.hasFocus
       *
       * @category Focus
       *
       */
      hasFocus() {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.hasFocus()) != null ? _b3 : false;
      }
      /**
       * Sets the focus to the mathfield (will respond to keyboard input).
       *
       * @category Focus
       *
       */
      focus() {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.focus();
      }
      /**
       * Remove the focus from the mathfield (will no longer respond to keyboard
       * input).
       *
       * @category Focus
       *
       */
      blur() {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.blur();
      }
      /**
       * Select the content of the mathfield.
       * @category Selection
       */
      select() {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.select();
      }
      /**
         * @inheritdoc Mathfield.insert
      
         *  @category Accessing and changing the content
         */
      insert(s, options) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.insert(s, options)) != null ? _b3 : false;
      }
      /**
       * @inheritdoc Mathfield.applyStyle
       *
       * @category Accessing and changing the content
       */
      applyStyle(style, options) {
        var _a3;
        return (_a3 = this._mathfield) == null ? void 0 : _a3.applyStyle(style, options);
      }
      /**
       * The bottom location of the caret (insertion point) in viewport
       * coordinates.
       *
       * @category Selection
       */
      get caretPoint() {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getCaretPoint()) != null ? _b3 : null;
      }
      set caretPoint(point) {
        var _a3;
        if (!point)
          return;
        (_a3 = this._mathfield) == null ? void 0 : _a3.setCaretPoint(point.x, point.y);
      }
      /**
       * `x` and `y` are in viewport coordinates.
       *
       * Return true if the location of the point is a valid caret location.
       *
       * See also [[`caretPoint`]]
       * @category Selection
       */
      setCaretPoint(x, y) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.setCaretPoint(x, y)) != null ? _b3 : false;
      }
      /** The offset closest to the location `(x, y)` in viewport coordinate.
       *
       * **`bias`**:  if `0`, the vertical midline is considered to the left or
       * right sibling. If `-1`, the left sibling is favored, if `+1`, the right
       * sibling is favored.
       *
       * @category Selection
       */
      offsetFromPoint(x, y, options) {
        if (!this._mathfield)
          return -1;
        return offsetFromPoint(this._mathfield, x, y, options);
      }
      /** The bounding rect of the atom at offset
       *
       * @category Selection
       *
       */
      hitboxFromOffset(offset) {
        if (!this._mathfield)
          return null;
        const atom = this._mathfield.model.at(offset);
        if (!atom)
          return null;
        const bounds = getAtomBounds(this._mathfield, atom);
        if (!bounds)
          return null;
        return new DOMRect(
          bounds.left,
          bounds.top,
          bounds.right - bounds.left,
          bounds.bottom - bounds.top
        );
      }
      /**
       * Reset the undo stack
       * (for parent components with their own undo/redo)
       */
      resetUndo() {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.resetUndo();
      }
      /**
       * Return whether there are undoable items
       * (for parent components with their own undo/redo)
       */
      canUndo() {
        if (!this._mathfield)
          return false;
        return this._mathfield.canUndo();
      }
      /**
       * Return whether there are redoable items
       * (for parent components with their own undo/redo)
       */
      canRedo() {
        if (!this._mathfield)
          return false;
        return this._mathfield.canRedo();
      }
      /**
       * Custom elements lifecycle hooks
       * @internal
       */
      connectedCallback() {
        var _a3, _b3, _c2;
        requestAnimationFrame(() => void loadFonts());
        this.shadowRoot.host.addEventListener(
          "pointerdown",
          () => this.onPointerDown(),
          true
        );
        this.shadowRoot.host.addEventListener(
          "focus",
          () => {
            var _a4;
            return (_a4 = this._mathfield) == null ? void 0 : _a4.focus();
          },
          true
        );
        this.shadowRoot.host.addEventListener(
          "blur",
          () => {
            var _a4;
            return (_a4 = this._mathfield) == null ? void 0 : _a4.blur();
          },
          true
        );
        if (!isElementInternalsSupported()) {
          if (!this.hasAttribute("role"))
            this.setAttribute("role", "math");
          if (!this.hasAttribute("aria-label"))
            this.setAttribute("aria-label", "math input field");
          this.setAttribute("aria-multiline", "false");
        }
        if (!this.hasAttribute("contenteditable"))
          this.setAttribute("contenteditable", "true");
        if (!this.hasAttribute("tabindex"))
          this.setAttribute("tabindex", "0");
        const slot = this.shadowRoot.querySelector("slot:not([name])");
        let value = "";
        if (this.hasAttribute("value"))
          value = (_a3 = this.getAttribute("value")) != null ? _a3 : "";
        else {
          value = (_b3 = slot == null ? void 0 : slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim()) != null ? _b3 : "";
        }
        this._mathfield = new MathfieldPrivate(
          this.shadowRoot.querySelector(":host > span"),
          __spreadProps(__spreadValues({}, gDeferredState.has(this) ? gDeferredState.get(this).options : getOptionsFromAttributes(this)), {
            eventSink: this,
            value
          })
        );
        if (!gDeferredState.has(this)) {
          this.upgradeProperty("disabled");
          this.upgradeProperty("readonly");
          for (const attr of Object.keys(_MathfieldElement.optionsAttributes))
            this.upgradeProperty(toCamelCase(attr));
        }
        if (!((_c2 = this._mathfield) == null ? void 0 : _c2.model)) {
          this._mathfield = null;
          return;
        }
        if (gDeferredState.has(this)) {
          this._mathfield.model.deferNotifications(
            { content: false, selection: false },
            () => {
              const value2 = gDeferredState.get(this).value;
              if (value2 !== void 0)
                this._mathfield.setValue(value2);
              this._mathfield.model.selection = gDeferredState.get(this).selection;
              gDeferredState.delete(this);
            }
          );
        }
        slot.addEventListener("slotchange", (event) => {
          if (event.target !== slot)
            return;
          const value2 = slot.assignedNodes().map((x) => x.nodeType === 3 ? x.textContent : "").join("").trim();
          if (value2 === this._slotValue)
            return;
          if (!this._mathfield)
            this.value = value2;
          else {
            this._mathfield.setValue(value2);
          }
        });
        this.dispatchEvent(
          new Event("mount", { cancelable: false, bubbles: true, composed: true })
        );
      }
      /**
       * Custom elements lifecycle hooks
       * @internal
       */
      disconnectedCallback() {
        this.dispatchEvent(
          new Event("unmount", { cancelable: false, bubbles: true, composed: true })
        );
        if (!this._mathfield)
          return;
        const options = get2(
          this._mathfield.options,
          Object.keys(_MathfieldElement.optionsAttributes).map((x) => toCamelCase(x))
        );
        gDeferredState.set(this, {
          value: this._mathfield.getValue(),
          selection: this._mathfield.model.selection,
          options
        });
        this._mathfield.dispose();
        this._mathfield = null;
      }
      /**
       * Private lifecycle hooks
       * @internal
       */
      upgradeProperty(prop) {
        if (this.hasOwnProperty(prop)) {
          const value = this[prop];
          delete this[prop];
          if (prop === "readonly" || prop === "read-only")
            prop = "readOnly";
          this[prop] = value;
        }
      }
      /**
       * Custom elements lifecycle hooks
       * @internal
       */
      attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue)
          return;
        const hasValue = newValue !== null;
        switch (name) {
          case "contenteditable":
            if (this._mathfield)
              requestUpdate(this._mathfield);
            break;
          case "disabled":
            this.disabled = hasValue;
            break;
          case "read-only":
          case "readonly":
            this.readOnly = hasValue;
            break;
        }
      }
      get readonly() {
        return this.hasAttribute("readonly") || this.hasAttribute("read-only");
      }
      set readonly(value) {
        const isReadonly2 = Boolean(value);
        if (isReadonly2) {
          this.setAttribute("readonly", "");
          if (isElementInternalsSupported())
            this._internals.ariaReadOnly = "true";
          else
            this.setAttribute("aria-readonly", "true");
          this.setAttribute("aria-readonly", "true");
        } else {
          if (isElementInternalsSupported())
            this._internals.ariaReadOnly = "false";
          else
            this.removeAttribute("aria-readonly");
          this.removeAttribute("readonly");
          this.removeAttribute("read-only");
        }
        this._setOptions({ readOnly: isReadonly2 });
      }
      get disabled() {
        return this.hasAttribute("disabled");
      }
      set disabled(value) {
        var _a3;
        const isDisabled = Boolean(value);
        if (isDisabled)
          this.setAttribute("disabled", "");
        else
          this.removeAttribute("disabled");
        if (isElementInternalsSupported())
          this._internals.ariaDisabled = isDisabled ? "true" : "false";
        else
          this.setAttribute("aria-disabled", isDisabled ? "true" : "false");
        if (isDisabled && ((_a3 = this._mathfield) == null ? void 0 : _a3.hasFocus) && window.mathVirtualKeyboard.visible)
          this._mathfield.executeCommand("hideVirtualKeyboard");
      }
      /**
       * The content of the mathfield as a LaTeX expression.
       * ```js
       * document.querySelector('mf').value = '\\frac{1}{\\pi}'
       * ```
       *  @category Accessing and changing the content
       */
      get value() {
        return this.getValue();
      }
      /**
       *  @category Accessing and changing the content
       */
      set value(value) {
        this.setValue(value);
      }
      get defaultMode() {
        return this._getOption("defaultMode");
      }
      set defaultMode(value) {
        this._setOptions({ defaultMode: value });
      }
      get macros() {
        return this._getOption("macros");
      }
      set macros(value) {
        this._setOptions({ macros: value });
      }
      get registers() {
        return this._getOption("registers");
      }
      set registers(value) {
        this._setOptions({ registers: value });
      }
      get colorMap() {
        return this._getOption("colorMap");
      }
      set colorMap(value) {
        this._setOptions({ colorMap: value });
      }
      get backgroundColorMap() {
        return this._getOption("backgroundColorMap");
      }
      set backgroundColorMap(value) {
        this._setOptions({ backgroundColorMap: value });
      }
      get letterShapeStyle() {
        return this._getOption("letterShapeStyle");
      }
      set letterShapeStyle(value) {
        this._setOptions({ letterShapeStyle: value });
      }
      get smartMode() {
        return this._getOption("smartMode");
      }
      set smartMode(value) {
        this._setOptions({ smartMode: value });
      }
      get smartFence() {
        return this._getOption("smartFence");
      }
      set smartFence(value) {
        this._setOptions({ smartFence: value });
      }
      get smartSuperscript() {
        return this._getOption("smartSuperscript");
      }
      set smartSuperscript(value) {
        this._setOptions({ smartSuperscript: value });
      }
      get scriptDepth() {
        return this._getOption("scriptDepth");
      }
      set scriptDepth(value) {
        this._setOptions({ scriptDepth: value });
      }
      get removeExtraneousParentheses() {
        return this._getOption("removeExtraneousParentheses");
      }
      set removeExtraneousParentheses(value) {
        this._setOptions({ removeExtraneousParentheses: value });
      }
      get mathModeSpace() {
        return this._getOption("mathModeSpace");
      }
      set mathModeSpace(value) {
        this._setOptions({ mathModeSpace: value });
      }
      get placeholderSymbol() {
        return this._getOption("placeholderSymbol");
      }
      set placeholderSymbol(value) {
        this._setOptions({ placeholderSymbol: value });
      }
      get popoverPolicy() {
        return this._getOption("popoverPolicy");
      }
      set popoverPolicy(value) {
        this._setOptions({ popoverPolicy: value });
      }
      get mathVirtualKeyboardPolicy() {
        return this._getOption("mathVirtualKeyboardPolicy");
      }
      set mathVirtualKeyboardPolicy(value) {
        this._setOptions({ mathVirtualKeyboardPolicy: value });
      }
      get inlineShortcuts() {
        return this._getOption("inlineShortcuts");
      }
      set inlineShortcuts(value) {
        this._setOptions({ inlineShortcuts: value });
      }
      get inlineShortcutTimeout() {
        return this._getOption("inlineShortcutTimeout");
      }
      set inlineShortcutTimeout(value) {
        this._setOptions({ inlineShortcutTimeout: value });
      }
      get keybindings() {
        return this._getOption("keybindings");
      }
      set keybindings(value) {
        this._setOptions({ keybindings: value });
      }
      get onInlineShortcut() {
        return this._getOption("onInlineShortcut");
      }
      set onInlineShortcut(value) {
        this._setOptions({ onInlineShortcut: value });
      }
      get onExport() {
        return this._getOption("onExport");
      }
      set onExport(value) {
        this._setOptions({ onExport: value });
      }
      get readOnly() {
        return this._getOption("readOnly");
      }
      set readOnly(value) {
        this._setOptions({ readOnly: value });
      }
      setPromptState(id, state, locked) {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.setPromptState(id, state, locked);
      }
      getPromptState(id) {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.getPromptState(id)) != null ? _b3 : [void 0, true];
      }
      setPromptContent(id, content, insertOptions) {
        var _a3;
        (_a3 = this._mathfield) == null ? void 0 : _a3.setPromptValue(id, content, insertOptions);
      }
      get virtualKeyboardTargetOrigin() {
        return this._getOption("virtualKeyboardTargetOrigin");
      }
      set virtualKeyboardTargetOrigin(value) {
        this._setOptions({ virtualKeyboardTargetOrigin: value });
      }
      /**
       * An array of ranges representing the selection.
       *
       * It is guaranteed there will be at least one element. If a discontinuous
       * selection is present, the result will include more than one element.
       *
       * @category Selection
       *
       */
      get selection() {
        if (this._mathfield)
          return this._mathfield.model.selection;
        if (gDeferredState.has(this))
          return gDeferredState.get(this).selection;
        return { ranges: [[0, 0]], direction: "forward" };
      }
      /**
       *
       * @category Selection
       */
      set selection(sel) {
        if (typeof sel === "number")
          sel = { ranges: [[sel, sel]] };
        if (this._mathfield) {
          this._mathfield.model.selection = sel;
          return;
        }
        if (gDeferredState.has(this)) {
          gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
            selection: sel
          }));
          return;
        }
        gDeferredState.set(this, {
          value: void 0,
          selection: sel,
          options: getOptionsFromAttributes(this)
        });
      }
      get selectionIsCollapsed() {
        const selection = this.selection;
        return selection.ranges.length === 1 && selection.ranges[0][0] === selection.ranges[0][1];
      }
      /**
       * The position of the caret/insertion point, from 0 to `lastOffset`.
       *
       * @category Selection
       *
       */
      get position() {
        if (this._mathfield)
          return this._mathfield.model.position;
        if (gDeferredState.has(this))
          return gDeferredState.get(this).selection.ranges[0][0];
        return 0;
      }
      /**
       * @category Selection
       */
      set position(offset) {
        if (this._mathfield)
          this._mathfield.model.position = offset;
        if (gDeferredState.has(this)) {
          gDeferredState.set(this, __spreadProps(__spreadValues({}, gDeferredState.get(this)), {
            selection: { ranges: [[offset, offset]] }
          }));
          return;
        }
        gDeferredState.set(this, {
          value: void 0,
          selection: { ranges: [[offset, offset]] },
          options: getOptionsFromAttributes(this)
        });
      }
      /**
       * The depth of an offset represent the depth in the expression tree.
       */
      getOffsetDepth(offset) {
        var _a3;
        if (this._mathfield)
          return ((_a3 = this._mathfield.model.at(offset)) == null ? void 0 : _a3.treeDepth) - 2;
        return 0;
      }
      /**
       * The last valid offset.
       * @category Selection
       */
      get lastOffset() {
        var _a3, _b3;
        return (_b3 = (_a3 = this._mathfield) == null ? void 0 : _a3.model.lastOffset) != null ? _b3 : -1;
      }
    };
    var MathfieldElement = _MathfieldElement;
    MathfieldElement.version = "0.90.9";
    MathfieldElement._fontsDirectory = "./fonts";
    MathfieldElement._soundsDirectory = "./sounds";
    MathfieldElement.keypressVibration = true;
    MathfieldElement._keypressSound = {
      spacebar: "keypress-spacebar.wav",
      return: "keypress-return.wav",
      delete: "keypress-delete.wav",
      default: "keypress-standard.wav"
    };
    MathfieldElement._plonkSound = "plonk.wav";
    MathfieldElement.audioBuffers = {};
    MathfieldElement.createHTML = (x) => x;
    MathfieldElement._speechEngineRate = "100%";
    MathfieldElement._speechEngineVoice = "Joanna";
    MathfieldElement._textToSpeechMarkup = "";
    MathfieldElement._textToSpeechRules = "mathlive";
    MathfieldElement._textToSpeechRulesOptions = {};
    MathfieldElement.speakHook = defaultSpeakHook;
    MathfieldElement.readAloudHook = defaultReadAloudHook;
    MathfieldElement._decimalSeparator = ".";
    MathfieldElement.fractionNavigationOrder = "numerator-denominator";
    function toCamelCase(s) {
      return s.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, (m, c) => c.toUpperCase());
    }
    function getOptionsFromAttributes(mfe) {
      const result = {};
      const attribs = MathfieldElement.optionsAttributes;
      Object.keys(attribs).forEach((x) => {
        if (mfe.hasAttribute(x)) {
          const value = mfe.getAttribute(x);
          if (attribs[x] === "boolean")
            result[toCamelCase(x)] = true;
          else if (attribs[x] === "on/off") {
            if (value === "on")
              result[toCamelCase(x)] = true;
            else if (value === "off")
              result[toCamelCase(x)] = false;
            else
              result[toCamelCase(x)] = void 0;
          } else if (attribs[x] === "number")
            result[toCamelCase(x)] = Number.parseFloat(value != null ? value : "0");
          else
            result[toCamelCase(x)] = value;
        } else if (attribs[x] === "boolean")
          result[toCamelCase(x)] = false;
      });
      return result;
    }
    function isElementInternalsSupported() {
      if (!("ElementInternals" in window) || !HTMLElement.prototype.attachInternals)
        return false;
      if (!("role" in window.ElementInternals.prototype))
        return false;
      return true;
    }
    var mathfield_element_default = MathfieldElement;
    var _a2, _b2, _c, _d;
    if (isBrowser() && !((_a2 = window.customElements) == null ? void 0 : _a2.get("math-field"))) {
      (_c = window[_b2 = Symbol.for("io.cortexjs.mathlive")]) != null ? _c : window[_b2] = {};
      const global2 = window[Symbol.for("io.cortexjs.mathlive")];
      global2.version = "0.90.9";
      window.MathfieldElement = MathfieldElement;
      (_d = window.customElements) == null ? void 0 : _d.define("math-field", MathfieldElement);
    }
    function convertLatexToMarkup(text, options) {
      var _a3;
      options = options != null ? options : {};
      options.mathstyle = (_a3 = options.mathstyle) != null ? _a3 : "displaystyle";
      const globalContext = defaultGlobalContext();
      const root = new Atom("root", globalContext);
      root.body = parseLatex(text, globalContext, {
        parseMode: "math",
        mathstyle: options.mathstyle
      });
      const context = new Context(
        {
          registers: globalContext.registers,
          renderPlaceholder: () => new Box(160, { maxFontSize: 1 })
        },
        {
          fontSize: DEFAULT_FONT_SIZE,
          letterShapeStyle: globalContext.letterShapeStyle
        },
        options.mathstyle
      );
      const box = root.render(context);
      if (!box)
        return "";
      adjustInterAtomSpacing(box, context);
      coalesce(box);
      const wrapper = makeStruts(box, { classes: "ML__mathlive" });
      return wrapper.toMarkup();
    }
    function validateLatex2(s) {
      return validateLatex(s, defaultGlobalContext());
    }
    function convertLatexToMathMl(latex, options = {}) {
      return toMathML(
        parseLatex(latex, defaultGlobalContext(), {
          parseMode: "math",
          args: () => "",
          mathstyle: "displaystyle"
        }),
        options
      );
    }
    function convertLatexToSpeakableText(latex) {
      const atoms = parseLatex(latex, defaultGlobalContext(), {
        parseMode: "math",
        mathstyle: "displaystyle"
      });
      return atomToSpeakableText(atoms);
    }
    var gComputeEngine;
    function serializeMathJsonToLatex(json) {
      var _a3, _b3;
      if (!gComputeEngine) {
        const ComputeEngineCtor = (_a3 = globalThis[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : _a3.ComputeEngine;
        if (ComputeEngineCtor)
          gComputeEngine = new ComputeEngineCtor();
        else {
          console.error(
            `MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`
          );
        }
      }
      return (_b3 = gComputeEngine == null ? void 0 : gComputeEngine.box(json).latex) != null ? _b3 : "";
    }
    function convertLatexToAsciiMath(latex, mode = "math") {
      const context = defaultGlobalContext();
      const root = new Atom("root", context);
      root.body = parseLatex(latex, context, { parseMode: mode });
      return atomToAsciiMath(root);
    }
    function convertAsciiMathToLatex(ascii) {
      return parseMathString(ascii, { format: "ascii-math" })[1];
    }
    function findEndOfMath(delimiter, text, startIndex) {
      let index = startIndex;
      let braceLevel = 0;
      const delimLength = delimiter.length;
      while (index < text.length) {
        const character = text[index];
        if (braceLevel <= 0 && text.slice(index, index + delimLength) === delimiter)
          return index;
        if (character === "\\")
          index++;
        else if (character === "{")
          braceLevel++;
        else if (character === "}")
          braceLevel--;
        index++;
      }
      return -1;
    }
    function splitAtDelimiters(startData, leftDelim, rightDelim, mathstyle, format = "latex") {
      const finalData = [];
      for (const startDatum of startData) {
        if (startDatum.type === "text") {
          const text = startDatum.data;
          let lookingForLeft = true;
          let currIndex = 0;
          let nextIndex;
          nextIndex = text.indexOf(leftDelim);
          if (nextIndex !== -1) {
            currIndex = nextIndex;
            if (currIndex > 0) {
              finalData.push({
                type: "text",
                data: text.slice(0, currIndex)
              });
            }
            lookingForLeft = false;
          }
          let done = false;
          while (!done) {
            if (lookingForLeft) {
              nextIndex = text.indexOf(leftDelim, currIndex);
              if (nextIndex === -1) {
                done = true;
                break;
              }
              if (currIndex !== nextIndex) {
                finalData.push({
                  type: "text",
                  data: text.slice(currIndex, nextIndex)
                });
              }
              currIndex = nextIndex;
            } else {
              nextIndex = findEndOfMath(
                rightDelim,
                text,
                currIndex + leftDelim.length
              );
              if (nextIndex === -1) {
                done = true;
                break;
              }
              let formula = text.slice(currIndex + leftDelim.length, nextIndex);
              if (format === "ascii-math")
                [, formula] = parseMathString(formula, { format: "ascii-math" });
              finalData.push({
                type: "math",
                data: formula,
                rawData: text.slice(currIndex, nextIndex + rightDelim.length),
                mathstyle
              });
              currIndex = nextIndex + rightDelim.length;
            }
            lookingForLeft = !lookingForLeft;
          }
          if (currIndex < text.length) {
            finalData.push({
              type: "text",
              data: text.slice(currIndex)
            });
          }
        } else
          finalData.push(startDatum);
      }
      return finalData;
    }
    function splitWithDelimiters(text, texDelimiters, mathAsciiDelimiters) {
      let data = [{ type: "text", data: text }];
      if (texDelimiters == null ? void 0 : texDelimiters.inline) {
        texDelimiters.inline.forEach(([openDelim, closeDelim]) => {
          data = splitAtDelimiters(data, openDelim, closeDelim, "textstyle");
        });
      }
      if (texDelimiters == null ? void 0 : texDelimiters.display) {
        texDelimiters.display.forEach(([openDelim, closeDelim]) => {
          data = splitAtDelimiters(data, openDelim, closeDelim, "displaystyle");
        });
      }
      if (mathAsciiDelimiters == null ? void 0 : mathAsciiDelimiters.inline) {
        mathAsciiDelimiters.inline.forEach(([openDelim, closeDelim]) => {
          data = splitAtDelimiters(
            data,
            openDelim,
            closeDelim,
            "textstyle",
            "ascii-math"
          );
        });
      }
      if (mathAsciiDelimiters == null ? void 0 : mathAsciiDelimiters.display) {
        mathAsciiDelimiters.display.forEach(([openDelim, closeDelim]) => {
          data = splitAtDelimiters(
            data,
            openDelim,
            closeDelim,
            "displaystyle",
            "ascii-math"
          );
        });
      }
      return data;
    }
    function createMathMLNode(latex, options) {
      const span = document.createElement("span");
      try {
        const html = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + options.renderToMathML(latex) + "</math>";
        span.innerHTML = window.MathfieldElement.createHTML(html);
      } catch (error) {
        console.error(
          `MathLive 0.90.9:  Could not convert "${latex}"' to MathML with ${error}`
        );
        span.textContent = latex;
      }
      span.className = "ML__sr-only";
      return span;
    }
    function createMarkupNode(text, options, mathstyle, createNodeOnFailure) {
      try {
        const html = options.renderToMarkup(text, {
          mathstyle,
          format: "html"
        });
        const element = document.createElement(
          mathstyle === "displaystyle" ? "div" : "span"
        );
        element.setAttribute("aria-hidden", "true");
        element.innerHTML = window.MathfieldElement.createHTML(html);
        return element;
      } catch (error) {
        console.error("Could not parse'" + text + "' with ", error);
        if (createNodeOnFailure)
          return document.createTextNode(text);
      }
      return null;
    }
    function createAccessibleMarkupPair(latex, mathstyle, options, createNodeOnFailure) {
      var _a3;
      const markupNode = createMarkupNode(
        latex,
        options,
        mathstyle ? mathstyle : "displaystyle",
        createNodeOnFailure
      );
      const accessibleContent = (_a3 = options.renderAccessibleContent) != null ? _a3 : "";
      if (markupNode && /\b(mathml|speakable-text)\b/i.test(accessibleContent)) {
        const fragment = document.createElement("span");
        if (/\bmathml\b/i.test(accessibleContent) && options.renderToMathML)
          fragment.append(createMathMLNode(latex, options));
        if (/\bspeakable-text\b/i.test(accessibleContent) && options.renderToSpeakableText) {
          const span = document.createElement("span");
          const html = options.renderToSpeakableText(latex);
          span.innerHTML = window.MathfieldElement.createHTML(html);
          span.className = "ML__sr-only";
          fragment.append(span);
        }
        fragment.append(markupNode);
        return fragment;
      }
      return markupNode;
    }
    function scanText2(text, options) {
      var _a3, _b3, _c2;
      let fragment = null;
      if (((_a3 = options.TeX) == null ? void 0 : _a3.processEnvironments) && /^\s*\\begin/.test(text)) {
        fragment = document.createDocumentFragment();
        const node = createAccessibleMarkupPair(text, "", options, true);
        if (node)
          fragment.appendChild(node);
      } else {
        if (!text.trim())
          return null;
        const data = splitWithDelimiters(
          text,
          (_b3 = options.TeX) == null ? void 0 : _b3.delimiters,
          (_c2 = options.asciiMath) == null ? void 0 : _c2.delimiters
        );
        if (data.length === 1 && data[0].type === "text") {
          return null;
        }
        fragment = document.createDocumentFragment();
        for (const datum of data) {
          if (datum.type === "text")
            fragment.appendChild(document.createTextNode(datum.data));
          else {
            const node = createAccessibleMarkupPair(
              datum.data,
              datum.mathstyle === "textstyle" ? "textstyle" : "displaystyle",
              options,
              true
            );
            if (node)
              fragment.appendChild(node);
          }
        }
      }
      return fragment;
    }
    function scanElement(element, options) {
      var _a3, _b3, _c2, _d2, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
        const text = (_a3 = element.childNodes[0].textContent) != null ? _a3 : "";
        if (((_b3 = options.TeX) == null ? void 0 : _b3.processEnvironments) && /^\s*\\begin/.test(text)) {
          element.textContent = "";
          const node = createAccessibleMarkupPair(text, "", options, true);
          if (node)
            element.append(node);
          return;
        }
        const data = splitWithDelimiters(
          text,
          (_c2 = options.TeX) == null ? void 0 : _c2.delimiters,
          (_d2 = options.asciiMath) == null ? void 0 : _d2.delimiters
        );
        if (data.length === 1 && data[0].type === "math") {
          element.textContent = "";
          const node = createAccessibleMarkupPair(
            data[0].data,
            data[0].mathstyle === "textstyle" ? "textstyle" : "displaystyle",
            options,
            true
          );
          if (node)
            element.append(node);
          return;
        }
        if (data.length === 1 && data[0].type === "text") {
          return;
        }
      }
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
        const childNode = element.childNodes[i];
        if (childNode.nodeType === 3) {
          const frag = scanText2((_e = childNode.textContent) != null ? _e : "", options);
          if (frag) {
            i += frag.childNodes.length - 1;
            childNode.replaceWith(frag);
          }
        } else if (childNode.nodeType === 1) {
          const el = childNode;
          const tag = childNode.nodeName.toLowerCase();
          if (tag === "script") {
            const scriptNode = childNode;
            let textContent = void 0;
            if ((_f = options.processScriptTypePattern) == null ? void 0 : _f.test(scriptNode.type))
              textContent = (_g = scriptNode.textContent) != null ? _g : "";
            else if ((_h = options.processMathJSONScriptTypePattern) == null ? void 0 : _h.test(scriptNode.type)) {
              try {
                textContent = (_j = options.serializeToLatex) == null ? void 0 : _j.call(
                  options,
                  JSON.parse((_i = scriptNode.textContent) != null ? _i : "")
                );
              } catch (e) {
                console.error(e);
              }
            }
            if (textContent) {
              let style = "displaystyle";
              for (const l of scriptNode.type.split(";")) {
                const [key, value] = l.toLowerCase().split("=");
                if (key.trim() === "mode")
                  style = value.trim() === "display" ? "displaystyle" : "textstyle";
              }
              const span = createAccessibleMarkupPair(
                textContent,
                style,
                options,
                true
              );
              if (span)
                scriptNode.parentNode.replaceChild(span, scriptNode);
            }
          } else {
            const shouldRender = ((_l = (_k = options.processClassPattern) == null ? void 0 : _k.test(el.className)) != null ? _l : false) || !(((_n = (_m = options.skipTags) == null ? void 0 : _m.includes(tag)) != null ? _n : false) || ((_p = (_o = options.ignoreClassPattern) == null ? void 0 : _o.test(el.className)) != null ? _p : false));
            if (shouldRender) {
              if (element.childNodes.length === 1 && element.childNodes[0].nodeType === 3) {
                const formula = element.textContent;
                element.textContent = "";
                const node = createAccessibleMarkupPair(
                  formula != null ? formula : "",
                  "displaystyle",
                  options,
                  true
                );
                if (node)
                  element.append(node);
              } else
                scanElement(el, options);
            }
          }
        }
      }
    }
    var DEFAULT_AUTO_RENDER_OPTIONS = {
      // Name of tags whose content will not be scanned for math delimiters
      skipTags: [
        "math-field",
        "noscript",
        "style",
        "textarea",
        "pre",
        "code",
        "annotation",
        "annotation-xml"
      ],
      // <script> tags of the following types will be processed. Others, ignored.
      processScriptType: "math/tex",
      // <script> tag with this type will be processed as MathJSON
      processMathJSONScriptType: "math/json",
      // Regex pattern of the class name of elements whose contents should not
      // be processed
      ignoreClass: "tex2jax_ignore",
      // Regex pattern of the class name of elements whose contents should
      // be processed when they appear inside ones that are ignored.
      processClass: "tex2jax_process",
      // Indicate the format to use to render accessible content
      renderAccessibleContent: "mathml",
      asciiMath: {
        delimiters: {
          display: [
            ["`", "`"]
            // ASCII Math delimiters
          ]
        }
      },
      TeX: {
        processEnvironments: true,
        delimiters: {
          inline: [["\\(", "\\)"]],
          display: [
            ["$$", "$$"],
            ["\\[", "\\]"]
          ]
        }
      }
    };
    function autoRenderMathInElement(element, options) {
      var _a3, _b3, _c2, _d2;
      try {
        const optionsPrivate = __spreadValues(__spreadValues({}, DEFAULT_AUTO_RENDER_OPTIONS), options);
        optionsPrivate.ignoreClassPattern = new RegExp(
          (_a3 = optionsPrivate.ignoreClass) != null ? _a3 : ""
        );
        optionsPrivate.processClassPattern = new RegExp(
          (_b3 = optionsPrivate.processClass) != null ? _b3 : ""
        );
        optionsPrivate.processScriptTypePattern = new RegExp(
          (_c2 = optionsPrivate.processScriptType) != null ? _c2 : ""
        );
        optionsPrivate.processMathJSONScriptTypePattern = new RegExp(
          (_d2 = optionsPrivate.processMathJSONScriptType) != null ? _d2 : ""
        );
        requestAnimationFrame(() => void loadFonts());
        inject2(
          null,
          core_default,
          hashCode(core_default).toString(36)
        );
        scanElement(element, optionsPrivate);
      } catch (error) {
        if (error instanceof Error)
          console.error("renderMathInElement(): " + error.message);
        else {
          console.error(
            "renderMathInElement(): Could not render math for element",
            element
          );
        }
      }
    }
    var MathliveDebug = {
      FUNCTIONS: LATEX_COMMANDS,
      MATH_SYMBOLS,
      TEXT_SYMBOLS,
      ENVIRONMENTS,
      DEFAULT_KEYBINDINGS,
      getKeybindingMarkup
    };
    var debug_default = MathliveDebug;
    var CRYPTIC = 0;
    var ARCANE = 200;
    var RARE = 1200;
    var UNCOMMON = 2e3;
    var COMMON = 3e3;
    var SUPERCOMMON = 4e3;
    function metadata(category, symbols, frequency = COMMON, template = "$0") {
      for (const symbol of symbols) {
        if (MATH_SYMBOLS[symbol]) {
          MATH_SYMBOLS[symbol].frequency = frequency;
          MATH_SYMBOLS[symbol].category = category;
          MATH_SYMBOLS[symbol].template = template.replace(/\$0/g, symbol);
        }
        if (LATEX_COMMANDS[symbol]) {
          LATEX_COMMANDS[symbol] = __spreadProps(__spreadValues({}, LATEX_COMMANDS[symbol]), {
            frequency,
            category,
            template: template.replace(/\$0/g, symbol)
          });
        }
      }
    }
    metadata("Trigonometry", ["\\cos", "\\sin", "\\tan"], SUPERCOMMON);
    metadata(
      "Trigonometry",
      [
        "\\arccos",
        "\\arcsin",
        "\\arctan",
        "\\arctg",
        "\\arcctg",
        "\\arcsec",
        "\\arccsc",
        "\\arsinh",
        "\\arcosh",
        "\\artanh",
        "\\arcsech",
        "\\arccsch",
        "\\arg",
        "\\ch",
        "\\cosec",
        "\\cosh",
        "\\cot",
        "\\cotg",
        "\\coth",
        "\\csc",
        "\\ctg",
        "\\cth",
        "\\lg",
        "\\lb",
        "\\sec",
        "\\sinh",
        "\\sh",
        "\\tanh",
        "\\tg",
        "\\th"
      ],
      UNCOMMON
    );
    metadata("Functions", ["\\ln", "\\log", "\\exp", "\\lim"], SUPERCOMMON);
    metadata(
      "Functions",
      ["\\dim", "\\ker", "\\deg", "\\det", "\\mod", "\\min", "\\max"],
      COMMON
    );
    metadata("Functions", ["\\hom"], RARE);
    metadata("Decoration", ["\\rule"], ARCANE, "$0{2em}{1em}");
    metadata(
      "Decoration",
      ["\\color", "\\textcolor"],
      ARCANE,
      "{$0{m0}A}{$0{m1}B}{$0{m2}C }{$0{m3}a}{$0{m4}b}{$0{m5}c}{$0{m6}8}"
    );
    metadata(
      "Decoration",
      ["\\overline", "\\underline"],
      COMMON,
      "$0{\\placeholder{}}"
    );
    metadata(
      "Decoration",
      ["\\enclose"],
      RARE,
      '\\enclose{updiagonalstrike,roundedbox}[1px solid red, mathbackground="#fbc0bd"]{x=0}'
    );
    metadata(
      "Decoration",
      ["\\fcolorbox"],
      RARE,
      '\\fcolorbox{#cd0030}{#ffd400}{\\unicode{"2B1A}}'
    );
    metadata(
      "Decoration",
      ["\\colorbox"],
      RARE,
      '\\colorbox{#fbc0bd}{\\unicode{"2B1A}}'
    );
    metadata(
      "Decoration",
      ["\\boxed", "\\cancel", "\\bcancel", "\\xcancel"],
      RARE,
      "$0{\\placeholder{}}"
    );
    metadata(
      "Decoration",
      ["\\bbox"],
      RARE,
      '\\bbox[#ffd400, solid 2px #ffd400]{\\unicode{"2B1A}}'
    );
    metadata("Styling", ["\\mathbb"], SUPERCOMMON, "$0{Don Knuth}");
    metadata(
      "Styling",
      [
        "\\textbf",
        "\\textup",
        "\\textit",
        "\\textrm",
        "\\textsf",
        "\\texttt",
        "\\textnormal",
        "\\textmd",
        "\\textsl",
        "\\textsc",
        "\\mathsf",
        "\\mathtt",
        "\\mathrm",
        "\\mathfrak",
        "\\mathcal",
        "\\mathscr",
        "\\mathbf",
        "\\mathmd",
        "\\mathit",
        "\\text",
        "\\mbox",
        "\\Bbb",
        "\\bold",
        "\\bm",
        "\\boldsymbol"
      ],
      COMMON,
      "$0{Don Knuth}"
    );
    metadata(
      "Styling",
      [
        "\\frak",
        "\\tt",
        "\\bf",
        "\\it",
        "\\rmfamily",
        // Note: In LaTeX, /rmfamily is a no-op in math mode
        "\\sffamily",
        "\\ttfamily",
        "\\class",
        "\\cssId",
        "\\htmlData",
        "\\htmlStyle"
      ],
      RARE,
      "{$0 Don Knuth}"
    );
    metadata(
      "Styling",
      ["\\bfseries", "\\mdseries", "\\upshape", "\\slshape", "\\scshape"],
      RARE,
      "\\text{$0 Don Knuth}"
    );
    metadata(
      "Styling",
      ["\\class", "\\cssId"],
      RARE,
      "$0{testIdentifier}{Don Knuth}"
    );
    metadata("Styling", ["\\fontseries"], RARE, "\\text{$0{b}Don Knuth}");
    metadata("Styling", ["\\fontfamily"], RARE, "\\text{$0{cmtt}Don Knuth}");
    metadata("Styling", ["\\fontshape"], RARE, "\\text{$0{sc}Don Knuth}");
    metadata("Styling", ["\\selectfont"], RARE, "\\text{$0}");
    metadata("Styling", ["\\emph"], RARE, "Don$0{Knuth}");
    metadata("Styling", ["\\em"], RARE, "Don{$0 Knuth}");
    metadata(
      "Layout",
      [
        "\\mathop",
        "\\mathbin",
        "\\mathrel",
        "\\mathopen",
        "\\mathclose",
        "\\mathpunct",
        "\\mathord",
        "\\mathinner",
        "\\operatorname",
        "\\operatorname*"
      ],
      RARE,
      "x=$0{arg}=0"
    );
    metadata("Layout", ["\\middle"], RARE, "\\left\\{x$0|x>0\\right\\}");
    metadata(
      "Layout",
      ["\\overset", "\\underset", "\\stackrel", "\\stackbin"],
      RARE,
      "$0{arg}{x=0}"
    );
    metadata("Layout", ["\\rlap", "\\mathrlap"], RARE, "$0{/}0");
    metadata("Layout", ["\\llap", "\\mathllap"], RARE, "o$0{/}");
    metadata(
      "Fractions",
      ["\\frac"],
      SUPERCOMMON,
      "$0{\\placeholder{}}{\\placeholder{}}"
    );
    metadata(
      "Fractions",
      [
        "\\binom",
        "\\dfrac",
        "\\tfrac",
        "\\dbinom",
        "\\tbinom",
        "\\pdiff",
        "\\cfrac"
      ],
      RARE,
      "$0{\\placeholder{}}{\\placeholder{}}"
    );
    metadata(
      "Fractions",
      ["\\over", "\\atop", "\\choose"],
      RARE,
      '\\unicode{"2B1A} $0 \\unicode{"2B1A}'
    );
    metadata(
      "Fractions",
      ["\\overwithdelims", "\\atopwithdelims"],
      RARE,
      '{\\unicode{"2B1A} $0{\\lbrace}{\\rbrace} \\unicode{"2B1A}}'
    );
    metadata(
      "Extensible Operators",
      ["\\sum", "\\prod", "\\bigcap", "\\bigcup", "\\int"],
      SUPERCOMMON
    );
    metadata(
      "Extensible Operators",
      ["\\bigoplus", "\\smallint", "\\iint", "\\oint"],
      COMMON
    );
    metadata(
      "Extensible Operators",
      [
        "\\bigwedge",
        "\\bigvee",
        "\\coprod",
        "\\bigsqcup",
        "\\bigotimes",
        "\\bigodot",
        "\\biguplus",
        "\\intop",
        "\\sqcup",
        "\\sqcap",
        "\\uplus",
        "\\wr",
        "\\Cap",
        "\\Cup",
        "\\doublecap",
        "\\doublecup",
        "\\amalg",
        "\\iiint",
        "\\oiint",
        "\\oiiint",
        "\\intclockwise",
        "\\varointclockwise",
        "\\ointctrclockwise",
        "\\intctrclockwise"
      ],
      RARE
    );
    metadata("Accents", ["\\vec"], SUPERCOMMON);
    metadata(
      "Accents",
      ["\\bar", "\\ddot", "\\acute", "\\tilde", "\\check"],
      COMMON,
      "$0{\\placeholder{}}"
    );
    metadata("Accents", ["\\^", "\\`", "\\'"], RARE, "$0{e}");
    metadata("Accents", ["\\c"], RARE, "$0{c}");
    metadata("Accents", ["\\~"], RARE, "$0{n}");
    metadata(
      "Accents",
      ["\\mathring", "\\hat", "\\dot", "\\breve", "\\grave"],
      RARE,
      "$0{\\placeholder{}}"
    );
    metadata(
      "Extensible Symbols",
      [
        "\\overrightarrow",
        "\\overleftarrow",
        "\\Overrightarrow",
        "\\overleftharpoon",
        "\\overrightharpoon",
        "\\overleftrightarrow",
        "\\overbrace",
        "\\overlinesegment",
        "\\overgroup",
        "\\widehat",
        "\\widecheck",
        "\\widetilde"
      ],
      COMMON,
      "$0{ABC}"
    );
    metadata(
      "Extensible Symbols",
      [
        "\\underrightarrow",
        "\\underleftarrow",
        "\\underleftrightarrow",
        "\\underbrace",
        "\\underlinesegment",
        "\\undergroup",
        "\\utilde"
      ],
      COMMON,
      "$0{ABC}"
    );
    metadata(
      "Sizing",
      [
        "\\tiny",
        "\\scriptsize",
        "\\footnotesize",
        "\\small",
        "\\normalsize",
        "\\large",
        "\\Large",
        "\\LARGE",
        "\\huge",
        "\\Huge"
      ],
      RARE,
      "$0{x=0}"
    );
    metadata("Sizing", ["\\big", "\\Big", "\\bigg", "\\Bigg"], RARE, "$0($0)");
    metadata("Sizing", ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl"], RARE, "$0(");
    metadata("Sizing", ["\\bigr", "\\Bigr", "\\biggr", "\\Biggr"], RARE, "$0)");
    metadata("Sizing", ["\\bigm", "\\Bigm", "\\biggm", "\\Biggm"], RARE, "$0|");
    metadata(
      "Letterlike Symbols",
      [
        "\\nabla",
        "\\partial",
        "\\N",
        "\\R",
        "\\Q",
        "\\C",
        "\\Z",
        "\\exponentialE",
        "\\forall",
        "\\exists",
        "\\nexists"
      ],
      SUPERCOMMON
    );
    metadata(
      "Letterlike Symbols",
      [
        "\\doubleStruckCapitalP",
        "\\P",
        "\\ell",
        "\\hbar",
        "\\hslash",
        "\\imath",
        "\\jmath",
        "\\imaginaryI",
        "\\imaginaryJ",
        "\\differentialD",
        "\\rd",
        "\\capitalDifferentialD",
        "\\doubleStruckCapitalN",
        "\\doubleStruckCapitalR",
        "\\doubleStruckCapitalQ",
        "\\doubleStruckCapitalC",
        "\\doubleStruckCapitalZ",
        "\\rD",
        "\\differencedelta",
        "\\mid",
        "@",
        "\\Re",
        "\\Im",
        "\\$",
        "\\%",
        "\\And",
        "\\degree"
      ],
      COMMON
    );
    metadata(
      "Letterlike Symbols",
      [
        "\\top",
        "\\bot",
        "\\scriptCapitalE",
        "\\scriptCapitalH",
        "\\scriptCapitalL",
        "\\gothicCapitalC",
        "\\gothicCapitalH",
        "\\gothicCapitalI",
        "\\gothicCapitalR",
        "\\Bbbk",
        "\\Finv",
        "\\Game",
        "\\wp",
        "\\eth",
        "\\mho",
        "\\pounds",
        "\\yen",
        "\\euro"
      ],
      RARE
    );
    metadata("Crosses", ["\\dagger", "\\dag"], SUPERCOMMON);
    metadata(
      "Crosses",
      ["\\ddag", "\\ddagger", "\\maltese", "\\textdagger", "\\textdaggerdbl"],
      RARE
    );
    metadata(
      "Various",
      [
        "\\checkmark",
        "\\diagup",
        "\\diagdown",
        "\\angle",
        "\\measuredangle",
        "\\sphericalangle",
        "\\prime",
        "\\doubleprime",
        "\\backprime",
        "\\backdoubleprime",
        "\\sharp",
        "\\flat",
        "\\natural",
        "\\&",
        "\\#",
        "\\clubsuit",
        "\\spadesuit",
        "\\diamondsuit",
        "\\heartsuit",
        "\\backslash",
        "\\infty",
        "/",
        "\\_",
        "\\/",
        "|",
        "'"
      ],
      RARE
    );
    metadata("Various", ["\\unicode"], RARE, '$0{"2B1A}');
    metadata(
      "Arrows",
      ["\\longrightarrow", "\\rightarrow", "\\Longrightarrow", "\\Rightarrow"],
      SUPERCOMMON
    );
    metadata(
      "Arrows",
      [
        "\\longmapsto",
        "\\mapsto",
        "\\Longleftrightarrow",
        "\\rightleftarrows",
        "\\leftarrow",
        "\\curvearrowleft",
        "\\uparrow",
        "\\downarrow",
        "\\hookrightarrow",
        "\\rightharpoonup",
        "\\rightleftharpoons"
      ],
      COMMON
    );
    metadata(
      "Arrows",
      [
        "\\Leftarrow",
        "\\longleftrightarrow",
        "\\longleftarrow",
        "\\Longleftarrow",
        "\\searrow",
        "\\nearrow",
        "\\swarrow",
        "\\nwarrow",
        "\\Uparrow",
        "\\Downarrow",
        "\\updownarrow",
        "\\Updownarrow",
        "\\hookleftarrow",
        "\\leftharpoonup",
        "\\leftharpoondown",
        "\\rightharpoondown",
        "\\leftrightarrows",
        "\\dashrightarrow",
        "\\dashleftarrow",
        "\\leftleftarrows",
        "\\Lleftarrow",
        "\\twoheadleftarrow",
        "\\leftarrowtail",
        "\\looparrowleft",
        "\\leftrightharpoons",
        "\\circlearrowleft",
        "\\Lsh",
        "\\upuparrows",
        "\\downharpoonleft",
        "\\multimap",
        "\\leftrightsquigarrow",
        "\\twoheadrightarrow",
        "\\rightarrowtail",
        "\\looparrowright",
        "\\curvearrowright",
        "\\circlearrowright",
        "\\Rsh",
        "\\downdownarrows",
        "\\upharpoonright",
        "\\downharpoonright",
        "\\rightsquigarrow",
        "\\leadsto",
        "\\Rrightarrow",
        "\\restriction"
      ],
      RARE
    );
    metadata("Arrows", ["\\upharpoonleft", "\\rightrightarrows"], CRYPTIC);
    metadata(
      "Negated Arrows",
      [
        "\\nrightarrow",
        "\\nRightarrow",
        "\\nleftrightarrow",
        "\\nLeftrightarrow",
        "\\nleftarrow",
        "\\nLeftarrow"
      ],
      RARE
    );
    metadata(
      "Extensible Symbols",
      [
        "\\xrightarrow",
        "\\xleftarrow",
        "\\xRightarrow",
        "\\xLeftarrow",
        "\\xleftharpoonup",
        "\\xleftharpoondown",
        "\\xrightharpoonup",
        "\\xrightharpoondown",
        "\\xlongequal",
        "\\xtwoheadleftarrow",
        "\\xtwoheadrightarrow",
        "\\xleftrightarrow",
        "\\xLeftrightarrow",
        "\\xrightleftharpoons",
        "\\xleftrightharpoons",
        "\\xhookleftarrow",
        "\\xhookrightarrow",
        "\\xmapsto",
        "\\xtofrom",
        "\\xrightleftarrows",
        // From mhchem.sty package
        "\\xrightequilibrium",
        // From mhchem.sty package
        "\\xleftequilibrium"
      ],
      RARE,
      "$0[below]{above}=0"
    );
    metadata(
      "Negated Relations",
      [
        "\\nless",
        "\\nleqslant",
        "\\lneq",
        "\\lneqq",
        "\\nleqq",
        "\\unlhd",
        "\\unrhd",
        "\\lvertneqq",
        "\\lnsim",
        "\\lnapprox",
        "\\nprec",
        "\\npreceq",
        "\\precnsim",
        "\\precnapprox",
        "\\nsim",
        "\\nshortmid",
        "\\nmid",
        "\\nvdash",
        "\\nvDash",
        "\\ngtr",
        "\\ngeqslant",
        "\\ngeqq",
        "\\gneq",
        "\\gneqq",
        "\\gvertneqq",
        "\\gnsim",
        "\\nsucc",
        "\\succnsim",
        "\\ncong",
        "\\nshortparallel",
        "\\nparallel",
        "\\nVDash",
        "\\nVdash",
        "\\precneqq",
        "\\succneqq",
        "\\gnapprox",
        "\\succnapprox",
        "\\nsucceq"
      ],
      RARE
    );
    metadata("Hebrew", ["\\aleph", "\\beth", "\\daleth", "\\gimel"], RARE);
    metadata(
      "Fences",
      [
        "\\lbrace",
        "\\rbrace",
        "\\vert",
        "\\Vert",
        "\\{",
        "\\}",
        "(",
        ")",
        "[",
        "]"
      ],
      SUPERCOMMON
    );
    metadata(
      "Fences",
      [
        "\\langle",
        "\\rangle",
        "\\lfloor",
        "\\rfloor",
        "\\lceil",
        "\\rceil",
        "\\mvert",
        "\\|",
        "\\mVert"
      ],
      COMMON
    );
    metadata(
      "Fences",
      [
        "\\lvert",
        "\\rvert",
        "\\lVert",
        "\\rVert",
        "\\lbrack",
        "\\rbrack",
        "\\ulcorner",
        "\\urcorner",
        "\\llcorner",
        "\\lrcorner",
        "\\lgroup",
        "\\rgroup",
        "\\lmoustache",
        "\\rmoustache"
      ],
      RARE
    );
    metadata(
      "Relations",
      ["=", "\\ne", "\\neq", "<", ">", "\\leqslant", "\\geqslant", "\\approx"],
      SUPERCOMMON
    );
    metadata(
      "Relations",
      [
        "\\lt",
        "\\gt",
        "\\le",
        "\\ge",
        "\\leq",
        "\\geq",
        "\\gg",
        "\\cong",
        "\\equiv",
        "\\prec",
        "\\preceq",
        "\\succ",
        "\\perp",
        "\\parallel",
        "\\propto",
        "\\smile",
        "\\frown",
        "\\sim",
        "\\gtrsim"
      ],
      COMMON
    );
    metadata(
      "Relations",
      [
        "\\coloneq",
        "\\succeq",
        "\\approxeq",
        "\\thickapprox",
        "\\lessapprox",
        "\\gtrapprox",
        "\\precapprox",
        "\\succapprox",
        "\\thicksim",
        "\\succsim",
        "\\precsim",
        "\\backsim",
        "\\eqsim",
        "\\backsimeq",
        "\\simeq",
        "\\lesssim",
        "\\nleq",
        "\\ngeq",
        "\\smallsmile",
        "\\smallfrown",
        "\\bowtie",
        "\\asymp",
        "\\leqq",
        "\\eqslantless",
        "\\ll",
        "\\lll",
        "\\lessgtr",
        "\\lesseqgtr",
        "\\lesseqqgtr",
        "\\risingdotseq",
        "\\fallingdotseq",
        "\\preccurlyeq",
        "\\curlyeqprec",
        "\\vDash",
        "\\Vvdash",
        "\\bumpeq",
        "\\Bumpeq",
        "\\geqq",
        "\\eqslantgtr",
        "\\ggg",
        "\\gtrless",
        "\\gtreqless",
        "\\gtreqqless",
        "\\succcurlyeq",
        "\\curlyeqsucc",
        "\\Vdash",
        "\\shortmid",
        "\\shortparallel",
        "\\between",
        "\\pitchfork",
        "\\varpropto",
        "\\backepsilon",
        "\\llless",
        "\\gggtr",
        "\\lhd",
        "\\rhd",
        "\\Join",
        "\\doteq",
        "\\doteqdot",
        "\\Doteq",
        "\\eqcirc",
        "\\circeq",
        "\\lessdot",
        "\\gtrdot",
        "\\measeq",
        "\\eqdef",
        "\\questeq"
      ],
      RARE
    );
    metadata(
      "Logic",
      ["\\leftrightarrow", "\\Leftrightarrow", "\\to"],
      SUPERCOMMON
    );
    metadata("Logic", ["\\models", "\\vdash"], COMMON);
    metadata(
      "Logic",
      [
        "\\therefore",
        "\\because",
        "\\implies",
        "\\gets",
        "\\dashv",
        "\\impliedby",
        "\\biconditional",
        "\\roundimplies"
      ],
      RARE
    );
    metadata("Operators", ["+", "-", "*", "\\cdot"], SUPERCOMMON);
    metadata("Operators", ["\\sqrt"], SUPERCOMMON, "$0{\\placeholder{}}");
    metadata("Operators", ["\\pm", "\\mp", "\\times", "\\div", "\\surd"], COMMON);
    metadata(
      "Operators",
      [
        "\\ltimes",
        "\\rtimes",
        "\\leftthreetimes",
        "\\rightthreetimes",
        "\\intercal",
        "\\dotplus",
        "\\centerdot",
        "\\doublebarwedge",
        "\\divideontimes",
        "\\divides"
      ],
      RARE
    );
    metadata("Logic", ["\\wedge", "\\vee", "\\neg"], SUPERCOMMON);
    metadata("Logic", ["\\lnot"], COMMON);
    metadata(
      "Logic",
      [
        "\\land",
        "\\lor",
        "\\barwedge",
        "\\veebar",
        "\\nor",
        "\\curlywedge",
        "\\curlyvee"
      ],
      RARE
    );
    metadata(
      "Greek",
      [
        "\\alpha",
        "\\beta",
        "\\gamma",
        "\\delta",
        "\\epsilon",
        "\\varepsilon",
        "\\zeta",
        "\\eta",
        "\\theta",
        "\\vartheta",
        "\\iota",
        "\\kappa",
        "\\varkappa",
        "\\lambda",
        "\\mu",
        "\\nu",
        "\\xi",
        "\\pi",
        "\\varpi",
        "\\rho",
        "\\varrho",
        "\\sigma",
        "\\varsigma",
        "\\tau",
        "\\phi",
        "\\varphi",
        "\\upsilon",
        "\\chi",
        "\\psi",
        "\\omega",
        "\\Gamma",
        "\\Delta",
        "\\Theta",
        "\\Lambda",
        "\\Xi",
        "\\Pi",
        "\\Sigma",
        "\\Upsilon",
        "\\Phi",
        "\\Psi",
        "\\Omega",
        "\\digamma",
        "\\omicron"
      ],
      COMMON
    );
    metadata(
      "Sets",
      [
        "\\emptyset",
        "\\varnothing",
        "\\cap",
        "\\cup",
        "\\in",
        "\\notin",
        "\\subset",
        "\\supset",
        "\\subseteq",
        "\\supseteq",
        "\\sqsubseteq"
      ],
      SUPERCOMMON
    );
    metadata(
      "Sets",
      [
        "\\setminus",
        "\\not",
        "\\ni",
        "\\sqsupseteq",
        "\\nsupseteqq",
        "\\supsetneq",
        "\\varsupsetneq",
        "\\supsetneqq",
        "\\varsupsetneqq"
      ],
      COMMON
    );
    metadata(
      "Sets",
      [
        "\\smallsetminus",
        "\\complement",
        "\\owns",
        "\\subsetneq",
        "\\varsubsetneq",
        "\\subsetneqq",
        "\\varsubsetneqq",
        "\\nsubset",
        "\\nsupset",
        "\\nsubseteq",
        "\\nsupseteq",
        "\\nsubseteqq",
        "\\subseteqq",
        "\\Subset",
        "\\sqsubset",
        "\\supseteqq",
        "\\Supset",
        "\\sqsupset"
      ],
      RARE
    );
    metadata(
      "Spacing",
      ["\\space", "\\quad", "\\qquad"],
      COMMON,
      '\\unicode{"203A}$0\\unicode{"2039}'
    );
    metadata(
      "Spacing",
      ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace"],
      RARE,
      '\\unicode{"203A}$0\\unicode{"2039}'
    );
    metadata(
      "Spacing",
      ["\\hspace", "\\hspace*"],
      RARE,
      '\\unicode{"203A}$0{1em}\\unicode{"2039}'
    );
    metadata(
      "Punctuation",
      [
        "\\colon",
        "\\cdotp",
        "\\ldots",
        "\\cdots",
        "\\ddots",
        "\\vdots",
        "?",
        "!",
        ":",
        '"',
        ",",
        ".",
        ";"
      ],
      COMMON
    );
    metadata("Punctuation", ["\\mathellipsis", "\\ldotp", "\\Colon"], RARE);
    metadata("Boxes", ["\\square", "\\Box"], COMMON);
    metadata(
      "Boxes",
      ["\\blacksquare", "\\boxminus", "\\boxplus", "\\boxtimes", "\\boxdot"],
      RARE
    );
    metadata(
      "Circles",
      ["\\circ", "\\bullet", "\\circleddash", "\\oplus", "\\otimes"],
      COMMON
    );
    metadata(
      "Circles",
      [
        "\\bigcirc",
        "\\circledast",
        "\\ominus",
        "\\circledcirc",
        "\\oslash",
        "\\circledS",
        "\\circledR",
        "\\odot"
      ],
      RARE
    );
    metadata("Triangles", ["\\triangle", "\\triangleq"], COMMON);
    metadata(
      "Triangles",
      [
        "\\bigtriangleup",
        "\\vartriangle",
        "\\triangledown",
        "\\bigtriangledown",
        "\\triangleleft",
        "\\vartriangleleft",
        "\\trianglelefteq",
        "\\ntriangleleft",
        "\\ntrianglelefteq",
        "\\triangleright",
        "\\vartriangleright",
        "\\trianglerighteq",
        "\\ntriangleright",
        "\\ntrianglerighteq",
        "\\blacktriangle",
        "\\blacktriangledown",
        "\\blacktriangleleft",
        "\\blacktriangleright"
      ],
      RARE
    );
    metadata("Shapes", ["\\ast", "\\star"], COMMON);
    metadata(
      "Shapes",
      ["\\diamond", "\\Diamond", "\\lozenge", "\\blacklozenge", "\\bigstar"],
      RARE
    );
    function switchKeyboardLayer(layer) {
      var _a3;
      window.mathVirtualKeyboard.show();
      hideVariantsPanel();
      unshiftKeyboardLayer();
      const layers = (_a3 = VirtualKeyboard.singleton) == null ? void 0 : _a3.element.querySelectorAll(".MLK__layer");
      let found = false;
      for (const layer_ of layers) {
        if (layer_.dataset.layer === layer) {
          found = true;
          break;
        }
      }
      if (found) {
        for (const layer_ of layers) {
          if (layer_.dataset.layer === layer)
            layer_.classList.add("is-visible");
          else
            layer_.classList.remove("is-visible");
        }
      }
      VirtualKeyboard.singleton.focus();
      return true;
    }
    function shiftKeyboardLayer() {
      var _a3;
      const keycaps = (_a3 = VirtualKeyboard.singleton) == null ? void 0 : _a3.element.querySelectorAll(
        ".MLK__layer.is-visible .MLK__keycap, .MLK__layer.is-visible .action"
      );
      if (keycaps) {
        for (const keycap of keycaps) {
          if (keycap.dataset.unshiftedContent)
            return false;
          let shiftedContent = keycap.getAttribute("data-shifted");
          if (shiftedContent || /^[a-z]$/.test(keycap.innerHTML)) {
            keycap.dataset.unshiftedContent = keycap.innerHTML;
            if (!shiftedContent)
              shiftedContent = keycap.innerHTML.toUpperCase();
            keycap.innerHTML = window.MathfieldElement.createHTML(shiftedContent);
            const command = keycap.getAttribute("data-command");
            if (command) {
              keycap.dataset.unshiftedCommand = command;
              const shiftedCommand = keycap.getAttribute("data-shifted-command");
              if (shiftedCommand)
                keycap.dataset.command = shiftedCommand;
              else {
                const commandObject = JSON.parse(command);
                if (isArray2(commandObject))
                  commandObject[1] = commandObject[1].toUpperCase();
                keycap.dataset.command = JSON.stringify(commandObject);
              }
            }
          }
        }
      }
      return false;
    }
    register2(
      {
        shiftKeyboardLayer
      },
      { target: "virtual-keyboard" }
    );
    function performVariant(command) {
      hideVariantsPanel();
      return window.mathVirtualKeyboard.executeCommand(command);
    }
    function insertAndUnshiftKeyboardLayer(c) {
      window.mathVirtualKeyboard.executeCommand(["insert", c]);
      unshiftKeyboardLayer();
      return true;
    }
    register2(
      {
        /*
         * The command invoked when a variant key is pressed:
         * hide the Variants panel, then perform the command.
         */
        performVariant,
        switchKeyboardLayer: (layer) => switchKeyboardLayer(layer),
        unshiftKeyboardLayer: () => unshiftKeyboardLayer(),
        insertAndUnshiftKeyboardLayer
      },
      { target: "virtual-keyboard" }
    );
    function toggleVirtualKeyboardShift() {
      var _a3, _b3, _c2;
      const kbd = VirtualKeyboard.singleton;
      kbd.alphabeticLayout = {
        qwerty: "azerty",
        azerty: "qwertz",
        qwertz: "dvorak",
        dvorak: "colemak",
        colemak: "qwerty"
      }[kbd.alphabeticLayout];
      const layer = (_c2 = (_b3 = (_a3 = kbd == null ? void 0 : kbd.element) == null ? void 0 : _a3.querySelector(".MLK__layer.is-visible")) == null ? void 0 : _b3.id) != null ? _c2 : "";
      kbd.show();
      if (layer)
        switchKeyboardLayer(layer);
      return false;
    }
    register2({ toggleVirtualKeyboardShift }, { target: "virtual-keyboard" });
    function toggleVirtualKeyboard() {
      const kbd = window.mathVirtualKeyboard;
      if (kbd.visible)
        kbd.hide();
      else
        kbd.show();
      return false;
    }
    register2(
      {
        toggleVirtualKeyboard,
        hideVirtualKeyboard: () => {
          window.mathVirtualKeyboard.hide();
          return false;
        },
        showVirtualKeyboard: () => {
          window.mathVirtualKeyboard.show();
          return false;
        }
      },
      { target: "virtual-keyboard" }
    );
    function globalMathLive() {
      var _a3, _b3;
      (_b3 = globalThis[_a3 = Symbol.for("io.cortexjs.mathlive")]) != null ? _b3 : globalThis[_a3] = {};
      return globalThis[Symbol.for("io.cortexjs.mathlive")];
    }
    function makeSharedVirtualKeyboard() {
      console.warn(
        `%cMathLive 0.90.9: %cmakeSharedVirtualKeyboard() is deprecated. 
    Use \`window.mathVirtualKeyboard\` to access the virtual keyboard instance.
    See https://cortexjs.io/mathlive/changelog/ for details.`,
        "color:#12b; font-size: 1.1rem",
        "color:#db1111; font-size: 1.1rem"
      );
      return window.mathVirtualKeyboard;
    }
    function renderMathInDocument(options) {
      renderMathInElement(document.body, options);
    }
    function getElement(element) {
      if (typeof element === "string") {
        const result = document.getElementById(element);
        if (result === null)
          throw new Error(`The element with ID "${element}" could not be found.`);
        return result;
      }
      return typeof element === "string" ? null : element;
    }
    function renderMathInElement(element, options) {
      var _a3, _b3, _c2, _d2;
      const el = getElement(element);
      if (!el)
        return;
      const optionsPrivate = options != null ? options : {};
      (_a3 = optionsPrivate.renderToMarkup) != null ? _a3 : optionsPrivate.renderToMarkup = convertLatexToMarkup;
      (_b3 = optionsPrivate.renderToMathML) != null ? _b3 : optionsPrivate.renderToMathML = convertLatexToMathMl;
      (_c2 = optionsPrivate.renderToSpeakableText) != null ? _c2 : optionsPrivate.renderToSpeakableText = convertLatexToSpeakableText;
      (_d2 = optionsPrivate.serializeToLatex) != null ? _d2 : optionsPrivate.serializeToLatex = serializeMathJsonToLatex;
      autoRenderMathInElement(el, optionsPrivate);
    }
    var version3 = {
      mathlive: "0.90.9"
    };
    var debug = {
      FUNCTIONS: debug_default.FUNCTIONS,
      MATH_SYMBOLS: debug_default.MATH_SYMBOLS,
      TEXT_SYMBOLS: debug_default.TEXT_SYMBOLS,
      ENVIRONMENTS: debug_default.ENVIRONMENTS,
      DEFAULT_KEYBINDINGS: debug_default.DEFAULT_KEYBINDINGS,
      getKeybindingMarkup: debug_default.getKeybindingMarkup
    };
    return __toCommonJS(mathlive_exports);
  })();
  Object.assign(exports2, MathLive);
  Object.defineProperty(exports2, "__esModule", { value: true });
});
class CardPlugin extends siyuan.Plugin {
  constructor() {
    initMathLive();
    super();
    __publicField(this, "el");
    __publicField(this, "sheet");
    __publicField(this, "settingConfig");
    this.el = document.createElement("div");
    this.el.classList.add("toolbar__item", "b3-tooltips", "b3-tooltips__se");
    this.el.setAttribute("aria-label", "右键打开菜单");
    this.sheet = document.createElement("div");
    this.settingConfig = null;
  }
  async onload() {
    let localConfig = await this.loadStorage("enhanceConfig.json");
    this.settingConfig = await getSetting(localConfig);
    console.log("数学增强当前配置：\n", settingList.getSetting());
    const AppSheet = createApp(_sfc_main, this.settingConfig);
    AppSheet.mount(this.sheet);
    let base = document.querySelector("head");
    base == null ? void 0 : base.appendChild(this.sheet);
    watch(settingList.setList, () => {
      this.writeConfig();
    });
  }
  async onunload() {
    this.el && this.el.remove();
    this.sheet && this.sheet.remove();
    removeMathLive();
    this.writeConfig();
  }
  async writeConfig() {
    let configText = JSON.stringify(settingList.getSetting());
    await this.writeStorage("enhanceConfig.json", configText);
  }
}
module.exports = CardPlugin;
