(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode("#option[data-v-6911afe5] {\r\n    display: grid;\r\n    align-items: center;\r\n    min-height: 30px;\n}\n#content[data-v-6911afe5] {\r\n    display: flex;\r\n    justify-content: space-between;\n}\r\n\n#option[data-v-465f3d4a] {\r\n    display: grid;\r\n    align-items: center;\r\n    min-height: 30px;\n}\n#content[data-v-465f3d4a] {\r\n    display: flex;\r\n    justify-content: space-between;\n}\r\n\n.option[data-v-1c0ece5c] {\n  font-size: 1.1em;\n  font-weight: 600;\n  margin: 5px 0px 0px;\n}\n.menu[data-v-1c0ece5c] {\n  color: var(--b3-theme-on-background);\n  background-color: var(--b3-menu-background);\n  margin: 1px;\n  padding: 10px 20px;\n  /* 添加边框 */\n  border: 1px solid var(--b3-theme-surface-lighter);;\n  border-radius: 3px;\n}"));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
"use strict";
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const siyuan = require("siyuan");
function makeMap(str, expectsLowerCase) {
  const map2 = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map2[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map2[val.toLowerCase()] : (val) => !!map2[val];
}
function normalizeStyle(value) {
  if (isArray(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value)) {
    return value;
  } else if (isObject(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
const HTML_TAGS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot";
const SVG_TAGS = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view";
const isHTMLTag = /* @__PURE__ */ makeMap(HTML_TAGS);
const isSVGTag = /* @__PURE__ */ makeMap(SVG_TAGS);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const EMPTY_OBJ = process.env.NODE_ENV !== "production" ? Object.freeze({}) : {};
const EMPTY_ARR = process.env.NODE_ENV !== "production" ? Object.freeze([]) : [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const isBuiltInDirective = /* @__PURE__ */ makeMap("bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo");
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function warn$1(msg, ...args) {
  console.warn(`[Vue warn] ${msg}`, ...args);
}
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn$1(`cannot run an inactive effect scope.`);
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "iterate" : "");
const MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== "production" ? "Map key iterate" : "");
class ReactiveEffect {
  constructor(fn, scheduler = null, scope) {
    this.fn = fn;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    const eventInfo = process.env.NODE_ENV !== "production" ? { effect: activeEffect, target, type, key } : void 0;
    trackEffects(dep, eventInfo);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
    if (process.env.NODE_ENV !== "production" && activeEffect.onTrack) {
      activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  const eventInfo = process.env.NODE_ENV !== "production" ? { target, type, key, newValue, oldValue, oldTarget } : void 0;
  if (deps.length === 1) {
    if (deps[0]) {
      if (process.env.NODE_ENV !== "production") {
        triggerEffects(deps[0], eventInfo);
      } else {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(createDep(effects), eventInfo);
    } else {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect, debuggerEventExtraInfo);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (process.env.NODE_ENV !== "production" && effect.onTrigger) {
      effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));
    }
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow$1(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value, oldValue);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  const oldValue = target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  },
  deleteProperty(target, key) {
    if (process.env.NODE_ENV !== "production") {
      warn$1(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
    }
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value, oldValue);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  } else if (process.env.NODE_ENV !== "production") {
    checkIdentityKeys(target, has2, key);
  }
  const oldValue = get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0, oldValue);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const oldTarget = process.env.NODE_ENV !== "production" ? isMap(target) ? new Map(target) : new Set(target) : void 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0, oldTarget);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    if (process.env.NODE_ENV !== "production") {
      const key = args[0] ? `on key "${args[0]}" ` : ``;
      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
    }
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add,
    set,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod(
      "add"
      /* TriggerOpTypes.ADD */
    ),
    set: createReadonlyMethod(
      "set"
      /* TriggerOpTypes.SET */
    ),
    delete: createReadonlyMethod(
      "delete"
      /* TriggerOpTypes.DELETE */
    ),
    clear: createReadonlyMethod(
      "clear"
      /* TriggerOpTypes.CLEAR */
    ),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
function checkIdentityKeys(target, has2, key) {
  const rawKey = toRaw(key);
  if (rawKey !== key && has2.call(target, rawKey)) {
    const type = toRawType(target);
    console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
  }
}
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject(target)) {
    if (process.env.NODE_ENV !== "production") {
      console.warn(`value cannot be made reactive: ${String(target)}`);
    }
    return target;
  }
  if (target[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ] && !(isReadonly2 && target[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value[
      "__v_raw"
      /* ReactiveFlags.RAW */
    ]);
  }
  return !!(value && value[
    "__v_isReactive"
    /* ReactiveFlags.IS_REACTIVE */
  ]);
}
function isReadonly(value) {
  return !!(value && value[
    "__v_isReadonly"
    /* ReactiveFlags.IS_READONLY */
  ]);
}
function isShallow$1(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed[
    "__v_raw"
    /* ReactiveFlags.RAW */
  ];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject(value) ? reactive(value) : value;
const toReadonly = (value) => isObject(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    if (process.env.NODE_ENV !== "production") {
      trackEffects(ref2.dep || (ref2.dep = createDep()), {
        target: ref2,
        type: "get",
        key: "value"
      });
    } else {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    if (process.env.NODE_ENV !== "production") {
      triggerEffects(dep, {
        target: ref2,
        type: "set",
        key: "value",
        newValue: newVal
      });
    } else {
      triggerEffects(dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow$1(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this, newVal);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this[
      "__v_isReadonly"
      /* ReactiveFlags.IS_READONLY */
    ] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = process.env.NODE_ENV !== "production" ? () => {
      console.warn("Write operation failed: computed value is readonly");
    } : NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  if (process.env.NODE_ENV !== "production" && debugOptions && !isSSR) {
    cRef.effect.onTrack = debugOptions.onTrack;
    cRef.effect.onTrigger = debugOptions.onTrigger;
  }
  return cRef;
}
const stack = [];
function pushWarningContext(vnode) {
  stack.push(vnode);
}
function popWarningContext() {
  stack.pop();
}
function warn(msg, ...args) {
  if (!(process.env.NODE_ENV !== "production"))
    return;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
const ErrorTypeStrings = {
  [
    "sp"
    /* LifecycleHooks.SERVER_PREFETCH */
  ]: "serverPrefetch hook",
  [
    "bc"
    /* LifecycleHooks.BEFORE_CREATE */
  ]: "beforeCreate hook",
  [
    "c"
    /* LifecycleHooks.CREATED */
  ]: "created hook",
  [
    "bm"
    /* LifecycleHooks.BEFORE_MOUNT */
  ]: "beforeMount hook",
  [
    "m"
    /* LifecycleHooks.MOUNTED */
  ]: "mounted hook",
  [
    "bu"
    /* LifecycleHooks.BEFORE_UPDATE */
  ]: "beforeUpdate hook",
  [
    "u"
    /* LifecycleHooks.UPDATED */
  ]: "updated",
  [
    "bum"
    /* LifecycleHooks.BEFORE_UNMOUNT */
  ]: "beforeUnmount hook",
  [
    "um"
    /* LifecycleHooks.UNMOUNTED */
  ]: "unmounted hook",
  [
    "a"
    /* LifecycleHooks.ACTIVATED */
  ]: "activated hook",
  [
    "da"
    /* LifecycleHooks.DEACTIVATED */
  ]: "deactivated hook",
  [
    "ec"
    /* LifecycleHooks.ERROR_CAPTURED */
  ]: "errorCaptured hook",
  [
    "rtc"
    /* LifecycleHooks.RENDER_TRACKED */
  ]: "renderTracked hook",
  [
    "rtg"
    /* LifecycleHooks.RENDER_TRIGGERED */
  ]: "renderTriggered hook",
  [
    0
    /* ErrorCodes.SETUP_FUNCTION */
  ]: "setup function",
  [
    1
    /* ErrorCodes.RENDER_FUNCTION */
  ]: "render function",
  [
    2
    /* ErrorCodes.WATCH_GETTER */
  ]: "watcher getter",
  [
    3
    /* ErrorCodes.WATCH_CALLBACK */
  ]: "watcher callback",
  [
    4
    /* ErrorCodes.WATCH_CLEANUP */
  ]: "watcher cleanup function",
  [
    5
    /* ErrorCodes.NATIVE_EVENT_HANDLER */
  ]: "native event handler",
  [
    6
    /* ErrorCodes.COMPONENT_EVENT_HANDLER */
  ]: "component event handler",
  [
    7
    /* ErrorCodes.VNODE_HOOK */
  ]: "vnode hook",
  [
    8
    /* ErrorCodes.DIRECTIVE_HOOK */
  ]: "directive hook",
  [
    9
    /* ErrorCodes.TRANSITION_HOOK */
  ]: "transition hook",
  [
    10
    /* ErrorCodes.APP_ERROR_HANDLER */
  ]: "app errorHandler",
  [
    11
    /* ErrorCodes.APP_WARN_HANDLER */
  ]: "app warnHandler",
  [
    12
    /* ErrorCodes.FUNCTION_REF */
  ]: "ref function",
  [
    13
    /* ErrorCodes.ASYNC_COMPONENT_LOADER */
  ]: "async component loader",
  [
    14
    /* ErrorCodes.SCHEDULER */
  ]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function callWithErrorHandling(fn, instance, type, args) {
  let res;
  try {
    res = args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn.length; i++) {
    values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = process.env.NODE_ENV !== "production" ? ErrorTypeStrings[type] : type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  if (process.env.NODE_ENV !== "production") {
    const info = ErrorTypeStrings[type];
    if (contextVNode) {
      pushWarningContext(contextVNode);
    }
    warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);
    if (contextVNode) {
      popWarningContext();
    }
    if (throwInDev) {
      throw err;
    } else {
      console.error(err);
    }
  } else {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
const RECURSION_LIMIT = 100;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 : 0) {
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  for (; i < queue.length; i++) {
    const cb = queue[i];
    if (cb && cb.pre) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, cb)) {
        continue;
      }
      queue.splice(i, 1);
      i--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    if (process.env.NODE_ENV !== "production") {
      seen = seen || /* @__PURE__ */ new Map();
    }
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      if (process.env.NODE_ENV !== "production" && checkRecursiveUpdates(seen, activePostFlushCbs[postFlushIndex])) {
        continue;
      }
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a, b) => {
  const diff = getId(a) - getId(b);
  if (diff === 0) {
    if (a.pre && !b.pre)
      return -1;
    if (b.pre && !a.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  if (process.env.NODE_ENV !== "production") {
    seen = seen || /* @__PURE__ */ new Map();
  }
  queue.sort(comparator);
  const check = process.env.NODE_ENV !== "production" ? (job) => checkRecursiveUpdates(seen, job) : NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (process.env.NODE_ENV !== "production" && check(job)) {
          continue;
        }
        callWithErrorHandling(
          job,
          null,
          14
          /* ErrorCodes.SCHEDULER */
        );
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs(seen);
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
function checkRecursiveUpdates(seen, fn) {
  if (!seen.has(fn)) {
    seen.set(fn, 1);
  } else {
    const count = seen.get(fn);
    if (count > RECURSION_LIMIT) {
      const instance = fn.ownerInstance;
      const componentName = instance && getComponentName(instance.type);
      warn(`Maximum recursive updates exceeded${componentName ? ` in component <${componentName}>` : ``}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`);
      return true;
    } else {
      seen.set(fn, count + 1);
    }
  }
}
let isHmrUpdating = false;
const hmrDirtyComponents = /* @__PURE__ */ new Set();
if (process.env.NODE_ENV !== "production") {
  getGlobalThis().__VUE_HMR_RUNTIME__ = {
    createRecord: tryWrap(createRecord),
    rerender: tryWrap(rerender),
    reload: tryWrap(reload)
  };
}
const map = /* @__PURE__ */ new Map();
function registerHMR(instance) {
  const id = instance.type.__hmrId;
  let record = map.get(id);
  if (!record) {
    createRecord(id, instance.type);
    record = map.get(id);
  }
  record.instances.add(instance);
}
function unregisterHMR(instance) {
  map.get(instance.type.__hmrId).instances.delete(instance);
}
function createRecord(id, initialDef) {
  if (map.has(id)) {
    return false;
  }
  map.set(id, {
    initialDef: normalizeClassComponent(initialDef),
    instances: /* @__PURE__ */ new Set()
  });
  return true;
}
function normalizeClassComponent(component) {
  return isClassComponent(component) ? component.__vccOpts : component;
}
function rerender(id, newRender) {
  const record = map.get(id);
  if (!record) {
    return;
  }
  record.initialDef.render = newRender;
  [...record.instances].forEach((instance) => {
    if (newRender) {
      instance.render = newRender;
      normalizeClassComponent(instance.type).render = newRender;
    }
    instance.renderCache = [];
    isHmrUpdating = true;
    instance.update();
    isHmrUpdating = false;
  });
}
function reload(id, newComp) {
  const record = map.get(id);
  if (!record)
    return;
  newComp = normalizeClassComponent(newComp);
  updateComponentDef(record.initialDef, newComp);
  const instances = [...record.instances];
  for (const instance of instances) {
    const oldComp = normalizeClassComponent(instance.type);
    if (!hmrDirtyComponents.has(oldComp)) {
      if (oldComp !== record.initialDef) {
        updateComponentDef(oldComp, newComp);
      }
      hmrDirtyComponents.add(oldComp);
    }
    instance.appContext.optionsCache.delete(instance.type);
    if (instance.ceReload) {
      hmrDirtyComponents.add(oldComp);
      instance.ceReload(newComp.styles);
      hmrDirtyComponents.delete(oldComp);
    } else if (instance.parent) {
      queueJob(instance.parent.update);
    } else if (instance.appContext.reload) {
      instance.appContext.reload();
    } else if (typeof window !== "undefined") {
      window.location.reload();
    } else {
      console.warn("[HMR] Root or manually mounted instance modified. Full reload required.");
    }
  }
  queuePostFlushCb(() => {
    for (const instance of instances) {
      hmrDirtyComponents.delete(normalizeClassComponent(instance.type));
    }
  });
}
function updateComponentDef(oldComp, newComp) {
  extend(oldComp, newComp);
  for (const key in oldComp) {
    if (key !== "__file" && !(key in newComp)) {
      delete oldComp[key];
    }
  }
}
function tryWrap(fn) {
  return (id, arg) => {
    try {
      return fn(id, arg);
    } catch (e) {
      console.error(e);
      console.warn(`[HMR] Something went wrong during Vue component hot-reload. Full reload required.`);
    }
  };
}
let devtools;
let buffer = [];
let devtoolsNotInstalled = false;
function emit$1(event, ...args) {
  if (devtools) {
    devtools.emit(event, ...args);
  } else if (!devtoolsNotInstalled) {
    buffer.push({ event, args });
  }
}
function setDevtoolsHook(hook, target) {
  var _a, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (
    // handle late devtools injection - only do this if we are in an actual
    // browser environment to avoid the timer handle stalling test runner exit
    // (#4815)
    typeof window !== "undefined" && // some envs mock window but not fully
    window.HTMLElement && // also exclude jsdom
    !((_b = (_a = window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))
  ) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        devtoolsNotInstalled = true;
        buffer = [];
      }
    }, 3e3);
  } else {
    devtoolsNotInstalled = true;
    buffer = [];
  }
}
function devtoolsInitApp(app, version2) {
  emit$1("app:init", app, version2, {
    Fragment,
    Text,
    Comment,
    Static
  });
}
function devtoolsUnmountApp(app) {
  emit$1("app:unmount", app);
}
const devtoolsComponentAdded = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:added"
  /* DevtoolsHooks.COMPONENT_ADDED */
);
const devtoolsComponentUpdated = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:updated"
  /* DevtoolsHooks.COMPONENT_UPDATED */
);
const _devtoolsComponentRemoved = /* @__PURE__ */ createDevtoolsComponentHook(
  "component:removed"
  /* DevtoolsHooks.COMPONENT_REMOVED */
);
const devtoolsComponentRemoved = (component) => {
  if (devtools && typeof devtools.cleanupBuffer === "function" && // remove the component if it wasn't buffered
  !devtools.cleanupBuffer(component)) {
    _devtoolsComponentRemoved(component);
  }
};
function createDevtoolsComponentHook(hook) {
  return (component) => {
    emit$1(hook, component.appContext.app, component.uid, component.parent ? component.parent.uid : void 0, component);
  };
}
const devtoolsPerfStart = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:start"
  /* DevtoolsHooks.PERFORMANCE_START */
);
const devtoolsPerfEnd = /* @__PURE__ */ createDevtoolsPerformanceHook(
  "perf:end"
  /* DevtoolsHooks.PERFORMANCE_END */
);
function createDevtoolsPerformanceHook(hook) {
  return (component, type, time) => {
    emit$1(hook, component.appContext.app, component.uid, component, type, time);
  };
}
function devtoolsComponentEmit(component, event, params) {
  emit$1("component:emit", component.appContext.app, component, event, params);
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  if (process.env.NODE_ENV !== "production") {
    const { emitsOptions, propsOptions: [propsOptions] } = instance;
    if (emitsOptions) {
      if (!(event in emitsOptions) && true) {
        if (!propsOptions || !(toHandlerKey(event) in propsOptions)) {
          warn(`Component emitted event "${event}" but it is neither declared in the emits option nor as an "${toHandlerKey(event)}" prop.`);
        }
      } else {
        const validator = emitsOptions[event];
        if (isFunction(validator)) {
          const isValid = validator(...rawArgs);
          if (!isValid) {
            warn(`Invalid event arguments: event validation failed for event "${event}".`);
          }
        }
      }
    }
  }
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => isString(a) ? a.trim() : a);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsComponentEmit(instance, event, args);
  }
  if (process.env.NODE_ENV !== "production") {
    const lowerCaseEvent = event.toLowerCase();
    if (lowerCaseEvent !== event && props[toHandlerKey(lowerCaseEvent)]) {
      warn(`Event "${lowerCaseEvent}" is emitted in component ${formatComponentName(instance, instance.type)} but the handler is registered for "${event}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${hyphenate(event)}" instead of "${event}".`);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentUpdated(ctx);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
let accessedAttrs = false;
function markAttrsAccessed() {
  accessedAttrs = true;
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  if (process.env.NODE_ENV !== "production") {
    accessedAttrs = false;
  }
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (process.env.NODE_ENV !== "production" && attrs === props) {
        markAttrsAccessed();
      }
      result = normalizeVNode(render2.length > 1 ? render2(props, process.env.NODE_ENV !== "production" ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render2(
        props,
        null
        /* we know it doesn't need it */
      ));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    handleError(
      err,
      instance,
      1
      /* ErrorCodes.RENDER_FUNCTION */
    );
    result = createVNode(Comment);
  }
  let root = result;
  let setRoot = void 0;
  if (process.env.NODE_ENV !== "production" && result.patchFlag > 0 && result.patchFlag & 2048) {
    [root, setRoot] = getChildRoot(result);
  }
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      } else if (process.env.NODE_ENV !== "production" && !accessedAttrs && root.type !== Comment) {
        const allAttrs = Object.keys(attrs);
        const eventAttrs = [];
        const extraAttrs = [];
        for (let i = 0, l = allAttrs.length; i < l; i++) {
          const key = allAttrs[i];
          if (isOn(key)) {
            if (!isModelListener(key)) {
              eventAttrs.push(key[2].toLowerCase() + key.slice(3));
            }
          } else {
            extraAttrs.push(key);
          }
        }
        if (extraAttrs.length) {
          warn(`Extraneous non-props attributes (${extraAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`);
        }
        if (eventAttrs.length) {
          warn(`Extraneous non-emits event listeners (${eventAttrs.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`);
        }
      }
    }
  }
  if (vnode.dirs) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Runtime directive used on component with non-element root node. The directives will not function as intended.`);
    }
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    if (process.env.NODE_ENV !== "production" && !isElementRoot(root)) {
      warn(`Component inside <Transition> renders non-element root node that cannot be animated.`);
    }
    root.transition = vnode.transition;
  }
  if (process.env.NODE_ENV !== "production" && setRoot) {
    setRoot(root);
  } else {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getChildRoot = (vnode) => {
  const rawChildren = vnode.children;
  const dynamicChildren = vnode.dynamicChildren;
  const childRoot = filterSingleRoot(rawChildren);
  if (!childRoot) {
    return [vnode, void 0];
  }
  const index = rawChildren.indexOf(childRoot);
  const dynamicIndex = dynamicChildren ? dynamicChildren.indexOf(childRoot) : -1;
  const setRoot = (updatedRoot) => {
    rawChildren[index] = updatedRoot;
    if (dynamicChildren) {
      if (dynamicIndex > -1) {
        dynamicChildren[dynamicIndex] = updatedRoot;
      } else if (updatedRoot.patchFlag > 0) {
        vnode.dynamicChildren = [...dynamicChildren, updatedRoot];
      }
    }
  };
  return [normalizeVNode(childRoot), setRoot];
};
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
const isElementRoot = (vnode) => {
  return vnode.shapeFlag & (6 | 1) || vnode.type === Comment;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (process.env.NODE_ENV !== "production" && (prevChildren || nextChildren) && isHmrUpdating) {
    return true;
  }
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
function provide(key, value) {
  if (!currentInstance) {
    if (process.env.NODE_ENV !== "production") {
      warn(`provide() can only be used inside setup().`);
    }
  } else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else if (process.env.NODE_ENV !== "production") {
      warn(`injection "${String(key)}" not found.`);
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`inject() can only be used inside setup() or functional components.`);
  }
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  if (process.env.NODE_ENV !== "production" && !isFunction(cb)) {
    warn(`\`watch(fn, options?)\` signature has been moved to a separate API. Use \`watchEffect(fn, options?)\` instead. \`watch\` now only supports \`watch(source, cb, options?) signature.`);
  }
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  if (process.env.NODE_ENV !== "production" && !cb) {
    if (immediate !== void 0) {
      warn(`watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.`);
    }
    if (deep !== void 0) {
      warn(`watch() "deep" option is only respected when using the watch(source, callback, options?) signature.`);
    }
  }
  const warnInvalidSource = (s) => {
    warn(`Invalid watch source: `, s, `A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.`);
  };
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow$1(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow$1(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction(s)) {
        return callWithErrorHandling(
          s,
          instance,
          2
          /* ErrorCodes.WATCH_GETTER */
        );
      } else {
        process.env.NODE_ENV !== "production" && warnInvalidSource(s);
      }
    });
  } else if (isFunction(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(
        source,
        instance,
        2
        /* ErrorCodes.WATCH_GETTER */
      );
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
    process.env.NODE_ENV !== "production" && warnInvalidSource(source);
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(
        fn,
        instance,
        4
        /* ErrorCodes.WATCH_CLEANUP */
      );
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          // pass undefined as the old value when it's changed for the first time
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (process.env.NODE_ENV !== "production") {
    effect.onTrack = onTrack;
    effect.onTrigger = onTrigger;
  }
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject(value) || value[
    "__v_skip"
    /* ReactiveFlags.SKIP */
  ]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function defineComponent(options) {
  return isFunction(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  } else if (process.env.NODE_ENV !== "production") {
    const apiName = toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/, ""));
    warn(`${apiName} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`);
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
);
const onBeforeMount = createHook(
  "bm"
  /* LifecycleHooks.BEFORE_MOUNT */
);
const onMounted = createHook(
  "m"
  /* LifecycleHooks.MOUNTED */
);
const onBeforeUpdate = createHook(
  "bu"
  /* LifecycleHooks.BEFORE_UPDATE */
);
const onUpdated = createHook(
  "u"
  /* LifecycleHooks.UPDATED */
);
const onBeforeUnmount = createHook(
  "bum"
  /* LifecycleHooks.BEFORE_UNMOUNT */
);
const onUnmounted = createHook(
  "um"
  /* LifecycleHooks.UNMOUNTED */
);
const onServerPrefetch = createHook(
  "sp"
  /* LifecycleHooks.SERVER_PREFETCH */
);
const onRenderTriggered = createHook(
  "rtg"
  /* LifecycleHooks.RENDER_TRIGGERED */
);
const onRenderTracked = createHook(
  "rtc"
  /* LifecycleHooks.RENDER_TRACKED */
);
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function validateDirectiveName(name) {
  if (isBuiltInDirective(name)) {
    warn("Do not use built-in directive ids as custom directive id: " + name);
  }
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const NULL_DYNAMIC_COMPONENT = Symbol();
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i) => i,
    $el: (i) => i.vnode.el,
    $data: (i) => i.data,
    $props: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.props) : i.props,
    $attrs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.attrs) : i.attrs,
    $slots: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.slots) : i.slots,
    $refs: (i) => process.env.NODE_ENV !== "production" ? shallowReadonly(i.refs) : i.refs,
    $parent: (i) => getPublicInstance(i.parent),
    $root: (i) => getPublicInstance(i.root),
    $emit: (i) => i.emit,
    $options: (i) => resolveMergedOptions(i),
    $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
    $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
    $watch: (i) => instanceWatch.bind(i)
  })
);
const isReservedPrefix = (key) => key === "_" || key === "$";
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    if (process.env.NODE_ENV !== "production" && key === "__isVue") {
      return true;
    }
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
        process.env.NODE_ENV !== "production" && markAttrsAccessed();
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else if (process.env.NODE_ENV !== "production" && currentRenderingInstance && (!isString(key) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    key.indexOf("__v") !== 0)) {
      if (data !== EMPTY_OBJ && isReservedPrefix(key[0]) && hasOwn(data, key)) {
        warn(`Property ${JSON.stringify(key)} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`);
      } else if (instance === currentRenderingInstance) {
        warn(`Property ${JSON.stringify(key)} was accessed during render but is not defined on instance.`);
      }
    }
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (process.env.NODE_ENV !== "production" && setupState.__isScriptSetup && hasOwn(setupState, key)) {
      warn(`Cannot mutate <script setup> binding "${key}" from Options API.`);
      return false;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate prop "${key}". Props are readonly.`);
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      process.env.NODE_ENV !== "production" && warn(`Attempting to mutate public property "${key}". Properties starting with $ are reserved and readonly.`);
      return false;
    } else {
      if (process.env.NODE_ENV !== "production" && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        });
      } else {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
if (process.env.NODE_ENV !== "production" && true) {
  PublicInstanceProxyHandlers.ownKeys = (target) => {
    warn(`Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.`);
    return Reflect.ownKeys(target);
  };
}
function createDevRenderContext(instance) {
  const target = {};
  Object.defineProperty(target, `_`, {
    configurable: true,
    enumerable: false,
    get: () => instance
  });
  Object.keys(publicPropertiesMap).forEach((key) => {
    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: false,
      get: () => publicPropertiesMap[key](instance),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: NOOP
    });
  });
  return target;
}
function exposePropsOnRenderContext(instance) {
  const { ctx, propsOptions: [propsOptions] } = instance;
  if (propsOptions) {
    Object.keys(propsOptions).forEach((key) => {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => instance.props[key],
        set: NOOP
      });
    });
  }
}
function exposeSetupStateOnRenderContext(instance) {
  const { ctx, setupState } = instance;
  Object.keys(toRaw(setupState)).forEach((key) => {
    if (!setupState.__isScriptSetup) {
      if (isReservedPrefix(key[0])) {
        warn(`setup() return property ${JSON.stringify(key)} should not start with "$" or "_" which are reserved prefixes for Vue internals.`);
        return;
      }
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => setupState[key],
        set: NOOP
      });
    }
  });
}
function createDuplicateChecker() {
  const cache = /* @__PURE__ */ Object.create(null);
  return (type, key) => {
    if (cache[key]) {
      warn(`${type} property "${key}" is already defined in ${cache[key]}.`);
    } else {
      cache[key] = type;
    }
  };
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook(
      options.beforeCreate,
      instance,
      "bc"
      /* LifecycleHooks.BEFORE_CREATE */
    );
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = process.env.NODE_ENV !== "production" ? createDuplicateChecker() : null;
  if (process.env.NODE_ENV !== "production") {
    const [propsOptions] = instance.propsOptions;
    if (propsOptions) {
      for (const key in propsOptions) {
        checkDuplicateProperties("Props", key);
      }
    }
  }
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction(methodHandler)) {
        if (process.env.NODE_ENV !== "production") {
          Object.defineProperty(ctx, key, {
            value: methodHandler.bind(publicThis),
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          ctx[key] = methodHandler.bind(publicThis);
        }
        if (process.env.NODE_ENV !== "production") {
          checkDuplicateProperties("Methods", key);
        }
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Method "${key}" has type "${typeof methodHandler}" in the component definition. Did you reference the function correctly?`);
      }
    }
  }
  if (dataOptions) {
    if (process.env.NODE_ENV !== "production" && !isFunction(dataOptions)) {
      warn(`The data option must be a function. Plain object usage is no longer supported.`);
    }
    const data = dataOptions.call(publicThis, publicThis);
    if (process.env.NODE_ENV !== "production" && isPromise(data)) {
      warn(`data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.`);
    }
    if (!isObject(data)) {
      process.env.NODE_ENV !== "production" && warn(`data() should return an object.`);
    } else {
      instance.data = reactive(data);
      if (process.env.NODE_ENV !== "production") {
        for (const key in data) {
          checkDuplicateProperties("Data", key);
          if (!isReservedPrefix(key[0])) {
            Object.defineProperty(ctx, key, {
              configurable: true,
              enumerable: true,
              get: () => data[key],
              set: NOOP
            });
          }
        }
      }
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction(opt) ? opt.bind(publicThis, publicThis) : isFunction(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      if (process.env.NODE_ENV !== "production" && get2 === NOOP) {
        warn(`Computed property "${key}" has no getter.`);
      }
      const set2 = !isFunction(opt) && isFunction(opt.set) ? opt.set.bind(publicThis) : process.env.NODE_ENV !== "production" ? () => {
        warn(`Write operation failed: computed property "${key}" is readonly.`);
      } : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
      if (process.env.NODE_ENV !== "production") {
        checkDuplicateProperties("Computed", key);
      }
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook(
      created,
      instance,
      "c"
      /* LifecycleHooks.CREATED */
    );
  }
  function registerLifecycleHook(register, hook) {
    if (isArray(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
          /* treat default function as factory */
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        if (process.env.NODE_ENV !== "production") {
          warn(`injected property "${key}" is a ref and will be auto-unwrapped and no longer needs \`.value\` in the next minor release. To opt-in to the new behavior now, set \`app.config.unwrapInjectedRef = true\` (this config is temporary and will not be needed in the future.)`);
        }
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
    if (process.env.NODE_ENV !== "production") {
      checkDuplicateProperties("Inject", key);
    }
  }
}
function callHook(hook, instance, type) {
  callWithAsyncErrorHandling(isArray(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction(handler)) {
      watch(getter, handler);
    } else if (process.env.NODE_ENV !== "production") {
      warn(`Invalid watch handler specified by key "${raw}"`, handler);
    }
  } else if (isFunction(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject(raw)) {
    if (isArray(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction(handler)) {
        watch(getter, handler, raw);
      } else if (process.env.NODE_ENV !== "production") {
        warn(`Invalid watch handler specified by key "${raw.handler}"`, handler);
      }
    }
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid watch option: "${key}"`, raw);
  }
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose") {
      process.env.NODE_ENV !== "production" && warn(`"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.`);
    } else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction(to) ? to.call(this, this) : to, isFunction(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance);
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function isInHmrContext(instance) {
  while (instance) {
    if (instance.type.__hmrId)
      return true;
    instance = instance.parent;
  }
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !(process.env.NODE_ENV !== "production" && isInHmrContext(instance)) && (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
              /* isAbsent */
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
              /* isAbsent */
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
  if (process.env.NODE_ENV !== "production") {
    validateProps(rawProps || {}, props, instance);
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[
      0
      /* BooleanFlags.shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* BooleanFlags.shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray(raw)) {
    for (let i = 0; i < raw.length; i++) {
      if (process.env.NODE_ENV !== "production" && !isString(raw[i])) {
        warn(`props must be strings when using array syntax.`, raw[i]);
      }
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    if (process.env.NODE_ENV !== "production" && !isObject(raw)) {
      warn(`invalid props options`, raw);
    }
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray(opt) || isFunction(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[
            0
            /* BooleanFlags.shouldCast */
          ] = booleanIndex > -1;
          prop[
            1
            /* BooleanFlags.shouldCastTrue */
          ] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  } else if (process.env.NODE_ENV !== "production") {
    warn(`Invalid prop name: "${key}" is a reserved property.`);
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match ? match[2] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
function validateProps(rawProps, props, instance) {
  const resolvedValues = toRaw(props);
  const options = instance.propsOptions[0];
  for (const key in options) {
    let opt = options[key];
    if (opt == null)
      continue;
    validateProp(key, resolvedValues[key], opt, !hasOwn(rawProps, key) && !hasOwn(rawProps, hyphenate(key)));
  }
}
function validateProp(name, value, prop, isAbsent) {
  const { type, required, validator } = prop;
  if (required && isAbsent) {
    warn('Missing required prop: "' + name + '"');
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  if (type != null && type !== true) {
    let isValid = false;
    const types = isArray(type) ? type : [type];
    const expectedTypes = [];
    for (let i = 0; i < types.length && !isValid; i++) {
      const { valid, expectedType } = assertType(value, types[i]);
      expectedTypes.push(expectedType || "");
      isValid = valid;
    }
    if (!isValid) {
      warn(getInvalidTypeMessage(name, value, expectedTypes));
      return;
    }
  }
  if (validator && !validator(value)) {
    warn('Invalid prop: custom validator check failed for prop "' + name + '".');
  }
}
const isSimpleType = /* @__PURE__ */ makeMap("String,Number,Boolean,Function,Symbol,BigInt");
function assertType(value, type) {
  let valid;
  const expectedType = getType(type);
  if (isSimpleType(expectedType)) {
    const t = typeof value;
    valid = t === expectedType.toLowerCase();
    if (!valid && t === "object") {
      valid = value instanceof type;
    }
  } else if (expectedType === "Object") {
    valid = isObject(value);
  } else if (expectedType === "Array") {
    valid = isArray(value);
  } else if (expectedType === "null") {
    valid = value === null;
  } else {
    valid = value instanceof type;
  }
  return {
    valid,
    expectedType
  };
}
function getInvalidTypeMessage(name, value, expectedTypes) {
  let message = `Invalid prop: type check failed for prop "${name}". Expected ${expectedTypes.map(capitalize).join(" | ")}`;
  const expectedType = expectedTypes[0];
  const receivedType = toRawType(value);
  const expectedValue = styleValue(value, expectedType);
  const receivedValue = styleValue(value, receivedType);
  if (expectedTypes.length === 1 && isExplicable(expectedType) && !isBoolean(expectedType, receivedType)) {
    message += ` with value ${expectedValue}`;
  }
  message += `, got ${receivedType} `;
  if (isExplicable(receivedType)) {
    message += `with value ${receivedValue}.`;
  }
  return message;
}
function styleValue(value, type) {
  if (type === "String") {
    return `"${value}"`;
  } else if (type === "Number") {
    return `${Number(value)}`;
  } else {
    return `${value}`;
  }
}
function isExplicable(type) {
  const explicitTypes = ["string", "number", "boolean"];
  return explicitTypes.some((elem) => type.toLowerCase() === elem);
}
function isBoolean(...args) {
  return args.some((elem) => elem.toLowerCase() === "boolean");
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (process.env.NODE_ENV !== "production" && currentInstance) {
      warn(`Slot "${key}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`);
    }
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      if (process.env.NODE_ENV !== "production" && true) {
        warn(`Non-function value encountered for slot "${key}". Prefer function slots for better performance.`);
      }
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  if (process.env.NODE_ENV !== "production" && !isKeepAlive(instance.vnode) && true) {
    warn(`Non-function value encountered for default slot. Prefer function slots for better performance.`);
  }
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
        extend(slots, children);
      } else if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject(rootProps)) {
      process.env.NODE_ENV !== "production" && warn(`root props passed to app.mount() must be an object.`);
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
        if (process.env.NODE_ENV !== "production") {
          warn(`app.config cannot be replaced. Modify individual options instead.`);
        }
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) {
          process.env.NODE_ENV !== "production" && warn(`Plugin has already been applied to target app.`);
        } else if (plugin && isFunction(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else if (process.env.NODE_ENV !== "production") {
          warn(`A plugin must either be a function or an object with an "install" function.`);
        }
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          } else if (process.env.NODE_ENV !== "production") {
            warn("Mixin has already been applied to target app" + (mixin.name ? `: ${mixin.name}` : ""));
          }
        }
        return app;
      },
      component(name, component) {
        if (process.env.NODE_ENV !== "production") {
          validateComponentName(name, context.config);
        }
        if (!component) {
          return context.components[name];
        }
        if (process.env.NODE_ENV !== "production" && context.components[name]) {
          warn(`Component "${name}" has already been registered in target app.`);
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (process.env.NODE_ENV !== "production") {
          validateDirectiveName(name);
        }
        if (!directive) {
          return context.directives[name];
        }
        if (process.env.NODE_ENV !== "production" && context.directives[name]) {
          warn(`Directive "${name}" has already been registered in target app.`);
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          if (process.env.NODE_ENV !== "production" && rootContainer.__vue_app__) {
            warn(`There is already an app instance mounted on the host container.
 If you want to mount another app on the same host container, you need to unmount the previous app by calling \`app.unmount()\` first.`);
          }
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (process.env.NODE_ENV !== "production") {
            context.reload = () => {
              render(cloneVNode(vnode), rootContainer, isSVG);
            };
          }
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          if (process.env.NODE_ENV !== "production" || false) {
            app._instance = vnode.component;
            devtoolsInitApp(app, version);
          }
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`App has already been mounted.
If you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. \`const createMyApp = () => createApp(App)\``);
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app._container);
          if (process.env.NODE_ENV !== "production" || false) {
            app._instance = null;
            devtoolsUnmountApp(app);
          }
          delete app._container.__vue_app__;
        } else if (process.env.NODE_ENV !== "production") {
          warn(`Cannot unmount an app that is not mounted.`);
        }
      },
      provide(key, value) {
        if (process.env.NODE_ENV !== "production" && key in context.provides) {
          warn(`App already provides property with key "${String(key)}". It will be overwritten with the new value.`);
        }
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  if (process.env.NODE_ENV !== "production" && !owner) {
    warn(`Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.`);
    return;
  }
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray(existing) && remove(existing, refValue);
          } else {
            if (!isArray(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
        }
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    } else if (process.env.NODE_ENV !== "production") {
      warn("Invalid template ref type:", ref2, `(${typeof ref2})`);
    }
  }
}
let supported;
let perf;
function startMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    perf.mark(`vue-${type}-${instance.uid}`);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfStart(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function endMeasure(instance, type) {
  if (instance.appContext.config.performance && isSupported()) {
    const startTag = `vue-${type}-${instance.uid}`;
    const endTag = startTag + `:end`;
    perf.mark(endTag);
    perf.measure(`<${formatComponentName(instance, instance.type)}> ${type}`, startTag, endTag);
    perf.clearMarks(startTag);
    perf.clearMarks(endTag);
  }
  if (process.env.NODE_ENV !== "production" || false) {
    devtoolsPerfEnd(instance, type, isSupported() ? perf.now() : Date.now());
  }
}
function isSupported() {
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else {
    supported = false;
  }
  return supported;
}
function initFeatureFlags() {
  const needWarn = [];
  if (process.env.NODE_ENV !== "production" && needWarn.length) {
    const multi = needWarn.length > 1;
    console.warn(`Feature flag${multi ? `s` : ``} ${needWarn.join(", ")} ${multi ? `are` : `is`} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`);
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  {
    initFeatureFlags();
  }
  const target = getGlobalThis();
  target.__VUE__ = true;
  if (process.env.NODE_ENV !== "production" || false) {
    setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__, target);
  }
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = process.env.NODE_ENV !== "production" && isHmrUpdating ? false : !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        } else if (process.env.NODE_ENV !== "production") {
          patchStaticNode(n1, n2, container, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (process.env.NODE_ENV !== "production") {
          warn("Invalid VNode type:", type, `(${typeof type})`);
        }
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const patchStaticNode = (n1, n2, container, isSVG) => {
    if (n2.children !== n1.children) {
      const anchor = hostNextSibling(n1.anchor);
      removeStaticNode(n1);
      [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG);
    } else {
      n2.el = n1.el;
      n2.anchor = n1.anchor;
    }
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      Object.defineProperty(el, "__vnode", {
        value: vnode,
        enumerable: false
      });
      Object.defineProperty(el, "__vueParentComponent", {
        value: parentComponent,
        enumerable: false
      });
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (process.env.NODE_ENV !== "production" && subTree.patchFlag > 0 && subTree.patchFlag & 2048) {
        subTree = filterSingleRoot(subTree.children) || subTree;
      }
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (process.env.NODE_ENV !== "production" && isHmrUpdating) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
      if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
        traverseStaticChildren(n1, n2);
      }
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (process.env.NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (isHmrUpdating || patchFlag & 2048)) {
      patchFlag = 0;
      optimized = false;
      dynamicChildren = null;
    }
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (process.env.NODE_ENV !== "production" && parentComponent && parentComponent.type.__hmrId) {
          traverseStaticChildren(n1, n2);
        } else if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
      registerHMR(instance);
    }
    if (process.env.NODE_ENV !== "production") {
      pushWarningContext(initialVNode);
      startMeasure(instance, `mount`);
    }
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      if (process.env.NODE_ENV !== "production") {
        startMeasure(instance, `init`);
      }
      setupComponent(instance);
      if (process.env.NODE_ENV !== "production") {
        endMeasure(instance, `init`);
      }
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
    if (process.env.NODE_ENV !== "production") {
      popWarningContext();
      endMeasure(instance, `mount`);
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(n2);
        }
        updateComponentPreRender(instance, n2, optimized);
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `render`);
            }
            instance.subTree = renderComponentRoot(instance);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `render`);
            }
            if (process.env.NODE_ENV !== "production") {
              startMeasure(instance, `hydrate`);
            }
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
            if (process.env.NODE_ENV !== "production") {
              endMeasure(instance, `hydrate`);
            }
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              // note: we are moving the render call into an async callback,
              // which means it won't track dependencies - but it's ok because
              // a server-rendered async wrapper is already in resolved state
              // and it will never need to change.
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `render`);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `render`);
          }
          if (process.env.NODE_ENV !== "production") {
            startMeasure(instance, `patch`);
          }
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          if (process.env.NODE_ENV !== "production") {
            endMeasure(instance, `patch`);
          }
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentAdded(instance);
        }
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        if (process.env.NODE_ENV !== "production") {
          pushWarningContext(next || instance.vnode);
        }
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `render`);
        }
        const nextTree = renderComponentRoot(instance);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `render`);
        }
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `patch`);
        }
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `patch`);
        }
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
        if (process.env.NODE_ENV !== "production" || false) {
          devtoolsComponentUpdated(instance);
        }
        if (process.env.NODE_ENV !== "production") {
          popWarningContext();
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
      // track it in component's effect scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    if (process.env.NODE_ENV !== "production") {
      effect.onTrack = instance.rtc ? (e) => invokeArrayFns(instance.rtc, e) : void 0;
      effect.onTrigger = instance.rtg ? (e) => invokeArrayFns(instance.rtg, e) : void 0;
      update.ownerInstance = instance;
    }
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          if (process.env.NODE_ENV !== "production" && keyToNewIndexMap.has(nextChild.key)) {
            warn(`Duplicate keys found during update:`, JSON.stringify(nextChild.key), `Make sure keys are unique.`);
          }
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(
              nextChild,
              container,
              anchor,
              2
              /* MoveType.REORDER */
            );
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      if (process.env.NODE_ENV !== "production" && vnode.patchFlag > 0 && vnode.patchFlag & 2048 && transition && !transition.persisted) {
        vnode.children.forEach((child) => {
          if (child.type === Comment) {
            hostRemove(child.el);
          } else {
            remove2(child);
          }
        });
      } else {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    if (process.env.NODE_ENV !== "production" && instance.type.__hmrId) {
      unregisterHMR(instance);
    }
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
    if (process.env.NODE_ENV !== "production" || false) {
      devtoolsComponentRemoved(instance);
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray(ch1) && isArray(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
      if (process.env.NODE_ENV !== "production" && c2.type === Comment && !c2.el) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const Fragment = Symbol(process.env.NODE_ENV !== "production" ? "Fragment" : void 0);
const Text = Symbol(process.env.NODE_ENV !== "production" ? "Text" : void 0);
const Comment = Symbol(process.env.NODE_ENV !== "production" ? "Comment" : void 0);
const Static = Symbol(process.env.NODE_ENV !== "production" ? "Static" : void 0);
let currentBlock = null;
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  if (process.env.NODE_ENV !== "production" && n2.shapeFlag & 6 && hmrDirtyComponents.has(n2.type)) {
    n1.shapeFlag &= ~256;
    n2.shapeFlag &= ~512;
    return false;
  }
  return n1.type === n2.type && n1.key === n2.key;
}
const createVNodeWithArgsTransform = (...args) => {
  return _createVNode(...args);
};
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString(ref2) || isRef(ref2) || isFunction(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (process.env.NODE_ENV !== "production" && vnode.key !== vnode.key) {
    warn(`VNode created with invalid key (NaN). VNode type:`, vnode.type);
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = process.env.NODE_ENV !== "production" ? createVNodeWithArgsTransform : _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    if (process.env.NODE_ENV !== "production" && !type) {
      warn(`Invalid vnode type when creating vnode: ${type}.`);
    }
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject(style)) {
      if (isProxy(style) && !isArray(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject(type) ? 4 : isFunction(type) ? 2 : 0;
  if (process.env.NODE_ENV !== "production" && shapeFlag & 4 && isProxy(type)) {
    type = toRaw(type);
    warn(`Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with \`markRaw\` or using \`shallowRef\` instead of \`ref\`.`, `
Component that was made reactive: `, type);
  }
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref2 ? isArray(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children: process.env.NODE_ENV !== "production" && patchFlag === -1 && isArray(children) ? children.map(deepCloneVNode) : children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function deepCloneVNode(vnode) {
  const cloned = cloneVNode(vnode);
  if (isArray(vnode.children)) {
    cloned.children = vnode.children.map(deepCloneVNode);
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  if (process.env.NODE_ENV !== "production") {
    instance.ctx = createDevRenderContext(instance);
  } else {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
const isBuiltInTag = /* @__PURE__ */ makeMap("slot,component");
function validateComponentName(name, config) {
  const appIsNativeTag = config.isNativeTag || NO;
  if (isBuiltInTag(name) || appIsNativeTag(name)) {
    warn("Do not use built-in or reserved HTML elements as component id: " + name);
  }
}
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  var _a;
  const Component = instance.type;
  if (process.env.NODE_ENV !== "production") {
    if (Component.name) {
      validateComponentName(Component.name, instance.appContext.config);
    }
    if (Component.components) {
      const names = Object.keys(Component.components);
      for (let i = 0; i < names.length; i++) {
        validateComponentName(names[i], instance.appContext.config);
      }
    }
    if (Component.directives) {
      const names = Object.keys(Component.directives);
      for (let i = 0; i < names.length; i++) {
        validateDirectiveName(names[i]);
      }
    }
    if (Component.compilerOptions && isRuntimeOnly()) {
      warn(`"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.`);
    }
  }
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  if (process.env.NODE_ENV !== "production") {
    exposePropsOnRenderContext(instance);
  }
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [process.env.NODE_ENV !== "production" ? shallowReadonly(instance.props) : instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(
            e,
            instance,
            0
            /* ErrorCodes.SETUP_FUNCTION */
          );
        });
      } else {
        instance.asyncDep = setupResult;
        if (process.env.NODE_ENV !== "production" && !instance.suspense) {
          const name = (_a = Component.name) !== null && _a !== void 0 ? _a : "Anonymous";
          warn(`Component <${name}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`);
        }
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject(setupResult)) {
    if (process.env.NODE_ENV !== "production" && isVNode(setupResult)) {
      warn(`setup() should not return VNodes directly - return a render function instead.`);
    }
    if (process.env.NODE_ENV !== "production" || false) {
      instance.devtoolsRawSetupState = setupResult;
    }
    instance.setupState = proxyRefs(setupResult);
    if (process.env.NODE_ENV !== "production") {
      exposeSetupStateOnRenderContext(instance);
    }
  } else if (process.env.NODE_ENV !== "production" && setupResult !== void 0) {
    warn(`setup() should return an object. Received: ${setupResult === null ? "null" : typeof setupResult}`);
  }
  finishComponentSetup(instance, isSSR);
}
let compile;
const isRuntimeOnly = () => !compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        if (process.env.NODE_ENV !== "production") {
          startMeasure(instance, `compile`);
        }
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
        if (process.env.NODE_ENV !== "production") {
          endMeasure(instance, `compile`);
        }
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
  if (process.env.NODE_ENV !== "production" && !Component.render && instance.render === NOOP && !isSSR) {
    if (Component.template) {
      warn(
        `Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".`
        /* should not happen */
      );
    } else {
      warn(`Component is missing template or render function.`);
    }
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, process.env.NODE_ENV !== "production" ? {
    get(target, key) {
      markAttrsAccessed();
      track(instance, "get", "$attrs");
      return target[key];
    },
    set() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    },
    deleteProperty() {
      warn(`setupContext.attrs is readonly.`);
      return false;
    }
  } : {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    if (process.env.NODE_ENV !== "production") {
      if (instance.exposed) {
        warn(`expose() should be called only once per setup().`);
      }
      if (exposed != null) {
        let exposedType = typeof exposed;
        if (exposedType === "object") {
          if (isArray(exposed)) {
            exposedType = "array";
          } else if (isRef(exposed)) {
            exposedType = "ref";
          }
        }
        if (exposedType !== "object") {
          warn(`expose() should be passed a plain object, received ${exposedType}.`);
        }
      }
    }
    instance.exposed = exposed || {};
  };
  let attrs;
  if (process.env.NODE_ENV !== "production") {
    return Object.freeze({
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      get slots() {
        return shallowReadonly(instance.slots);
      },
      get emit() {
        return (event, ...args) => instance.emit(event, ...args);
      },
      expose
    });
  } else {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
const ssrContextKey = Symbol(process.env.NODE_ENV !== "production" ? `ssrContext` : ``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      process.env.NODE_ENV !== "production" && warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function isShallow(value) {
  return !!(value && value[
    "__v_isShallow"
    /* ReactiveFlags.IS_SHALLOW */
  ]);
}
function initCustomFormatter() {
  if (!(process.env.NODE_ENV !== "production") || typeof window === "undefined") {
    return;
  }
  const vueStyle = { style: "color:#3ba776" };
  const numberStyle = { style: "color:#0b1bc9" };
  const stringStyle = { style: "color:#b62e24" };
  const keywordStyle = { style: "color:#9d288c" };
  const formatter = {
    header(obj) {
      if (!isObject(obj)) {
        return null;
      }
      if (obj.__isVue) {
        return ["div", vueStyle, `VueInstance`];
      } else if (isRef(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, genRefFlag(obj)],
          "<",
          formatValue(obj.value),
          `>`
        ];
      } else if (isReactive(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReactive" : "Reactive"],
          "<",
          formatValue(obj),
          `>${isReadonly(obj) ? ` (readonly)` : ``}`
        ];
      } else if (isReadonly(obj)) {
        return [
          "div",
          {},
          ["span", vueStyle, isShallow(obj) ? "ShallowReadonly" : "Readonly"],
          "<",
          formatValue(obj),
          ">"
        ];
      }
      return null;
    },
    hasBody(obj) {
      return obj && obj.__isVue;
    },
    body(obj) {
      if (obj && obj.__isVue) {
        return [
          "div",
          {},
          ...formatInstance(obj.$)
        ];
      }
    }
  };
  function formatInstance(instance) {
    const blocks = [];
    if (instance.type.props && instance.props) {
      blocks.push(createInstanceBlock("props", toRaw(instance.props)));
    }
    if (instance.setupState !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("setup", instance.setupState));
    }
    if (instance.data !== EMPTY_OBJ) {
      blocks.push(createInstanceBlock("data", toRaw(instance.data)));
    }
    const computed2 = extractKeys(instance, "computed");
    if (computed2) {
      blocks.push(createInstanceBlock("computed", computed2));
    }
    const injected = extractKeys(instance, "inject");
    if (injected) {
      blocks.push(createInstanceBlock("injected", injected));
    }
    blocks.push([
      "div",
      {},
      [
        "span",
        {
          style: keywordStyle.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: instance }]
    ]);
    return blocks;
  }
  function createInstanceBlock(type, target) {
    target = extend({}, target);
    if (!Object.keys(target).length) {
      return ["span", {}];
    }
    return [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        type
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(target).map((key) => {
          return [
            "div",
            {},
            ["span", keywordStyle, key + ": "],
            formatValue(target[key], false)
          ];
        })
      ]
    ];
  }
  function formatValue(v, asRaw = true) {
    if (typeof v === "number") {
      return ["span", numberStyle, v];
    } else if (typeof v === "string") {
      return ["span", stringStyle, JSON.stringify(v)];
    } else if (typeof v === "boolean") {
      return ["span", keywordStyle, v];
    } else if (isObject(v)) {
      return ["object", { object: asRaw ? toRaw(v) : v }];
    } else {
      return ["span", stringStyle, String(v)];
    }
  }
  function extractKeys(instance, type) {
    const Comp = instance.type;
    if (isFunction(Comp)) {
      return;
    }
    const extracted = {};
    for (const key in instance.ctx) {
      if (isKeyOfType(Comp, key, type)) {
        extracted[key] = instance.ctx[key];
      }
    }
    return extracted;
  }
  function isKeyOfType(Comp, key, type) {
    const opts = Comp[type];
    if (isArray(opts) && opts.includes(key) || isObject(opts) && key in opts) {
      return true;
    }
    if (Comp.extends && isKeyOfType(Comp.extends, key, type)) {
      return true;
    }
    if (Comp.mixins && Comp.mixins.some((m) => isKeyOfType(m, key, type))) {
      return true;
    }
  }
  function genRefFlag(v) {
    if (isShallow(v)) {
      return `ShallowRef`;
    }
    if (v.effect) {
      return `ComputedRef`;
    }
    return `Ref`;
  }
  if (window.devtoolsFormatters) {
    window.devtoolsFormatters.push(formatter);
  } else {
    window.devtoolsFormatters = [formatter];
  }
}
const version = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  if (next && !isCssString) {
    if (prev && !isString(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const semicolonRE = /[^\\];\s*$/;
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (process.env.NODE_ENV !== "production") {
      if (semicolonRE.test(val)) {
        warn(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);
      }
    }
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && // custom elements may use _value internally
  !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || // #4956: always set for OPTION elements because its value falls back to
    // textContent if no value attribute is present. And setting .value for
    // OPTION has no side effect
    el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
    if (process.env.NODE_ENV !== "production" && !needRemove) {
      warn(`Failed setting prop "${key}" on <${el.tagName.toLowerCase()}>: value ${value} is invalid.`, e);
    }
  }
  needRemove && el.removeAttribute(key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  if (process.env.NODE_ENV !== "production") {
    injectNativeTagCheck(app);
    injectCompilerOptionsCheck(app);
  }
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function injectNativeTagCheck(app) {
  Object.defineProperty(app.config, "isNativeTag", {
    value: (tag) => isHTMLTag(tag) || isSVGTag(tag),
    writable: false
  });
}
function injectCompilerOptionsCheck(app) {
  {
    const isCustomElement = app.config.isCustomElement;
    Object.defineProperty(app.config, "isCustomElement", {
      get() {
        return isCustomElement;
      },
      set() {
        warn(`The \`isCustomElement\` config option is deprecated. Use \`compilerOptions.isCustomElement\` instead.`);
      }
    });
    const compilerOptions = app.config.compilerOptions;
    const msg = `The \`compilerOptions\` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, \`compilerOptions\` must be passed to \`@vue/compiler-dom\` in the build setup instead.
- For vue-loader: pass it via vue-loader's \`compilerOptions\` loader option.
- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader
- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;
    Object.defineProperty(app.config, "compilerOptions", {
      get() {
        warn(msg);
        return compilerOptions;
      },
      set() {
        warn(msg);
      }
    });
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    if (process.env.NODE_ENV !== "production" && !res) {
      warn(`Failed to mount app: mount target selector "${container}" returned null.`);
    }
    return res;
  }
  if (process.env.NODE_ENV !== "production" && window.ShadowRoot && container instanceof window.ShadowRoot && container.mode === "closed") {
    warn(`mounting on a ShadowRoot with \`{mode: "closed"}\` may lead to unpredictable bugs`);
  }
  return container;
}
function initDev() {
  {
    initCustomFormatter();
  }
}
if (process.env.NODE_ENV !== "production") {
  initDev();
}
const Option_vue_vue_type_style_index_0_scoped_6911afe5_lang = "";
const MyButton_vue_vue_type_style_index_0_scoped_465f3d4a_lang = "";
const App_vue_vue_type_style_index_0_scoped_1c0ece5c_lang = "";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "sheet",
  props: {
    beautifulFeature: Array,
    labFeature: Array,
    dangerousFeature: Array
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return null;
    };
  }
});
const labFeatureList = [
  "原生替换"
];
class SettingList {
  constructor() {
    __publicField(this, "setList");
    __publicField(this, "SetDict");
    this.setList = [];
    this.SetDict = {};
  }
  setting(init, name) {
    this.setList.push(init);
    this.SetDict[name] = init;
    return init;
  }
  //返回读取结果后的dict字典，方便保存
  getSetting() {
    let settingKey = Object.keys(this.SetDict);
    let returnDict = {};
    for (let item of settingKey) {
      returnDict[item] = this.SetDict[item].value;
    }
    return returnDict;
  }
}
let settingList = new SettingList();
function addSetting(settingKey, setDict) {
  return {
    content: settingKey,
    status: settingList.setting(
      ref(setDict[settingKey]),
      settingKey
    )
  };
}
function loadSetting(settingDict) {
  let labFeature = [];
  for (let item of labFeatureList) {
    labFeature.push(addSetting(item, settingDict));
  }
  let settingConfig = {
    labFeature
  };
  return settingConfig;
}
function initSetting() {
  let setDict = {};
  for (let item of labFeatureList) {
    setDict[item] = false;
  }
  let settingConfig = loadSetting(setDict);
  return settingConfig;
}
async function getSetting(localConfig) {
  if (!localConfig) {
    return initSetting();
  }
  let setDictText = localConfig;
  let setDict = JSON.parse(setDictText);
  return loadSetting(setDict);
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var jqueryExports = {};
var jquery = {
  get exports() {
    return jqueryExports;
  },
  set exports(v) {
    jqueryExports = v;
  }
};
/*!
 * jQuery JavaScript Library v3.6.4
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-03-08T15:28Z
 */
(function(module2) {
  (function(global2, factory) {
    {
      module2.exports = global2.document ? factory(global2, true) : function(w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }
        return factory(w);
      };
    }
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
    var arr = [];
    var getProto2 = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = arr.flat ? function(array) {
      return arr.flat.call(array);
    } : function(array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn2 = class2type.hasOwnProperty;
    var fnToString = hasOwn2.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};
    var isFunction2 = function isFunction3(obj) {
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };
    var isWindow = function isWindow2(obj) {
      return obj != null && obj === obj.window;
    };
    var document2 = window2.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };
    function DOMEval(code, node, doc2) {
      doc2 = doc2 || document2;
      var i, val, script = doc2.createElement("script");
      script.text = code;
      if (node) {
        for (i in preservedScriptAttributes) {
          val = node[i] || node.getAttribute && node.getAttribute(i);
          if (val) {
            script.setAttribute(i, val);
          }
        }
      }
      doc2.head.appendChild(script).parentNode.removeChild(script);
    }
    function toType(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    var version2 = "3.6.4", jQuery = function(selector, context) {
      return new jQuery.fn.init(selector, context);
    };
    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version2,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function() {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function(num) {
        if (num == null) {
          return slice.call(this);
        }
        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function(elems) {
        var ret = jQuery.merge(this.constructor(), elems);
        ret.prevObject = this;
        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function(callback) {
        return jQuery.each(this, callback);
      },
      map: function(callback) {
        return this.pushStack(jQuery.map(this, function(elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function() {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function() {
        return this.eq(0);
      },
      last: function() {
        return this.eq(-1);
      },
      even: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function() {
        return this.pushStack(jQuery.grep(this, function(_elem, i) {
          return i % 2;
        }));
      },
      eq: function(i) {
        var len = this.length, j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function() {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push,
      sort: arr.sort,
      splice: arr.splice
    };
    jQuery.extend = jQuery.fn.extend = function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[i] || {};
        i++;
      }
      if (typeof target !== "object" && !isFunction2(target)) {
        target = {};
      }
      if (i === length) {
        target = this;
        i--;
      }
      for (; i < length; i++) {
        if ((options = arguments[i]) != null) {
          for (name in options) {
            copy = options[name];
            if (name === "__proto__" || target === copy) {
              continue;
            }
            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name];
              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }
              copyIsArray = false;
              target[name] = jQuery.extend(deep, clone, copy);
            } else if (copy !== void 0) {
              target[name] = copy;
            }
          }
        }
      }
      return target;
    };
    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version2 + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function(msg) {
        throw new Error(msg);
      },
      noop: function() {
      },
      isPlainObject: function(obj) {
        var proto, Ctor;
        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }
        proto = getProto2(obj);
        if (!proto) {
          return true;
        }
        Ctor = hasOwn2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function(obj) {
        var name;
        for (name in obj) {
          return false;
        }
        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function(code, options, doc2) {
        DOMEval(code, { nonce: options && options.nonce }, doc2);
      },
      each: function(obj, callback) {
        var length, i = 0;
        if (isArrayLike(obj)) {
          length = obj.length;
          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }
        return obj;
      },
      // results is for internal usage only
      makeArray: function(arr2, results) {
        var ret = results || [];
        if (arr2 != null) {
          if (isArrayLike(Object(arr2))) {
            jQuery.merge(
              ret,
              typeof arr2 === "string" ? [arr2] : arr2
            );
          } else {
            push.call(ret, arr2);
          }
        }
        return ret;
      },
      inArray: function(elem, arr2, i) {
        return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function(first, second) {
        var len = +second.length, j = 0, i = first.length;
        for (; j < len; j++) {
          first[i++] = second[j];
        }
        first.length = i;
        return first;
      },
      grep: function(elems, callback, invert) {
        var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);
          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }
        return matches;
      },
      // arg is for internal usage only
      map: function(elems, callback, arg) {
        var length, value, i = 0, ret = [];
        if (isArrayLike(elems)) {
          length = elems.length;
          for (; i < length; i++) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);
            if (value != null) {
              ret.push(value);
            }
          }
        }
        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support
    });
    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    jQuery.each(
      "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
      function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      }
    );
    function isArrayLike(obj) {
      var length = !!obj && "length" in obj && obj.length, type = toType(obj);
      if (isFunction2(obj) || isWindow(obj)) {
        return false;
      }
      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }
    var Sizzle = (
      /*!
       * Sizzle CSS Selector Engine v2.3.10
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://js.foundation/
       *
       * Date: 2023-02-14
       */
      function(window3) {
        var i, support2, Expr, getText, isXML, tokenize, compile2, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, hasOwn3 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
          var i2 = 0, len = list.length;
          for (; i2 < len; i2++) {
            if (list[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace2 + // "Attribute values must be CSS identifiers [capture 5]
        // or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rleadingCombinator = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 65536;
          return nonHex ? (
            // Strip the backslash prefix from a non-hex escape sequence
            nonHex
          ) : (
            // Replace a hexadecimal escape sequence with the encoded Unicode code point
            // Support: IE <=11+
            // For values outside the Basic Multilingual Plane (BMP), manually construct a
            // surrogate pair
            high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
          );
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "�";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
          },
          { dir: "parentNode", next: "legend" }
        );
        try {
          push2.apply(
            arr2 = slice2.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: arr2.length ? (
              // Leverage slice if possible
              function(target, els) {
                pushNative.apply(target, slice2.call(els));
              }
            ) : (
              // Support: IE<9
              // Otherwise append directly
              function(target, els) {
                var j = target.length, i2 = 0;
                while (target[j++] = els[i2++]) {
                }
                target.length = j - 1;
              }
            )
          };
        }
        function Sizzle2(selector, context, results, seed) {
          var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && // Support: IE 8 only
              // Exclude object elements
              (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext !== context || !support2.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = nid.replace(rcssescape, fcssescape);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim2, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr3 = attrs.split("|"), i2 = arr3.length;
          while (i2--) {
            Expr.attrHandle[arr3[i2]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
          if (diff) {
            return diff;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                /* jshint -W018 */
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j = matchIndexes[i2]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support2 = Sizzle2.support = {};
        isXML = Sizzle2.isXML = function(elem) {
          var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
        };
        setDocument = Sizzle2.setDocument = function(node) {
          var hasCompare, subWindow, doc2 = node ? node.ownerDocument || node : preferredDoc;
          if (doc2 == document3 || doc2.nodeType !== 9 || !doc2.documentElement) {
            return document3;
          }
          document3 = doc2;
          docElem = document3.documentElement;
          documentIsHTML = !isXML(document3);
          if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            if (subWindow.addEventListener) {
              subWindow.addEventListener("unload", unloadHandler, false);
            } else if (subWindow.attachEvent) {
              subWindow.attachEvent("onunload", unloadHandler);
            }
          }
          support2.scope = assert(function(el) {
            docElem.appendChild(el).appendChild(document3.createElement("div"));
            return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
          });
          support2.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e) {
              return true;
            }
          });
          support2.attributes = assert(function(el) {
            el.className = "i";
            return !el.getAttribute("className");
          });
          support2.getElementsByTagName = assert(function(el) {
            el.appendChild(document3.createComment(""));
            return !el.getElementsByTagName("*").length;
          });
          support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
          support2.getById = assert(function(el) {
            docElem.appendChild(el).id = expando;
            return !document3.getElementsByName || !document3.getElementsByName(expando).length;
          });
          if (support2.getById) {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i2, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support2.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if (support2.qsa = rnative.test(document3.querySelectorAll)) {
            assert(function(el) {
              var input;
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
              if (el.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              el.querySelectorAll("\\\f");
              rbuggyQSA.push("[\\r\\n\\f]");
            });
            assert(function(el) {
              el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              if (el.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
              }
              if (el.querySelectorAll(":enabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              docElem.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              el.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function(el) {
              support2.disconnectedMatch = matches.call(el, "*");
              matches.call(el, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          if (!support2.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
            if (!aup || !bup) {
              return a == document3 ? -1 : b == document3 ? 1 : (
                /* eslint-enable eqeqeq */
                aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0
              );
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? (
              // Do a sibling check if the nodes have a common ancestor
              siblingCheck(ap[i2], bp[i2])
            ) : (
              // Otherwise nodes in our document sort first
              // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              /* eslint-disable eqeqeq */
              ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : (
                /* eslint-enable eqeqeq */
                0
              )
            );
          };
          return document3;
        };
        Sizzle2.matches = function(expr, elements) {
          return Sizzle2(expr, null, null, elements);
        };
        Sizzle2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support2.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return Sizzle2(expr, document3, null, [elem]).length > 0;
        };
        Sizzle2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle2.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn3.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle2.escape = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support2.detectDuplicates;
          sortInput = !support2.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle2.getText = function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle2.selectors = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                Sizzle2.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(
                className,
                function(elem) {
                  return pattern.test(
                    typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                  );
                }
              );
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle2.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf2(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function(selector) {
              var input = [], results = [], matcher = compile2(selector.replace(rtrim2, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle2(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || getText(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            "target": function(elem) {
              var hash = window3.location && window3.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            "enabled": createDisabledPseudo(false),
            "disabled": createDisabledPseudo(true),
            "checked": function(elem) {
              var nodeName2 = elem.nodeName.toLowerCase();
              return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            // Element/input types
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrim2, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                    if (skip && skip === elem.nodeName.toLowerCase()) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      uniqueCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle2(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? (
              // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
              postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              )
            ) : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf2(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i2 > 1 && elementMatcher(matchers),
                  i2 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                  ).replace(rtrim2, "$1"),
                  matcher,
                  i2 < j && matcherFromTokens(tokens.slice(i2, j)),
                  j < len && matcherFromTokens(tokens = tokens.slice(j)),
                  j < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile2 = Sizzle2.compile = function(selector, match) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i2 = match.length;
            while (i2--) {
              cached = matcherFromTokens(match[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle2.select = function(selector, context, results, seed) {
          var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find = Expr.find[type]) {
                if (seed = find(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile2(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        };
        support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support2.detectDuplicates = !!hasDuplicate;
        setDocument();
        support2.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        if (!assert(function(el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML2) {
            if (!isXML2) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support2.attributes || !assert(function(el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, _name, isXML2) {
            if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(el) {
          return el.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML2) {
            var val;
            if (!isXML2) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle2;
      }(window2)
    );
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir2, until) {
      var matched = [], truncate = until !== void 0;
      while ((elem = elem[dir2]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }
          matched.push(elem);
        }
      }
      return matched;
    };
    var siblings = function(n, elem) {
      var matched = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }
      return matched;
    };
    var rneedsContext = jQuery.expr.match.needsContext;
    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }
    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    function winnow(elements, qualifier, not) {
      if (isFunction2(qualifier)) {
        return jQuery.grep(elements, function(elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      }
      if (qualifier.nodeType) {
        return jQuery.grep(elements, function(elem) {
          return elem === qualifier !== not;
        });
      }
      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function(elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      }
      return jQuery.filter(qualifier, elements, not);
    }
    jQuery.filter = function(expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ":not(" + expr + ")";
      }
      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }
      return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
        return elem2.nodeType === 1;
      }));
    };
    jQuery.fn.extend({
      find: function(selector) {
        var i, ret, len = this.length, self2 = this;
        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function() {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self2[i], this)) {
                return true;
              }
            }
          }));
        }
        ret = this.pushStack([]);
        for (i = 0; i < len; i++) {
          jQuery.find(selector, self2[i], ret);
        }
        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function(selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function(selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function(selector) {
        return !!winnow(
          this,
          // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [],
          false
        ).length;
      }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
      var match, elem;
      if (!selector) {
        return this;
      }
      root = root || rootjQuery;
      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        }
        if (match && (match[1] || !context)) {
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            jQuery.merge(this, jQuery.parseHTML(
              match[1],
              context && context.nodeType ? context.ownerDocument || context : document2,
              true
            ));
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                if (isFunction2(this[match])) {
                  this[match](context[match]);
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;
          } else {
            elem = document2.getElementById(match[2]);
            if (elem) {
              this[0] = elem;
              this.length = 1;
            }
            return this;
          }
        } else if (!context || context.jquery) {
          return (context || root).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this;
      } else if (isFunction2(selector)) {
        return root.ready !== void 0 ? root.ready(selector) : (
          // Execute immediately if ready is not present
          selector(jQuery)
        );
      }
      return jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn;
    rootjQuery = jQuery(document2);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function(target) {
        var targets = jQuery(target, this), l = targets.length;
        return this.filter(function() {
          var i = 0;
          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function(selectors, context) {
        var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors)
              ))) {
                matched.push(cur);
                break;
              }
            }
          }
        }
        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function(elem) {
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        }
        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        }
        return indexOf.call(
          this,
          // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem
        );
      },
      add: function(selector, context) {
        return this.pushStack(
          jQuery.uniqueSort(
            jQuery.merge(this.get(), jQuery(selector, context))
          )
        );
      },
      addBack: function(selector) {
        return this.add(
          selector == null ? this.prevObject : this.prevObject.filter(selector)
        );
      }
    });
    function sibling(cur, dir2) {
      while ((cur = cur[dir2]) && cur.nodeType !== 1) {
      }
      return cur;
    }
    jQuery.each({
      parent: function(elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function(elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function(elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function(elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function(elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function(elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function(elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function(elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function(elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function(elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function(elem) {
        return siblings(elem.firstChild);
      },
      contents: function(elem) {
        if (elem.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto2(elem.contentDocument)) {
          return elem.contentDocument;
        }
        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }
        return jQuery.merge([], elem.childNodes);
      }
    }, function(name, fn) {
      jQuery.fn[name] = function(until, selector) {
        var matched = jQuery.map(this, fn, until);
        if (name.slice(-5) !== "Until") {
          selector = until;
        }
        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }
        if (this.length > 1) {
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          }
          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }
        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
        object[flag] = true;
      });
      return object;
    }
    jQuery.Callbacks = function(options) {
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
      var firing, memory, fired, locked, list = [], queue2 = [], firingIndex = -1, fire = function() {
        locked = locked || options.once;
        fired = firing = true;
        for (; queue2.length; firingIndex = -1) {
          memory = queue2.shift();
          while (++firingIndex < list.length) {
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              firingIndex = list.length;
              memory = false;
            }
          }
        }
        if (!options.memory) {
          memory = false;
        }
        firing = false;
        if (locked) {
          if (memory) {
            list = [];
          } else {
            list = "";
          }
        }
      }, self2 = {
        // Add a callback or a collection of callbacks to the list
        add: function() {
          if (list) {
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue2.push(memory);
            }
            (function add2(args) {
              jQuery.each(args, function(_, arg) {
                if (isFunction2(arg)) {
                  if (!options.unique || !self2.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  add2(arg);
                }
              });
            })(arguments);
            if (memory && !firing) {
              fire();
            }
          }
          return this;
        },
        // Remove a callback from the list
        remove: function() {
          jQuery.each(arguments, function(_, arg) {
            var index;
            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1);
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function(fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function() {
          if (list) {
            list = [];
          }
          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function() {
          locked = queue2 = [];
          list = memory = "";
          return this;
        },
        disabled: function() {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function() {
          locked = queue2 = [];
          if (!memory && !firing) {
            list = memory = "";
          }
          return this;
        },
        locked: function() {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function(context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue2.push(args);
            if (!firing) {
              fire();
            }
          }
          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function() {
          self2.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function() {
          return !!fired;
        }
      };
      return self2;
    };
    function Identity(v) {
      return v;
    }
    function Thrower(ex) {
      throw ex;
    }
    function adoptValue(value, resolve, reject, noValue) {
      var method;
      try {
        if (value && isFunction2(method = value.promise)) {
          method.call(value).done(resolve).fail(reject);
        } else if (value && isFunction2(method = value.then)) {
          method.call(value, resolve, reject);
        } else {
          resolve.apply(void 0, [value].slice(noValue));
        }
      } catch (value2) {
        reject.apply(void 0, [value2]);
      }
    }
    jQuery.extend({
      Deferred: function(func) {
        var tuples = [
          // action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          [
            "notify",
            "progress",
            jQuery.Callbacks("memory"),
            jQuery.Callbacks("memory"),
            2
          ],
          [
            "resolve",
            "done",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            0,
            "resolved"
          ],
          [
            "reject",
            "fail",
            jQuery.Callbacks("once memory"),
            jQuery.Callbacks("once memory"),
            1,
            "rejected"
          ]
        ], state = "pending", promise = {
          state: function() {
            return state;
          },
          always: function() {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function(fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function() {
            var fns = arguments;
            return jQuery.Deferred(function(newDefer) {
              jQuery.each(tuples, function(_i, tuple) {
                var fn = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                deferred[tuple[1]](function() {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && isFunction2(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](
                      this,
                      fn ? [returned] : arguments
                    );
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function(onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;
            function resolve(depth, deferred2, handler, special) {
              return function() {
                var that = this, args = arguments, mightThrow = function() {
                  var returned, then;
                  if (depth < maxDepth) {
                    return;
                  }
                  returned = handler.apply(that, args);
                  if (returned === deferred2.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  }
                  then = returned && // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  (typeof returned === "object" || typeof returned === "function") && returned.then;
                  if (isFunction2(then)) {
                    if (special) {
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special)
                      );
                    } else {
                      maxDepth++;
                      then.call(
                        returned,
                        resolve(maxDepth, deferred2, Identity, special),
                        resolve(maxDepth, deferred2, Thrower, special),
                        resolve(
                          maxDepth,
                          deferred2,
                          Identity,
                          deferred2.notifyWith
                        )
                      );
                    }
                  } else {
                    if (handler !== Identity) {
                      that = void 0;
                      args = [returned];
                    }
                    (special || deferred2.resolveWith)(that, args);
                  }
                }, process2 = special ? mightThrow : function() {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(
                        e,
                        process2.stackTrace
                      );
                    }
                    if (depth + 1 >= maxDepth) {
                      if (handler !== Thrower) {
                        that = void 0;
                        args = [e];
                      }
                      deferred2.rejectWith(that, args);
                    }
                  }
                };
                if (depth) {
                  process2();
                } else {
                  if (jQuery.Deferred.getStackHook) {
                    process2.stackTrace = jQuery.Deferred.getStackHook();
                  }
                  window2.setTimeout(process2);
                }
              };
            }
            return jQuery.Deferred(function(newDefer) {
              tuples[0][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onProgress) ? onProgress : Identity,
                  newDefer.notifyWith
                )
              );
              tuples[1][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onFulfilled) ? onFulfilled : Identity
                )
              );
              tuples[2][3].add(
                resolve(
                  0,
                  newDefer,
                  isFunction2(onRejected) ? onRejected : Thrower
                )
              );
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function(obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
        jQuery.each(tuples, function(i, tuple) {
          var list = tuple[2], stateString = tuple[5];
          promise[tuple[1]] = list.add;
          if (stateString) {
            list.add(
              function() {
                state = stateString;
              },
              // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable,
              // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable,
              // progress_callbacks.lock
              tuples[0][2].lock,
              // progress_handlers.lock
              tuples[0][3].lock
            );
          }
          list.add(tuple[3].fire);
          deferred[tuple[0]] = function() {
            deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
            return this;
          };
          deferred[tuple[0] + "With"] = list.fireWith;
        });
        promise.promise(deferred);
        if (func) {
          func.call(deferred, deferred);
        }
        return deferred;
      },
      // Deferred helper
      when: function(singleValue) {
        var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
          return function(value) {
            resolveContexts[i2] = this;
            resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
            if (!--remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        };
        if (remaining <= 1) {
          adoptValue(
            singleValue,
            primary.done(updateFunc(i)).resolve,
            primary.reject,
            !remaining
          );
          if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        }
        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }
        return primary.promise();
      }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack2) {
      if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
        window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack2);
      }
    };
    jQuery.readyException = function(error) {
      window2.setTimeout(function() {
        throw error;
      });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
      readyList.then(fn).catch(function(error) {
        jQuery.readyException(error);
      });
      return this;
    };
    jQuery.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See trac-6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function(wait) {
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        }
        jQuery.isReady = true;
        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        }
        readyList.resolveWith(document2, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then;
    function completed() {
      document2.removeEventListener("DOMContentLoaded", completed);
      window2.removeEventListener("load", completed);
      jQuery.ready();
    }
    if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
      window2.setTimeout(jQuery.ready);
    } else {
      document2.addEventListener("DOMContentLoaded", completed);
      window2.addEventListener("load", completed);
    }
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, len = elems.length, bulk = key == null;
      if (toType(key) === "object") {
        chainable = true;
        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        }
      } else if (value !== void 0) {
        chainable = true;
        if (!isFunction2(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, _key, value2) {
              return bulk.call(jQuery(elem), value2);
            };
          }
        }
        if (fn) {
          for (; i < len; i++) {
            fn(
              elems[i],
              key,
              raw ? value : value.call(elems[i], i, fn(elems[i], key))
            );
          }
        }
      }
      if (chainable) {
        return elems;
      }
      if (bulk) {
        return fn.call(elems);
      }
      return len ? fn(elems[0], key) : emptyGet;
    };
    var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }
    var acceptData = function(owner) {
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };
    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }
    Data.uid = 1;
    Data.prototype = {
      cache: function(owner) {
        var value = owner[this.expando];
        if (!value) {
          value = {};
          if (acceptData(owner)) {
            if (owner.nodeType) {
              owner[this.expando] = value;
            } else {
              Object.defineProperty(owner, this.expando, {
                value,
                configurable: true
              });
            }
          }
        }
        return value;
      },
      set: function(owner, data, value) {
        var prop, cache = this.cache(owner);
        if (typeof data === "string") {
          cache[camelCase(data)] = value;
        } else {
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }
        return cache;
      },
      get: function(owner, key) {
        return key === void 0 ? this.cache(owner) : (
          // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)]
        );
      },
      access: function(owner, key, value) {
        if (key === void 0 || key && typeof key === "string" && value === void 0) {
          return this.get(owner, key);
        }
        this.set(owner, key, value);
        return value !== void 0 ? value : key;
      },
      remove: function(owner, key) {
        var i, cache = owner[this.expando];
        if (cache === void 0) {
          return;
        }
        if (key !== void 0) {
          if (Array.isArray(key)) {
            key = key.map(camelCase);
          } else {
            key = camelCase(key);
            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }
          i = key.length;
          while (i--) {
            delete cache[key[i]];
          }
        }
        if (key === void 0 || jQuery.isEmptyObject(cache)) {
          if (owner.nodeType) {
            owner[this.expando] = void 0;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function(owner) {
        var cache = owner[this.expando];
        return cache !== void 0 && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data();
    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    function getData(data) {
      if (data === "true") {
        return true;
      }
      if (data === "false") {
        return false;
      }
      if (data === "null") {
        return null;
      }
      if (data === +data + "") {
        return +data;
      }
      if (rbrace.test(data)) {
        return JSON.parse(data);
      }
      return data;
    }
    function dataAttr(elem, key, data) {
      var name;
      if (data === void 0 && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);
        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {
          }
          dataUser.set(elem, key, data);
        } else {
          data = void 0;
        }
      }
      return data;
    }
    jQuery.extend({
      hasData: function(elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function(elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function(elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function(elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function(elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function(key, value) {
        var i, name, data, elem = this[0], attrs = elem && elem.attributes;
        if (key === void 0) {
          if (this.length) {
            data = dataUser.get(elem);
            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;
              while (i--) {
                if (attrs[i]) {
                  name = attrs[i].name;
                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }
              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }
          return data;
        }
        if (typeof key === "object") {
          return this.each(function() {
            dataUser.set(this, key);
          });
        }
        return access(this, function(value2) {
          var data2;
          if (elem && value2 === void 0) {
            data2 = dataUser.get(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            data2 = dataAttr(elem, key);
            if (data2 !== void 0) {
              return data2;
            }
            return;
          }
          this.each(function() {
            dataUser.set(this, key, value2);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function(key) {
        return this.each(function() {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function(elem, type, data) {
        var queue2;
        if (elem) {
          type = (type || "fx") + "queue";
          queue2 = dataPriv.get(elem, type);
          if (data) {
            if (!queue2 || Array.isArray(data)) {
              queue2 = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue2.push(data);
            }
          }
          return queue2 || [];
        }
      },
      dequeue: function(elem, type) {
        type = type || "fx";
        var queue2 = jQuery.queue(elem, type), startLength = queue2.length, fn = queue2.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
          jQuery.dequeue(elem, type);
        };
        if (fn === "inprogress") {
          fn = queue2.shift();
          startLength--;
        }
        if (fn) {
          if (type === "fx") {
            queue2.unshift("inprogress");
          }
          delete hooks.stop;
          fn.call(elem, next, hooks);
        }
        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function(elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function() {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function(type, data) {
        var setter = 2;
        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }
        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }
        return data === void 0 ? this : this.each(function() {
          var queue2 = jQuery.queue(this, type, data);
          jQuery._queueHooks(this, type);
          if (type === "fx" && queue2[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function(type) {
        return this.each(function() {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function(type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function(type, obj) {
        var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
        if (typeof type !== "string") {
          obj = type;
          type = void 0;
        }
        type = type || "fx";
        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");
          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }
        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document2.documentElement;
    var isAttached = function(elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    }, composed = { composed: true };
    if (documentElement.getRootNode) {
      isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }
    var isHiddenWithinTree = function(elem, el) {
      elem = el || elem;
      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached(elem) && jQuery.css(elem, "display") === "none";
    };
    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
        return tween.cur();
      } : function() {
        return jQuery.css(elem, prop, "");
      }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
      if (initialInUnit && initialInUnit[3] !== unit) {
        initial = initial / 2;
        unit = unit || initialInUnit[3];
        initialInUnit = +initial || 1;
        while (maxIterations--) {
          jQuery.style(elem, prop, initialInUnit + unit);
          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }
          initialInUnit = initialInUnit / scale;
        }
        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit);
        valueParts = valueParts || [];
      }
      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0;
        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }
      return adjusted;
    }
    var defaultDisplayMap = {};
    function getDefaultDisplay(elem) {
      var temp, doc2 = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
      if (display) {
        return display;
      }
      temp = doc2.body.appendChild(doc2.createElement(nodeName2));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);
      if (display === "none") {
        display = "block";
      }
      defaultDisplayMap[nodeName2] = display;
      return display;
    }
    function showHide(elements, show) {
      var display, elem, values = [], index = 0, length = elements.length;
      for (; index < length; index++) {
        elem = elements[index];
        if (!elem.style) {
          continue;
        }
        display = elem.style.display;
        if (show) {
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;
            if (!values[index]) {
              elem.style.display = "";
            }
          }
          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none";
            dataPriv.set(elem, "display", display);
          }
        }
      }
      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }
      return elements;
    }
    jQuery.fn.extend({
      show: function() {
        return showHide(this, true);
      },
      hide: function() {
        return showHide(this);
      },
      toggle: function(state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }
        return this.each(function() {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
    (function() {
      var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input);
      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })();
    var wrapMap = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;
    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }
    function getAll(context, tag) {
      var ret;
      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }
      if (tag === void 0 || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }
      return ret;
    }
    function setGlobalEval(elems, refElements) {
      var i = 0, l = elems.length;
      for (; i < l; i++) {
        dataPriv.set(
          elems[i],
          "globalEval",
          !refElements || dataPriv.get(refElements[i], "globalEval")
        );
      }
    }
    var rhtml = /<|&#?\w+;/;
    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          if (toType(elem) === "object") {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div"));
            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp = fragment.firstChild;
            tmp.textContent = "";
          }
        }
      }
      fragment.textContent = "";
      i = 0;
      while (elem = nodes[i++]) {
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }
          continue;
        }
        attached = isAttached(elem);
        tmp = getAll(fragment.appendChild(elem), "script");
        if (attached) {
          setGlobalEval(tmp);
        }
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }
      return fragment;
    }
    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    function returnTrue() {
      return true;
    }
    function returnFalse() {
      return false;
    }
    function expectSync(elem, type) {
      return elem === safeActiveElement() === (type === "focus");
    }
    function safeActiveElement() {
      try {
        return document2.activeElement;
      } catch (err) {
      }
    }
    function on(elem, types, selector, data, fn, one) {
      var origFn, type;
      if (typeof types === "object") {
        if (typeof selector !== "string") {
          data = data || selector;
          selector = void 0;
        }
        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }
        return elem;
      }
      if (data == null && fn == null) {
        fn = selector;
        data = selector = void 0;
      } else if (fn == null) {
        if (typeof selector === "string") {
          fn = data;
          data = void 0;
        } else {
          fn = data;
          data = selector;
          selector = void 0;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }
      if (one === 1) {
        origFn = fn;
        fn = function(event) {
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return elem.each(function() {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    jQuery.event = {
      global: {},
      add: function(elem, types, handler, data, selector) {
        var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
        if (!acceptData(elem)) {
          return;
        }
        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        }
        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        }
        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        }
        if (!(events = elemData.events)) {
          events = elemData.events = /* @__PURE__ */ Object.create(null);
        }
        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function(e) {
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
          };
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          special = jQuery.event.special[type] || {};
          handleObj = jQuery.extend({
            type,
            origType,
            data,
            handler,
            guid: handler.guid,
            selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn);
          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0;
            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }
          if (special.add) {
            special.add.call(elem, handleObj);
            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          }
          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          }
          jQuery.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function(elem, types, handler, selector, mappedTypes) {
        var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
        if (!elemData || !(events = elemData.events)) {
          return;
        }
        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;
        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort();
          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }
            continue;
          }
          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
          origCount = j = handlers.length;
          while (j--) {
            handleObj = handlers[j];
            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);
              if (handleObj.selector) {
                handlers.delegateCount--;
              }
              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          }
          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }
            delete events[type];
          }
        }
        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function(nativeEvent) {
        var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
        args[0] = event;
        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        event.delegateTarget = this;
        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        }
        handlerQueue = jQuery.event.handlers.call(this, event, handlers);
        i = 0;
        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;
          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
              if (ret !== void 0) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        }
        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }
        return event.result;
      },
      handlers: function(event, handlers) {
        var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};
              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i];
                sel = handleObj.selector + " ";
                if (matchedSelectors[sel] === void 0) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }
                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }
              if (matchedHandlers.length) {
                handlerQueue.push({ elem: cur, handlers: matchedHandlers });
              }
            }
          }
        }
        cur = this;
        if (delegateCount < handlers.length) {
          handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
        }
        return handlerQueue;
      },
      addProp: function(name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction2(hook) ? function() {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function() {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function(value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value
            });
          }
        });
      },
      fix: function(originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click", returnTrue);
            }
            return false;
          },
          trigger: function(data) {
            var el = this || data;
            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            }
            return true;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function(event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function(event) {
            if (event.result !== void 0 && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    };
    function leverageNative(el, type, expectSync2) {
      if (!expectSync2) {
        if (dataPriv.get(el, type) === void 0) {
          jQuery.event.add(el, type, returnTrue);
        }
        return;
      }
      dataPriv.set(el, type, false);
      jQuery.event.add(el, type, {
        namespace: false,
        handler: function(event) {
          var notAsync, result, saved = dataPriv.get(this, type);
          if (event.isTrigger & 1 && this[type]) {
            if (!saved.length) {
              saved = slice.call(arguments);
              dataPriv.set(this, type, saved);
              notAsync = expectSync2(this, type);
              this[type]();
              result = dataPriv.get(this, type);
              if (saved !== result || notAsync) {
                dataPriv.set(this, type, false);
              } else {
                result = {};
              }
              if (saved !== result) {
                event.stopImmediatePropagation();
                event.preventDefault();
                return result && result.value;
              }
            } else if ((jQuery.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            }
          } else if (saved.length) {
            dataPriv.set(this, type, {
              value: jQuery.event.trigger(
                // Support: IE <=9 - 11+
                // Extend with the prototype to reset the above stopImmediatePropagation()
                jQuery.extend(saved[0], jQuery.Event.prototype),
                saved.slice(1),
                this
              )
            });
            event.stopImmediatePropagation();
          }
        }
      });
    }
    jQuery.removeEvent = function(elem, type, handle) {
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };
    jQuery.Event = function(src, props) {
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      }
      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type;
        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse;
        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget;
      } else {
        this.type = src;
      }
      if (props) {
        jQuery.extend(this, props);
      }
      this.timeStamp = src && src.timeStamp || Date.now();
      this[jQuery.expando] = true;
    };
    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function() {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;
        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function() {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function() {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;
        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }
        this.stopPropagation();
      }
    };
    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);
    jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
      jQuery.event.special[type] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function() {
          leverageNative(this, type, expectSync);
          return false;
        },
        trigger: function() {
          leverageNative(this, type);
          return true;
        },
        // Suppress native focus or blur if we're currently inside
        // a leveraged native-event stack
        _default: function(event) {
          return dataPriv.get(event.target, type);
        },
        delegateType
      };
    });
    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function(orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function(event) {
          var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }
          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function(types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function(types, selector, fn) {
        var handleObj, type;
        if (types && types.preventDefault && types.handleObj) {
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(
            handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
            handleObj.selector,
            handleObj.handler
          );
          return this;
        }
        if (typeof types === "object") {
          for (type in types) {
            this.off(type, selector, types[type]);
          }
          return this;
        }
        if (selector === false || typeof selector === "function") {
          fn = selector;
          selector = void 0;
        }
        if (fn === false) {
          fn = returnFalse;
        }
        return this.each(function() {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }
      return elem;
    }
    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }
    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }
      return elem;
    }
    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;
      if (dest.nodeType !== 1) {
        return;
      }
      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;
        if (events) {
          dataPriv.remove(dest, "handle events");
          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      }
      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    }
    function fixInput(src, dest) {
      var nodeName2 = dest.nodeName.toLowerCase();
      if (nodeName2 === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked;
      } else if (nodeName2 === "input" || nodeName2 === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }
    function domManip(collection, args, callback, ignored) {
      args = flat(args);
      var fragment, first, scripts, hasScripts, node, doc2, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction2(value);
      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function(index) {
          var self2 = collection.eq(index);
          if (valueIsFunction) {
            args[0] = value.call(this, index, self2.html());
          }
          domManip(self2, args, callback, ignored);
        });
      }
      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length;
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }
            callback.call(collection[i], node, i);
          }
          if (hasScripts) {
            doc2 = scripts[scripts.length - 1].ownerDocument;
            jQuery.map(scripts, restoreScript);
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc2, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  if (jQuery._evalUrl && !node.noModule) {
                    jQuery._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc2);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc2);
                }
              }
            }
          }
        }
      }
      return collection;
    }
    function remove2(elem, selector, keepData) {
      var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }
        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }
          node.parentNode.removeChild(node);
        }
      }
      return elem;
    }
    jQuery.extend({
      htmlPrefilter: function(html) {
        return html;
      },
      clone: function(elem, dataAndEvents, deepDataAndEvents) {
        var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          destElements = getAll(clone);
          srcElements = getAll(elem);
          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        }
        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);
            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        }
        destElements = getAll(clone, "script");
        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        }
        return clone;
      },
      cleanData: function(elems) {
        var data, elem, type, special = jQuery.event.special, i = 0;
        for (; (elem = elems[i]) !== void 0; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type);
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              }
              elem[dataPriv.expando] = void 0;
            }
            if (elem[dataUser.expando]) {
              elem[dataUser.expando] = void 0;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function(selector) {
        return remove2(this, selector, true);
      },
      remove: function(selector) {
        return remove2(this, selector);
      },
      text: function(value) {
        return access(this, function(value2) {
          return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value2;
            }
          });
        }, null, value, arguments.length);
      },
      append: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function() {
        return domManip(this, arguments, function(elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function() {
        return domManip(this, arguments, function(elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function() {
        var elem, i = 0;
        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            jQuery.cleanData(getAll(elem, false));
            elem.textContent = "";
          }
        }
        return this;
      },
      clone: function(dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function() {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function(value) {
        return access(this, function(value2) {
          var elem = this[0] || {}, i = 0, l = this.length;
          if (value2 === void 0 && elem.nodeType === 1) {
            return elem.innerHTML;
          }
          if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
            value2 = jQuery.htmlPrefilter(value2);
            try {
              for (; i < l; i++) {
                elem = this[i] || {};
                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value2;
                }
              }
              elem = 0;
            } catch (e) {
            }
          }
          if (elem) {
            this.empty().append(value2);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function() {
        var ignored = [];
        return domManip(this, arguments, function(elem) {
          var parent = this.parentNode;
          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));
            if (parent) {
              parent.replaceChild(elem, this);
            }
          }
        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function(name, original) {
      jQuery.fn[name] = function(selector) {
        var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems);
          push.apply(ret, elems.get());
        }
        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
    var rcustomProp = /^--/;
    var getStyles = function(elem) {
      var view = elem.ownerDocument.defaultView;
      if (!view || !view.opener) {
        view = window2;
      }
      return view.getComputedStyle(elem);
    };
    var swap = function(elem, options, callback) {
      var ret, name, old = {};
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.call(elem);
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    };
    var rboxStyle = new RegExp(cssExpand.join("|"), "i");
    var whitespace = "[\\x20\\t\\r\\n\\f]";
    var rtrimCSS = new RegExp(
      "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
      "g"
    );
    (function() {
      function computeStyleTests() {
        if (!div) {
          return;
        }
        container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window2.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%";
        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container);
        div = null;
      }
      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }
      var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
      if (!div.style) {
        return;
      }
      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function() {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function() {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function() {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function() {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function() {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function() {
          var table, tr, trChild, trStyle;
          if (reliableTrDimensionsVal == null) {
            table = document2.createElement("table");
            tr = document2.createElement("tr");
            trChild = document2.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid";
            tr.style.height = "1px";
            trChild.style.height = "9px";
            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window2.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }
          return reliableTrDimensionsVal;
        }
      });
    })();
    function curCSS(elem, name, computed2) {
      var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
      computed2 = computed2 || getStyles(elem);
      if (computed2) {
        ret = computed2.getPropertyValue(name) || computed2[name];
        if (isCustomProp && ret) {
          ret = ret.replace(rtrimCSS, "$1") || void 0;
        }
        if (ret === "" && !isAttached(elem)) {
          ret = jQuery.style(elem, name);
        }
        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed2.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret !== void 0 ? (
        // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + ""
      ) : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
      return {
        get: function() {
          if (conditionFn()) {
            delete this.get;
            return;
          }
          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }
    var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
    function vendorPropName(name) {
      var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
      while (i--) {
        name = cssPrefixes[i] + capName;
        if (name in emptyStyle) {
          return name;
        }
      }
    }
    function finalPropName(name) {
      var final = jQuery.cssProps[name] || vendorProps[name];
      if (final) {
        return final;
      }
      if (name in emptyStyle) {
        return name;
      }
      return vendorProps[name] = vendorPropName(name) || name;
    }
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };
    function setPositiveNumber(_elem, value, subtract) {
      var matches = rcssNum.exec(value);
      return matches ? (
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
      ) : value;
    }
    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }
      for (; i < 4; i += 2) {
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
        }
        if (!isBorderBox) {
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        } else {
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          }
          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      }
      if (!isBorderBox && computedVal >= 0) {
        delta += Math.max(0, Math.ceil(
          elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
          // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }
      return delta;
    }
    function getWidthOrHeight(elem, dimension, extra) {
      var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }
        val = "auto";
      }
      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
      elem.getClientRects().length) {
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
        valueIsBorderBox = offsetProp in elem;
        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      }
      val = parseFloat(val) || 0;
      return val + boxModelAdjustment(
        elem,
        dimension,
        extra || (isBorderBox ? "border" : "content"),
        valueIsBorderBox,
        styles,
        // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val
      ) + "px";
    }
    jQuery.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function(elem, computed2) {
            if (computed2) {
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function(elem, name, value, extra) {
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        }
        var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (value !== void 0) {
          type = typeof value;
          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret);
            type = "number";
          }
          if (value == null || value !== value) {
            return;
          }
          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          }
          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          }
          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
            return ret;
          }
          return style[name];
        }
      },
      css: function(elem, name, extra, styles) {
        var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
        if (!isCustomProp) {
          name = finalPropName(origName);
        }
        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        }
        if (val === void 0) {
          val = curCSS(elem, name, styles);
        }
        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        }
        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }
        return val;
      }
    });
    jQuery.each(["height", "width"], function(_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function(elem, computed2, extra) {
          if (computed2) {
            return rdisplayswap.test(jQuery.css(elem, "display")) && // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function(elem, value, extra) {
          var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(
            elem,
            dimension,
            extra,
            isBorderBox,
            styles
          ) : 0;
          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(
              elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5
            );
          }
          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }
          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(
      support.reliableMarginLeft,
      function(elem, computed2) {
        if (computed2) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }
    );
    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function(prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function(value) {
          var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }
          return expanded;
        }
      };
      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function(name, value) {
        return access(this, function(elem, name2, value2) {
          var styles, len, map2 = {}, i = 0;
          if (Array.isArray(name2)) {
            styles = getStyles(elem);
            len = name2.length;
            for (; i < len; i++) {
              map2[name2[i]] = jQuery.css(elem, name2[i], false, styles);
            }
            return map2;
          }
          return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
        }, name, value, arguments.length > 1);
      }
    });
    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function(elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function() {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function(percent) {
        var eased, hooks = Tween.propHooks[this.prop];
        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](
            percent,
            this.options.duration * percent,
            0,
            1,
            this.options.duration
          );
        } else {
          this.pos = eased = percent;
        }
        this.now = (this.end - this.start) * eased + this.start;
        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }
        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }
        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function(tween) {
          var result;
          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          }
          result = jQuery.css(tween.elem, tween.prop, "");
          return !result || result === "auto" ? 0 : result;
        },
        set: function(tween) {
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    };
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function(tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function(p2) {
        return p2;
      },
      swing: function(p2) {
        return 0.5 - Math.cos(p2 * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init;
    jQuery.fx.step = {};
    var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    function schedule() {
      if (inProgress) {
        if (document2.hidden === false && window2.requestAnimationFrame) {
          window2.requestAnimationFrame(schedule);
        } else {
          window2.setTimeout(schedule, jQuery.fx.interval);
        }
        jQuery.fx.tick();
      }
    }
    function createFxNow() {
      window2.setTimeout(function() {
        fxNow = void 0;
      });
      return fxNow = Date.now();
    }
    function genFx(type, includeWidth) {
      var which, i = 0, attrs = { height: type };
      includeWidth = includeWidth ? 1 : 0;
      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }
      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }
      return attrs;
    }
    function createTween(value, prop, animation) {
      var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          return tween;
        }
      }
    }
    function defaultPrefilter(elem, props, opts) {
      var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");
        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;
          hooks.empty.fire = function() {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }
        hooks.unqueued++;
        anim.always(function() {
          anim.always(function() {
            hooks.unqueued--;
            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      }
      for (prop in props) {
        value = props[prop];
        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";
          if (value === (hidden ? "hide" : "show")) {
            if (value === "show" && dataShow && dataShow[prop] !== void 0) {
              hidden = true;
            } else {
              continue;
            }
          }
          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      }
      propTween = !jQuery.isEmptyObject(props);
      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      }
      if (isBox && elem.nodeType === 1) {
        opts.overflow = [style.overflow, style.overflowX, style.overflowY];
        restoreDisplay = dataShow && dataShow.display;
        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }
        display = jQuery.css(elem, "display");
        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        }
        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            if (!propTween) {
              anim.done(function() {
                style.display = restoreDisplay;
              });
              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }
            style.display = "inline-block";
          }
        }
      }
      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
      propTween = false;
      for (prop in orig) {
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
          }
          if (toggle) {
            dataShow.hidden = !hidden;
          }
          if (hidden) {
            showHide([elem], true);
          }
          anim.done(function() {
            if (!hidden) {
              showHide([elem]);
            }
            dataPriv.remove(elem, "fxshow");
            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        }
        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;
          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }
    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks;
      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];
        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }
        if (index !== name) {
          props[name] = value;
          delete props[index];
        }
        hooks = jQuery.cssHooks[name];
        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name];
          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }
    function Animation(elem, properties, options) {
      var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
        delete tick.elem;
      }), tick = function() {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
        for (; index2 < length2; index2++) {
          animation.tweens[index2].run(percent);
        }
        deferred.notifyWith(elem, [animation, percent, remaining]);
        if (percent < 1 && length2) {
          return remaining;
        }
        if (!length2) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        }
        deferred.resolveWith(elem, [animation]);
        return false;
      }, animation = deferred.promise({
        elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function(prop, end) {
          var tween = jQuery.Tween(
            elem,
            animation.opts,
            prop,
            end,
            animation.opts.specialEasing[prop] || animation.opts.easing
          );
          animation.tweens.push(tween);
          return tween;
        },
        stop: function(gotoEnd) {
          var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(1);
          }
          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }
          return this;
        }
      }), props = animation.props;
      propFilter(props, animation.opts.specialEasing);
      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
        if (result) {
          if (isFunction2(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }
          return result;
        }
      }
      jQuery.map(props, createTween, animation);
      if (isFunction2(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      }
      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(
        jQuery.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        })
      );
      return animation;
    }
    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function(prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function(props, callback) {
        if (isFunction2(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }
        var prop, index = 0, length = props.length;
        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function(callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });
    jQuery.speed = function(speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction2(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction2(easing) && easing
      };
      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      }
      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      }
      opt.old = opt.complete;
      opt.complete = function() {
        if (isFunction2(opt.old)) {
          opt.old.call(this);
        }
        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };
      return opt;
    };
    jQuery.fn.extend({
      fadeTo: function(speed, to, easing, callback) {
        return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
      },
      animate: function(prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };
        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function(type, clearQueue, gotoEnd) {
        var stopQueue = function(hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };
        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = void 0;
        }
        if (clearQueue) {
          this.queue(type || "fx", []);
        }
        return this.each(function() {
          var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          }
          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function(type) {
        if (type !== false) {
          type = type || "fx";
        }
        return this.each(function() {
          var index, data = dataPriv.get(this), queue2 = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue2 ? queue2.length : 0;
          data.finish = true;
          jQuery.queue(this, type, []);
          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          }
          for (index = timers.length; index--; ) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          }
          for (index = 0; index < length; index++) {
            if (queue2[index] && queue2[index].finish) {
              queue2[index].finish.call(this);
            }
          }
          delete data.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function(_i, name) {
      var cssFn = jQuery.fn[name];
      jQuery.fn[name] = function(speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    });
    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: { opacity: "show" },
      fadeOut: { opacity: "hide" },
      fadeToggle: { opacity: "toggle" }
    }, function(name, props) {
      jQuery.fn[name] = function(speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];
    jQuery.fx.tick = function() {
      var timer, i = 0, timers = jQuery.timers;
      fxNow = Date.now();
      for (; i < timers.length; i++) {
        timer = timers[i];
        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }
      if (!timers.length) {
        jQuery.fx.stop();
      }
      fxNow = void 0;
    };
    jQuery.fx.timer = function(timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };
    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
      if (inProgress) {
        return;
      }
      inProgress = true;
      schedule();
    };
    jQuery.fx.stop = function() {
      inProgress = null;
    };
    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    };
    jQuery.fn.delay = function(time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function(next, hooks) {
        var timeout = window2.setTimeout(next, time);
        hooks.stop = function() {
          window2.clearTimeout(timeout);
        };
      });
    };
    (function() {
      var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
      input.type = "checkbox";
      support.checkOn = input.value !== "";
      support.optSelected = opt.selected;
      input = document2.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function(name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function(name) {
        return this.each(function() {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
        }
        if (value !== void 0) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          elem.setAttribute(name, value + "");
          return value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        ret = jQuery.find.attr(elem, name);
        return ret == null ? void 0 : ret;
      },
      attrHooks: {
        type: {
          set: function(elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);
              if (val) {
                elem.value = val;
              }
              return value;
            }
          }
        }
      },
      removeAttr: function(elem, value) {
        var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    });
    boolHook = {
      set: function(elem, value, name) {
        if (value === false) {
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }
        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;
      attrHandle[name] = function(elem, name2, isXML) {
        var ret, handle, lowercaseName = name2.toLowerCase();
        if (!isXML) {
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }
        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function(name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function(name) {
        return this.each(function() {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function(elem, name, value) {
        var ret, hooks, nType = elem.nodeType;
        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }
        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }
        if (value !== void 0) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
            return ret;
          }
          return elem[name] = value;
        }
        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }
        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function(elem) {
            var tabindex = jQuery.find.attr(elem, "tabindex");
            if (tabindex) {
              return parseInt(tabindex, 10);
            }
            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }
            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    });
    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function(elem) {
          var parent = elem.parentNode;
          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
          return null;
        },
        set: function(elem) {
          var parent = elem.parentNode;
          if (parent) {
            parent.selectedIndex;
            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }
    jQuery.each([
      "tabIndex",
      "readOnly",
      "maxLength",
      "cellSpacing",
      "cellPadding",
      "rowSpan",
      "colSpan",
      "useMap",
      "frameBorder",
      "contentEditable"
    ], function() {
      jQuery.propFix[this.toLowerCase()] = this;
    });
    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }
    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }
      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }
      return [];
    }
    jQuery.fn.extend({
      addClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (cur.indexOf(" " + className + " ") < 0) {
                  cur += className + " ";
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      removeClass: function(value) {
        var classNames, cur, curValue, className, i, finalValue;
        if (isFunction2(value)) {
          return this.each(function(j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }
        if (!arguments.length) {
          return this.attr("class", "");
        }
        classNames = classesToArray(value);
        if (classNames.length) {
          return this.each(function() {
            curValue = getClass(this);
            cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
            if (cur) {
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                while (cur.indexOf(" " + className + " ") > -1) {
                  cur = cur.replace(" " + className + " ", " ");
                }
              }
              finalValue = stripAndCollapse(cur);
              if (curValue !== finalValue) {
                this.setAttribute("class", finalValue);
              }
            }
          });
        }
        return this;
      },
      toggleClass: function(value, stateVal) {
        var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
        if (isFunction2(value)) {
          return this.each(function(i2) {
            jQuery(this).toggleClass(
              value.call(this, i2, getClass(this), stateVal),
              stateVal
            );
          });
        }
        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }
        classNames = classesToArray(value);
        return this.each(function() {
          if (isValidValue) {
            self2 = jQuery(this);
            for (i = 0; i < classNames.length; i++) {
              className = classNames[i];
              if (self2.hasClass(className)) {
                self2.removeClass(className);
              } else {
                self2.addClass(className);
              }
            }
          } else if (value === void 0 || type === "boolean") {
            className = getClass(this);
            if (className) {
              dataPriv.set(this, "__className__", className);
            }
            if (this.setAttribute) {
              this.setAttribute(
                "class",
                className || value === false ? "" : dataPriv.get(this, "__className__") || ""
              );
            }
          }
        });
      },
      hasClass: function(selector) {
        var className, elem, i = 0;
        className = " " + selector + " ";
        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }
        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function(value) {
        var hooks, ret, valueIsFunction, elem = this[0];
        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
              return ret;
            }
            ret = elem.value;
            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            }
            return ret == null ? "" : ret;
          }
          return;
        }
        valueIsFunction = isFunction2(value);
        return this.each(function(i) {
          var val;
          if (this.nodeType !== 1) {
            return;
          }
          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          }
          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function(value2) {
              return value2 == null ? "" : value2 + "";
            });
          }
          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function(elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : (
              // Support: IE <=10 - 11 only
              // option.text throws exceptions (trac-14686, trac-14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem))
            );
          }
        },
        select: {
          get: function(elem) {
            var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            }
            for (; i < max; i++) {
              option = options[i];
              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                value = jQuery(option).val();
                if (one) {
                  return value;
                }
                values.push(value);
              }
            }
            return values;
          },
          set: function(elem, value) {
            var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
            while (i--) {
              option = options[i];
              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
            }
            if (!optionSet) {
              elem.selectedIndex = -1;
            }
            return values;
          }
        }
      }
    });
    jQuery.each(["radio", "checkbox"], function() {
      jQuery.valHooks[this] = {
        set: function(elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };
      if (!support.checkOn) {
        jQuery.valHooks[this].get = function(elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    });
    support.focusin = "onfocusin" in window2;
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
      e.stopPropagation();
    };
    jQuery.extend(jQuery.event, {
      trigger: function(event, data, elem, onlyHandlers) {
        var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn2.call(event, "type") ? event.type : event, namespaces = hasOwn2.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document2;
        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        }
        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }
        if (type.indexOf(".") > -1) {
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }
        ontype = type.indexOf(":") < 0 && "on" + type;
        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
        event.result = void 0;
        if (!event.target) {
          event.target = elem;
        }
        data = data == null ? [event] : jQuery.makeArray(data, [event]);
        special = jQuery.event.special[type] || {};
        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        }
        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;
          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }
          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          }
          if (tmp === (elem.ownerDocument || document2)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
          }
        }
        i = 0;
        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type;
          handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
          if (handle) {
            handle.apply(cur, data);
          }
          handle = ontype && cur[ontype];
          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);
            if (event.result === false) {
              event.preventDefault();
            }
          }
        }
        event.type = type;
        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
              tmp = elem[ontype];
              if (tmp) {
                elem[ontype] = null;
              }
              jQuery.event.triggered = type;
              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }
              elem[type]();
              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }
              jQuery.event.triggered = void 0;
              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }
        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function(type, elem, event) {
        var e = jQuery.extend(
          new jQuery.Event(),
          event,
          {
            type,
            isSimulated: true
          }
        );
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function(type, data) {
        return this.each(function() {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function(type, data) {
        var elem = this[0];
        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    });
    if (!support.focusin) {
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
        var handler = function(event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
          setup: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix);
            if (!attaches) {
              doc2.addEventListener(orig, handler, true);
            }
            dataPriv.access(doc2, fix, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc2 = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc2, fix) - 1;
            if (!attaches) {
              doc2.removeEventListener(orig, handler, true);
              dataPriv.remove(doc2, fix);
            } else {
              dataPriv.access(doc2, fix, attaches);
            }
          }
        };
      });
    }
    var location = window2.location;
    var nonce = { guid: Date.now() };
    var rquery = /\?/;
    jQuery.parseXML = function(data) {
      var xml, parserErrorElem;
      if (!data || typeof data !== "string") {
        return null;
      }
      try {
        xml = new window2.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {
      }
      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
      if (!xml || parserErrorElem) {
        jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
          return el.textContent;
        }).join("\n") : data));
      }
      return xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    function buildParams(prefix, obj, traditional, add2) {
      var name;
      if (Array.isArray(obj)) {
        jQuery.each(obj, function(i, v) {
          if (traditional || rbracket.test(prefix)) {
            add2(prefix, v);
          } else {
            buildParams(
              prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
              v,
              traditional,
              add2
            );
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add2);
        }
      } else {
        add2(prefix, obj);
      }
    }
    jQuery.param = function(a, traditional) {
      var prefix, s = [], add2 = function(key, valueOrFunction) {
        var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };
      if (a == null) {
        return "";
      }
      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        jQuery.each(a, function() {
          add2(this.name, this.value);
        });
      } else {
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add2);
        }
      }
      return s.join("&");
    };
    jQuery.fn.extend({
      serialize: function() {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function() {
        return this.map(function() {
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function() {
          var type = this.type;
          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function(_i, elem) {
          var val = jQuery(this).val();
          if (val == null) {
            return null;
          }
          if (Array.isArray(val)) {
            return jQuery.map(val, function(val2) {
              return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
            });
          }
          return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
        }).get();
      }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
    originAnchor.href = location.href;
    function addToPrefiltersOrTransports(structure) {
      return function(dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }
        var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
        if (isFunction2(func)) {
          while (dataType = dataTypes[i++]) {
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func);
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {}, seekingTransport = structure === transports;
      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }
      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
      var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
      for (key in src) {
        if (src[key] !== void 0) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }
      if (deep) {
        jQuery.extend(true, target, deep);
      }
      return target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
      while (dataTypes[0] === "*") {
        dataTypes.shift();
        if (ct === void 0) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      }
      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      }
      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }
          if (!firstDataType) {
            firstDataType = type;
          }
        }
        finalDataType = finalDataType || firstDataType;
      }
      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }
        return responses[finalDataType];
      }
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }
      current = dataTypes.shift();
      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        }
        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }
        prev = current;
        current = dataTypes.shift();
        if (current) {
          if (current === "*") {
            current = prev;
          } else if (prev !== "*" && prev !== current) {
            conv = converters[prev + " " + current] || converters["* " + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(" ");
                if (tmp[1] === current) {
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }
      return { state: "success", data: response };
    }
    jQuery.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",
        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function(target, settings) {
        return settings ? (
          // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings)
        ) : (
          // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target)
        );
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function(url, options) {
        if (typeof url === "object") {
          options = url;
          url = void 0;
        }
        options = options || {};
        var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function(key) {
            var match;
            if (completed2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                }
              }
              match = responseHeaders[key.toLowerCase() + " "];
            }
            return match == null ? null : match.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function() {
            return completed2 ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function(name, value) {
            if (completed2 == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function(type) {
            if (completed2 == null) {
              s.mimeType = type;
            }
            return this;
          },
          // Status-dependent callbacks
          statusCode: function(map2) {
            var code;
            if (map2) {
              if (completed2) {
                jqXHR.always(map2[jqXHR.status]);
              } else {
                for (code in map2) {
                  statusCode[code] = [statusCode[code], map2[code]];
                }
              }
            }
            return this;
          },
          // Cancel the request
          abort: function(statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
        deferred.promise(jqXHR);
        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
        s.type = options.method || options.type || s.method || s.type;
        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
        if (s.crossDomain == null) {
          urlAnchor = document2.createElement("a");
          try {
            urlAnchor.href = s.url;
            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            s.crossDomain = true;
          }
        }
        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        }
        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
        if (completed2) {
          return jqXHR;
        }
        fireGlobals = jQuery.event && s.global;
        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        }
        s.type = s.type.toUpperCase();
        s.hasContent = !rnoContent.test(s.type);
        cacheURL = s.url.replace(rhash, "");
        if (!s.hasContent) {
          uncached = s.url.slice(cacheURL.length);
          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
            delete s.data;
          }
          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          }
          s.url = cacheURL + uncached;
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        }
        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }
          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        }
        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        }
        jqXHR.setRequestHeader(
          "Accept",
          s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]
        );
        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        }
        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
          return jqXHR.abort();
        }
        strAbort = "abort";
        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error);
        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1;
          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          }
          if (completed2) {
            return jqXHR;
          }
          if (s.async && s.timeout > 0) {
            timeoutTimer = window2.setTimeout(function() {
              jqXHR.abort("timeout");
            }, s.timeout);
          }
          try {
            completed2 = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            if (completed2) {
              throw e;
            }
            done(-1, e);
          }
        }
        function done(status, nativeStatusText, responses, headers) {
          var isSuccess, success, error, response, modified, statusText = nativeStatusText;
          if (completed2) {
            return;
          }
          completed2 = true;
          if (timeoutTimer) {
            window2.clearTimeout(timeoutTimer);
          }
          transport = void 0;
          responseHeadersString = headers || "";
          jqXHR.readyState = status > 0 ? 4 : 0;
          isSuccess = status >= 200 && status < 300 || status === 304;
          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          }
          if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function() {
            };
          }
          response = ajaxConvert(s, response, jqXHR, isSuccess);
          if (isSuccess) {
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");
              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }
              modified = jqXHR.getResponseHeader("etag");
              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            }
            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent";
            } else if (status === 304) {
              statusText = "notmodified";
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            error = statusText;
            if (status || !statusText) {
              statusText = "error";
              if (status < 0) {
                status = 0;
              }
            }
          }
          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + "";
          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          }
          jqXHR.statusCode(statusCode);
          statusCode = void 0;
          if (fireGlobals) {
            globalEventContext.trigger(
              isSuccess ? "ajaxSuccess" : "ajaxError",
              [jqXHR, s, isSuccess ? success : error]
            );
          }
          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
            if (!--jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }
        return jqXHR;
      },
      getJSON: function(url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function(url, callback) {
        return jQuery.get(url, void 0, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function(_i, method) {
      jQuery[method] = function(url, data, callback, type) {
        if (isFunction2(data)) {
          type = type || callback;
          callback = data;
          data = void 0;
        }
        return jQuery.ajax(jQuery.extend({
          url,
          type: method,
          dataType: type,
          data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });
    jQuery.ajaxPrefilter(function(s) {
      var i;
      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });
    jQuery._evalUrl = function(url, options, doc2) {
      return jQuery.ajax({
        url,
        // Make this explicit, since user can override this through ajaxSetup (trac-11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function() {
          }
        },
        dataFilter: function(response) {
          jQuery.globalEval(response, options, doc2);
        }
      });
    };
    jQuery.fn.extend({
      wrapAll: function(html) {
        var wrap;
        if (this[0]) {
          if (isFunction2(html)) {
            html = html.call(this[0]);
          }
          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }
          wrap.map(function() {
            var elem = this;
            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }
            return elem;
          }).append(this);
        }
        return this;
      },
      wrapInner: function(html) {
        if (isFunction2(html)) {
          return this.each(function(i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }
        return this.each(function() {
          var self2 = jQuery(this), contents = self2.contents();
          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self2.append(html);
          }
        });
      },
      wrap: function(html) {
        var htmlIsFunction = isFunction2(html);
        return this.each(function(i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function(selector) {
        this.parent(selector).not("body").each(function() {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });
    jQuery.expr.pseudos.hidden = function(elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };
    jQuery.expr.pseudos.visible = function(elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };
    jQuery.ajaxSettings.xhr = function() {
      try {
        return new window2.XMLHttpRequest();
      } catch (e) {
      }
    };
    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // trac-1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function(options) {
      var callback, errorCallback;
      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function(headers, complete) {
            var i, xhr = options.xhr();
            xhr.open(
              options.type,
              options.url,
              options.async,
              options.username,
              options.password
            );
            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            }
            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            }
            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            }
            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            }
            callback = function(type) {
              return function() {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete(
                        // File: protocol always yields status 0; see trac-8605, trac-14207
                        xhr.status,
                        xhr.statusText
                      );
                    }
                  } else {
                    complete(
                      xhrSuccessStatus[xhr.status] || xhr.status,
                      xhr.statusText,
                      // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                      xhr.getAllResponseHeaders()
                    );
                  }
                }
              };
            };
            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
            if (xhr.onabort !== void 0) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  window2.setTimeout(function() {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            }
            callback = callback("abort");
            try {
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              if (callback) {
                throw e;
              }
            }
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    jQuery.ajaxPrefilter(function(s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    });
    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function(text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    });
    jQuery.ajaxPrefilter("script", function(s) {
      if (s.cache === void 0) {
        s.cache = false;
      }
      if (s.crossDomain) {
        s.type = "GET";
      }
    });
    jQuery.ajaxTransport("script", function(s) {
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function(_, complete) {
            script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
              script.remove();
              callback = null;
              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            });
            document2.head.appendChild(script[0]);
          },
          abort: function() {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function() {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    });
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
      var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
      if (jsonProp || s.dataTypes[0] === "jsonp") {
        callbackName = s.jsonpCallback = isFunction2(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        }
        s.converters["script json"] = function() {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }
          return responseContainer[0];
        };
        s.dataTypes[0] = "json";
        overwritten = window2[callbackName];
        window2[callbackName] = function() {
          responseContainer = arguments;
        };
        jqXHR.always(function() {
          if (overwritten === void 0) {
            jQuery(window2).removeProp(callbackName);
          } else {
            window2[callbackName] = overwritten;
          }
          if (s[callbackName]) {
            s.jsonpCallback = originalSettings.jsonpCallback;
            oldCallbacks.push(callbackName);
          }
          if (responseContainer && isFunction2(overwritten)) {
            overwritten(responseContainer[0]);
          }
          responseContainer = overwritten = void 0;
        });
        return "script";
      }
    });
    support.createHTMLDocument = function() {
      var body = document2.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }();
    jQuery.parseHTML = function(data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }
      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }
      var base, parsed, scripts;
      if (!context) {
        if (support.createHTMLDocument) {
          context = document2.implementation.createHTMLDocument("");
          base = context.createElement("base");
          base.href = document2.location.href;
          context.head.appendChild(base);
        } else {
          context = document2;
        }
      }
      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && [];
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = buildFragment([data], context, scripts);
      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    };
    jQuery.fn.load = function(url, params, callback) {
      var selector, type, response, self2 = this, off = url.indexOf(" ");
      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      }
      if (isFunction2(params)) {
        callback = params;
        params = void 0;
      } else if (params && typeof params === "object") {
        type = "POST";
      }
      if (self2.length > 0) {
        jQuery.ajax({
          url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function(responseText) {
          response = arguments;
          self2.html(selector ? (
            // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector)
          ) : (
            // Otherwise use the full result
            responseText
          ));
        }).always(callback && function(jqXHR, status) {
          self2.each(function() {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }
      return this;
    };
    jQuery.expr.pseudos.animated = function(elem) {
      return jQuery.grep(jQuery.timers, function(fn) {
        return elem === fn.elem;
      }).length;
    };
    jQuery.offset = {
      setOffset: function(elem, options, i) {
        var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
        if (position === "static") {
          elem.style.position = "relative";
        }
        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }
        if (isFunction2(options)) {
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }
        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }
        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }
        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function(options) {
        if (arguments.length) {
          return options === void 0 ? this : this.each(function(i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }
        var rect, win, elem = this[0];
        if (!elem) {
          return;
        }
        if (!elem.getClientRects().length) {
          return { top: 0, left: 0 };
        }
        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function() {
        if (!this[0]) {
          return;
        }
        var offsetParent, offset, doc2, elem = this[0], parentOffset = { top: 0, left: 0 };
        if (jQuery.css(elem, "position") === "fixed") {
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset();
          doc2 = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc2.documentElement;
          while (offsetParent && (offsetParent === doc2.body || offsetParent === doc2.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }
          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        }
        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function() {
        return this.map(function() {
          var offsetParent = this.offsetParent;
          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }
          return offsetParent || documentElement;
        });
      }
    });
    jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
      var top = "pageYOffset" === prop;
      jQuery.fn[method] = function(val) {
        return access(this, function(elem, method2, val2) {
          var win;
          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }
          if (val2 === void 0) {
            return win ? win[prop] : elem[method2];
          }
          if (win) {
            win.scrollTo(
              !top ? val2 : win.pageXOffset,
              top ? val2 : win.pageYOffset
            );
          } else {
            elem[method2] = val2;
          }
        }, method, val, arguments.length);
      };
    });
    jQuery.each(["top", "left"], function(_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(
        support.pixelPosition,
        function(elem, computed2) {
          if (computed2) {
            computed2 = curCSS(elem, prop);
            return rnumnonpx.test(computed2) ? jQuery(elem).position()[prop] + "px" : computed2;
          }
        }
      );
    });
    jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function(defaultExtra, funcName) {
        jQuery.fn[funcName] = function(margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function(elem, type2, value2) {
            var doc2;
            if (isWindow(elem)) {
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            }
            if (elem.nodeType === 9) {
              doc2 = elem.documentElement;
              return Math.max(
                elem.body["scroll" + name],
                doc2["scroll" + name],
                elem.body["offset" + name],
                doc2["offset" + name],
                doc2["client" + name]
              );
            }
            return value2 === void 0 ? (
              // Get width or height on the element, requesting but not forcing parseFloat
              jQuery.css(elem, type2, extra)
            ) : (
              // Set width or height on the element
              jQuery.style(elem, type2, value2, extra)
            );
          }, type, chainable ? margin : void 0, chainable);
        };
      });
    });
    jQuery.each([
      "ajaxStart",
      "ajaxStop",
      "ajaxComplete",
      "ajaxError",
      "ajaxSuccess",
      "ajaxSend"
    ], function(_i, type) {
      jQuery.fn[type] = function(fn) {
        return this.on(type, fn);
      };
    });
    jQuery.fn.extend({
      bind: function(types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function(types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function(selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function(selector, types, fn) {
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      },
      hover: function(fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.each(
      "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
      function(_i, name) {
        jQuery.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      }
    );
    var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
    jQuery.proxy = function(fn, context) {
      var tmp, args, proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!isFunction2(fn)) {
        return void 0;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };
    jQuery.holdReady = function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };
    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction2;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;
    jQuery.isNumeric = function(obj) {
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };
    jQuery.trim = function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "$1");
    };
    var _jQuery = window2.jQuery, _$ = window2.$;
    jQuery.noConflict = function(deep) {
      if (window2.$ === jQuery) {
        window2.$ = _$;
      }
      if (deep && window2.jQuery === jQuery) {
        window2.jQuery = _jQuery;
      }
      return jQuery;
    };
    if (typeof noGlobal === "undefined") {
      window2.jQuery = window2.$ = jQuery;
    }
    return jQuery;
  });
})(jquery);
const $ = jqueryExports;
const currentLayout = $("body");
function renderMathLive(naiveDom, originMathBlock, debug = false) {
  initVitrualKeyboard();
  var textBlock = document.querySelector(".block__popover--move");
  var latexBlock = document.querySelector(".block__popover--move > textarea");
  if (!textBlock || !latexBlock) {
    console.log("renderMathLive 初始化获得输入框元素错误！");
    console.log(`textBlock ${textBlock} ||  latexBlock ${latexBlock} `);
    return;
  }
  if (debug === true) {
    console.log("renderMathLive 初始化获得输入框元素成功！");
    console.log(`textBlock ${textBlock} ||  latexBlock ${latexBlock} `);
  }
  var dyBlock = document.createElement("div");
  dyBlock.id = "mathEnhanceDyBlock";
  var keyboardBlock = initkeyboardBlock();
  var MathLiveBlock = initMathLiveBlock(latexBlock);
  if (naiveDom === true) {
    console.log("启动原生渲染！");
    dyBlock.appendChild(MathLiveBlock);
  } else {
    dyBlock.appendChild(MathLiveBlock);
  }
  textBlock.appendChild(dyBlock);
  textBlock.appendChild(keyboardBlock);
  addMathLiveListener(latexBlock, MathLiveBlock);
}
function addMathLiveListener(latexBlock, MathLiveBlock) {
  var tempLatex = MathLiveBlock.value;
  var liveCall = false;
  let evt = new Event("input", {
    bubbles: true,
    cancelable: true
  });
  MathLiveBlock.addEventListener("input", () => {
    var expendLatex = MathLiveBlock.getValue("latex-expanded");
    latexBlock.value = expendLatex.replace(/\{\\textcolor\{#6495ed\}\{(.+?)\}\}/g, "\\mark{$1}").replace(/\\textcolor\{#6495ed\}\{(.+?)\}/g, "\\mark{$1}");
    if (tempLatex === MathLiveBlock.value) {
      tempLatex = MathLiveBlock.value;
      return;
    }
    tempLatex = MathLiveBlock.value;
    liveCall = true;
    latexBlock.dispatchEvent(evt);
  });
  latexBlock.addEventListener(
    "input",
    (ev) => {
      if (liveCall === true) {
        liveCall = false;
        return;
      }
      MathLiveBlock.setValue(latexBlock.value, { suppressChangeNotifications: true });
    }
  );
}
function initMathLiveBlock(latexBlock) {
  var mathLiveBlock = document.createElement("math-field");
  mathLiveBlock.style.width = "-webkit-fill-available";
  mathLiveBlock.value = latexBlock.value;
  mathLiveBlock.macros = {
    ...mathLiveBlock.macros,
    mark: {
      args: 1,
      def: "{\\color{#6495ed}#1}",
      captureSelection: false
    }
  };
  return mathLiveBlock;
}
function initkeyboardBlock() {
  var keyboardBlock = document.createElement("div");
  keyboardBlock.style.height = "auto";
  mathVirtualKeyboard.container = keyboardBlock;
  return keyboardBlock;
}
function initStyle() {
  var mathlive_css = document.createElement("style");
  mathlive_css.innerHTML = `
#mathlive-popover-panel{
    z-index: 200;
}
.ML__keyboard.is-visible{
    height: calc(var(--keyboard-height) + 10px);
}
`;
  document.body.appendChild(mathlive_css);
  document.body.style.setProperty("--keycap-height", "3em");
  document.body.style.setProperty("--keycap-font-size", "1.2em");
}
function initMathLive() {
  initStyle();
  currentLayout.on("mouseup", '[data-subtype="math"]', initMathLiveRender);
}
function initMathLiveRender(event) {
  event.target;
  setTimeout(() => {
    renderMathLive(false);
  }, 10);
}
function initVitrualKeyboard() {
  mathVirtualKeyboard.layouts[0].layers[0].markup = `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='x-var'><i>x</i></li>
    <li class='MLK__keycap MLK__tex' data-variants='n-var'><i>n</i></li>
    <li class='separator w5'></li>
    <row name='numpad-1'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='exponentialE' data-variants='ee'>e</li>
    <li class='MLK__keycap MLK__tex' data-latex='imaginaryI' data-variants='ii'>i</li>
    <li class='MLK__keycap MLK__tex' data-latex='pi' data-variants='numeric-pi'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-key='<' data-variants='<'>&lt;</li>
    <li class='MLK__keycap MLK__tex' data-key='>' data-variants='>'>&gt;</li>
    <li class='separator w5'></li>
    <row name='numpad-2'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='#@^{2}' data-latex='x^2'></li>
    <li class='MLK__keycap MLK__tex' data-variants='^' data-insert='#@^{#?}' data-latex='x^placeholder'></li>
    <li class='MLK__keycap MLK__tex small' data-insert='sqrt{#0}' data-latex='sqrt{#0}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='(' >(</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' >)</li>
    <li class='separator w5'></li>
    <row name='numpad-3'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap small' data-variants='int' data-latex='int_0^infty'></li>
    <li class='MLK__keycap' data-latex='\forall' data-variants='logic' ></li>
    <li class='action font-glyph bottom right' data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  </ul>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"#6495ed"}]'><span style='color:#6495ed'>[...]</span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>
    <li class='separator w5'></li>
    <row name='numpad-4'/>
    <li class='separator w5'></li>
    <arrows/>
  </ul>
</div>
    `;
}
function removeMathLive() {
  currentLayout.off("mouseup", '[data-subtype="math"]', initMathLiveRender);
  var dyBlock = document.querySelector("#mathEnhanceDyBlock");
  dyBlock == null ? void 0 : dyBlock.remove();
}
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.MathLive = {}));
})(globalThis, function(exports2) {
  var MathLive = (() => {
    var Ji = Object.defineProperty, ml = Object.defineProperties, pl = Object.getOwnPropertyDescriptor, hl = Object.getOwnPropertyDescriptors, fl = Object.getOwnPropertyNames, dn = Object.getOwnPropertySymbols;
    var pn = Object.prototype.hasOwnProperty, gl = Object.prototype.propertyIsEnumerable;
    var mn = (r, e, t) => e in r ? Ji(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t, b = (r, e) => {
      for (var t in e || (e = {}))
        pn.call(e, t) && mn(r, t, e[t]);
      if (dn)
        for (var t of dn(e))
          gl.call(e, t) && mn(r, t, e[t]);
      return r;
    }, E = (r, e) => ml(r, hl(e));
    var yl = (r, e) => {
      for (var t in e)
        Ji(r, t, { get: e[t], enumerable: true });
    }, bl = (r, e, t, i) => {
      if (e && typeof e == "object" || typeof e == "function")
        for (let o of fl(e))
          !pn.call(r, o) && o !== t && Ji(r, o, { get: () => e[o], enumerable: !(i = pl(e, o)) || i.enumerable });
      return r;
    };
    var xl = (r) => bl(Ji({}, "__esModule", { value: true }), r);
    var id = {};
    yl(id, { MathfieldElement: () => re, autoRenderMathInElement: () => cn, convertAsciiMathToLatex: () => Fu, convertLatexToAsciiMath: () => Ru, convertLatexToMarkup: () => an, convertLatexToMathMl: () => nn, convertLatexToSpeakableText: () => sn, debug: () => rd, globalMathLive: () => bt, makeSharedVirtualKeyboard: () => Yu, renderMathInDocument: () => Qu, renderMathInElement: () => dl, serializeMathJsonToLatex: () => ln, validateLatex: () => zu, version: () => td });
    function Y(r) {
      return Array.isArray(r);
    }
    var hn = { en: { "keyboard.tooltip.functions": "Functions", "keyboard.tooltip.symbols": "Symbols", "keyboard.tooltip.greek": "Greek Letters", "keyboard.tooltip.command": "LaTeX Command Mode", "keyboard.tooltip.numeric": "Numeric", "keyboard.tooltip.alphabetic": "Roman Letters", "tooltip.copy to clipboard": "Copy to Clipboard", "tooltip.cut to clipboard": "Cut to Clipboard", "tooltip.paste from clipboard": "Paste from Clipboard", "tooltip.redo": "Redo", "tooltip.toggle virtual keyboard": "Toggle Virtual Keyboard", "tooltip.undo": "Undo", "menu.insert matrix": "Insert Matrix", "menu.insert vector": "Insert Vector", "submenu.array.matrix delimiters": "Matrix Delimiters", "menu.array.add row above": "Add Row After", "menu.array.add row below": "Add Row Before", "menu.array.add column after": "Add Column After", "menu.array.add column before": "Add Column Before", "menu.array.delete row": "Delete Row", "menu.array.delete rows": "Delete Selected Rows", "menu.array.delete column": "Delete Column", "menu.array.delete columns": "Delete Selected Columns", "submenu.array.insert separator": "Insert Separator", "menu.insert table": "Insert Table", "submenu.table style": "Table Style" }, ar: { "keyboard.tooltip.functions": "مهام", "keyboard.tooltip.symbols": "حرف او رمز", "keyboard.tooltip.greek": "حروف يونانية", "keyboard.tooltip.command": "حالة تلقي الأوامر اللاتك", "keyboard.tooltip.numeric": "الرقمية", "keyboard.tooltip.alphabetic": "رموز الاحرف الرومانية", "tooltip.copy to clipboard": "نسخ إلى الحافظة", "tooltip.redo": "الإعادة", "tooltip.toggle virtual keyboard": "تبديل لوحة المفاتيح الإفتراضية", "tooltip.undo": "إلغاء", "menu.insert matrix": "أدخل المصفوفة", "menu.insert vector": "أدخل متجه", "submenu.array.matrix delimiters": "محددات المصفوفة", "menu.array.add row above": "أضف صفًا بعد ذلك", "menu.array.add row below": "أضف الصف قبل", "menu.array.add column after": "أضف العمود بعد ذلك", "menu.array.add column before": "أضف العمود قبل", "menu.array.delete row": "احذف صف", "menu.array.delete rows": "حذف الصفوف المحددة", "menu.array.delete column": "حذف العمود", "menu.array.delete columns": "حذف الأعمدة المحددة", "submenu.array.insert separator": "أدخل فاصل", "menu.insert table": "إدراج جدول", "submenu.table style": "نمط الجدول" }, bg: { "keyboard.tooltip.functions": "Функции", "keyboard.tooltip.symbols": "Символи", "keyboard.tooltip.greek": "Гръцки букви", "keyboard.tooltip.command": "Команден режим на латекс", "keyboard.tooltip.numeric": "Числови", "keyboard.tooltip.alphabetic": "Римски букви", "tooltip.copy to clipboard": "Копиране в клипборда", "tooltip.redo": "Повторно", "tooltip.toggle virtual keyboard": "Превключване на виртуална клавиатура", "tooltip.undo": "Отмяна", "menu.insert matrix": "Вмъкване на матрица", "menu.insert vector": "Вмъкване на вектор", "submenu.array.matrix delimiters": "Матрични разделители", "menu.array.add row above": "Добавяне на ред след", "menu.array.add row below": "Добавяне на ред преди", "menu.array.add column after": "Добавяне на колона след", "menu.array.add column before": "Добавяне на колона преди", "menu.array.delete row": "Изтриване на реда", "menu.array.delete rows": "Изтриване на избраните редове", "menu.array.delete column": "Изтриване на колона", "menu.array.delete columns": "Изтриване на избраните колони", "submenu.array.insert separator": "Поставете разделител", "menu.insert table": "Вмъкване на таблица", "submenu.table style": "Табличен стил" }, bs: { "keyboard.tooltip.functions": "Funkcije", "keyboard.tooltip.symbols": "Simboli", "keyboard.tooltip.greek": "Grčka slova", "keyboard.tooltip.command": "LaTeX naredbeni način", "keyboard.tooltip.numeric": "Numerički", "keyboard.tooltip.alphabetic": "Rimska slova", "tooltip.copy to clipboard": "Kopirati u clipboard", "tooltip.redo": "Ponovi", "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu", "tooltip.undo": "Poništi", "menu.insert matrix": "Umetni matricu", "menu.insert vector": "Umetni vektor", "submenu.array.matrix delimiters": "Matrični razdjelnici", "menu.array.add row above": "Dodaj redak nakon", "menu.array.add row below": "Dodaj red prije", "menu.array.add column after": "Dodaj stupac nakon", "menu.array.add column before": "Dodaj stupac prije", "menu.array.delete row": "Izbriši red", "menu.array.delete rows": "Izbriši odabrane redove", "menu.array.delete column": "Izbriši stupac", "menu.array.delete columns": "Izbriši odabrane stupce", "submenu.array.insert separator": "Umetni separator", "menu.insert table": "Ubaci tabelu", "submenu.table style": "Stil tabele" }, cs: { "keyboard.tooltip.functions": "Funkce", "keyboard.tooltip.symbols": "Symboly", "keyboard.tooltip.greek": "Řecké dopisy", "keyboard.tooltip.command": "Příkazový režim LaTeX", "keyboard.tooltip.numeric": "Číselné", "keyboard.tooltip.alphabetic": "Římské dopisy", "tooltip.copy to clipboard": "Zkopírovat do schránky", "tooltip.redo": "Předělat", "tooltip.toggle virtual keyboard": "Přepnout virtuální klávesnici", "tooltip.undo": "Vrátit", "menu.insert matrix": "Vložte matici", "menu.insert vector": "Vložit vektor", "submenu.array.matrix delimiters": "Oddělovače matic", "menu.array.add row above": "Přidat řádek za", "menu.array.add row below": "Přidat řádek před", "menu.array.add column after": "Přidat sloupec za", "menu.array.add column before": "Přidat sloupec dříve", "menu.array.delete row": "Odstranit řádek", "menu.array.delete rows": "Odstranit vybrané řádky", "menu.array.delete column": "Odstranit sloupec", "menu.array.delete columns": "Odstranit vybrané sloupce", "submenu.array.insert separator": "Vložte oddělovač", "menu.insert table": "Vložit tabulku", "submenu.table style": "Styl tabulky" }, da: { "keyboard.tooltip.functions": "Funktioner", "keyboard.tooltip.symbols": "Symboler", "keyboard.tooltip.greek": "Græske bogstaver", "keyboard.tooltip.command": "LaTeX kommandotilstand", "keyboard.tooltip.numeric": "Numerisk", "keyboard.tooltip.alphabetic": "Romerske breve", "tooltip.copy to clipboard": "Kopier til udklipsholder", "tooltip.redo": "Gentag igen", "tooltip.toggle virtual keyboard": "Skift virtuelt tastatur", "tooltip.undo": "Fortryd", "menu.insert matrix": "Indsæt matrix", "menu.insert vector": "Indsæt vektor", "submenu.array.matrix delimiters": "Matrixafgrænsere", "menu.array.add row above": "Tilføj række efter", "menu.array.add row below": "Tilføj række før", "menu.array.add column after": "Tilføj kolonne efter", "menu.array.add column before": "Tilføj kolonne før", "menu.array.delete row": "Slet række", "menu.array.delete rows": "Slet valgte rækker", "menu.array.delete column": "Slet kolonne", "menu.array.delete columns": "Slet valgte kolonner", "submenu.array.insert separator": "Indsæt separator", "menu.insert table": "Indsæt tabel", "submenu.table style": "Tabelstil" }, de: { "keyboard.tooltip.functions": "Funktionen", "keyboard.tooltip.symbols": "Symbole", "keyboard.tooltip.greek": "Griechische Buchstaben", "keyboard.tooltip.command": "LaTeX-Befehlsmodus", "keyboard.tooltip.numeric": "Numerisch", "keyboard.tooltip.alphabetic": "Römische Buchstaben", "tooltip.copy to clipboard": "In die Zwischenablage kopieren", "tooltip.redo": "Wiederholen", "tooltip.toggle virtual keyboard": "Virtuelle Tastatur umschalten", "tooltip.undo": "Widerrufen", "menu.insert matrix": "Matrix einfügen", "menu.insert vector": "Vektor einfügen", "submenu.array.matrix delimiters": "Matrixtrennzeichen", "menu.array.add row above": "Zeile hinzufügen nach", "menu.array.add row below": "Zeile hinzufügen vor", "menu.array.add column after": "Spalte hinzufügen nach", "menu.array.add column before": "Spalte hinzufügen vor", "menu.array.delete row": "Zeile löschen", "menu.array.delete rows": "Ausgewählte Zeilen löschen", "menu.array.delete column": "Spalte löschen", "menu.array.delete columns": "Ausgewählte Spalten löschen", "submenu.array.insert separator": "Trennzeichen einfügen", "menu.insert table": "Tabelle einfügen", "submenu.table style": "Tabellenstil" }, el: { "keyboard.tooltip.functions": "συναρτήσεις", "keyboard.tooltip.symbols": "σύμβολα", "keyboard.tooltip.greek": "ελληνικά γράμματα", "keyboard.tooltip.command": "Λειτουργία εντολών LaTeX", "keyboard.tooltip.numeric": "Αριθμητικός", "keyboard.tooltip.alphabetic": "Ρωμαϊκά γράμματα", "tooltip.copy to clipboard": "Αντιγραφή στο πρόχειρο", "tooltip.redo": "Ξανακάνω", "tooltip.toggle virtual keyboard": "Εναλλαγή εικονικού πληκτρολογίου", "tooltip.undo": "Ξεκάνω", "menu.insert matrix": "Εισαγωγή Matrix", "menu.insert vector": "Εισαγωγή διανύσματος", "submenu.array.matrix delimiters": "Οριοθέτες Matrix", "menu.array.add row above": "Προσθήκη σειράς μετά", "menu.array.add row below": "Προσθήκη σειράς πριν", "menu.array.add column after": "Προσθήκη στήλης μετά", "menu.array.add column before": "Προσθήκη στήλης πριν", "menu.array.delete row": "Διαγραφή σειράς", "menu.array.delete rows": "Διαγραφή επιλεγμένων σειρών", "menu.array.delete column": "Διαγραφή στήλης", "menu.array.delete columns": "Διαγραφή επιλεγμένων στηλών", "submenu.array.insert separator": "Εισαγωγή διαχωριστικού", "menu.insert table": "Εισαγωγή πίνακα", "submenu.table style": "Στυλ πίνακα" }, es: { "keyboard.tooltip.functions": "Funciones", "keyboard.tooltip.symbols": "Símbolos", "keyboard.tooltip.greek": "Letras griegas", "keyboard.tooltip.command": "Modo Comando LaTeX", "keyboard.tooltip.numeric": "Numérico", "keyboard.tooltip.alphabetic": "Letras romanas", "tooltip.copy to clipboard": "Copiar al portapapeles", "tooltip.redo": "Rehacer", "tooltip.toggle virtual keyboard": "Alternar teclado virtual", "tooltip.undo": "Deshacer", "menu.insert matrix": "Añadir Matriz", "menu.insert vector": "Añadir vector", "submenu.array.matrix delimiters": "Delimitadores de Matriz", "menu.array.add row above": "Añadir Línea Antes", "menu.array.add row below": "Añadir Línea Despues", "menu.array.add column after": "Añadir Columna Despues", "menu.array.add column before": "Añadir Columna Antes", "menu.array.delete row": "Borrar Línea", "menu.array.delete rows": "Borrar Líneas Seleccionadas", "menu.array.delete column": "Borrar Columna", "menu.array.delete columns": "Borrar Columnas Seleccionadas", "submenu.array.insert separator": "Insertar un Separador", "menu.insert table": "Insertar Tabla", "submenu.table style": "Estilo de Tabla" }, et: { "keyboard.tooltip.functions": "Funktsioonid", "keyboard.tooltip.symbols": "Sümbolid", "keyboard.tooltip.greek": "Kreeka kirjad", "keyboard.tooltip.command": "LaTeXi käsurežiim", "keyboard.tooltip.numeric": "Numbriline", "keyboard.tooltip.alphabetic": "Rooma kirjad", "tooltip.copy to clipboard": "Kopeerida lõikelauale", "tooltip.redo": "Tee uuesti", "tooltip.toggle virtual keyboard": "Lülitage sisse virtuaalne klaviatuur", "tooltip.undo": "Võta tagasi", "menu.insert matrix": "Sisesta maatriks", "menu.insert vector": "Sisesta vektor", "submenu.array.matrix delimiters": "Maatriksi eraldajad", "menu.array.add row above": "Lisa rida pärast", "menu.array.add row below": "Lisa rida enne", "menu.array.add column after": "Lisa veerg pärast", "menu.array.add column before": "Lisa veerg enne", "menu.array.delete row": "Kustuta rida", "menu.array.delete rows": "Kustuta valitud read", "menu.array.delete column": "Kustuta veerg", "menu.array.delete columns": "Kustuta valitud veerud", "submenu.array.insert separator": "Sisestage eraldaja", "menu.insert table": "Sisesta tabeli", "submenu.table style": "Tabeli stiilis" }, fa: { "keyboard.tooltip.functions": "توابع", "keyboard.tooltip.symbols": "نمادها", "keyboard.tooltip.greek": "حروف یونانی", "keyboard.tooltip.command": "حالت دستور لاتک", "keyboard.tooltip.numeric": "عددی", "keyboard.tooltip.alphabetic": "حروف رومی", "tooltip.copy to clipboard": "کپی به کلیپبورد", "tooltip.redo": "بازگشت به بعد", "tooltip.toggle virtual keyboard": "نمایش/نهفتن کیبورد مجازی", "tooltip.undo": "بازگشت به قبل", "menu.insert matrix": "ماتریس را وارد کنید", "menu.insert vector": "درج بردار", "submenu.array.matrix delimiters": "مرزهای ماتریس", "menu.array.add row above": "بعد از آن ردیف اضافه کنید", "menu.array.add row below": "ردیف را قبل اضافه کنید", "menu.array.add column after": "اضافه کردن ستون بعد", "menu.array.add column before": "ستون قبل را اضافه کنید", "menu.array.delete row": "ردیف را حذف کنید", "menu.array.delete rows": "ردیف های انتخاب شده را حذف کنید", "menu.array.delete column": "حذف ستون", "menu.array.delete columns": "ستون های انتخاب شده را حذف کنید", "submenu.array.insert separator": "درج جدا کننده", "menu.insert table": "قرار دادن جدول", "submenu.table style": "سبک میز" }, fi: { "keyboard.tooltip.functions": "Toiminnot", "keyboard.tooltip.symbols": "Symbolit", "keyboard.tooltip.greek": "Kreikkalaiset kirjeet", "keyboard.tooltip.command": "LaTeX-komentotila", "keyboard.tooltip.numeric": "Numeerinen", "keyboard.tooltip.alphabetic": "Roomalaiset kirjeet", "tooltip.copy to clipboard": "Kopioi leikepöydälle", "tooltip.redo": "Tee uudelleen", "tooltip.toggle virtual keyboard": "Vaihda virtuaalinäppäimistö", "tooltip.undo": "Kumoa", "menu.insert matrix": "Lisää matriisi", "menu.insert vector": "Lisää vektori", "submenu.array.matrix delimiters": "Matriisin erottimet", "menu.array.add row above": "Lisää rivi jälkeen", "menu.array.add row below": "Lisää rivi ennen", "menu.array.add column after": "Lisää sarake jälkeen", "menu.array.add column before": "Lisää sarake ennen", "menu.array.delete row": "Poista rivi", "menu.array.delete rows": "Poista valitut rivit", "menu.array.delete column": "Poista sarake", "menu.array.delete columns": "Poista valitut sarakkeet", "submenu.array.insert separator": "Aseta erotin", "menu.insert table": "Lisää taulukko", "submenu.table style": "Taulukon tyyli" }, fr: { "keyboard.tooltip.functions": "Fonctions", "keyboard.tooltip.symbols": "Symboles", "keyboard.tooltip.greek": "Lettres grecques", "keyboard.tooltip.command": "Mode de commandes LaTeX", "keyboard.tooltip.numeric": "Numérique", "keyboard.tooltip.alphabetic": "Lettres romaines", "tooltip.copy to clipboard": "Copier dans le presse-papiers", "tooltip.redo": "Rétablir", "tooltip.toggle virtual keyboard": "Afficher/Masquer le clavier virtuel", "tooltip.undo": "Annuler", "menu.insert matrix": "Insérer une Matrice", "menu.insert vector": "Insérer un Vecteur", "submenu.array.matrix delimiters": "Délimiteurs de la Matrice", "menu.array.add row above": "Ajouter une Ligne Avant", "menu.array.add row below": "Ajouter une Ligne Après", "menu.array.add column before": "Ajouter une Colonne Avant", "menu.array.add column after": "Ajouter une Colonne Après", "menu.array.delete row": "Enlever une Ligne", "menu.array.delete rows": "Enlever les Lignes Sélectionées", "menu.array.delete column": "Enlever une Colone", "menu.array.delete columns": "Enlever les Colonnes Sélectionées", "submenu.array.insert separator": "Insérer un Séparateur", "menu.insert table": "Insérer une Table", "submenu.table style": "Style de la  Table" }, ga: { "keyboard.tooltip.functions": "Feidhmeanna", "keyboard.tooltip.symbols": "Siombailí", "keyboard.tooltip.greek": "Litreacha na Gréige", "keyboard.tooltip.command": "Mód Ordú LaTeX", "keyboard.tooltip.numeric": "Uimhriúil", "keyboard.tooltip.alphabetic": "Litreacha Rómhánacha", "tooltip.copy to clipboard": "Cóipeáil chuig an Ghearrthaisce", "tooltip.redo": "Athdhéan", "tooltip.toggle virtual keyboard": "Méarchláir Fíorúil a Fháil", "tooltip.undo": "Cealaigh", "menu.insert matrix": "Cuir isteach Maitrís", "menu.insert vector": "Cuir isteach Veicteoir", "submenu.array.matrix delimiters": "Delimiters Maitrís", "menu.array.add row above": "Cuir Rae Tar éis", "menu.array.add row below": "Cuir Rae Roimh", "menu.array.add column after": "Cuir Colún Tar éis", "menu.array.add column before": "Cuir Colún Roimh", "menu.array.delete row": "Scrios Rae", "menu.array.delete rows": "Scrios Sraitheanna Roghnaithe", "menu.array.delete column": "Scrios Colún", "menu.array.delete columns": "Scrios Colúin Roghnaithe", "submenu.array.insert separator": "Cuir Deighilteoir isteach", "menu.insert table": "Ionsáigh Tábla", "submenu.table style": "Stíl Tábla" }, he: { "keyboard.tooltip.functions": "פונקציות", "keyboard.tooltip.symbols": "סמלים", "keyboard.tooltip.greek": "אותיות יווניות", "keyboard.tooltip.command": "מצב פקודה לטקס", "keyboard.tooltip.numeric": "מספרי", "keyboard.tooltip.alphabetic": "מכתבים רומיים", "tooltip.copy to clipboard": "העתק ללוח", "tooltip.redo": "לַעֲשׂוֹת שׁוּב", "tooltip.toggle virtual keyboard": "החלף את המקלדת הווירטואלית", "tooltip.undo": "לבטל", "menu.insert matrix": "הכנס מטריקס", "menu.insert vector": "הכנס וקטור", "submenu.array.matrix delimiters": "מפרידי מטריקס", "menu.array.add row above": "הוסף שורה אחרי", "menu.array.add row below": "הוסף שורה לפני", "menu.array.add column after": "הוסף עמודה אחרי", "menu.array.add column before": "הוסף עמודה לפני", "menu.array.delete row": "מחק שורה", "menu.array.delete rows": "מחק שורות שנבחרו", "menu.array.delete column": "מחק עמודה", "menu.array.delete columns": "מחק עמודות שנבחרו", "submenu.array.insert separator": "הכנס מפריד", "menu.insert table": "הכנס טבלה", "submenu.table style": "טבלה סִגְנוֹן" }, hr: { "keyboard.tooltip.functions": "Funkcije", "keyboard.tooltip.symbols": "Simboli", "keyboard.tooltip.greek": "Grčka slova", "keyboard.tooltip.command": "LaTeX naredbeni način", "keyboard.tooltip.numeric": "Numerički", "keyboard.tooltip.alphabetic": "Rimska slova", "tooltip.copy to clipboard": "Kopirati u međuspremnik", "tooltip.redo": "Ponovi", "tooltip.toggle virtual keyboard": "Uključi / isključi virtualnu tipkovnicu", "tooltip.undo": "Poništi", "menu.insert matrix": "Umetni matricu", "menu.insert vector": "Umetni vektor", "submenu.array.matrix delimiters": "Matrični razdjelnici", "menu.array.add row above": "Dodaj redak nakon", "menu.array.add row below": "Dodaj redak prije", "menu.array.add column after": "Dodaj stupac nakon", "menu.array.add column before": "Dodaj stupac prije", "menu.array.delete row": "Izbriši redak", "menu.array.delete rows": "Izbriši odabrane retke", "menu.array.delete column": "Izbriši stupac", "menu.array.delete columns": "Izbriši odabrane stupce", "submenu.array.insert separator": "Umetni separator", "menu.insert table": "Umetni tablicu", "submenu.table style": "Stil tabele" }, id: { "keyboard.tooltip.functions": "Fungsi", "keyboard.tooltip.symbols": "Simbol", "keyboard.tooltip.greek": "Huruf Yunani", "keyboard.tooltip.command": "Mode Perintah LaTeX", "keyboard.tooltip.numeric": "Numerik", "keyboard.tooltip.alphabetic": "Surat Romawi", "tooltip.copy to clipboard": "Menyalin ke clipboard", "tooltip.redo": "Mengulangi", "tooltip.toggle virtual keyboard": "Alihkan Keyboard Virtual", "tooltip.undo": "Membuka", "menu.insert matrix": "Sisipkan Matriks", "menu.insert vector": "Sisipkan Vektor", "submenu.array.matrix delimiters": "Pembatas Matriks", "menu.array.add row above": "Tambahkan Baris Setelah", "menu.array.add row below": "Tambahkan Baris Sebelumnya", "menu.array.add column after": "Tambahkan Kolom Setelah", "menu.array.add column before": "Tambahkan Kolom Sebelumnya", "menu.array.delete row": "Hapus Baris", "menu.array.delete rows": "Hapus Baris yang Dipilih", "menu.array.delete column": "Hapus Kolom", "menu.array.delete columns": "Hapus Kolom yang Dipilih", "submenu.array.insert separator": "Sisipkan Pemisah", "menu.insert table": "Sisipkan Tabel", "submenu.table style": "Gaya Tabel" }, hi: { "keyboard.tooltip.functions": "कार्यों", "keyboard.tooltip.symbols": "प्रतीक", "keyboard.tooltip.greek": "ग्रीक अक्षर", "keyboard.tooltip.command": "लाटेक्स कमांड मोड", "keyboard.tooltip.numeric": "संख्यात्मक", "keyboard.tooltip.alphabetic": "रोमन पत्र", "tooltip.copy to clipboard": "क्लिपबोर्ड पर कॉपी करें", "tooltip.redo": "फिर से करें", "tooltip.toggle virtual keyboard": "वर्चुअल कीबोर्ड टॉगल करें", "tooltip.undo": "पूर्ववत", "menu.insert matrix": "मैट्रिक्स डालें", "menu.insert vector": "वेक्टर डालें", "submenu.array.matrix delimiters": "मैट्रिक्स सीमांकक", "menu.array.add row above": "बाद में पंक्ति जोड़ें", "menu.array.add row below": "पहले पंक्ति जोड़ें", "menu.array.add column after": "बाद में कॉलम जोड़ें", "menu.array.add column before": "पहले कॉलम जोड़ें", "menu.array.delete row": "पंक्ति को हटाएं", "menu.array.delete rows": "चयनित पंक्तियों को हटाएं", "menu.array.delete column": "कॉलम हटाएं", "menu.array.delete columns": "चयनित कॉलम हटाएं", "submenu.array.insert separator": "विभाजक डालें", "menu.insert table": "टेबल इंसर्ट करें", "submenu.table style": "टेबल स्टाइल" }, hu: { "keyboard.tooltip.functions": "Funkciók", "keyboard.tooltip.symbols": "Szimbólumok", "keyboard.tooltip.greek": "Görög levelek", "keyboard.tooltip.command": "LaTeX Parancs mód", "keyboard.tooltip.numeric": "Numerikus", "keyboard.tooltip.alphabetic": "Római levelek", "tooltip.copy to clipboard": "Másolja a vágólapra", "tooltip.redo": "Újra", "tooltip.toggle virtual keyboard": "Váltás a virtuális billentyűzetre", "tooltip.undo": "Visszavonás", "menu.insert matrix": "Helyezze be a Mátrixot", "menu.insert vector": "Vektor beszúrása", "submenu.array.matrix delimiters": "Mátrixhatárolók", "menu.array.add row above": "Sor hozzáadása után", "menu.array.add row below": "Add Add Sor előtt", "menu.array.add column after": "Oszlop hozzáadása után", "menu.array.add column before": "Add oszlop előtt", "menu.array.delete row": "Sor törlése", "menu.array.delete rows": "Kijelölt sorok törlése", "menu.array.delete column": "Oszlop törlése", "menu.array.delete columns": "A kijelölt oszlopok törlése", "submenu.array.insert separator": "Helyezze be az elválasztót", "menu.insert table": "Helyezze be a táblázatot", "submenu.table style": "Táblázatos stílus" }, it: { "keyboard.tooltip.functions": "Funzioni", "keyboard.tooltip.symbols": "Simboli", "keyboard.tooltip.greek": "Lettere greche", "keyboard.tooltip.command": "Modalità di comando LaTeX", "keyboard.tooltip.numeric": "Numerico", "keyboard.tooltip.alphabetic": "Lettere romane", "tooltip.copy to clipboard": "Copia negli appunti", "tooltip.redo": "Rifare", "tooltip.toggle virtual keyboard": "Attiva / disattiva la tastiera virtuale", "tooltip.undo": "Disfare", "menu.insert matrix": "Inserisci una Matrice", "menu.insert vector": "Inserisci Vettore", "submenu.array.matrix delimiters": "Delimitatori di Matrice", "menu.array.add row above": "Aggiungi una Riga Prima", "menu.array.add row below": "Aggiungi una Riga Dopo", "menu.array.add column before": "Aggiungi una Colonna Prima", "menu.array.add column after": "Aggiungi una Colonna Dopo", "menu.array.delete row": "Rimuovi una Riga", "menu.array.delete rows": "Rimuovi le Righe Selezionate", "menu.array.delete column": "Rimuovi una Colonna", "menu.array.delete columns": "Rimuovi le Colonne Selezionate", "submenu.array.insert separator": "Inserisci un Separatore", "menu.insert table": "Inserisci Tabella", "submenu.table style": "Stile tabella" }, is: { "keyboard.tooltip.functions": "Aðgerðir", "keyboard.tooltip.symbols": "Tákn", "keyboard.tooltip.greek": "Grísk bréf", "keyboard.tooltip.command": "LaTeX stjórnunarstilling", "keyboard.tooltip.numeric": "Tölulegt", "keyboard.tooltip.alphabetic": "Rómversk bréf", "tooltip.copy to clipboard": "Afritaðu á klemmuspjald", "tooltip.redo": "Endurtaka", "tooltip.toggle virtual keyboard": "Skiptu um sýndarlyklaborð", "tooltip.undo": "Afturkalla", "menu.insert matrix": "Settu fylki inn", "menu.insert vector": "Settu inn Vector", "submenu.array.matrix delimiters": "Matrix afmörkun", "menu.array.add row above": "Bæta við röð á eftir", "menu.array.add row below": "Bæta við röð áður", "menu.array.add column after": "Bæta við dálki á eftir", "menu.array.add column before": "Bæta við dálki áður", "menu.array.delete row": "Eyða röð", "menu.array.delete rows": "Eyða völdum línum", "menu.array.delete column": "Eyða dálki", "menu.array.delete columns": "Eyða völdum dálkum", "submenu.array.insert separator": "Settu skiljuna í", "menu.insert table": "Settu inn töflu", "submenu.table style": "Töflu stíl" }, ja: { "keyboard.tooltip.functions": "関数", "keyboard.tooltip.symbols": "シンボル", "keyboard.tooltip.greek": "ギリシャ文字", "keyboard.tooltip.command": "ラテックスコマンドモード", "keyboard.tooltip.numeric": "数値", "keyboard.tooltip.alphabetic": "ローマ字", "tooltip.copy to clipboard": "クリップボードにコピー", "tooltip.redo": "やり直し", "tooltip.toggle virtual keyboard": "仮想キーボードの切り替え", "tooltip.undo": "元に戻す", "menu.insert matrix": "マトリックスを挿入", "menu.insert vector": "ベクトルを挿入", "submenu.array.matrix delimiters": "行列区切り文字", "menu.array.add row above": "後に行を追加", "menu.array.add row below": "前に行を追加", "menu.array.add column after": "後に列を追加", "menu.array.add column before": "前に列を追加", "menu.array.delete row": "行を削除", "menu.array.delete rows": "選択した行を削除する", "menu.array.delete column": "列を削除", "menu.array.delete columns": "選択した列を削除する", "submenu.array.insert separator": "セパレーターを挿入", "menu.insert table": "テーブルを挿入", "submenu.table style": "テーブルスタイル" }, ko: { "keyboard.tooltip.functions": "기능", "keyboard.tooltip.symbols": "기호", "keyboard.tooltip.greek": "그리스 문자", "keyboard.tooltip.command": "유액 명령 모드", "keyboard.tooltip.numeric": "숫자", "keyboard.tooltip.alphabetic": "로마 문자", "tooltip.copy to clipboard": "클립 보드에 복사", "tooltip.redo": "다시 하다", "tooltip.toggle virtual keyboard": "가상 키보드 전환", "tooltip.undo": "실행 취소", "menu.insert matrix": "매트릭스 삽입", "menu.insert vector": "벡터 삽입", "submenu.array.matrix delimiters": "행렬 구분 기호", "menu.array.add row above": "뒤에 행 추가", "menu.array.add row below": "앞에 행 추가", "menu.array.add column after": "뒤에 열 추가", "menu.array.add column before": "앞에 열 추가", "menu.array.delete row": "행 삭제", "menu.array.delete rows": "선택한 행 삭제", "menu.array.delete column": "열 삭제", "menu.array.delete columns": "선택한 열 삭제", "submenu.array.insert separator": "구분자 삽입", "menu.insert table": "표 삽입", "submenu.table style": "테이블 스타일" }, lv: { "keyboard.tooltip.functions": "Funkcijas", "keyboard.tooltip.symbols": "Simboli", "keyboard.tooltip.greek": "Grieķu burti", "keyboard.tooltip.command": "LaTeX komandu režīms", "keyboard.tooltip.numeric": "Ciparu skaitlis", "keyboard.tooltip.alphabetic": "Romiešu vēstules", "tooltip.copy to clipboard": "Kopēt starpliktuvē", "tooltip.redo": "Pārtaisīt", "tooltip.toggle virtual keyboard": "Pārslēgt virtuālo tastatūru", "tooltip.undo": "Atsaukt", "menu.insert matrix": "Ievietojiet matricu", "menu.insert vector": "Ievietot vektoru", "submenu.array.matrix delimiters": "Matricas norobežotāji", "menu.array.add row above": "Pievienot rindu pēc", "menu.array.add row below": "Pievienot rindu pirms", "menu.array.add column after": "Pievienot kolonnu pēc", "menu.array.add column before": "Pievienot kolonnu pirms", "menu.array.delete row": "Dzēst rindu", "menu.array.delete rows": "Dzēst atlasītās rindas", "menu.array.delete column": "Dzēst kolonnu", "menu.array.delete columns": "Dzēst atlasītās kolonnas", "submenu.array.insert separator": "Ievietojiet atdalītāju", "menu.insert table": "Ievietojiet tabulu", "submenu.table style": "Galda stils" }, lt: { "keyboard.tooltip.functions": "Funkcijos", "keyboard.tooltip.symbols": "Simboliai", "keyboard.tooltip.greek": "Graikiškos raidės", "keyboard.tooltip.command": "LaTeX komandų režimas", "keyboard.tooltip.numeric": "Skaitmeninis", "keyboard.tooltip.alphabetic": "Romos laiškai", "tooltip.copy to clipboard": "Nukopijuoti į iškarpinę", "tooltip.redo": "Perdaryti", "tooltip.toggle virtual keyboard": "Perjungti virtualiąją klaviatūrą", "tooltip.undo": "Atšaukti", "menu.insert matrix": "Ievietojiet matricu", "menu.insert vector": "Ievietot vektoru", "submenu.array.matrix delimiters": "Matricas norobežotāji", "menu.array.add row above": "Pievienot rindu pēc", "menu.array.add row below": "Pievienot rindu pirms", "menu.array.add column after": "Pievienot kolonnu pēc", "menu.array.add column before": "Pievienot kolonnu pirms", "menu.array.delete row": "Dzēst rindu", "menu.array.delete rows": "Dzēst atlasītās rindas", "menu.array.delete column": "Dzēst kolonnu", "menu.array.delete columns": "Dzēst atlasītās kolonnas", "submenu.array.insert separator": "Ievietojiet atdalītāju", "menu.insert table": "Ievietojiet tabulu", "submenu.table style": "Tabulas stili" }, lu: { "keyboard.tooltip.functions": "Funktiounen", "keyboard.tooltip.symbols": "Symboler", "keyboard.tooltip.greek": "Griichesch Bréiwer", "keyboard.tooltip.command": "LaTeX Kommando Modus", "keyboard.tooltip.numeric": "Numeresch", "keyboard.tooltip.alphabetic": "Réimesch Bréiwer", "tooltip.copy to clipboard": "Kopéiert op Clipboard", "tooltip.redo": "Nees nei maachen", "tooltip.toggle virtual keyboard": "Wiesselt Virtuell Tastatur", "tooltip.undo": "Undoen", "menu.insert matrix": "Matrix asetzen", "menu.insert vector": "Insert Vector", "submenu.array.matrix delimiters": "Matrix Ofgrenzer", "menu.array.add row above": "Dobäizemaachen Rei No", "menu.array.add row below": "Füügt Rei vir", "menu.array.add column after": "Dobäizemaachen Kolonn No", "menu.array.add column before": "Kolonn derbäi Virun", "menu.array.delete row": "Rad läschen", "menu.array.delete rows": "Läscht Ausgewielte Reien", "menu.array.delete column": "Läscht Kolonn", "menu.array.delete columns": "Läscht Ausgewielte Kolonnen", "submenu.array.insert separator": "Insert Separator", "menu.insert table": "Dësch anzeginn", "submenu.table style": "Dësch Style" }, nl: { "keyboard.tooltip.functions": "Functies", "keyboard.tooltip.symbols": "Symbolen", "keyboard.tooltip.greek": "Griekse letters", "keyboard.tooltip.command": "LaTeX commando mode", "keyboard.tooltip.numeric": "Numeriek", "keyboard.tooltip.alphabetic": "Romeinse letters", "tooltip.copy to clipboard": "Kopiëren naar klembord", "tooltip.redo": "Opnieuw", "tooltip.toggle virtual keyboard": "Schakel naar virtueel toetsenbord", "tooltip.undo": "Ongedaan maken", "menu.insert matrix": "Matrix invoegen", "menu.insert vector": "Vector invoegen", "submenu.array.matrix delimiters": "Matrixscheidingstekens", "menu.array.add row above": "Rij toevoegen na", "menu.array.add row below": "Rij toevoegen eerder", "menu.array.add column after": "Kolom toevoegen na", "menu.array.add column before": "Kolom toevoegen voor", "menu.array.delete row": "Verwijder rij", "menu.array.delete rows": "Geselecteerde rijen verwijderen", "menu.array.delete column": "Kolom verwijderen", "menu.array.delete columns": "Geselecteerde kolommen verwijderen", "submenu.array.insert separator": "Scheidingsteken invoegen", "menu.insert table": "Tabel invoegen", "submenu.table style": "Tabelstijl" }, no: { "keyboard.tooltip.functions": "Funksjoner", "keyboard.tooltip.symbols": "Symboler", "keyboard.tooltip.greek": "Greske bokstaver", "keyboard.tooltip.command": "LaTeX kommandomodus", "keyboard.tooltip.numeric": "Numerisk", "keyboard.tooltip.alphabetic": "Romerske bokstaver", "tooltip.copy to clipboard": "Kopiere til utklippstavle", "tooltip.redo": "Gjøre om", "tooltip.toggle virtual keyboard": "Bytt virtuelt tastatur", "tooltip.undo": "Angre", "menu.insert matrix": "Sett inn matrise", "menu.insert vector": "Sett inn vektor", "submenu.array.matrix delimiters": "Matrix avgrensere", "menu.array.add row above": "Legg til rad etter", "menu.array.add row below": "Legg til rad før", "menu.array.add column after": "Legg til kolonne etter", "menu.array.add column before": "Legg til kolonne før", "menu.array.delete row": "Slett rad", "menu.array.delete rows": "Slett valgte rader", "menu.array.delete column": "Slett kolonne", "menu.array.delete columns": "Slett valgte kolonner", "submenu.array.insert separator": "Sett inn skilletegn", "menu.insert table": "Sett inn tabell", "submenu.table style": "Tabellstil" }, mk: { "keyboard.tooltip.functions": "Функции", "keyboard.tooltip.symbols": "Симболи", "keyboard.tooltip.greek": "Грчки букви", "keyboard.tooltip.command": "Режим на команда во латекс", "keyboard.tooltip.numeric": "Нумерички", "keyboard.tooltip.alphabetic": "Римски писма", "tooltip.copy to clipboard": "Копирајте во клипборд", "tooltip.redo": "Повторно", "tooltip.toggle virtual keyboard": "Вклучете ја виртуелната тастатура", "tooltip.undo": "Врати", "menu.insert matrix": "Вметнете матрица", "menu.insert vector": "Вметни вектор", "submenu.array.matrix delimiters": "Разграничувачи на матрица", "menu.array.add row above": "Додадете ред после", "menu.array.add row below": "Додади ред пред тоа", "menu.array.add column after": "Додадете колона после", "menu.array.add column before": "Додадете колона пред тоа", "menu.array.delete row": "Избриши го редот", "menu.array.delete rows": "Избришете ги избраните редови", "menu.array.delete column": "Избриши ја колоната", "menu.array.delete columns": "Избриши ја колоната", "submenu.array.insert separator": "Вметнете сепаратор", "menu.insert table": "Вметни табела", "submenu.table style": "Табела стил" }, pl: { "keyboard.tooltip.functions": "Funkcje", "keyboard.tooltip.symbols": "Symbolika", "keyboard.tooltip.greek": "Litery greckie", "keyboard.tooltip.command": "Tryb poleceń LaTeX", "keyboard.tooltip.numeric": "Numeryczne", "keyboard.tooltip.alphabetic": "Litery rzymskie", "tooltip.copy to clipboard": "Kopiuj do Schowka", "tooltip.redo": "Przywróć", "tooltip.toggle virtual keyboard": "Przełącz wirtualną klawiaturę", "tooltip.undo": "Cofnij", "menu.insert matrix": "Wstaw macierz", "menu.insert vector": "Wstaw wektor", "submenu.array.matrix delimiters": "Ograniczniki macierzy", "menu.array.add row above": "Dodaj wiersz po", "menu.array.add row below": "Dodaj wiersz przed", "menu.array.add column after": "Dodaj kolumnę po", "menu.array.add column before": "Dodaj kolumnę przed", "menu.array.delete row": "Usuń wiersz", "menu.array.delete rows": "Usuń wybrane wiersze", "menu.array.delete column": "Usuń kolumnę", "menu.array.delete columns": "Usuń wybrane kolumny", "submenu.array.insert separator": "Wstaw separator", "menu.insert table": "Wypełnij tabelę", "submenu.table style": "Styl tabelę" }, pt: { "keyboard.tooltip.functions": "Functions", "keyboard.tooltip.symbols": "Símbolos", "keyboard.tooltip.greek": "Letras gregas", "keyboard.tooltip.command": "Modo de Comando LaTeX", "keyboard.tooltip.numeric": "Numérico", "keyboard.tooltip.alphabetic": "Letras romanas", "tooltip.copy to clipboard": "Copiar para área de transferência", "tooltip.redo": "Refazer", "tooltip.toggle virtual keyboard": "Alternar teclado virtual", "tooltip.undo": "Desfazer", "menu.insert matrix": "Inserir Matriz", "menu.insert vector": "Inserir vetor", "submenu.array.matrix delimiters": "Delimitadores de matriz", "menu.array.add row above": "Adicionar linha depois", "menu.array.add row below": "Adicionar linha antes", "menu.array.add column after": "Adicionar coluna depois", "menu.array.add column before": "Adicionar coluna antes", "menu.array.delete row": "Excluir linha", "menu.array.delete rows": "Excluir linhas selecionadas", "menu.array.delete column": "Apagar Coluna", "menu.array.delete columns": "Excluir Colunas Selecionadas", "submenu.array.insert separator": "Inserir Separador", "menu.insert table": "Insira a tabela", "submenu.table style": "Estilo tabela" }, ro: { "keyboard.tooltip.functions": "Funcții", "keyboard.tooltip.symbols": "Simboluri", "keyboard.tooltip.greek": "Scrisori grecești", "keyboard.tooltip.command": "Modul de comandă latex", "keyboard.tooltip.numeric": "Numeric", "keyboard.tooltip.alphabetic": "Scrisori romane", "tooltip.copy to clipboard": "Copiați în clipboard", "tooltip.redo": "A reface", "tooltip.toggle virtual keyboard": "Comutați tastatura virtuală", "tooltip.undo": "Anula", "menu.insert matrix": "Introduceți Matrix", "menu.insert vector": "Inserați Vector", "submenu.array.matrix delimiters": "Delimitatori de matrice", "menu.array.add row above": "Adăugați rândul după", "menu.array.add row below": "Adăugați rândul înainte", "menu.array.add column after": "Adăugați o coloană după", "menu.array.add column before": "Adăugați o coloană înainte", "menu.array.delete row": "Ștergeți rândul", "menu.array.delete rows": "Ștergeți rândurile selectate", "menu.array.delete column": "Ștergeți coloana", "menu.array.delete columns": "Ștergeți coloanele selectate", "submenu.array.insert separator": "Introduceți separatorul", "menu.insert table": "Introduceți tabelul", "submenu.table style": "Table style" }, ru: { "keyboard.tooltip.functions": "Функции", "keyboard.tooltip.symbols": "Символы", "keyboard.tooltip.greek": "Греческие буквы", "keyboard.tooltip.command": "Режим командной строки Латекс", "keyboard.tooltip.numeric": "числовой", "keyboard.tooltip.alphabetic": "Латинские буквы", "tooltip.copy to clipboard": "Скопировать в буфер обмена", "tooltip.redo": "переделывать", "tooltip.toggle virtual keyboard": "Переключить виртуальную клавиатуру", "tooltip.undo": "расстегивать", "menu.insert matrix": "Вставить матрицу", "menu.insert vector": "Вставить вектор", "submenu.array.matrix delimiters": "Матричные разделители", "menu.array.add row above": "Добавить строку после", "menu.array.add row below": "Добавить строку перед", "menu.array.add column after": "Добавить столбец после", "menu.array.add column before": "Добавить столбец перед", "menu.array.delete row": "Удалить строку", "menu.array.delete rows": "Удалить выбранные строки", "menu.array.delete column": "Удалить столбец", "menu.array.delete columns": "Удалить выбранные столбцы", "submenu.array.insert separator": "Вставить разделитель", "menu.insert table": "Вставить таблицу", "submenu.table style": "Табличный стиль" }, sk: { "keyboard.tooltip.functions": "Functions", "keyboard.tooltip.symbols": "Symboly", "keyboard.tooltip.greek": "Grécke listy", "keyboard.tooltip.command": "Príkazový režim LaTeX", "keyboard.tooltip.numeric": "Numerické", "keyboard.tooltip.alphabetic": "Rímske listy", "tooltip.copy to clipboard": "Skopírovať do schránky", "tooltip.redo": "Znova", "tooltip.toggle virtual keyboard": "Prepnúť virtuálnu klávesnicu", "tooltip.undo": "Vrátenie späť", "menu.insert matrix": "Vložte maticu", "menu.insert vector": "Vložte vektor", "submenu.array.matrix delimiters": "Oddeľovače matíc", "menu.array.add row above": "Pridajte riadok za", "menu.array.add row below": "Pridajte riadok pred", "menu.array.add column after": "Pridať stĺpec za", "menu.array.add column before": "Pridajte stĺpec predtým", "menu.array.delete row": "Odstrániť riadok", "menu.array.delete rows": "Odstrániť vybraté riadky", "menu.array.delete column": "Odstrániť stĺpec", "menu.array.delete columns": "Odstrániť vybraté stĺpce", "submenu.array.insert separator": "Vložte oddeľovač", "menu.insert table": "Vložte tabuľku", "submenu.table style": "Štýl tabuľky" }, sl: { "keyboard.tooltip.functions": "Funkcije", "keyboard.tooltip.symbols": "Simboli", "keyboard.tooltip.greek": "Grška pisma", "keyboard.tooltip.command": "Ukazni način LaTeX", "keyboard.tooltip.numeric": "Številsko", "keyboard.tooltip.alphabetic": "Rimska pisma", "tooltip.copy to clipboard": "Kopirati v odložišče", "tooltip.redo": "Ponovi", "tooltip.toggle virtual keyboard": "Preklop navidezne tipkovnice", "tooltip.undo": "Razveljavi", "menu.insert matrix": "Vstavi matrico", "menu.insert vector": "Vstavi vektor", "submenu.array.matrix delimiters": "Matrični ločevalniki", "menu.array.add row above": "Dodaj vrstico po", "menu.array.add row below": "Dodaj vrstico prej", "menu.array.add column after": "Dodaj stolpec po", "menu.array.add column before": "Dodaj stolpec prej", "menu.array.delete row": "Izbriši vrstico", "menu.array.delete rows": "Izbriši izbrane vrstice", "menu.array.delete column": "Izbriši stolpec", "menu.array.delete columns": "Izbriši izbrane stolpce", "submenu.array.insert separator": "Vstavi ločilo", "menu.insert table": "Vstavi tabelo", "submenu.table style": "Tabela slog" }, sq: { "keyboard.tooltip.functions": "Funksione", "keyboard.tooltip.symbols": "Simbolet", "keyboard.tooltip.greek": "Letrat Greke", "keyboard.tooltip.command": "Modaliteti i komandës latex", "keyboard.tooltip.numeric": "Numerike", "keyboard.tooltip.alphabetic": "Letrat romake", "tooltip.copy to clipboard": "Kopjoni në Clipboard", "tooltip.redo": "Riparo", "tooltip.toggle virtual keyboard": "Aktivizo tastierën virtuale", "tooltip.undo": "Zhbëj", "menu.insert matrix": "Vendosni Matricën", "menu.insert vector": "Vendos vektorin", "submenu.array.matrix delimiters": "Përcaktuesit e matricës", "menu.array.add row above": "Shto Rreshtin Pas", "menu.array.add row below": "Shto Rreshtin Para", "menu.array.add column after": "Shto kolonën pas", "menu.array.add column before": "Shto kolonën para", "menu.array.delete row": "Fshi Rreshtin", "menu.array.delete rows": "Fshi rreshtat e zgjedhur", "menu.array.delete column": "Fshi kolonën", "menu.array.delete columns": "Fshi kolonat e zgjedhura", "submenu.array.insert separator": "Vendos Ndarësin", "menu.insert table": "Vendos tabelën", "submenu.table style": "Stili tabelën" }, sr: { "keyboard.tooltip.functions": "Функције", "keyboard.tooltip.symbols": "Симболи", "keyboard.tooltip.greek": "Греек Леттерс", "keyboard.tooltip.command": "ЛаТеКс командни режим", "keyboard.tooltip.numeric": "Нумерички", "keyboard.tooltip.alphabetic": "Римска писма", "tooltip.copy to clipboard": "Копирајте у међуспремник", "tooltip.redo": "Понови", "tooltip.toggle virtual keyboard": "Укључи / искључи виртуелну тастатуру", "tooltip.undo": "Опозови", "menu.insert matrix": "Уметни матрицу", "menu.insert vector": "Уметни вектор", "submenu.array.matrix delimiters": "Матрик Делимитерс", "menu.array.add row above": "Додај ред после", "menu.array.add row below": "Додај ред пре", "menu.array.add column after": "Додај колону после", "menu.array.add column before": "Додај колону пре", "menu.array.delete row": "Избриши ред", "menu.array.delete rows": "Избриши изабране редове", "menu.array.delete column": "Избриши колону", "menu.array.delete columns": "Избриши изабране колоне", "submenu.array.insert separator": "Уметни сепаратор", "menu.insert table": "Убаци табелу", "submenu.table style": "Табеларни стил" }, sv: { "keyboard.tooltip.functions": "Funktioner", "keyboard.tooltip.symbols": "Symboler", "keyboard.tooltip.greek": "Grekiska bokstäver", "keyboard.tooltip.command": "LaTeX kommandoläge", "keyboard.tooltip.numeric": "Numerisk", "keyboard.tooltip.alphabetic": "Romerska bokstäver", "tooltip.copy to clipboard": "Kopiera till Urklipp", "tooltip.redo": "Göra om", "tooltip.toggle virtual keyboard": "Växla virtuellt tangentbord", "tooltip.undo": "Ångra", "menu.insert matrix": "Sätt in matris", "menu.insert vector": "Infoga vektor", "submenu.array.matrix delimiters": "Matrisavgränsare", "menu.array.add row above": "Lägg till rad efter", "menu.array.add row below": "Lägg till rad före", "menu.array.add column after": "Lägg till kolumn efter", "menu.array.add column before": "Lägg till kolumn före", "menu.array.delete row": "Radera rad", "menu.array.delete rows": "Ta bort valda rader", "menu.array.delete column": "Ta bort kolumn", "menu.array.delete columns": "Ta bort valda kolumner", "submenu.array.insert separator": "Sätt i separator", "menu.insert table": "Infoga tabell", "submenu.table style": "Tabellstil" }, th: { "keyboard.tooltip.functions": "ฟังก์ชั่น", "keyboard.tooltip.symbols": "สัญลักษณ์", "keyboard.tooltip.greek": "อักษรกรีก", "keyboard.tooltip.command": "โหมดคำสั่ง น้ำยาง", "keyboard.tooltip.numeric": "ตัวเลข", "keyboard.tooltip.alphabetic": "อักษรโรมัน", "tooltip.copy to clipboard": "คัดลอกไปที่คลิปบอร์ด", "tooltip.redo": "ทำซ้ำ", "tooltip.toggle virtual keyboard": "สลับแป้นพิมพ์เสมือน", "tooltip.undo": "เลิกทำ", "menu.insert matrix": "แทรกเมทริกซ์", "menu.insert vector": "แทรกเวกเตอร์", "submenu.array.matrix delimiters": "ตัวคั่นเมทริกซ์", "menu.array.add row above": "เพิ่มแถวหลัง", "menu.array.add row below": "เพิ่มแถวก่อน", "menu.array.add column after": "เพิ่มคอลัมน์หลัง", "menu.array.add column before": "เพิ่มคอลัมน์ก่อน", "menu.array.delete row": "ลบแถว", "menu.array.delete rows": "ลบแถวที่เลือก", "menu.array.delete column": "ลบคอลัมน์", "menu.array.delete columns": "ลบคอลัมน์ที่เลือก", "submenu.array.insert separator": "ตัวคั่นแทรก", "menu.insert table": "แทรกตาราง", "submenu.table style": "สไตล์ตาราง" }, tr: { "keyboard.tooltip.functions": "Fonksiyonlar", "keyboard.tooltip.symbols": "Semboller", "keyboard.tooltip.greek": "Yunan harfleri", "keyboard.tooltip.command": "LaTeX Komut Modu", "keyboard.tooltip.numeric": "Sayısal", "keyboard.tooltip.alphabetic": "Roma Harfleri", "tooltip.copy to clipboard": "Panoya kopyala", "tooltip.redo": "Yeniden yap", "tooltip.toggle virtual keyboard": "Sanal Klavyeyi Aç/Kapat", "tooltip.undo": "Geri alma", "menu.insert matrix": "Matris Ekle", "menu.insert vector": "Vektör Ekle", "submenu.array.matrix delimiters": "Matris Sınırlayıcılar", "menu.array.add row above": "Satırdan Sonra Ekle", "menu.array.add row below": "Önce Satır Ekle", "menu.array.add column after": "Sonra Sütun Ekle", "menu.array.add column before": "Önce Sütun Ekle", "menu.array.delete row": "Sırayı sil", "menu.array.delete rows": "Seçili Satırları Sil", "menu.array.delete column": "Sütunu Sil", "menu.array.delete columns": "Seçili Sütunları Sil", "submenu.array.insert separator": "Ayırıcı Ekle", "menu.insert table": "Tablo Ekle", "submenu.table style": "Tablo Stili" }, uk: { "keyboard.tooltip.functions": "Функції", "keyboard.tooltip.symbols": "Символи", "keyboard.tooltip.greek": "Грецькі літери", "keyboard.tooltip.command": "Командний режим латексу", "keyboard.tooltip.numeric": "Числовий", "keyboard.tooltip.alphabetic": "Римські літери", "tooltip.copy to clipboard": "Копіювати в буфер обміну", "tooltip.redo": "Повторити", "tooltip.toggle virtual keyboard": "Переключити віртуальну клавіатуру", "tooltip.undo": "Скасувати", "menu.insert matrix": "Вставити матрицю", "menu.insert vector": "Вставити вектор", "submenu.array.matrix delimiters": "Матричні роздільники", "menu.array.add row above": "Додати рядок після", "menu.array.add row below": "Додати рядок до", "menu.array.add column after": "Додати стовпець після", "menu.array.add column before": "Додати стовпець перед", "menu.array.delete row": "Видалити рядок", "menu.array.delete rows": "Видалити вибрані рядки", "menu.array.delete column": "Видалити стовпець", "menu.array.delete columns": "Видалити вибрані стовпці", "submenu.array.insert separator": "Вставте роздільник", "menu.insert table": "Вставити таблицю", "submenu.table style": "Стиль таблиці" }, vi: { "keyboard.tooltip.functions": "Chức năng", "keyboard.tooltip.symbols": "Ký hiệu", "keyboard.tooltip.greek": "Chữ Hy Lạp", "keyboard.tooltip.command": "Chế độ lệnh LaTeX", "keyboard.tooltip.numeric": "Số", "keyboard.tooltip.alphabetic": "Chữ cái La mã", "tooltip.copy to clipboard": "Sao chép vào clipboard", "tooltip.redo": "Làm lại", "tooltip.toggle virtual keyboard": "Chuyển đổi bàn phím ảo", "tooltip.undo": "Hoàn tác", "menu.insert matrix": "Chèn ma trận", "menu.insert vector": "Insert Vector", "submenu.array.matrix delimiters": "Dấu phân cách ma trận", "menu.array.add row above": "Thêm hàng sau", "menu.array.add row below": "Thêm hàng trước", "menu.array.add column after": "Thêm cột sau", "menu.array.add column before": "Thêm cột trước", "menu.array.delete row": "Xóa hàng", "menu.array.delete rows": "Xóa hàng đã chọn", "menu.array.delete column": "Xóa cột", "menu.array.delete columns": "Xóa các cột đã chọn", "submenu.array.insert separator": "Chèn dấu phân cách", "menu.insert table": "Chèn bảng", "submenu.table style": "Kiểu bảng" }, zh_cn: { "keyboard.tooltip.functions": "职能", "keyboard.tooltip.symbols": "符号", "keyboard.tooltip.greek": "希腊字母", "keyboard.tooltip.command": "乳胶 命令模式", "keyboard.tooltip.numeric": "数字", "keyboard.tooltip.alphabetic": "罗马字母", "tooltip.copy to clipboard": "复制到剪贴板", "tooltip.redo": "重做", "tooltip.toggle virtual keyboard": "切换虚拟键盘", "tooltip.undo": "撤消", "menu.insert matrix": "插入矩阵", "menu.insert vector": "插入向量", "submenu.array.matrix delimiters": "矩阵分隔符", "menu.array.add row above": "在后面添加行", "menu.array.add row below": "在前面添加行", "menu.array.add column after": "在后面添加列r", "menu.array.add column before": "在前面添加列", "menu.array.delete row": "删除行", "menu.array.delete rows": "删除选定行", "menu.array.delete column": "删除列", "menu.array.delete columns": "删除选定的列", "submenu.array.insert separator": "插入分隔符", "menu.insert table": "插入表格", "submenu.table style": "表格样式" }, zh_tw: { "keyboard.tooltip.functions": "職能", "keyboard.tooltip.symbols": "符號", "keyboard.tooltip.greek": "希臘字母", "keyboard.tooltip.command": "乳膠命令模式", "keyboard.tooltip.numeric": "數字", "keyboard.tooltip.alphabetic": "羅馬字母", "tooltip.copy to clipboard": "複製到剪貼板", "tooltip.redo": "重做", "tooltip.toggle virtual keyboard": "切換虛擬鍵盤", "tooltip.undo": "撤消", "menu.insert matrix": "插入矩陣", "menu.insert vector": "插入向量", "submenu.array.matrix delimiters": "矩陣分隔符", "menu.array.add row above": "在後面添加行", "menu.array.add row below": "在前面添加行", "menu.array.add column after": "在後面添加列", "menu.array.add column before": "在前面添加列", "menu.array.delete row": "刪除行", "menu.array.delete rows": "刪除選定行", "menu.array.delete column": "刪除列", "menu.array.delete columns": "刪除選定的列", "submenu.array.insert separator": "插入分隔符", "menu.insert table": "插入表格", "submenu.table style": "表格樣式" } };
    function fe() {
      return "window" in globalThis && "document" in globalThis;
    }
    function Wi() {
      if (!fe())
        throw new Error(`<math-field> is an interactive component that needs to run in a browser environment
If you are using nextjs, see https://nextjs.org/docs/advanced-features/dynamic-import#with-no-ssr`);
    }
    function fn() {
      return "matchMedia" in window ? window.matchMedia("(any-pointer: coarse)").matches : "ontouchstart" in window || navigator.maxTouchPoints > 0;
    }
    function Ui() {
      return typeof navigator.vibrate == "function";
    }
    function Xt() {
      var e, t;
      if (!fe())
        return "other";
      let r = (t = (e = navigator.userAgentData) == null ? void 0 : e.platform) != null ? t : navigator.platform;
      return /^mac/i.test(r) ? navigator.maxTouchPoints === 5 ? "ios" : "macos" : /^win/i.test(r) ? "windows" : /android/i.test(navigator.userAgent) ? "android" : /iphone|ipod|ipad/i.test(navigator.userAgent) ? "ios" : /\bcros\b/i.test(navigator.userAgent) ? "chromeos" : "other";
    }
    function Vo() {
      if (!fe())
        return true;
      if (/firefox/i.test(navigator.userAgent)) {
        let r = navigator.userAgent.match(/firefox\/(\d+)/i);
        return r ? parseInt(r[1]) >= 78 : false;
      }
      if (/trident/i.test(navigator.userAgent))
        return false;
      if (/edge/i.test(navigator.userAgent)) {
        let r = navigator.userAgent.match(/edg\/(\d+)/i);
        return r ? parseInt(r[1]) >= 79 : false;
      }
      return true;
    }
    var U = { strings: hn, _locale: "", get locale() {
      return U._locale || (U._locale = fe() ? navigator.language.slice(0, 5) : "en"), U._locale;
    }, set locale(r) {
      U._locale = r;
    }, merge(r, e) {
      if (r && e) {
        let t = U._locale;
        U.locale = r, U.strings[r] = b(b({}, U.strings[r]), e), U.locale = t;
      } else if (r && !e)
        for (let t of Object.keys(r))
          U.merge(t, r[t]);
    } };
    function kt(r) {
      if (r === void 0)
        return;
      let e = U.locale.slice(0, 2), t = "";
      if (U.strings[U.locale] && (t = U.strings[U.locale][r]), !t && U.strings[e] && (t = U.strings[e][r]), t || (t = U.strings.en[r]), !!t)
        return t;
    }
    var vl = { m0: "#3F3D99", m1: "#993D71", m2: "#998B3D", m3: "#3D9956", m4: "#3D5A99", m5: "#993D90", m6: "#996D3D", m7: "#43993D", m8: "#3D7999", m9: "#843D99" }, wl = { blue: "#0072BD", orange: "#D95319", yellow: "#EDB120", purple: "#7E2F8E", green: "#77AC30", cyan: "#4DBEEE", red: "#A2142F" }, pi = { red: "#fbbbb6", orange: "#ffe0c2", yellow: "#fff1c2", lime: "#d0e8b9", green: "#bceac4", teal: "#b9f1f1", blue: "#b6d9fb", indigo: "#d1c2f0", purple: "#e3baf8", magenta: "#f9c8e0", black: "#353535", "dark-grey": "#8C8C8C", grey: "#D0D0D0", "light-grey": "#F0F0F0", white: "#ffffff" }, hi = { red: "#d7170b", orange: "#fe8a2b", yellow: "#ffc02b", lime: "#63b215", green: "#21ba3a", teal: "#17cfcf", blue: "#0d80f2", indigo: "#63c", purple: "#a219e6", magenta: "#eb4799", black: "#000", "dark-grey": "#666", grey: "#A6A6A6", "light-grey": "#d4d5d2", white: "#ffffff" }, gn = { Red: "red", Orange: "orange", Yellow: "yellow", LimeGreen: "lime", Green: "green", TealBlue: "teal", Blue: "blue", Violet: "indigo", Purple: "purple", Magenta: "magenta", Black: "black", Gray: "grey", White: "white" }, kl = { Apricot: "#FBB982", Aquamarine: "#00B5BE", Bittersweet: "#C04F17", Black: "#221E1F", Blue: "#2D2F92", BlueGreen: "#00B3B8", BlueViolet: "#473992", BrickRed: "#B6321C", Brown: "#792500", BurntOrange: "#F7921D", CadetBlue: "#74729A", CarnationPink: "#F282B4", Cerulean: "#00A2E3", CornflowerBlue: "#41B0E4", Cyan: "#00AEEF", Dandelion: "#FDBC42", DarkOrchid: "#A4538A", Emerald: "#00A99D", ForestGreen: "#009B55", Fuchsia: "#8C368C", Goldenrod: "#FFDF42", Gray: "#949698", Green: "#00A64F", GreenYellow: "#DFE674", JungleGreen: "#00A99A", Lavender: "#F49EC4", Limegreen: "#8DC73E", Magenta: "#EC008C", Mahogany: "#A9341F", Maroon: "#AF3235", Melon: "#F89E7B", MidnightBlue: "#006795", Mulberry: "#A93C93", NavyBlue: "#006EB8", OliveGreen: "#3C8031", Orange: "#F58137", OrangeRed: "#ED135A", Orchid: "#AF72B0", Peach: "#F7965A", Periwinkle: "#7977B8", PineGreen: "#008B72", Plum: "#92268F", ProcessBlue: "#00B0F0", Purple: "#99479B", RawSienna: "#974006", Red: "#ED1B23", RedOrange: "#F26035", RedViolet: "#A1246B", Rhodamine: "#EF559F", RoyalBlue: "#0071BC", RoyalPurple: "#613F99", RubineRed: "#ED017D", Salmon: "#F69289", SeaGreen: "#3FBC9D", Sepia: "#671800", SkyBlue: "#46C5DD", SpringGreen: "#C6DC67", Tan: "#DA9D76", TealBlue: "#00AEB3", Thistle: "#D883B7", Turquoise: "#00B4CE", Violet: "#58429B", VioletRed: "#EF58A0", White: "#FFFFFF", WildStrawberry: "#EE2967", Yellow: "#FFF200", YellowGreen: "#98CC70", YellowOrange: "#FAA21A" };
    function br(r) {
      var u, d, m, h, f, y;
      let e = r.split("!"), t, i, o, a = 255, n = 255, s = 255, l = -1, c = e.length > 0 && e[0].startsWith("-");
      c && (e[0] = e[0].slice(1));
      for (let w = 0; w < e.length; w++) {
        t = a, i = n, o = s;
        let k = (u = e[w].trim().match(/^([A-Za-z\d]+)/)) == null ? void 0 : u[1], S = k == null ? void 0 : k.toLowerCase(), T = k && (y = (f = (h = (m = (d = hi[S]) != null ? d : hi[gn[k]]) != null ? m : wl[k]) != null ? h : kl[k]) != null ? f : vl[k]) != null ? y : e[w].trim(), C = T.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i);
        if (C != null && C[1] && C[2] && C[3])
          a = Math.max(0, Math.min(255, Number.parseInt(C[1], 16))), n = Math.max(0, Math.min(255, Number.parseInt(C[2], 16))), s = Math.max(0, Math.min(255, Number.parseInt(C[3], 16)));
        else if (C = T.match(/^#([\da-f]{3})$/i), C != null && C[1]) {
          let K = Number.parseInt(C[1][0], 16), M = Number.parseInt(C[1][1], 16), R = Number.parseInt(C[1][2], 16);
          a = Math.max(0, Math.min(255, K * 16 + K)), n = Math.max(0, Math.min(255, M * 16 + M)), s = Math.max(0, Math.min(255, R * 16 + R));
        } else if (C = T.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i), C != null && C[1] && C[2] && C[3])
          a = Math.max(0, Math.min(255, Number.parseInt(C[1]))), n = Math.max(0, Math.min(255, Number.parseInt(C[2]))), s = Math.max(0, Math.min(255, Number.parseInt(C[3])));
        else
          return;
        l >= 0 && (a = (1 - l) * a + l * t, n = (1 - l) * n + l * i, s = (1 - l) * s + l * o, l = -1), w + 1 < e.length && (l = Math.max(0, Math.min(100, Number.parseInt(e[++w]))) / 100);
      }
      return l >= 0 && (a = l * a + (1 - l) * t, n = l * n + (1 - l) * i, s = l * s + (1 - l) * o), c && (a = 255 - a, n = 255 - n, s = 255 - s), "#" + ("00" + Math.round(a).toString(16)).slice(-2) + ("00" + Math.round(n).toString(16)).slice(-2) + ("00" + Math.round(s).toString(16)).slice(-2);
    }
    function Rr(r) {
      var e, t;
      return r = r.trim(), (t = (e = pi[r.toLowerCase()]) != null ? e : pi[gn[r]]) != null ? t : br(r);
    }
    function Sl(r) {
      if (!r || r[0] !== "#")
        return;
      r = r.slice(1);
      let e;
      return r.length <= 4 ? (e = { r: parseInt(r[0] + r[0], 16), g: parseInt(r[1] + r[1], 16), b: parseInt(r[2] + r[2], 16) }, r.length === 4 && (e.a = parseInt(r[3] + r[3], 16) / 255)) : (e = { r: parseInt(r[0] + r[1], 16), g: parseInt(r[2] + r[3], 16), b: parseInt(r[4] + r[5], 16) }, r.length === 8 && (e.a = parseInt(r[6] + r[7], 16) / 255)), e && e.a === void 0 && (e.a = 1), e;
    }
    function Ho(r, e, t) {
      return t < 0 && (t += 6), t >= 6 && (t -= 6), t < 1 ? (e - r) * t + r : t < 3 ? e : t < 4 ? (e - r) * (4 - t) + r : r;
    }
    function _l(r) {
      let [e, t, i] = [r.h, r.s, r.l];
      e = (e + 360) % 360 / 60, i = Math.max(0, Math.min(i, 1)), t = Math.max(0, Math.min(t, 1));
      let o = i <= 0.5 ? i * (t + 1) : i + t - i * t, a = i * 2 - o;
      return { r: Math.round(255 * Ho(a, o, e + 2)), g: Math.round(255 * Ho(a, o, e)), b: Math.round(255 * Ho(a, o, e - 2)) };
    }
    function Go(r) {
      return r < 0 ? 0 : r > 255 ? 255 : Math.round(r);
    }
    function Ml(r) {
      let { r: e, g: t, b: i } = r, o = ((1 << 24) + (Go(e) << 16) + (Go(t) << 8) + Go(i)).toString(16).slice(1);
      return o[0] === o[1] && o[2] === o[3] && o[4] === o[5] && o[6] === o[7] && (o = o[0] + o[2] + o[4]), "#" + o;
    }
    function Al(r) {
      let { r: e, g: t, b: i } = r;
      e = e / 255, t = t / 255, i = i / 255;
      let o = Math.min(e, t, i), a = Math.max(e, t, i), n = a - o, s, l;
      a === o ? s = 0 : e === a ? s = (t - i) / n : t === a ? s = 2 + (i - e) / n : i === a && (s = 4 + (e - t) / n), s = Math.min(s * 60, 360), s < 0 && (s += 360);
      let c = (o + a) / 2;
      return a === o ? l = 0 : c <= 0.5 ? l = n / (a + o) : l = n / (2 - a - o), { h: s, s: l, l: c };
    }
    function Jo(r) {
      let e = Sl(r);
      if (!e)
        return r;
      let { h: t, s: i, l: o } = Al(e);
      return i += 0.1, o -= 0.1, Ml(_l({ h: t, s: i, l: o }));
    }
    var p2 = [0, 0.69444, 0, 0], L = [0, 0.61111, 0, 0], B = [0.25, 0.75, 0, 0], O = [0, 0.44444, 0, 0], z = [0, 0.68611, 0, 0], N = [0.19444, 0.69444, 0, 0], I = [0, 0.68333, 0, 0], $2 = [0, 0.68889, 0, 0], G = [0, 0.69141, 0, 0], q = [0, 0, 0, 0], ce = [0, 0.64444, 0, 0], ge = [0, 0.69224, 0, 0], ye = [0.19444, 0.44444, 0, 0], Me = [0.65002, 1.15, 0, 0], Ce = [0, 0.55556, 0, 0], De = [0.35001, 0.85, 0, 0], Be = [1.25003, 1.75, 0, 0], Oe = [0.95003, 1.45, 0, 0], Ve = [0, 0.75, 0, 0], He = [0, 0.47534, 0, 0], it = [0.25001, 0.75, 0, 0], ot = [0.55001, 1.05, 0, 0], Wo = [0.16667, 0.68889, 0, 0], at = [0.08167, 0.58167, 0, 0], yn = { "AMS-Regular": { 32: q, 65: $2, 66: $2, 67: $2, 68: $2, 69: $2, 70: $2, 71: $2, 72: $2, 73: $2, 74: Wo, 75: $2, 76: $2, 77: $2, 78: $2, 79: Wo, 80: $2, 81: Wo, 82: $2, 83: $2, 84: $2, 85: $2, 86: $2, 87: $2, 88: $2, 89: $2, 90: $2, 107: $2, 160: q, 165: [0, 0.675, 0.025, 0], 174: [0.15559, 0.69224, 0, 0], 240: $2, 295: $2, 710: [0, 0.825, 0, 0], 732: [0, 0.9, 0, 0], 770: [0, 0.825, 0, 0], 771: [0, 0.9, 0, 0], 989: at, 1008: [0, 0.43056, 0.04028, 0], 8245: [0, 0.54986, 0, 0], 8463: $2, 8487: $2, 8498: $2, 8502: $2, 8503: $2, 8504: $2, 8513: $2, 8592: [-0.03598, 0.46402, 0, 0], 8594: [-0.03598, 0.46402, 0, 0], 8602: [-0.13313, 0.36687, 0, 0], 8603: [-0.13313, 0.36687, 0, 0], 8606: [0.01354, 0.52239, 0, 0], 8608: [0.01354, 0.52239, 0, 0], 8610: [0.01354, 0.52239, 0, 0], 8611: [0.01354, 0.52239, 0, 0], 8619: [0, 0.54986, 0, 0], 8620: [0, 0.54986, 0, 0], 8621: [-0.13313, 0.37788, 0, 0], 8622: [-0.13313, 0.36687, 0, 0], 8624: ge, 8625: ge, 8630: [0, 0.43056, 0, 0], 8631: [0, 0.43056, 0, 0], 8634: [0.08198, 0.58198, 0, 0], 8635: [0.08198, 0.58198, 0, 0], 8638: [0.19444, 0.69224, 0, 0], 8639: [0.19444, 0.69224, 0, 0], 8642: [0.19444, 0.69224, 0, 0], 8643: [0.19444, 0.69224, 0, 0], 8644: [0.1808, 0.675, 0, 0], 8646: [0.1808, 0.675, 0, 0], 8647: [0.1808, 0.675, 0, 0], 8648: [0.19444, 0.69224, 0, 0], 8649: [0.1808, 0.675, 0, 0], 8650: [0.19444, 0.69224, 0, 0], 8651: [0.01354, 0.52239, 0, 0], 8652: [0.01354, 0.52239, 0, 0], 8653: [-0.13313, 0.36687, 0, 0], 8654: [-0.13313, 0.36687, 0, 0], 8655: [-0.13313, 0.36687, 0, 0], 8666: [0.13667, 0.63667, 0, 0], 8667: [0.13667, 0.63667, 0, 0], 8669: [-0.13313, 0.37788, 0, 0], 8672: [-0.064, 0.437, 0, 0], 8674: [-0.064, 0.437, 0, 0], 8705: [0, 0.825, 0, 0], 8708: $2, 8709: at, 8717: [0, 0.43056, 0, 0], 8722: [-0.03598, 0.46402, 0, 0], 8724: [0.08198, 0.69224, 0, 0], 8726: at, 8733: ge, 8736: ge, 8737: ge, 8738: [0.03517, 0.52239, 0, 0], 8739: at, 8740: [0.25142, 0.74111, 0, 0], 8741: at, 8742: [0.25142, 0.74111, 0, 0], 8756: ge, 8757: ge, 8764: [-0.13313, 0.36687, 0, 0], 8765: [-0.13313, 0.37788, 0, 0], 8769: [-0.13313, 0.36687, 0, 0], 8770: [-0.03625, 0.46375, 0, 0], 8774: [0.30274, 0.79383, 0, 0], 8776: [-0.01688, 0.48312, 0, 0], 8778: at, 8782: [0.06062, 0.54986, 0, 0], 8783: [0.06062, 0.54986, 0, 0], 8785: [0.08198, 0.58198, 0, 0], 8786: [0.08198, 0.58198, 0, 0], 8787: [0.08198, 0.58198, 0, 0], 8790: ge, 8791: [0.22958, 0.72958, 0, 0], 8796: [0.08198, 0.91667, 0, 0], 8806: [0.25583, 0.75583, 0, 0], 8807: [0.25583, 0.75583, 0, 0], 8808: [0.25142, 0.75726, 0, 0], 8809: [0.25142, 0.75726, 0, 0], 8812: [0.25583, 0.75583, 0, 0], 8814: [0.20576, 0.70576, 0, 0], 8815: [0.20576, 0.70576, 0, 0], 8816: [0.30274, 0.79383, 0, 0], 8817: [0.30274, 0.79383, 0, 0], 8818: [0.22958, 0.72958, 0, 0], 8819: [0.22958, 0.72958, 0, 0], 8822: [0.1808, 0.675, 0, 0], 8823: [0.1808, 0.675, 0, 0], 8828: [0.13667, 0.63667, 0, 0], 8829: [0.13667, 0.63667, 0, 0], 8830: [0.22958, 0.72958, 0, 0], 8831: [0.22958, 0.72958, 0, 0], 8832: [0.20576, 0.70576, 0, 0], 8833: [0.20576, 0.70576, 0, 0], 8840: [0.30274, 0.79383, 0, 0], 8841: [0.30274, 0.79383, 0, 0], 8842: [0.13597, 0.63597, 0, 0], 8843: [0.13597, 0.63597, 0, 0], 8847: [0.03517, 0.54986, 0, 0], 8848: [0.03517, 0.54986, 0, 0], 8858: [0.08198, 0.58198, 0, 0], 8859: [0.08198, 0.58198, 0, 0], 8861: [0.08198, 0.58198, 0, 0], 8862: [0, 0.675, 0, 0], 8863: [0, 0.675, 0, 0], 8864: [0, 0.675, 0, 0], 8865: [0, 0.675, 0, 0], 8872: ge, 8873: ge, 8874: ge, 8876: $2, 8877: $2, 8878: $2, 8879: $2, 8882: [0.03517, 0.54986, 0, 0], 8883: [0.03517, 0.54986, 0, 0], 8884: [0.13667, 0.63667, 0, 0], 8885: [0.13667, 0.63667, 0, 0], 8888: [0, 0.54986, 0, 0], 8890: [0.19444, 0.43056, 0, 0], 8891: [0.19444, 0.69224, 0, 0], 8892: [0.19444, 0.69224, 0, 0], 8901: [0, 0.54986, 0, 0], 8903: at, 8905: at, 8906: at, 8907: ge, 8908: ge, 8909: [-0.03598, 0.46402, 0, 0], 8910: [0, 0.54986, 0, 0], 8911: [0, 0.54986, 0, 0], 8912: [0.03517, 0.54986, 0, 0], 8913: [0.03517, 0.54986, 0, 0], 8914: [0, 0.54986, 0, 0], 8915: [0, 0.54986, 0, 0], 8916: ge, 8918: [0.0391, 0.5391, 0, 0], 8919: [0.0391, 0.5391, 0, 0], 8920: [0.03517, 0.54986, 0, 0], 8921: [0.03517, 0.54986, 0, 0], 8922: [0.38569, 0.88569, 0, 0], 8923: [0.38569, 0.88569, 0, 0], 8926: [0.13667, 0.63667, 0, 0], 8927: [0.13667, 0.63667, 0, 0], 8928: [0.30274, 0.79383, 0, 0], 8929: [0.30274, 0.79383, 0, 0], 8934: [0.23222, 0.74111, 0, 0], 8935: [0.23222, 0.74111, 0, 0], 8936: [0.23222, 0.74111, 0, 0], 8937: [0.23222, 0.74111, 0, 0], 8938: [0.20576, 0.70576, 0, 0], 8939: [0.20576, 0.70576, 0, 0], 8940: [0.30274, 0.79383, 0, 0], 8941: [0.30274, 0.79383, 0, 0], 8994: [0.19444, 0.69224, 0, 0], 8995: [0.19444, 0.69224, 0, 0], 9416: [0.15559, 0.69224, 0, 0], 9484: ge, 9488: ge, 9492: [0, 0.37788, 0, 0], 9496: [0, 0.37788, 0, 0], 9585: [0.19444, 0.68889, 0, 0], 9586: [0.19444, 0.74111, 0, 0], 9632: [0, 0.675, 0, 0], 9633: [0, 0.675, 0, 0], 9650: [0, 0.54986, 0, 0], 9651: [0, 0.54986, 0, 0], 9654: [0.03517, 0.54986, 0, 0], 9660: [0, 0.54986, 0, 0], 9661: [0, 0.54986, 0, 0], 9664: [0.03517, 0.54986, 0, 0], 9674: [0.11111, 0.69224, 0, 0], 9733: [0.19444, 0.69224, 0, 0], 10003: ge, 10016: ge, 10731: [0.11111, 0.69224, 0, 0], 10846: [0.19444, 0.75583, 0, 0], 10877: [0.13667, 0.63667, 0, 0], 10878: [0.13667, 0.63667, 0, 0], 10885: [0.25583, 0.75583, 0, 0], 10886: [0.25583, 0.75583, 0, 0], 10887: [0.13597, 0.63597, 0, 0], 10888: [0.13597, 0.63597, 0, 0], 10889: [0.26167, 0.75726, 0, 0], 10890: [0.26167, 0.75726, 0, 0], 10891: [0.48256, 0.98256, 0, 0], 10892: [0.48256, 0.98256, 0, 0], 10901: [0.13667, 0.63667, 0, 0], 10902: [0.13667, 0.63667, 0, 0], 10933: [0.25142, 0.75726, 0, 0], 10934: [0.25142, 0.75726, 0, 0], 10935: [0.26167, 0.75726, 0, 0], 10936: [0.26167, 0.75726, 0, 0], 10937: [0.26167, 0.75726, 0, 0], 10938: [0.26167, 0.75726, 0, 0], 10949: [0.25583, 0.75583, 0, 0], 10950: [0.25583, 0.75583, 0, 0], 10955: [0.28481, 0.79383, 0, 0], 10956: [0.28481, 0.79383, 0, 0], 57350: at, 57351: at, 57352: at, 57353: [0, 0.43056, 0.04028, 0], 57356: [0.25142, 0.75726, 0, 0], 57357: [0.25142, 0.75726, 0, 0], 57358: [0.41951, 0.91951, 0, 0], 57359: [0.30274, 0.79383, 0, 0], 57360: [0.30274, 0.79383, 0, 0], 57361: [0.41951, 0.91951, 0, 0], 57366: [0.25142, 0.75726, 0, 0], 57367: [0.25142, 0.75726, 0, 0], 57368: [0.25142, 0.75726, 0, 0], 57369: [0.25142, 0.75726, 0, 0], 57370: [0.13597, 0.63597, 0, 0], 57371: [0.13597, 0.63597, 0, 0] }, "Caligraphic-Regular": { 32: q, 65: [0, 0.68333, 0, 0.19445], 66: [0, 0.68333, 0.03041, 0.13889], 67: [0, 0.68333, 0.05834, 0.13889], 68: [0, 0.68333, 0.02778, 0.08334], 69: [0, 0.68333, 0.08944, 0.11111], 70: [0, 0.68333, 0.09931, 0.11111], 71: [0.09722, 0.68333, 0.0593, 0.11111], 72: [0, 0.68333, 965e-5, 0.11111], 73: [0, 0.68333, 0.07382, 0], 74: [0.09722, 0.68333, 0.18472, 0.16667], 75: [0, 0.68333, 0.01445, 0.05556], 76: [0, 0.68333, 0, 0.13889], 77: [0, 0.68333, 0, 0.13889], 78: [0, 0.68333, 0.14736, 0.08334], 79: [0, 0.68333, 0.02778, 0.11111], 80: [0, 0.68333, 0.08222, 0.08334], 81: [0.09722, 0.68333, 0, 0.11111], 82: [0, 0.68333, 0, 0.08334], 83: [0, 0.68333, 0.075, 0.13889], 84: [0, 0.68333, 0.25417, 0], 85: [0, 0.68333, 0.09931, 0.08334], 86: [0, 0.68333, 0.08222, 0], 87: [0, 0.68333, 0.08222, 0.08334], 88: [0, 0.68333, 0.14643, 0.13889], 89: [0.09722, 0.68333, 0.08222, 0.08334], 90: [0, 0.68333, 0.07944, 0.13889], 160: q }, "Fraktur-Regular": { 32: q, 33: G, 34: G, 38: G, 39: G, 40: [0.24982, 0.74947, 0, 0], 41: [0.24982, 0.74947, 0, 0], 42: [0, 0.62119, 0, 0], 43: [0.08319, 0.58283, 0, 0], 44: [0, 0.10803, 0, 0], 45: [0.08319, 0.58283, 0, 0], 46: [0, 0.10803, 0, 0], 47: [0.24982, 0.74947, 0, 0], 48: He, 49: He, 50: He, 51: [0.18906, 0.47534, 0, 0], 52: [0.18906, 0.47534, 0, 0], 53: [0.18906, 0.47534, 0, 0], 54: G, 55: [0.18906, 0.47534, 0, 0], 56: G, 57: [0.18906, 0.47534, 0, 0], 58: He, 59: [0.12604, 0.47534, 0, 0], 61: [-0.13099, 0.36866, 0, 0], 63: G, 65: G, 66: G, 67: G, 68: G, 69: G, 70: [0.12604, 0.69141, 0, 0], 71: G, 72: [0.06302, 0.69141, 0, 0], 73: G, 74: [0.12604, 0.69141, 0, 0], 75: G, 76: G, 77: G, 78: G, 79: G, 80: [0.18906, 0.69141, 0, 0], 81: [0.03781, 0.69141, 0, 0], 82: G, 83: G, 84: G, 85: G, 86: G, 87: G, 88: G, 89: [0.18906, 0.69141, 0, 0], 90: [0.12604, 0.69141, 0, 0], 91: [0.24982, 0.74947, 0, 0], 93: [0.24982, 0.74947, 0, 0], 94: G, 97: He, 98: G, 99: He, 100: [0, 0.62119, 0, 0], 101: He, 102: [0.18906, 0.69141, 0, 0], 103: [0.18906, 0.47534, 0, 0], 104: [0.18906, 0.69141, 0, 0], 105: G, 106: G, 107: G, 108: G, 109: He, 110: He, 111: He, 112: [0.18906, 0.52396, 0, 0], 113: [0.18906, 0.47534, 0, 0], 114: He, 115: He, 116: [0, 0.62119, 0, 0], 117: He, 118: [0, 0.52396, 0, 0], 119: [0, 0.52396, 0, 0], 120: [0.18906, 0.47534, 0, 0], 121: [0.18906, 0.47534, 0, 0], 122: [0.18906, 0.47534, 0, 0], 160: q, 8216: G, 8217: G, 58112: [0, 0.62119, 0, 0], 58113: [0, 0.62119, 0, 0], 58114: [0.18906, 0.69141, 0, 0], 58115: [0.18906, 0.69141, 0, 0], 58116: [0.18906, 0.47534, 0, 0], 58117: G, 58118: [0, 0.62119, 0, 0], 58119: He }, "Main-Bold": { 32: q, 33: p2, 34: p2, 35: N, 36: [0.05556, 0.75, 0, 0], 37: [0.05556, 0.75, 0, 0], 38: p2, 39: p2, 40: B, 41: B, 42: Ve, 43: [0.13333, 0.63333, 0, 0], 44: [0.19444, 0.15556, 0, 0], 45: O, 46: [0, 0.15556, 0, 0], 47: B, 48: ce, 49: ce, 50: ce, 51: ce, 52: ce, 53: ce, 54: ce, 55: ce, 56: ce, 57: ce, 58: O, 59: ye, 60: [0.08556, 0.58556, 0, 0], 61: [-0.10889, 0.39111, 0, 0], 62: [0.08556, 0.58556, 0, 0], 63: p2, 64: p2, 65: z, 66: z, 67: z, 68: z, 69: z, 70: z, 71: z, 72: z, 73: z, 74: z, 75: z, 76: z, 77: z, 78: z, 79: z, 80: z, 81: [0.19444, 0.68611, 0, 0], 82: z, 83: z, 84: z, 85: z, 86: [0, 0.68611, 0.01597, 0], 87: [0, 0.68611, 0.01597, 0], 88: z, 89: [0, 0.68611, 0.02875, 0], 90: z, 91: B, 92: B, 93: B, 94: p2, 95: [0.31, 0.13444, 0.03194, 0], 97: O, 98: p2, 99: O, 100: p2, 101: O, 102: [0, 0.69444, 0.10903, 0], 103: [0.19444, 0.44444, 0.01597, 0], 104: p2, 105: p2, 106: N, 107: p2, 108: p2, 109: O, 110: O, 111: O, 112: ye, 113: ye, 114: O, 115: O, 116: [0, 0.63492, 0, 0], 117: O, 118: [0, 0.44444, 0.01597, 0], 119: [0, 0.44444, 0.01597, 0], 120: O, 121: [0.19444, 0.44444, 0.01597, 0], 122: O, 123: B, 124: B, 125: B, 126: [0.35, 0.34444, 0, 0], 160: q, 163: p2, 168: p2, 172: O, 176: p2, 177: [0.13333, 0.63333, 0, 0], 184: [0.17014, 0, 0, 0], 198: z, 215: [0.13333, 0.63333, 0, 0], 216: [0.04861, 0.73472, 0, 0], 223: p2, 230: O, 247: [0.13333, 0.63333, 0, 0], 248: [0.09722, 0.54167, 0, 0], 305: O, 338: z, 339: O, 567: ye, 710: p2, 711: [0, 0.63194, 0, 0], 713: [0, 0.59611, 0, 0], 714: p2, 715: p2, 728: p2, 729: p2, 730: p2, 732: p2, 733: p2, 915: z, 916: z, 920: z, 923: z, 926: z, 928: z, 931: z, 933: z, 934: z, 936: z, 937: z, 8211: [0, 0.44444, 0.03194, 0], 8212: [0, 0.44444, 0.03194, 0], 8216: p2, 8217: p2, 8220: p2, 8221: p2, 8224: N, 8225: N, 8242: Ce, 8407: [0, 0.72444, 0.15486, 0], 8463: p2, 8465: p2, 8467: p2, 8472: ye, 8476: p2, 8501: p2, 8592: [-0.10889, 0.39111, 0, 0], 8593: N, 8594: [-0.10889, 0.39111, 0, 0], 8595: N, 8596: [-0.10889, 0.39111, 0, 0], 8597: B, 8598: N, 8599: N, 8600: N, 8601: N, 8636: [-0.10889, 0.39111, 0, 0], 8637: [-0.10889, 0.39111, 0, 0], 8640: [-0.10889, 0.39111, 0, 0], 8641: [-0.10889, 0.39111, 0, 0], 8656: [-0.10889, 0.39111, 0, 0], 8657: N, 8658: [-0.10889, 0.39111, 0, 0], 8659: N, 8660: [-0.10889, 0.39111, 0, 0], 8661: B, 8704: p2, 8706: [0, 0.69444, 0.06389, 0], 8707: p2, 8709: [0.05556, 0.75, 0, 0], 8711: z, 8712: [0.08556, 0.58556, 0, 0], 8715: [0.08556, 0.58556, 0, 0], 8722: [0.13333, 0.63333, 0, 0], 8723: [0.13333, 0.63333, 0, 0], 8725: B, 8726: B, 8727: [-0.02778, 0.47222, 0, 0], 8728: [-0.02639, 0.47361, 0, 0], 8729: [-0.02639, 0.47361, 0, 0], 8730: [0.18, 0.82, 0, 0], 8733: O, 8734: O, 8736: ge, 8739: B, 8741: B, 8743: Ce, 8744: Ce, 8745: Ce, 8746: Ce, 8747: [0.19444, 0.69444, 0.12778, 0], 8764: [-0.10889, 0.39111, 0, 0], 8768: N, 8771: [222e-5, 0.50222, 0, 0], 8776: [0.02444, 0.52444, 0, 0], 8781: [222e-5, 0.50222, 0, 0], 8801: [222e-5, 0.50222, 0, 0], 8804: [0.19667, 0.69667, 0, 0], 8805: [0.19667, 0.69667, 0, 0], 8810: [0.08556, 0.58556, 0, 0], 8811: [0.08556, 0.58556, 0, 0], 8826: [0.08556, 0.58556, 0, 0], 8827: [0.08556, 0.58556, 0, 0], 8834: [0.08556, 0.58556, 0, 0], 8835: [0.08556, 0.58556, 0, 0], 8838: [0.19667, 0.69667, 0, 0], 8839: [0.19667, 0.69667, 0, 0], 8846: Ce, 8849: [0.19667, 0.69667, 0, 0], 8850: [0.19667, 0.69667, 0, 0], 8851: Ce, 8852: Ce, 8853: [0.13333, 0.63333, 0, 0], 8854: [0.13333, 0.63333, 0, 0], 8855: [0.13333, 0.63333, 0, 0], 8856: [0.13333, 0.63333, 0, 0], 8857: [0.13333, 0.63333, 0, 0], 8866: p2, 8867: p2, 8868: p2, 8869: p2, 8900: [-0.02639, 0.47361, 0, 0], 8901: [-0.02639, 0.47361, 0, 0], 8902: [-0.02778, 0.47222, 0, 0], 8968: B, 8969: B, 8970: B, 8971: B, 8994: [-0.13889, 0.36111, 0, 0], 8995: [-0.13889, 0.36111, 0, 0], 9651: N, 9657: [-0.02778, 0.47222, 0, 0], 9661: N, 9667: [-0.02778, 0.47222, 0, 0], 9711: N, 9824: [0.12963, 0.69444, 0, 0], 9825: [0.12963, 0.69444, 0, 0], 9826: [0.12963, 0.69444, 0, 0], 9827: [0.12963, 0.69444, 0, 0], 9837: Ve, 9838: N, 9839: N, 10216: B, 10217: B, 10815: z, 10927: [0.19667, 0.69667, 0, 0], 10928: [0.19667, 0.69667, 0, 0], 57376: N }, "Main-BoldItalic": { 32: q, 33: [0, 0.69444, 0.11417, 0], 34: [0, 0.69444, 0.07939, 0], 35: [0.19444, 0.69444, 0.06833, 0], 37: [0.05556, 0.75, 0.12861, 0], 38: [0, 0.69444, 0.08528, 0], 39: [0, 0.69444, 0.12945, 0], 40: [0.25, 0.75, 0.15806, 0], 41: [0.25, 0.75, 0.03306, 0], 42: [0, 0.75, 0.14333, 0], 43: [0.10333, 0.60333, 0.03306, 0], 44: [0.19444, 0.14722, 0, 0], 45: [0, 0.44444, 0.02611, 0], 46: [0, 0.14722, 0, 0], 47: [0.25, 0.75, 0.15806, 0], 48: [0, 0.64444, 0.13167, 0], 49: [0, 0.64444, 0.13167, 0], 50: [0, 0.64444, 0.13167, 0], 51: [0, 0.64444, 0.13167, 0], 52: [0.19444, 0.64444, 0.13167, 0], 53: [0, 0.64444, 0.13167, 0], 54: [0, 0.64444, 0.13167, 0], 55: [0.19444, 0.64444, 0.13167, 0], 56: [0, 0.64444, 0.13167, 0], 57: [0, 0.64444, 0.13167, 0], 58: [0, 0.44444, 0.06695, 0], 59: [0.19444, 0.44444, 0.06695, 0], 61: [-0.10889, 0.39111, 0.06833, 0], 63: [0, 0.69444, 0.11472, 0], 64: [0, 0.69444, 0.09208, 0], 65: z, 66: [0, 0.68611, 0.0992, 0], 67: [0, 0.68611, 0.14208, 0], 68: [0, 0.68611, 0.09062, 0], 69: [0, 0.68611, 0.11431, 0], 70: [0, 0.68611, 0.12903, 0], 71: [0, 0.68611, 0.07347, 0], 72: [0, 0.68611, 0.17208, 0], 73: [0, 0.68611, 0.15681, 0], 74: [0, 0.68611, 0.145, 0], 75: [0, 0.68611, 0.14208, 0], 76: z, 77: [0, 0.68611, 0.17208, 0], 78: [0, 0.68611, 0.17208, 0], 79: [0, 0.68611, 0.09062, 0], 80: [0, 0.68611, 0.0992, 0], 81: [0.19444, 0.68611, 0.09062, 0], 82: [0, 0.68611, 0.02559, 0], 83: [0, 0.68611, 0.11264, 0], 84: [0, 0.68611, 0.12903, 0], 85: [0, 0.68611, 0.17208, 0], 86: [0, 0.68611, 0.18625, 0], 87: [0, 0.68611, 0.18625, 0], 88: [0, 0.68611, 0.15681, 0], 89: [0, 0.68611, 0.19803, 0], 90: [0, 0.68611, 0.14208, 0], 91: [0.25, 0.75, 0.1875, 0], 93: [0.25, 0.75, 0.09972, 0], 94: [0, 0.69444, 0.06709, 0], 95: [0.31, 0.13444, 0.09811, 0], 97: [0, 0.44444, 0.09426, 0], 98: [0, 0.69444, 0.07861, 0], 99: [0, 0.44444, 0.05222, 0], 100: [0, 0.69444, 0.10861, 0], 101: [0, 0.44444, 0.085, 0], 102: [0.19444, 0.69444, 0.21778, 0], 103: [0.19444, 0.44444, 0.105, 0], 104: [0, 0.69444, 0.09426, 0], 105: [0, 0.69326, 0.11387, 0], 106: [0.19444, 0.69326, 0.1672, 0], 107: [0, 0.69444, 0.11111, 0], 108: [0, 0.69444, 0.10861, 0], 109: [0, 0.44444, 0.09426, 0], 110: [0, 0.44444, 0.09426, 0], 111: [0, 0.44444, 0.07861, 0], 112: [0.19444, 0.44444, 0.07861, 0], 113: [0.19444, 0.44444, 0.105, 0], 114: [0, 0.44444, 0.11111, 0], 115: [0, 0.44444, 0.08167, 0], 116: [0, 0.63492, 0.09639, 0], 117: [0, 0.44444, 0.09426, 0], 118: [0, 0.44444, 0.11111, 0], 119: [0, 0.44444, 0.11111, 0], 120: [0, 0.44444, 0.12583, 0], 121: [0.19444, 0.44444, 0.105, 0], 122: [0, 0.44444, 0.13889, 0], 126: [0.35, 0.34444, 0.11472, 0], 160: q, 168: [0, 0.69444, 0.11473, 0], 176: p2, 184: [0.17014, 0, 0, 0], 198: [0, 0.68611, 0.11431, 0], 216: [0.04861, 0.73472, 0.09062, 0], 223: [0.19444, 0.69444, 0.09736, 0], 230: [0, 0.44444, 0.085, 0], 248: [0.09722, 0.54167, 0.09458, 0], 305: [0, 0.44444, 0.09426, 0], 338: [0, 0.68611, 0.11431, 0], 339: [0, 0.44444, 0.085, 0], 567: [0.19444, 0.44444, 0.04611, 0], 710: [0, 0.69444, 0.06709, 0], 711: [0, 0.63194, 0.08271, 0], 713: [0, 0.59444, 0.10444, 0], 714: [0, 0.69444, 0.08528, 0], 715: p2, 728: [0, 0.69444, 0.10333, 0], 729: [0, 0.69444, 0.12945, 0], 730: p2, 732: [0, 0.69444, 0.11472, 0], 733: [0, 0.69444, 0.11472, 0], 915: [0, 0.68611, 0.12903, 0], 916: z, 920: [0, 0.68611, 0.09062, 0], 923: z, 926: [0, 0.68611, 0.15092, 0], 928: [0, 0.68611, 0.17208, 0], 931: [0, 0.68611, 0.11431, 0], 933: [0, 0.68611, 0.10778, 0], 934: [0, 0.68611, 0.05632, 0], 936: [0, 0.68611, 0.10778, 0], 937: [0, 0.68611, 0.0992, 0], 8211: [0, 0.44444, 0.09811, 0], 8212: [0, 0.44444, 0.09811, 0], 8216: [0, 0.69444, 0.12945, 0], 8217: [0, 0.69444, 0.12945, 0], 8220: [0, 0.69444, 0.16772, 0], 8221: [0, 0.69444, 0.07939, 0] }, "Main-Italic": { 32: q, 33: [0, 0.69444, 0.12417, 0], 34: [0, 0.69444, 0.06961, 0], 35: [0.19444, 0.69444, 0.06616, 0], 37: [0.05556, 0.75, 0.13639, 0], 38: [0, 0.69444, 0.09694, 0], 39: [0, 0.69444, 0.12417, 0], 40: [0.25, 0.75, 0.16194, 0], 41: [0.25, 0.75, 0.03694, 0], 42: [0, 0.75, 0.14917, 0], 43: [0.05667, 0.56167, 0.03694, 0], 44: [0.19444, 0.10556, 0, 0], 45: [0, 0.43056, 0.02826, 0], 46: [0, 0.10556, 0, 0], 47: [0.25, 0.75, 0.16194, 0], 48: [0, 0.64444, 0.13556, 0], 49: [0, 0.64444, 0.13556, 0], 50: [0, 0.64444, 0.13556, 0], 51: [0, 0.64444, 0.13556, 0], 52: [0.19444, 0.64444, 0.13556, 0], 53: [0, 0.64444, 0.13556, 0], 54: [0, 0.64444, 0.13556, 0], 55: [0.19444, 0.64444, 0.13556, 0], 56: [0, 0.64444, 0.13556, 0], 57: [0, 0.64444, 0.13556, 0], 58: [0, 0.43056, 0.0582, 0], 59: [0.19444, 0.43056, 0.0582, 0], 61: [-0.13313, 0.36687, 0.06616, 0], 63: [0, 0.69444, 0.1225, 0], 64: [0, 0.69444, 0.09597, 0], 65: I, 66: [0, 0.68333, 0.10257, 0], 67: [0, 0.68333, 0.14528, 0], 68: [0, 0.68333, 0.09403, 0], 69: [0, 0.68333, 0.12028, 0], 70: [0, 0.68333, 0.13305, 0], 71: [0, 0.68333, 0.08722, 0], 72: [0, 0.68333, 0.16389, 0], 73: [0, 0.68333, 0.15806, 0], 74: [0, 0.68333, 0.14028, 0], 75: [0, 0.68333, 0.14528, 0], 76: I, 77: [0, 0.68333, 0.16389, 0], 78: [0, 0.68333, 0.16389, 0], 79: [0, 0.68333, 0.09403, 0], 80: [0, 0.68333, 0.10257, 0], 81: [0.19444, 0.68333, 0.09403, 0], 82: [0, 0.68333, 0.03868, 0], 83: [0, 0.68333, 0.11972, 0], 84: [0, 0.68333, 0.13305, 0], 85: [0, 0.68333, 0.16389, 0], 86: [0, 0.68333, 0.18361, 0], 87: [0, 0.68333, 0.18361, 0], 88: [0, 0.68333, 0.15806, 0], 89: [0, 0.68333, 0.19383, 0], 90: [0, 0.68333, 0.14528, 0], 91: [0.25, 0.75, 0.1875, 0], 93: [0.25, 0.75, 0.10528, 0], 94: [0, 0.69444, 0.06646, 0], 95: [0.31, 0.12056, 0.09208, 0], 97: [0, 0.43056, 0.07671, 0], 98: [0, 0.69444, 0.06312, 0], 99: [0, 0.43056, 0.05653, 0], 100: [0, 0.69444, 0.10333, 0], 101: [0, 0.43056, 0.07514, 0], 102: [0.19444, 0.69444, 0.21194, 0], 103: [0.19444, 0.43056, 0.08847, 0], 104: [0, 0.69444, 0.07671, 0], 105: [0, 0.65536, 0.1019, 0], 106: [0.19444, 0.65536, 0.14467, 0], 107: [0, 0.69444, 0.10764, 0], 108: [0, 0.69444, 0.10333, 0], 109: [0, 0.43056, 0.07671, 0], 110: [0, 0.43056, 0.07671, 0], 111: [0, 0.43056, 0.06312, 0], 112: [0.19444, 0.43056, 0.06312, 0], 113: [0.19444, 0.43056, 0.08847, 0], 114: [0, 0.43056, 0.10764, 0], 115: [0, 0.43056, 0.08208, 0], 116: [0, 0.61508, 0.09486, 0], 117: [0, 0.43056, 0.07671, 0], 118: [0, 0.43056, 0.10764, 0], 119: [0, 0.43056, 0.10764, 0], 120: [0, 0.43056, 0.12042, 0], 121: [0.19444, 0.43056, 0.08847, 0], 122: [0, 0.43056, 0.12292, 0], 126: [0.35, 0.31786, 0.11585, 0], 160: q, 168: [0, 0.66786, 0.10474, 0], 176: p2, 184: [0.17014, 0, 0, 0], 198: [0, 0.68333, 0.12028, 0], 216: [0.04861, 0.73194, 0.09403, 0], 223: [0.19444, 0.69444, 0.10514, 0], 230: [0, 0.43056, 0.07514, 0], 248: [0.09722, 0.52778, 0.09194, 0], 338: [0, 0.68333, 0.12028, 0], 339: [0, 0.43056, 0.07514, 0], 710: [0, 0.69444, 0.06646, 0], 711: [0, 0.62847, 0.08295, 0], 713: [0, 0.56167, 0.10333, 0], 714: [0, 0.69444, 0.09694, 0], 715: p2, 728: [0, 0.69444, 0.10806, 0], 729: [0, 0.66786, 0.11752, 0], 730: p2, 732: [0, 0.66786, 0.11585, 0], 733: [0, 0.69444, 0.1225, 0], 915: [0, 0.68333, 0.13305, 0], 916: I, 920: [0, 0.68333, 0.09403, 0], 923: I, 926: [0, 0.68333, 0.15294, 0], 928: [0, 0.68333, 0.16389, 0], 931: [0, 0.68333, 0.12028, 0], 933: [0, 0.68333, 0.11111, 0], 934: [0, 0.68333, 0.05986, 0], 936: [0, 0.68333, 0.11111, 0], 937: [0, 0.68333, 0.10257, 0], 8211: [0, 0.43056, 0.09208, 0], 8212: [0, 0.43056, 0.09208, 0], 8216: [0, 0.69444, 0.12417, 0], 8217: [0, 0.69444, 0.12417, 0], 8220: [0, 0.69444, 0.1685, 0], 8221: [0, 0.69444, 0.06961, 0], 8463: $2 }, "Main-Regular": { 32: q, 33: p2, 34: p2, 35: N, 36: [0.05556, 0.75, 0, 0], 37: [0.05556, 0.75, 0, 0], 38: p2, 39: p2, 40: B, 41: B, 42: Ve, 43: [0.08333, 0.58333, 0, 0], 44: [0.19444, 0.10556, 0, 0], 45: [0, 0.43056, 0, 0], 46: [0, 0.10556, 0, 0], 47: B, 48: ce, 49: ce, 50: ce, 51: ce, 52: ce, 53: ce, 54: ce, 55: ce, 56: ce, 57: ce, 58: [0, 0.43056, 0, 0], 59: [0.19444, 0.43056, 0, 0], 60: [0.0391, 0.5391, 0, 0], 61: [-0.13313, 0.36687, 0, 0], 62: [0.0391, 0.5391, 0, 0], 63: p2, 64: p2, 65: I, 66: I, 67: I, 68: I, 69: I, 70: I, 71: I, 72: I, 73: I, 74: I, 75: I, 76: I, 77: I, 78: I, 79: I, 80: I, 81: [0.19444, 0.68333, 0, 0], 82: I, 83: I, 84: I, 85: I, 86: [0, 0.68333, 0.01389, 0], 87: [0, 0.68333, 0.01389, 0], 88: I, 89: [0, 0.68333, 0.025, 0], 90: I, 91: B, 92: B, 93: B, 94: p2, 95: [0.31, 0.12056, 0.02778, 0], 97: [0, 0.43056, 0, 0], 98: p2, 99: [0, 0.43056, 0, 0], 100: p2, 101: [0, 0.43056, 0, 0], 102: [0, 0.69444, 0.07778, 0], 103: [0.19444, 0.43056, 0.01389, 0], 104: p2, 105: [0, 0.66786, 0, 0], 106: [0.19444, 0.66786, 0, 0], 107: p2, 108: p2, 109: [0, 0.43056, 0, 0], 110: [0, 0.43056, 0, 0], 111: [0, 0.43056, 0, 0], 112: [0.19444, 0.43056, 0, 0], 113: [0.19444, 0.43056, 0, 0], 114: [0, 0.43056, 0, 0], 115: [0, 0.43056, 0, 0], 116: [0, 0.61508, 0, 0], 117: [0, 0.43056, 0, 0], 118: [0, 0.43056, 0.01389, 0], 119: [0, 0.43056, 0.01389, 0], 120: [0, 0.43056, 0, 0], 121: [0.19444, 0.43056, 0.01389, 0], 122: [0, 0.43056, 0, 0], 123: B, 124: B, 125: B, 126: [0.35, 0.31786, 0, 0], 160: q, 163: p2, 167: N, 168: [0, 0.66786, 0, 0], 172: [0, 0.43056, 0, 0], 176: p2, 177: [0.08333, 0.58333, 0, 0], 182: N, 184: [0.17014, 0, 0, 0], 198: I, 215: [0.08333, 0.58333, 0, 0], 216: [0.04861, 0.73194, 0, 0], 223: p2, 230: [0, 0.43056, 0, 0], 247: [0.08333, 0.58333, 0, 0], 248: [0.09722, 0.52778, 0, 0], 305: [0, 0.43056, 0, 0], 338: I, 339: [0, 0.43056, 0, 0], 567: [0.19444, 0.43056, 0, 0], 710: p2, 711: [0, 0.62847, 0, 0], 713: [0, 0.56778, 0, 0], 714: p2, 715: p2, 728: p2, 729: [0, 0.66786, 0, 0], 730: p2, 732: [0, 0.66786, 0, 0], 733: p2, 915: I, 916: I, 920: I, 923: I, 926: I, 928: I, 931: I, 933: I, 934: I, 936: I, 937: I, 8211: [0, 0.43056, 0.02778, 0], 8212: [0, 0.43056, 0.02778, 0], 8216: p2, 8217: p2, 8220: p2, 8221: p2, 8224: N, 8225: N, 8230: [0, 0.12, 0, 0], 8242: Ce, 8407: [0, 0.71444, 0.15382, 0], 8463: $2, 8465: p2, 8467: [0, 0.69444, 0, 0.11111], 8472: [0.19444, 0.43056, 0, 0.11111], 8476: p2, 8501: p2, 8592: [-0.13313, 0.36687, 0, 0], 8593: N, 8594: [-0.13313, 0.36687, 0, 0], 8595: N, 8596: [-0.13313, 0.36687, 0, 0], 8597: B, 8598: N, 8599: N, 8600: N, 8601: N, 8614: [0.011, 0.511, 0, 0], 8617: [0.011, 0.511, 0, 0], 8618: [0.011, 0.511, 0, 0], 8636: [-0.13313, 0.36687, 0, 0], 8637: [-0.13313, 0.36687, 0, 0], 8640: [-0.13313, 0.36687, 0, 0], 8641: [-0.13313, 0.36687, 0, 0], 8652: [0.011, 0.671, 0, 0], 8656: [-0.13313, 0.36687, 0, 0], 8657: N, 8658: [-0.13313, 0.36687, 0, 0], 8659: N, 8660: [-0.13313, 0.36687, 0, 0], 8661: B, 8704: p2, 8706: [0, 0.69444, 0.05556, 0.08334], 8707: p2, 8709: [0.05556, 0.75, 0, 0], 8711: I, 8712: [0.0391, 0.5391, 0, 0], 8715: [0.0391, 0.5391, 0, 0], 8722: [0.08333, 0.58333, 0, 0], 8723: [0.08333, 0.58333, 0, 0], 8725: B, 8726: B, 8727: [-0.03472, 0.46528, 0, 0], 8728: [-0.05555, 0.44445, 0, 0], 8729: [-0.05555, 0.44445, 0, 0], 8730: [0.2, 0.8, 0, 0], 8733: [0, 0.43056, 0, 0], 8734: [0, 0.43056, 0, 0], 8736: ge, 8739: B, 8741: B, 8743: Ce, 8744: Ce, 8745: Ce, 8746: Ce, 8747: [0.19444, 0.69444, 0.11111, 0], 8764: [-0.13313, 0.36687, 0, 0], 8768: N, 8771: [-0.03625, 0.46375, 0, 0], 8773: [-0.022, 0.589, 0, 0], 8776: [-0.01688, 0.48312, 0, 0], 8781: [-0.03625, 0.46375, 0, 0], 8784: [-0.133, 0.67, 0, 0], 8801: [-0.03625, 0.46375, 0, 0], 8804: [0.13597, 0.63597, 0, 0], 8805: [0.13597, 0.63597, 0, 0], 8810: [0.0391, 0.5391, 0, 0], 8811: [0.0391, 0.5391, 0, 0], 8826: [0.0391, 0.5391, 0, 0], 8827: [0.0391, 0.5391, 0, 0], 8834: [0.0391, 0.5391, 0, 0], 8835: [0.0391, 0.5391, 0, 0], 8838: [0.13597, 0.63597, 0, 0], 8839: [0.13597, 0.63597, 0, 0], 8846: Ce, 8849: [0.13597, 0.63597, 0, 0], 8850: [0.13597, 0.63597, 0, 0], 8851: Ce, 8852: Ce, 8853: [0.08333, 0.58333, 0, 0], 8854: [0.08333, 0.58333, 0, 0], 8855: [0.08333, 0.58333, 0, 0], 8856: [0.08333, 0.58333, 0, 0], 8857: [0.08333, 0.58333, 0, 0], 8866: p2, 8867: p2, 8868: p2, 8869: p2, 8872: [0.249, 0.75, 0, 0], 8900: [-0.05555, 0.44445, 0, 0], 8901: [-0.05555, 0.44445, 0, 0], 8902: [-0.03472, 0.46528, 0, 0], 8904: [5e-3, 0.505, 0, 0], 8942: [0.03, 0.9, 0, 0], 8943: [-0.19, 0.31, 0, 0], 8945: [-0.1, 0.82, 0, 0], 8968: B, 8969: B, 8970: B, 8971: B, 8994: [-0.14236, 0.35764, 0, 0], 8995: [-0.14236, 0.35764, 0, 0], 9136: [0.244, 0.744, 0, 0], 9137: [0.244, 0.744, 0, 0], 9651: N, 9657: [-0.03472, 0.46528, 0, 0], 9661: N, 9667: [-0.03472, 0.46528, 0, 0], 9711: N, 9824: [0.12963, 0.69444, 0, 0], 9825: [0.12963, 0.69444, 0, 0], 9826: [0.12963, 0.69444, 0, 0], 9827: [0.12963, 0.69444, 0, 0], 9837: Ve, 9838: N, 9839: N, 10216: B, 10217: B, 10222: [0.244, 0.744, 0, 0], 10223: [0.244, 0.744, 0, 0], 10229: [0.011, 0.511, 0, 0], 10230: [0.011, 0.511, 0, 0], 10231: [0.011, 0.511, 0, 0], 10232: [0.024, 0.525, 0, 0], 10233: [0.024, 0.525, 0, 0], 10234: [0.024, 0.525, 0, 0], 10236: [0.011, 0.511, 0, 0], 10815: I, 10927: [0.13597, 0.63597, 0, 0], 10928: [0.13597, 0.63597, 0, 0], 57376: N }, "Math-BoldItalic": { 32: q, 48: O, 49: O, 50: O, 51: ye, 52: ye, 53: ye, 54: ce, 55: ye, 56: ce, 57: ye, 65: z, 66: [0, 0.68611, 0.04835, 0], 67: [0, 0.68611, 0.06979, 0], 68: [0, 0.68611, 0.03194, 0], 69: [0, 0.68611, 0.05451, 0], 70: [0, 0.68611, 0.15972, 0], 71: z, 72: [0, 0.68611, 0.08229, 0], 73: [0, 0.68611, 0.07778, 0], 74: [0, 0.68611, 0.10069, 0], 75: [0, 0.68611, 0.06979, 0], 76: z, 77: [0, 0.68611, 0.11424, 0], 78: [0, 0.68611, 0.11424, 0], 79: [0, 0.68611, 0.03194, 0], 80: [0, 0.68611, 0.15972, 0], 81: [0.19444, 0.68611, 0, 0], 82: [0, 0.68611, 421e-5, 0], 83: [0, 0.68611, 0.05382, 0], 84: [0, 0.68611, 0.15972, 0], 85: [0, 0.68611, 0.11424, 0], 86: [0, 0.68611, 0.25555, 0], 87: [0, 0.68611, 0.15972, 0], 88: [0, 0.68611, 0.07778, 0], 89: [0, 0.68611, 0.25555, 0], 90: [0, 0.68611, 0.06979, 0], 97: O, 98: p2, 99: O, 100: p2, 101: O, 102: [0.19444, 0.69444, 0.11042, 0], 103: [0.19444, 0.44444, 0.03704, 0], 104: p2, 105: [0, 0.69326, 0, 0], 106: [0.19444, 0.69326, 0.0622, 0], 107: [0, 0.69444, 0.01852, 0], 108: [0, 0.69444, 88e-4, 0], 109: O, 110: O, 111: O, 112: ye, 113: [0.19444, 0.44444, 0.03704, 0], 114: [0, 0.44444, 0.03194, 0], 115: O, 116: [0, 0.63492, 0, 0], 117: O, 118: [0, 0.44444, 0.03704, 0], 119: [0, 0.44444, 0.02778, 0], 120: O, 121: [0.19444, 0.44444, 0.03704, 0], 122: [0, 0.44444, 0.04213, 0], 160: q, 915: [0, 0.68611, 0.15972, 0], 916: z, 920: [0, 0.68611, 0.03194, 0], 923: z, 926: [0, 0.68611, 0.07458, 0], 928: [0, 0.68611, 0.08229, 0], 931: [0, 0.68611, 0.05451, 0], 933: [0, 0.68611, 0.15972, 0], 934: z, 936: [0, 0.68611, 0.11653, 0], 937: [0, 0.68611, 0.04835, 0], 945: O, 946: [0.19444, 0.69444, 0.03403, 0], 947: [0.19444, 0.44444, 0.06389, 0], 948: [0, 0.69444, 0.03819, 0], 949: O, 950: [0.19444, 0.69444, 0.06215, 0], 951: [0.19444, 0.44444, 0.03704, 0], 952: [0, 0.69444, 0.03194, 0], 953: O, 954: O, 955: p2, 956: ye, 957: [0, 0.44444, 0.06898, 0], 958: [0.19444, 0.69444, 0.03021, 0], 959: O, 960: [0, 0.44444, 0.03704, 0], 961: ye, 962: [0.09722, 0.44444, 0.07917, 0], 963: [0, 0.44444, 0.03704, 0], 964: [0, 0.44444, 0.13472, 0], 965: [0, 0.44444, 0.03704, 0], 966: ye, 967: ye, 968: [0.19444, 0.69444, 0.03704, 0], 969: [0, 0.44444, 0.03704, 0], 977: p2, 981: N, 982: [0, 0.44444, 0.03194, 0], 1009: ye, 1013: O, 57649: O, 57911: ye }, "Math-Italic": { 32: q, 48: [0, 0.43056, 0, 0], 49: [0, 0.43056, 0, 0], 50: [0, 0.43056, 0, 0], 51: [0.19444, 0.43056, 0, 0], 52: [0.19444, 0.43056, 0, 0], 53: [0.19444, 0.43056, 0, 0], 54: ce, 55: [0.19444, 0.43056, 0, 0], 56: ce, 57: [0.19444, 0.43056, 0, 0], 65: [0, 0.68333, 0, 0.13889], 66: [0, 0.68333, 0.05017, 0.08334], 67: [0, 0.68333, 0.07153, 0.08334], 68: [0, 0.68333, 0.02778, 0.05556], 69: [0, 0.68333, 0.05764, 0.08334], 70: [0, 0.68333, 0.13889, 0.08334], 71: [0, 0.68333, 0, 0.08334], 72: [0, 0.68333, 0.08125, 0.05556], 73: [0, 0.68333, 0.07847, 0.11111], 74: [0, 0.68333, 0.09618, 0.16667], 75: [0, 0.68333, 0.07153, 0.05556], 76: [0, 0.68333, 0, 0.02778], 77: [0, 0.68333, 0.10903, 0.08334], 78: [0, 0.68333, 0.10903, 0.08334], 79: [0, 0.68333, 0.02778, 0.08334], 80: [0, 0.68333, 0.13889, 0.08334], 81: [0.19444, 0.68333, 0, 0.08334], 82: [0, 0.68333, 773e-5, 0.08334], 83: [0, 0.68333, 0.05764, 0.08334], 84: [0, 0.68333, 0.13889, 0.08334], 85: [0, 0.68333, 0.10903, 0.02778], 86: [0, 0.68333, 0.22222, 0], 87: [0, 0.68333, 0.13889, 0], 88: [0, 0.68333, 0.07847, 0.08334], 89: [0, 0.68333, 0.22222, 0], 90: [0, 0.68333, 0.07153, 0.08334], 97: [0, 0.43056, 0, 0], 98: p2, 99: [0, 0.43056, 0, 0.05556], 100: [0, 0.69444, 0, 0.16667], 101: [0, 0.43056, 0, 0.05556], 102: [0.19444, 0.69444, 0.10764, 0.16667], 103: [0.19444, 0.43056, 0.03588, 0.02778], 104: p2, 105: [0, 0.65952, 0, 0], 106: [0.19444, 0.65952, 0.05724, 0], 107: [0, 0.69444, 0.03148, 0], 108: [0, 0.69444, 0.01968, 0.08334], 109: [0, 0.43056, 0, 0], 110: [0, 0.43056, 0, 0], 111: [0, 0.43056, 0, 0.05556], 112: [0.19444, 0.43056, 0, 0.08334], 113: [0.19444, 0.43056, 0.03588, 0.08334], 114: [0, 0.43056, 0.02778, 0.05556], 115: [0, 0.43056, 0, 0.05556], 116: [0, 0.61508, 0, 0.08334], 117: [0, 0.43056, 0, 0.02778], 118: [0, 0.43056, 0.03588, 0.02778], 119: [0, 0.43056, 0.02691, 0.08334], 120: [0, 0.43056, 0, 0.02778], 121: [0.19444, 0.43056, 0.03588, 0.05556], 122: [0, 0.43056, 0.04398, 0.05556], 160: q, 915: [0, 0.68333, 0.13889, 0.08334], 916: [0, 0.68333, 0, 0.16667], 920: [0, 0.68333, 0.02778, 0.08334], 923: [0, 0.68333, 0, 0.16667], 926: [0, 0.68333, 0.07569, 0.08334], 928: [0, 0.68333, 0.08125, 0.05556], 931: [0, 0.68333, 0.05764, 0.08334], 933: [0, 0.68333, 0.13889, 0.05556], 934: [0, 0.68333, 0, 0.08334], 936: [0, 0.68333, 0.11, 0.05556], 937: [0, 0.68333, 0.05017, 0.08334], 945: [0, 0.43056, 37e-4, 0.02778], 946: [0.19444, 0.69444, 0.05278, 0.08334], 947: [0.19444, 0.43056, 0.05556, 0], 948: [0, 0.69444, 0.03785, 0.05556], 949: [0, 0.43056, 0, 0.08334], 950: [0.19444, 0.69444, 0.07378, 0.08334], 951: [0.19444, 0.43056, 0.03588, 0.05556], 952: [0, 0.69444, 0.02778, 0.08334], 953: [0, 0.43056, 0, 0.05556], 954: [0, 0.43056, 0, 0], 955: p2, 956: [0.19444, 0.43056, 0, 0.02778], 957: [0, 0.43056, 0.06366, 0.02778], 958: [0.19444, 0.69444, 0.04601, 0.11111], 959: [0, 0.43056, 0, 0.05556], 960: [0, 0.43056, 0.03588, 0], 961: [0.19444, 0.43056, 0, 0.08334], 962: [0.09722, 0.43056, 0.07986, 0.08334], 963: [0, 0.43056, 0.03588, 0], 964: [0, 0.43056, 0.1132, 0.02778], 965: [0, 0.43056, 0.03588, 0.02778], 966: [0.19444, 0.43056, 0, 0.08334], 967: [0.19444, 0.43056, 0, 0.05556], 968: [0.19444, 0.69444, 0.03588, 0.11111], 969: [0, 0.43056, 0.03588, 0], 977: [0, 0.69444, 0, 0.08334], 981: [0.19444, 0.69444, 0, 0.08334], 982: [0, 0.43056, 0.02778, 0], 1009: [0.19444, 0.43056, 0, 0.08334], 1013: [0, 0.43056, 0, 0.05556], 57649: [0, 0.43056, 0, 0.02778], 57911: [0.19444, 0.43056, 0, 0.08334] }, "SansSerif-Bold": { 32: q, 33: p2, 34: p2, 35: N, 36: [0.05556, 0.75, 0, 0], 37: [0.05556, 0.75, 0, 0], 38: p2, 39: p2, 40: B, 41: B, 42: Ve, 43: [0.11667, 0.61667, 0, 0], 44: [0.10556, 0.13056, 0, 0], 45: [0, 0.45833, 0, 0], 46: [0, 0.13056, 0, 0], 47: B, 48: p2, 49: p2, 50: p2, 51: p2, 52: p2, 53: p2, 54: p2, 55: p2, 56: p2, 57: p2, 58: [0, 0.45833, 0, 0], 59: [0.10556, 0.45833, 0, 0], 61: [-0.09375, 0.40625, 0, 0], 63: p2, 64: p2, 65: p2, 66: p2, 67: p2, 68: p2, 69: p2, 70: p2, 71: p2, 72: p2, 73: p2, 74: p2, 75: p2, 76: p2, 77: p2, 78: p2, 79: p2, 80: p2, 81: [0.10556, 0.69444, 0, 0], 82: p2, 83: p2, 84: p2, 85: p2, 86: [0, 0.69444, 0.01528, 0], 87: [0, 0.69444, 0.01528, 0], 88: p2, 89: [0, 0.69444, 0.0275, 0], 90: p2, 91: B, 93: B, 94: p2, 95: [0.35, 0.10833, 0.03056, 0], 97: [0, 0.45833, 0, 0], 98: p2, 99: [0, 0.45833, 0, 0], 100: p2, 101: [0, 0.45833, 0, 0], 102: [0, 0.69444, 0.07639, 0], 103: [0.19444, 0.45833, 0.01528, 0], 104: p2, 105: p2, 106: N, 107: p2, 108: p2, 109: [0, 0.45833, 0, 0], 110: [0, 0.45833, 0, 0], 111: [0, 0.45833, 0, 0], 112: [0.19444, 0.45833, 0, 0], 113: [0.19444, 0.45833, 0, 0], 114: [0, 0.45833, 0.01528, 0], 115: [0, 0.45833, 0, 0], 116: [0, 0.58929, 0, 0], 117: [0, 0.45833, 0, 0], 118: [0, 0.45833, 0.01528, 0], 119: [0, 0.45833, 0.01528, 0], 120: [0, 0.45833, 0, 0], 121: [0.19444, 0.45833, 0.01528, 0], 122: [0, 0.45833, 0, 0], 126: [0.35, 0.34444, 0, 0], 160: q, 168: p2, 176: p2, 180: p2, 184: [0.17014, 0, 0, 0], 305: [0, 0.45833, 0, 0], 567: [0.19444, 0.45833, 0, 0], 710: p2, 711: [0, 0.63542, 0, 0], 713: [0, 0.63778, 0, 0], 728: p2, 729: p2, 730: p2, 732: p2, 733: p2, 915: p2, 916: p2, 920: p2, 923: p2, 926: p2, 928: p2, 931: p2, 933: p2, 934: p2, 936: p2, 937: p2, 8211: [0, 0.45833, 0.03056, 0], 8212: [0, 0.45833, 0.03056, 0], 8216: p2, 8217: p2, 8220: p2, 8221: p2 }, "SansSerif-Italic": { 32: q, 33: [0, 0.69444, 0.05733, 0], 34: [0, 0.69444, 316e-5, 0], 35: [0.19444, 0.69444, 0.05087, 0], 36: [0.05556, 0.75, 0.11156, 0], 37: [0.05556, 0.75, 0.03126, 0], 38: [0, 0.69444, 0.03058, 0], 39: [0, 0.69444, 0.07816, 0], 40: [0.25, 0.75, 0.13164, 0], 41: [0.25, 0.75, 0.02536, 0], 42: [0, 0.75, 0.11775, 0], 43: [0.08333, 0.58333, 0.02536, 0], 44: [0.125, 0.08333, 0, 0], 45: [0, 0.44444, 0.01946, 0], 46: [0, 0.08333, 0, 0], 47: [0.25, 0.75, 0.13164, 0], 48: [0, 0.65556, 0.11156, 0], 49: [0, 0.65556, 0.11156, 0], 50: [0, 0.65556, 0.11156, 0], 51: [0, 0.65556, 0.11156, 0], 52: [0, 0.65556, 0.11156, 0], 53: [0, 0.65556, 0.11156, 0], 54: [0, 0.65556, 0.11156, 0], 55: [0, 0.65556, 0.11156, 0], 56: [0, 0.65556, 0.11156, 0], 57: [0, 0.65556, 0.11156, 0], 58: [0, 0.44444, 0.02502, 0], 59: [0.125, 0.44444, 0.02502, 0], 61: [-0.13, 0.37, 0.05087, 0], 63: [0, 0.69444, 0.11809, 0], 64: [0, 0.69444, 0.07555, 0], 65: p2, 66: [0, 0.69444, 0.08293, 0], 67: [0, 0.69444, 0.11983, 0], 68: [0, 0.69444, 0.07555, 0], 69: [0, 0.69444, 0.11983, 0], 70: [0, 0.69444, 0.13372, 0], 71: [0, 0.69444, 0.11983, 0], 72: [0, 0.69444, 0.08094, 0], 73: [0, 0.69444, 0.13372, 0], 74: [0, 0.69444, 0.08094, 0], 75: [0, 0.69444, 0.11983, 0], 76: p2, 77: [0, 0.69444, 0.08094, 0], 78: [0, 0.69444, 0.08094, 0], 79: [0, 0.69444, 0.07555, 0], 80: [0, 0.69444, 0.08293, 0], 81: [0.125, 0.69444, 0.07555, 0], 82: [0, 0.69444, 0.08293, 0], 83: [0, 0.69444, 0.09205, 0], 84: [0, 0.69444, 0.13372, 0], 85: [0, 0.69444, 0.08094, 0], 86: [0, 0.69444, 0.1615, 0], 87: [0, 0.69444, 0.1615, 0], 88: [0, 0.69444, 0.13372, 0], 89: [0, 0.69444, 0.17261, 0], 90: [0, 0.69444, 0.11983, 0], 91: [0.25, 0.75, 0.15942, 0], 93: [0.25, 0.75, 0.08719, 0], 94: [0, 0.69444, 0.0799, 0], 95: [0.35, 0.09444, 0.08616, 0], 97: [0, 0.44444, 981e-5, 0], 98: [0, 0.69444, 0.03057, 0], 99: [0, 0.44444, 0.08336, 0], 100: [0, 0.69444, 0.09483, 0], 101: [0, 0.44444, 0.06778, 0], 102: [0, 0.69444, 0.21705, 0], 103: [0.19444, 0.44444, 0.10836, 0], 104: [0, 0.69444, 0.01778, 0], 105: [0, 0.67937, 0.09718, 0], 106: [0.19444, 0.67937, 0.09162, 0], 107: [0, 0.69444, 0.08336, 0], 108: [0, 0.69444, 0.09483, 0], 109: [0, 0.44444, 0.01778, 0], 110: [0, 0.44444, 0.01778, 0], 111: [0, 0.44444, 0.06613, 0], 112: [0.19444, 0.44444, 0.0389, 0], 113: [0.19444, 0.44444, 0.04169, 0], 114: [0, 0.44444, 0.10836, 0], 115: [0, 0.44444, 0.0778, 0], 116: [0, 0.57143, 0.07225, 0], 117: [0, 0.44444, 0.04169, 0], 118: [0, 0.44444, 0.10836, 0], 119: [0, 0.44444, 0.10836, 0], 120: [0, 0.44444, 0.09169, 0], 121: [0.19444, 0.44444, 0.10836, 0], 122: [0, 0.44444, 0.08752, 0], 126: [0.35, 0.32659, 0.08826, 0], 160: q, 168: [0, 0.67937, 0.06385, 0], 176: p2, 184: [0.17014, 0, 0, 0], 305: [0, 0.44444, 0.04169, 0], 567: [0.19444, 0.44444, 0.04169, 0], 710: [0, 0.69444, 0.0799, 0], 711: [0, 0.63194, 0.08432, 0], 713: [0, 0.60889, 0.08776, 0], 714: [0, 0.69444, 0.09205, 0], 715: p2, 728: [0, 0.69444, 0.09483, 0], 729: [0, 0.67937, 0.07774, 0], 730: p2, 732: [0, 0.67659, 0.08826, 0], 733: [0, 0.69444, 0.09205, 0], 915: [0, 0.69444, 0.13372, 0], 916: p2, 920: [0, 0.69444, 0.07555, 0], 923: p2, 926: [0, 0.69444, 0.12816, 0], 928: [0, 0.69444, 0.08094, 0], 931: [0, 0.69444, 0.11983, 0], 933: [0, 0.69444, 0.09031, 0], 934: [0, 0.69444, 0.04603, 0], 936: [0, 0.69444, 0.09031, 0], 937: [0, 0.69444, 0.08293, 0], 8211: [0, 0.44444, 0.08616, 0], 8212: [0, 0.44444, 0.08616, 0], 8216: [0, 0.69444, 0.07816, 0], 8217: [0, 0.69444, 0.07816, 0], 8220: [0, 0.69444, 0.14205, 0], 8221: [0, 0.69444, 316e-5, 0] }, "SansSerif-Regular": { 32: q, 33: p2, 34: p2, 35: N, 36: [0.05556, 0.75, 0, 0], 37: [0.05556, 0.75, 0, 0], 38: p2, 39: p2, 40: B, 41: B, 42: Ve, 43: [0.08333, 0.58333, 0, 0], 44: [0.125, 0.08333, 0, 0], 45: O, 46: [0, 0.08333, 0, 0], 47: B, 48: [0, 0.65556, 0, 0], 49: [0, 0.65556, 0, 0], 50: [0, 0.65556, 0, 0], 51: [0, 0.65556, 0, 0], 52: [0, 0.65556, 0, 0], 53: [0, 0.65556, 0, 0], 54: [0, 0.65556, 0, 0], 55: [0, 0.65556, 0, 0], 56: [0, 0.65556, 0, 0], 57: [0, 0.65556, 0, 0], 58: O, 59: [0.125, 0.44444, 0, 0], 61: [-0.13, 0.37, 0, 0], 63: p2, 64: p2, 65: p2, 66: p2, 67: p2, 68: p2, 69: p2, 70: p2, 71: p2, 72: p2, 73: p2, 74: p2, 75: p2, 76: p2, 77: p2, 78: p2, 79: p2, 80: p2, 81: [0.125, 0.69444, 0, 0], 82: p2, 83: p2, 84: p2, 85: p2, 86: [0, 0.69444, 0.01389, 0], 87: [0, 0.69444, 0.01389, 0], 88: p2, 89: [0, 0.69444, 0.025, 0], 90: p2, 91: B, 93: B, 94: p2, 95: [0.35, 0.09444, 0.02778, 0], 97: O, 98: p2, 99: O, 100: p2, 101: O, 102: [0, 0.69444, 0.06944, 0], 103: [0.19444, 0.44444, 0.01389, 0], 104: p2, 105: [0, 0.67937, 0, 0], 106: [0.19444, 0.67937, 0, 0], 107: p2, 108: p2, 109: O, 110: O, 111: O, 112: ye, 113: ye, 114: [0, 0.44444, 0.01389, 0], 115: O, 116: [0, 0.57143, 0, 0], 117: O, 118: [0, 0.44444, 0.01389, 0], 119: [0, 0.44444, 0.01389, 0], 120: O, 121: [0.19444, 0.44444, 0.01389, 0], 122: O, 126: [0.35, 0.32659, 0, 0], 160: q, 168: [0, 0.67937, 0, 0], 176: p2, 184: [0.17014, 0, 0, 0], 305: O, 567: ye, 710: p2, 711: [0, 0.63194, 0, 0], 713: [0, 0.60889, 0, 0], 714: p2, 715: p2, 728: p2, 729: [0, 0.67937, 0, 0], 730: p2, 732: [0, 0.67659, 0, 0], 733: p2, 915: p2, 916: p2, 920: p2, 923: p2, 926: p2, 928: p2, 931: p2, 933: p2, 934: p2, 936: p2, 937: p2, 8211: [0, 0.44444, 0.02778, 0], 8212: [0, 0.44444, 0.02778, 0], 8216: p2, 8217: p2, 8220: p2, 8221: p2 }, "Script-Regular": { 32: q, 65: [0, 0.7, 0.22925, 0], 66: [0, 0.7, 0.04087, 0], 67: [0, 0.7, 0.1689, 0], 68: [0, 0.7, 0.09371, 0], 69: [0, 0.7, 0.18583, 0], 70: [0, 0.7, 0.13634, 0], 71: [0, 0.7, 0.17322, 0], 72: [0, 0.7, 0.29694, 0], 73: [0, 0.7, 0.19189, 0], 74: [0.27778, 0.7, 0.19189, 0], 75: [0, 0.7, 0.31259, 0], 76: [0, 0.7, 0.19189, 0], 77: [0, 0.7, 0.15981, 0], 78: [0, 0.7, 0.3525, 0], 79: [0, 0.7, 0.08078, 0], 80: [0, 0.7, 0.08078, 0], 81: [0, 0.7, 0.03305, 0], 82: [0, 0.7, 0.06259, 0], 83: [0, 0.7, 0.19189, 0], 84: [0, 0.7, 0.29087, 0], 85: [0, 0.7, 0.25815, 0], 86: [0, 0.7, 0.27523, 0], 87: [0, 0.7, 0.27523, 0], 88: [0, 0.7, 0.26006, 0], 89: [0, 0.7, 0.2939, 0], 90: [0, 0.7, 0.24037, 0], 160: q }, "Size1-Regular": { 32: q, 40: De, 41: De, 47: De, 91: De, 92: De, 93: De, 123: De, 125: De, 160: q, 710: [0, 0.72222, 0, 0], 732: [0, 0.72222, 0, 0], 770: [0, 0.72222, 0, 0], 771: [0, 0.72222, 0, 0], 8214: [-99e-5, 0.601, 0, 0], 8593: [1e-5, 0.6, 0, 0], 8595: [1e-5, 0.6, 0, 0], 8657: [1e-5, 0.6, 0, 0], 8659: [1e-5, 0.6, 0, 0], 8719: it, 8720: it, 8721: it, 8730: De, 8739: [-599e-5, 0.606, 0, 0], 8741: [-599e-5, 0.606, 0, 0], 8747: [0.30612, 0.805, 0.19445, 0], 8748: [0.306, 0.805, 0.19445, 0], 8749: [0.306, 0.805, 0.19445, 0], 8750: [0.30612, 0.805, 0.19445, 0], 8896: it, 8897: it, 8898: it, 8899: it, 8968: De, 8969: De, 8970: De, 8971: De, 9168: [-99e-5, 0.601, 0, 0], 10216: De, 10217: De, 10752: it, 10753: it, 10754: it, 10756: it, 10758: it }, "Size2-Regular": { 32: q, 40: Me, 41: Me, 47: Me, 91: Me, 92: Me, 93: Me, 123: Me, 125: Me, 160: q, 710: Ve, 732: Ve, 770: Ve, 771: Ve, 8719: ot, 8720: ot, 8721: ot, 8730: Me, 8747: [0.86225, 1.36, 0.44445, 0], 8748: [0.862, 1.36, 0.44445, 0], 8749: [0.862, 1.36, 0.44445, 0], 8750: [0.86225, 1.36, 0.44445, 0], 8896: ot, 8897: ot, 8898: ot, 8899: ot, 8968: Me, 8969: Me, 8970: Me, 8971: Me, 10216: Me, 10217: Me, 10752: ot, 10753: ot, 10754: ot, 10756: ot, 10758: ot }, "Size3-Regular": { 32: q, 40: Oe, 41: Oe, 47: Oe, 91: Oe, 92: Oe, 93: Oe, 123: Oe, 125: Oe, 160: q, 710: Ve, 732: Ve, 770: Ve, 771: Ve, 8730: Oe, 8968: Oe, 8969: Oe, 8970: Oe, 8971: Oe, 10216: Oe, 10217: Oe }, "Size4-Regular": { 32: q, 40: Be, 41: Be, 47: Be, 91: Be, 92: Be, 93: Be, 123: Be, 125: Be, 160: q, 710: [0, 0.825, 0, 0], 732: [0, 0.825, 0, 0], 770: [0, 0.825, 0, 0], 771: [0, 0.825, 0, 0], 8730: Be, 8968: Be, 8969: Be, 8970: Be, 8971: Be, 9115: [0.64502, 1.155, 0, 0], 9116: [1e-5, 0.6, 0, 0], 9117: [0.64502, 1.155, 0, 0], 9118: [0.64502, 1.155, 0, 0], 9119: [1e-5, 0.6, 0, 0], 9120: [0.64502, 1.155, 0, 0], 9121: [0.64502, 1.155, 0, 0], 9122: [-99e-5, 0.601, 0, 0], 9123: [0.64502, 1.155, 0, 0], 9124: [0.64502, 1.155, 0, 0], 9125: [-99e-5, 0.601, 0, 0], 9126: [0.64502, 1.155, 0, 0], 9127: [1e-5, 0.9, 0, 0], 9128: Me, 9129: [0.90001, 0, 0, 0], 9130: [0, 0.3, 0, 0], 9131: [1e-5, 0.9, 0, 0], 9132: Me, 9133: [0.90001, 0, 0, 0], 9143: [0.88502, 0.915, 0, 0], 10216: Be, 10217: Be, 57344: [-499e-5, 0.605, 0, 0], 57345: [-499e-5, 0.605, 0, 0], 57680: [0, 0.12, 0, 0], 57681: [0, 0.12, 0, 0], 57682: [0, 0.12, 0, 0], 57683: [0, 0.12, 0, 0] }, "Typewriter-Regular": { 32: q, 33: L, 34: L, 35: L, 36: [0.08333, 0.69444, 0, 0], 37: [0.08333, 0.69444, 0, 0], 38: L, 39: L, 40: [0.08333, 0.69444, 0, 0], 41: [0.08333, 0.69444, 0, 0], 42: [0, 0.52083, 0, 0], 43: [-0.08056, 0.53055, 0, 0], 44: [0.13889, 0.125, 0, 0], 45: [-0.08056, 0.53055, 0, 0], 46: [0, 0.125, 0, 0], 47: [0.08333, 0.69444, 0, 0], 48: L, 49: L, 50: L, 51: L, 52: L, 53: L, 54: L, 55: L, 56: L, 57: L, 58: [0, 0.43056, 0, 0], 59: [0.13889, 0.43056, 0, 0], 60: [-0.05556, 0.55556, 0, 0], 61: [-0.19549, 0.41562, 0, 0], 62: [-0.05556, 0.55556, 0, 0], 63: L, 64: L, 65: L, 66: L, 67: L, 68: L, 69: L, 70: L, 71: L, 72: L, 73: L, 74: L, 75: L, 76: L, 77: L, 78: L, 79: L, 80: L, 81: [0.13889, 0.61111, 0, 0], 82: L, 83: L, 84: L, 85: L, 86: L, 87: L, 88: L, 89: L, 90: L, 91: [0.08333, 0.69444, 0, 0], 92: [0.08333, 0.69444, 0, 0], 93: [0.08333, 0.69444, 0, 0], 94: L, 95: [0.09514, 0, 0, 0], 96: L, 97: [0, 0.43056, 0, 0], 98: L, 99: [0, 0.43056, 0, 0], 100: L, 101: [0, 0.43056, 0, 0], 102: L, 103: [0.22222, 0.43056, 0, 0], 104: L, 105: L, 106: [0.22222, 0.61111, 0, 0], 107: L, 108: L, 109: [0, 0.43056, 0, 0], 110: [0, 0.43056, 0, 0], 111: [0, 0.43056, 0, 0], 112: [0.22222, 0.43056, 0, 0], 113: [0.22222, 0.43056, 0, 0], 114: [0, 0.43056, 0, 0], 115: [0, 0.43056, 0, 0], 116: [0, 0.55358, 0, 0], 117: [0, 0.43056, 0, 0], 118: [0, 0.43056, 0, 0], 119: [0, 0.43056, 0, 0], 120: [0, 0.43056, 0, 0], 121: [0.22222, 0.43056, 0, 0], 122: [0, 0.43056, 0, 0], 123: [0.08333, 0.69444, 0, 0], 124: [0.08333, 0.69444, 0, 0], 125: [0.08333, 0.69444, 0, 0], 126: L, 127: L, 160: q, 176: L, 184: [0.19445, 0, 0, 0], 305: [0, 0.43056, 0, 0], 567: [0.22222, 0.43056, 0, 0], 711: [0, 0.56597, 0, 0], 713: [0, 0.56555, 0, 0], 714: L, 715: L, 728: L, 730: L, 770: L, 771: L, 776: L, 915: L, 916: L, 920: L, 923: L, 926: L, 928: L, 931: L, 933: L, 934: L, 936: L, 937: L, 8216: L, 8217: L, 8242: L, 9251: [0.11111, 0.21944, 0, 0] } };
    var Ll = /[\u3040-\u309F]|[\u30A0-\u30FF]|[\u4E00-\u9FAF]|[\uAC00-\uD7AF]/, Zt = 10, ze = 0.25, xn = 1.2, St = 0.431, Uo = { slant: [0.25, 0.25, 0.25], space: [0, 0, 0], stretch: [0, 0, 0], shrink: [0, 0, 0], xHeight: [St, St, St], quad: [1, 1.171, 1.472], extraSpace: [0, 0, 0], num1: [0.677, 0.732, 0.925], num2: [0.394, 0.384, 0.387], num3: [0.444, 0.471, 0.504], denom1: [0.686, 0.752, 1.025], denom2: [0.345, 0.344, 0.532], sup1: [0.413, 0.503, 0.504], sup2: [0.363, 0.431, 0.404], sup3: [0.289, 0.286, 0.294], sub1: [0.15, 0.143, 0.2], sub2: [0.247, 0.286, 0.4], supDrop: [0.386, 0.353, 0.494], subDrop: [0.05, 0.071, 0.1], delim1: [2.39, 1.7, 1.98], delim2: [1.01, 1.157, 1.42], axisHeight: [ze, ze, ze], defaultRuleThickness: [0.04, 0.049, 0.049], bigOpSpacing1: [0.111, 0.111, 0.111], bigOpSpacing2: [0.166, 0.166, 0.166], bigOpSpacing3: [0.2, 0.2, 0.2], bigOpSpacing4: [0.6, 0.611, 0.611], bigOpSpacing5: [0.1, 0.143, 0.143], sqrtRuleThickness: [0.04, 0.04, 0.04] }, fi = [0, 0.5, 0.7, 0.8, 0.9, 1, 1.2, 1.44, 1.728, 2.074, 2.488], nt = 5, bn = { " ": " ", "​": " ", Å: "A", Ç: "C", Ð: "D", Þ: "o", å: "a", ç: "c", ð: "d", þ: "o", А: "A", Б: "B", В: "B", Г: "F", Д: "A", Е: "E", Ж: "K", З: "3", И: "N", Й: "N", К: "K", Л: "N", М: "M", Н: "H", О: "O", П: "N", Р: "P", С: "C", Т: "T", У: "y", Ф: "O", Х: "X", Ц: "U", Ч: "h", Ш: "W", Щ: "W", Ъ: "B", Ы: "X", Ь: "B", Э: "3", Ю: "X", Я: "R", а: "a", б: "b", в: "a", г: "r", д: "y", е: "e", ж: "m", з: "e", и: "n", й: "n", к: "n", л: "n", м: "m", н: "n", о: "o", п: "n", р: "p", с: "c", т: "o", у: "y", ф: "b", х: "x", ц: "n", ч: "n", ш: "w", щ: "w", ъ: "a", ы: "m", ь: "a", э: "e", ю: "m", я: "r" };
    function zt(r, e) {
      r === void 0 && (r = 77);
      let t = yn[e][r];
      if (t)
        return { defaultMetrics: false, depth: t[0], height: t[1], italic: t[2], skew: t[3] };
      if (r === 11034)
        return { defaultMetrics: true, depth: 0.2, height: 0.8, italic: 0, skew: 0 };
      let i = String.fromCodePoint(r);
      if (i in bn)
        r = bn[i].codePointAt(0);
      else if (Ll.test(i))
        return r = 77, { defaultMetrics: true, depth: 0.2, height: 0.9, italic: 0, skew: 0 };
      return { defaultMetrics: true, depth: 0.2, height: 0.7, italic: 0, skew: 0 };
    }
    var jo = { overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"], overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"], underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"], underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"], xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"], xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"], Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"], xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"], xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"], overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"], xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"], xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"], overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"], xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"], xlongequal: [["longequal"], 0.888, 334, "xMinYMin"], xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"], xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"], overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522], overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548], underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548], underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522], xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522], xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560], xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716], xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716], xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522], xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522], overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522], underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522], overgroup: [["leftgroup", "rightgroup"], 0.888, 342], undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342], xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522], xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528], xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901], xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716], xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716] }, Xo = { widehat1: [1062, 239, 0.24], widehat2: [2364, 300, 0.3], widehat3: [2364, 360, 0.36], widehat4: [2364, 420, 0.42], widecheck1: [1062, 239, 0.24], widecheck2: [2364, 300, 0.3], widecheck3: [2364, 360, 0.36], widecheck4: [2364, 420, 0.42], widetilde1: [600, 260, 0.26], widetilde2: [1033, 286, 0.286], widetilde3: [2339, 306, 0.306], widetilde4: [2340, 312, 0.34], overarc: [1061, 159, 0.3], underarc: [1061, 159, 0.3] }, vn = { doubleleftarrow: `M262 157
l10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3
 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28
 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5
c2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5
 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87
-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7
-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z
m8 0v40h399730v-40zm0 194v40h399730v-40z`, doublerightarrow: `M399738 392l
-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5
 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88
-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68
-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18
-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782
c-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3
-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z`, leftarrow: `M400000 241H110l3-3c68.7-52.7 113.7-120
 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8
-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247
c-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208
 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3
 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202
 l-3-3h399890zM100 241v40h399900v-40z`, leftbrace: `M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117
-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7
 5-6 9-10 13-.7 1-7.3 1-20 1H6z`, leftbraceunder: `M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13
 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688
 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7
-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z`, overarc: "M529 0c179 0 524 115 524 115 5 1 9 5 9 10 0 1-1 2-1 3l-4 22c-1 5-5 9-11 9h-2s-338-93-512-92c-174 0-513 92-513 92h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13 0 0 342-115 520-115z", underarc: `m 529 160
  c -179 0 -524 -115 -524 -115
  c -5 -1 -9 -5 -9 -10
  c 0 -1 1 -2 1 -3
  l 4 -22
  c 1 -5 5 -9 11 -9
  h 2
  s 338 93 512 92
  c 174 0 513 -92 513 -92
  h 2
  c 5 0 9 4 11 9
  l 5 22
  c 1 6 -2 12 -8 13
  c 0 0 -342 115 -520 115
  z
  `, leftgroup: `M400000 80
H435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0
 435 0h399565z`, leftgroupunder: `M400000 262
H435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219
 435 219h399565z`, leftharpoon: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3
-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5
-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7
-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z`, leftharpoonplus: `M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5
 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3
-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7
-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z
m0 0v40h400000v-40z`, leftharpoondown: `M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333
 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5
 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667
-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z`, leftharpoondownplus: `M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12
 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7
-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0
v40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z`, lefthook: `M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5
-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3
-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21
 71.5 23h399859zM103 281v-40h399897v40z`, leftlinesegment: `M40 281 V428 H0 V94 H40 V241 H400000 v40z
M40 281 V428 H0 V94 H40 V241 H400000 v40z`, leftmapsto: `M40 281 V448H0V74H40V241H400000v40z
M40 281 V448H0V74H40V241H400000v40z`, leftToFrom: `M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23
-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8
c28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3
 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z`, longequal: `M0 50 h400000 v40H0z m0 194h40000v40H0z
M0 50 h400000 v40H0z m0 194h40000v40H0z`, midbrace: `M200428 334
c-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14
-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7
 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11
 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z`, midbraceunder: `M199572 214
c100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14
 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3
 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0
-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z`, oiintSize1: `M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6
-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z
m368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8
60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z`, oiintSize2: `M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8
-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z
m502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2
c0 110 84 276 504 276s502.4-166 502.4-276z`, oiiintSize1: `M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6
-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z
m525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0
85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z`, oiiintSize2: `M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8
-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z
m770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1
c0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z`, rightarrow: `M0 241v40h399891c-47.3 35.3-84 78-110 128
-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20
 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7
 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85
-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
 151.7 139 205zm0 0v40h399900v-40z`, rightbrace: `M400000 542l
-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5
s-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1
c124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z`, rightbraceunder: `M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3
 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237
-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z`, rightgroup: `M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0
 3-1 3-3v-38c-76-158-257-219-435-219H0z`, rightgroupunder: `M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18
 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z`, rightharpoon: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3
-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2
-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58
 69.2 92 94.5zm0 0v40h399900v-40z`, rightharpoonplus: `M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11
-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7
 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z
m0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z`, rightharpoondown: `M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8
 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5
-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95
-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z`, rightharpoondownplus: `M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8
 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3
 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3
-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z
m0-194v40h400000v-40zm0 0v40h400000v-40z`, righthook: `M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3
 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0
-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21
 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z`, rightlinesegment: `M399960 241 V94 h40 V428 h-40 V281 H0 v-40z
M399960 241 V94 h40 V428 h-40 V281 H0 v-40z`, rightToFrom: `M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23
 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32
-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142
-167z M100 147v40h399900v-40zM0 341v40h399900v-40z`, twoheadleftarrow: `M0 167c68 40
 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69
-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3
-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19
-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101
 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z`, twoheadrightarrow: `M400000 167
c-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3
 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42
 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333
-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70
 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z`, widetilde1: `M200 55.538c-77 0-168 73.953-177 73.953-3 0-7
-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0
 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0
 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128
-68.267.847-113-73.952-191-73.952z`, widetilde2: `M344 55.266c-142 0-300.638 81.316-311.5 86.418
-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9
 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114
c1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751
 181.476 676 181.476c-149 0-189-126.21-332-126.21z`, widetilde3: `M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457
-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0
 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697
 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696
 -338 0-409-156.573-744-156.573z`, widetilde4: `M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345
-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409
 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9
 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409
 -175.236-744-175.236z`, vec: `M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5
3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11
10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63
-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1
-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59
H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359
c-16-25.333-24-45-24-59z`, widehat1: `M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22
c-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z`, widehat2: `M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widehat3: `M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widehat4: `M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10
-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z`, widecheck1: `M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,
-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z`, widecheck2: `M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, widecheck3: `M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, widecheck4: `M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,
-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z`, baraboveleftarrow: `M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202
c4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5
c-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130
s-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47
121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6
s2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11
c0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z
M100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z`, rightarrowabovebar: `M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32
-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0
13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39
-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5
-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5
-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67
151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z`, baraboveshortleftharpoon: `M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17
c2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21
c-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40
c-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z
M0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z`, rightharpoonaboveshortbar: `M0,241 l0,40c399126,0,399993,0,399993,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z`, shortbaraboveleftharpoon: `M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11
c1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,
1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,
-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z
M93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z`, shortrightharpoonabovebar: `M53,241l0,40c398570,0,399437,0,399437,0
c4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,
-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6
c-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z
M500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z` };
    function wn(r) {
      if (Xo[r]) {
        let [c, u, d] = Xo[r], m = `<span class="stretchy" style="height:${d}em"><svg width="100%" height="${d}em" viewBox="0 0 ${c} ${u}" preserveAspectRatio="none" ><path fill="currentcolor" d="${vn[r]}"></path></svg></span>`;
        return `<span style="display:inline-block;height:${d / 2}em;min-width:0">${m}</span>`;
      }
      let [e, t, i, o] = jo[r], a, n, s = i / 1e3;
      e.length === 3 ? (a = ["slice-1-of-3", "slice-2-of-3", "slice-3-of-3"], n = ["xMinYMin", "xMidYMin", "xMaxYMin"]) : e.length === 2 ? (a = ["slice-1-of-2", "slice-2-of-2"], n = ["xMinYMin", "xMaxYMin"]) : (a = ["slice-1-of-1"], n = [o]);
      let l = e.map((c, u) => `<span class="${a[u]}" style=height:${s}em><svg width=400em height=${s}em viewBox="0 0 400000 ${i}" preserveAspectRatio="${n[u]} slice"><path fill="currentcolor" d="${vn[c]}"></path></svg></span>`).join("");
      return `<span style="display:inline-block;height:${s}em;min-width:${t}em;">${l}</span>`;
    }
    function kn(r) {
      return jo[r] ? jo[r][2] / 1e3 : Xo[r][2];
    }
    var Fr = class {
      constructor(e) {
        Fr._registry[e] = this;
      }
      static createAtom(e, t, i, o) {
        return Fr._registry[e].createAtom(t, i, o);
      }
      static serialize(e, t) {
        return e.length > 0, Fr._registry[e[0].mode].serialize(e, t);
      }
      static applyStyle(e, t, i) {
        return Fr._registry[e].applyStyle(t, i);
      }
    }, Te = Fr;
    Te._registry = {};
    function Sn(r) {
      let e = [], t = [], i = "NONE";
      for (let o of r)
        o.type !== "first" && (o.mode !== i ? (t.length > 0 && e.push(t), t = [o], i = o.mode) : t.push(o));
      return t.length > 0 && e.push(t), e;
    }
    function Re(r, e) {
      let t = [], i = [], o;
      for (let a of r)
        if (a.type !== "first" && a.style) {
          let n;
          e === "variant" ? (n = a.style.variant, a.style.variantStyle && a.style.variantStyle !== "up" && (n += "-" + a.style.variantStyle)) : e === "cssClass" ? a.type === "group" && (n = a.customClass) : n = a.style[e], n === o ? i.push(a) : (i.length > 0 && t.push(i), i = [a], o = n);
        }
      return i.length > 0 && t.push(i), t;
    }
    function _n(r, e, t) {
      return Te.applyStyle(r, e, t);
    }
    var Mn = ["", "chem", "mord", "mbin", "mop", "mrel", "mopen", "mclose", "mpunct", "minner", "spacing", "first", "latex", "composition", "error", "placeholder", "supsub", "none", "mathfield"];
    function An(r) {
      return Mn.includes(r);
    }
    var Cl = { mord: { mop: 3, mbin: 4, mrel: 5, minner: 3 }, mop: { mord: 3, mop: 3, rel: 5, minner: 3 }, mbin: { mord: 4, mop: 4, mopen: 4, minner: 4 }, mrel: { mord: 5, mop: 5, mopen: 5, minner: 5 }, mclose: { mop: 3, mbin: 4, mrel: 5, minner: 3 }, mpunct: { mord: 3, mop: 3, mrel: 3, mopen: 3, mpunct: 3, minner: 3 }, minner: { mord: 3, mop: 3, mbin: 4, mrel: 5, mopen: 3, mpunct: 3, minner: 3 } }, Tl = { mord: { mop: 3 }, mop: { mord: 3, mop: 3 }, mclose: { mop: 3 }, minner: { mop: 3 } };
    function gi(r, e) {
      if (typeof r == "string")
        return r;
      if (typeof r == "number") {
        let t = Math.ceil(100 * r) / 100;
        return t === 0 ? "0" : t.toString() + (e != null ? e : "");
      }
      return "";
    }
    var v = class {
      constructor(e, t) {
        var o, a, n, s, l, c;
        if (typeof e == "number" ? this.value = String.fromCodePoint(e) : typeof e == "string" ? this.value = e : Y(e) ? this.children = e.filter((u) => u !== null) : e && e instanceof v && (this.children = [e]), this.type = (o = t == null ? void 0 : t.type) != null ? o : "", this.isSelected = false, this.isTight = (a = t == null ? void 0 : t.isTight) != null ? a : false, this.newList = (n = t == null ? void 0 : t.newList) != null ? n : false, t != null && t.properties)
          for (let u of Object.keys(t.properties))
            this.setStyle(u, t.properties[u]);
        t != null && t.attributes && (this.attributes = t.attributes), this.classes = (s = t == null ? void 0 : t.classes) != null ? s : "";
        let i = (t == null ? void 0 : t.fontFamily) || "Main-Regular";
        if (t != null && t.style && this.value && (i = _n((l = t.mode) != null ? l : "math", this, t.style) || "Main-Regular"), this.height = 0, this.depth = 0, this.skew = 0, this.italic = 0, this.maxFontSize = 0, this.type === "latex")
          this.height = 0.8, this.depth = 0.2;
        else if (typeof e == "number") {
          let u = zt(e, i);
          this.height = u.height, this.depth = u.depth, this.skew = u.skew, this.italic = u.italic;
        } else if (this.value) {
          this.height = -1 / 0, this.depth = -1 / 0, this.skew = -1 / 0, this.italic = -1 / 0;
          for (let u = 0; u < this.value.length; u++) {
            let d = zt(this.value.codePointAt(u), i || "Main-Regular");
            this.height = Math.max(this.height, d.height), this.depth = Math.max(this.depth, d.depth), this.skew = d.skew, this.italic = d.italic;
          }
        } else if (this.children && this.children.length > 0)
          if (this.children.length === 1) {
            let u = this.children[0];
            this.height = u.height, this.depth = u.depth, this.maxFontSize = u.maxFontSize, this.skew = u.skew, this.italic = u.italic;
          } else {
            let u = -1 / 0, d = -1 / 0, m = 0;
            for (let h of this.children)
              h.height > u && (u = h.height), h.depth > d && (d = h.depth), m = Math.max(m, (c = h.maxFontSize) != null ? c : 0);
            this.height = u, this.depth = d, this.maxFontSize = m;
          }
        (t == null ? void 0 : t.height) !== void 0 && (this.height = t.height), (t == null ? void 0 : t.depth) !== void 0 && (this.depth = t.depth), (t == null ? void 0 : t.maxFontSize) !== void 0 && (this.maxFontSize = t.maxFontSize);
      }
      set atomID(e) {
        e === void 0 || e.length === 0 || (this.attributes || (this.attributes = {}), this.attributes["data-atom-id"] = e);
      }
      selected(e) {
        if (this.isSelected !== e && (this.isSelected = e, this.children))
          for (let t of this.children)
            t.selected(e);
      }
      setStyle(e, t, i) {
        if (t === void 0)
          return;
        let o = gi(t, i);
        o.length > 0 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties[e] = o);
      }
      setTop(e) {
        Number.isFinite(e) && Math.abs(e) > 0.01 && (this.cssProperties || (this.cssProperties = {}), this.cssProperties.top = gi(e, "em"), this.height -= e, this.depth += e);
      }
      get left() {
        var e;
        return (e = this.cssProperties) != null && e["margin-left"] ? Number.parseFloat(this.cssProperties["margin-left"]) : 0;
      }
      set left(e) {
        Number.isFinite(e) && (e === 0 ? this.cssProperties && delete this.cssProperties["margin-left"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-left"] = gi(e, "em")));
      }
      set right(e) {
        Number.isFinite(e) && (e === 0 ? this.cssProperties && delete this.cssProperties["margin-right"] : (this.cssProperties || (this.cssProperties = {}), this.cssProperties["margin-right"] = gi(e, "em")));
      }
      set width(e) {
        Number.isFinite(e) && (e === 0 ? this.cssProperties && delete this.cssProperties.width : (this.cssProperties || (this.cssProperties = {}), this.cssProperties.width = gi(e, "em")));
      }
      wrap(e, t) {
        let i = e.parent;
        if (!i)
          return this;
        e.isPhantom && this.setStyle("opacity", 0);
        let o = e.computedColor;
        o === i.computedColor && (o = ""), this.setStyle("color", o);
        let a = e.effectiveFontSize === i.effectiveFontSize ? void 0 : e.effectiveFontSize, n = e.computedBackgroundColor;
        if (this.isSelected && (n = Jo(n)), n === i.computedBackgroundColor && (n = ""), !a && !n && !(t && (t.classes || t.type)))
          return this;
        let s;
        n ? (s = _t(this, t), s.selected(this.isSelected), s.setStyle("background-color", n), s.setStyle("display", "inline-block")) : s = new v(this, t);
        let l = e.scalingFactor;
        return l !== 1 && (s.setStyle("font-size", l * 100, "%"), s.height *= l, s.depth *= l, s.italic *= l, s.skew *= l), s;
      }
      wrapSelect(e) {
        if (!this.isSelected)
          return this;
        if (!e.parent)
          return this;
        let i = Jo(e.computedBackgroundColor), o = _t(this);
        return o.selected(true), o.setStyle("background-color", i), o.setStyle("display", "inline-block"), o;
      }
      toMarkup() {
        var a, n, s;
        let e = (a = this.value) != null ? a : "";
        if (this.children)
          for (let l of this.children)
            e += l.toMarkup();
        let t = this.classes.split(" ");
        t.push((n = { latex: "ML__latex", placeholder: "ML__placeholder", error: "ML__error" }[this.type]) != null ? n : ""), this.caret === "latex" && t.push("ML__latex-caret");
        let i = t.length === 1 ? t[0] : t.filter((l, c, u) => l.length > 0 && u.indexOf(l) === c).join(" "), o = "";
        if (e.length > 0 && e !== "​" || i.length > 0 || this.cssId || this.htmlData || this.htmlStyle || this.attributes || this.cssProperties || this.svgBody || this.svgOverlay) {
          let l = "";
          if (this.cssId && (l += ` id="${this.cssId.replace(/ /g, "-")}" `), this.htmlData) {
            let u = this.htmlData.split(",");
            for (let d of u) {
              let m = d.match(/([^=]+)=(.+$)/);
              if (m) {
                let h = m[1].trim().replace(/ /g, "-");
                h && (l += ` data-${h}="${m[2]}" `);
              } else {
                let h = d.trim().replace(/ /g, "-");
                h && (l += ` data-${h} `);
              }
            }
          }
          if (this.htmlStyle) {
            let u = this.htmlStyle.split(";"), d = "";
            for (let m of u) {
              let h = m.match(/([^=]+):(.+$)/);
              if (h) {
                let f = h[1].trim().replace(/ /g, "-");
                f && (d += `${f}:${h[2]};`);
              }
            }
            d && (l += ` style="${d}"`);
          }
          if (this.attributes && (l += " " + Object.keys(this.attributes).map((u) => `${u}="${this.attributes[u]}"`).join(" ")), i.length > 0 && (l += ` class="${i}"`), this.cssProperties) {
            let u = Object.keys(this.cssProperties).map((d) => `${d}:${this.cssProperties[d]}`).join(";");
            u.length > 0 && (l += ` style="${u}"`);
          }
          let c = "";
          this.svgBody ? c = wn(this.svgBody) : this.svgOverlay && (c = '<span style="', c += "display: inline-block;", c += `height:${this.height + this.depth}em;`, c += `vertical-align:${this.depth}em;`, c += '">', c += e, c += "</span>", c += '<svg style="position:absolute;overflow:overlay;', c += `height:${this.height + this.depth}em;`, (s = this.cssProperties) != null && s.padding ? (c += `top:${this.cssProperties.padding}em;`, c += `left:${this.cssProperties.padding}em;`, c += `width:calc(100% - 2 * ${this.cssProperties.padding}em );`) : c += "top:0;left:0;width:100%;", c += "z-index:2;", c += '"', this.svgStyle && (c += ` style="${this.svgStyle}"`), c += `>${this.svgOverlay}</svg>`), o = `<span${l}>${e}${c}</span>`;
        }
        return this.caret === "text" ? o += '<span class="ML__text-caret"></span>' : this.caret === "math" && (o += '<span class="ML__caret"></span>'), o;
      }
      tryCoalesceWith(e) {
        if (this.type !== e.type || !/ML__text/.test(this.classes) && !["mord", "mbin", "mrel"].includes(this.type) || this.svgBody || !this.value || e.svgBody || !e.value)
          return false;
        let t = this.children && this.children.length > 0, i = e.children && e.children.length > 0;
        if (t || i)
          return false;
        let o = this.cssProperties ? Object.keys(this.cssProperties).length : 0, a = e.cssProperties ? Object.keys(e.cssProperties).length : 0;
        if (o !== a)
          return false;
        if (o > 0) {
          for (let l of Object.keys(this.cssProperties))
            if (this.cssProperties[l] !== e.cssProperties[l])
              return false;
        }
        let n = this.classes.trim().replace(/\s+/g, " ").split(" "), s = e.classes.trim().replace(/\s+/g, " ").split(" ");
        if (n.length !== s.length)
          return false;
        n.sort(), s.sort();
        for (let [l, c] of n.entries())
          if (c === "vertical-separator" || c !== s[l])
            return false;
        return this.value += e.value, this.height = Math.max(this.height, e.height), this.depth = Math.max(this.depth, e.depth), this.maxFontSize = Math.max(this.maxFontSize, e.maxFontSize), this.italic = e.italic, true;
      }
    };
    function Zo(r) {
      if (!r || r.length === 0)
        return [];
      r[0].children = Zo(r[0].children);
      let e = [r[0]];
      for (let t = 1; t < r.length; t++)
        e[e.length - 1].tryCoalesceWith(r[t]) || (r[t].children = Zo(r[t].children), e.push(r[t]));
      return e;
    }
    function Yt(r) {
      return r.children && (r.children = Zo(r.children)), r;
    }
    function El(r) {
      Cn(r, (e, t) => {
        t.type === "mbin" && (!e || /first|none|mbin|mop|mrel|mopen|mpunct/.test(e.type)) && (t.type = "mord"), e && e.type === "mbin" && /mrel|mclose|mpunct|placeholder/.test(t.type) && (e.type = "mord");
      });
    }
    function Pl(r, e) {
      Cn(r, (t, i) => {
        var s, l, c, u;
        let o = (s = t == null ? void 0 : t.type) != null ? s : "none", a = i.isTight ? (l = Tl[o]) != null ? l : null : (c = Cl[o]) != null ? c : null, n = (u = a == null ? void 0 : a[i.type]) != null ? u : "none";
        n !== "none" && (n === 3 && (i.left += e.getRegisterAsEm("thinmuskip")), n === 4 && (i.left += e.getRegisterAsEm("medmuskip")), n === 5 && (i.left += e.getRegisterAsEm("thickmuskip")));
      });
    }
    function Ln(r, e, t) {
      e.newList && (r = null);
      let i = e.type;
      if (i === "first")
        return e.newList, null;
      if (i === "spacing")
        return r;
      if (t(r, e), e.children) {
        let o = null;
        (i === void 0 || i.length === 0) && (o = r);
        for (let a of e.children)
          o = Ln(o, a, t);
        (i === void 0 || i.length === 0) && (r = o);
      }
      return i !== "supsub" && i !== void 0 && i.length > 0 && (r = e), r;
    }
    function Cn(r, e) {
      r && Ln(null, r, e);
    }
    function Mt(r, e) {
      return El(r), Pl(r, e), r;
    }
    function _t(r, e) {
      if (!r)
        return new v(null, e);
      let t = new v(null, { classes: "ML__strut" });
      t.setStyle("height", Math.max(0, r.height), "em");
      let i = [t];
      if (r.depth !== 0) {
        let o = new v(null, { classes: "ML__strut--bottom" });
        o.setStyle("height", r.height + r.depth, "em"), o.setStyle("vertical-align", -r.depth, "em"), i.push(o);
      }
      return i.push(r), new v(i, e);
    }
    function ji(r, e, t) {
      return r.svgOverlay = e, r.svgStyle = t, r;
    }
    function Nr(r) {
      let e = kn(r) / 2, t = new v(null, { height: e + 0.166, depth: e - 0.166, maxFontSize: 0 });
      return t.svgBody = r, t;
    }
    function Kl(r) {
      if ("individualShift" in r) {
        let e = r.individualShift, t = e[0], i = [t], o = -t.shift - t.box.depth, a = o;
        for (let n = 1; n < e.length; n++) {
          let s = e[n], l = -s.shift - a - s.box.depth, c = l - (t.box.height + t.box.depth);
          a = a + l, i.push(c), i.push(s), t = s;
        }
        return [i, o];
      }
      if ("top" in r) {
        let e = r.top;
        for (let t of r.children)
          e -= typeof t == "number" ? t : t.box.height + t.box.depth;
        return [r.children, e];
      } else {
        if ("bottom" in r)
          return [r.children, -r.bottom];
        if ("firstBaseline" in r) {
          let e = r.firstBaseline[0];
          if (typeof e == "number")
            throw new Error("First child must be an element.");
          return [r.firstBaseline, -e.box.depth];
        } else if ("shift" in r) {
          let e = r.children[0];
          if (typeof e == "number")
            throw new Error("First child must be an element.");
          return [r.children, -e.box.depth - r.shift];
        }
      }
      return [null, 0];
    }
    function Dl(r) {
      var m;
      let [e, t] = Kl(r);
      if (!e)
        return [[], 0, 0];
      let i = 0;
      for (let h of e)
        if (typeof h != "number") {
          let f = h.box;
          i = Math.max(i, f.maxFontSize, f.height);
        }
      i += 2;
      let o = new v(null, { classes: "pstrut" });
      o.setStyle("height", i, "em");
      let a = [], n = t, s = t, l = t;
      for (let h of e) {
        if (typeof h == "number")
          l += h;
        else {
          let f = h.box, y = (m = h.classes) != null ? m : [], w = new v([o, f], { classes: y.join(" "), style: h.style });
          w.setStyle("top", -i - l - f.depth, "em"), h.marginLeft && w.setStyle("margin-left", h.marginLeft, "em"), h.marginRight && w.setStyle("margin-right", h.marginRight, "em"), a.push(w), l += f.height + f.depth;
        }
        n = Math.min(n, l), s = Math.max(s, l);
      }
      let c = new v(a, { classes: "vlist" });
      if (c.setStyle("height", s, "em"), n >= 0)
        return [[new v(c, { classes: "vlist-r" })], s, -n];
      let u = new v(new v(null), { classes: "vlist" });
      u.setStyle("height", -n, "em");
      let d = new v(8203, { classes: "vlist-s", maxFontSize: 0, height: 0, depth: 0 });
      return [[new v([c, d], { classes: "vlist-r" }), new v(u, { classes: "vlist-r" })], s, -n];
    }
    var Q = class extends v {
      constructor(e, t) {
        var n;
        let [i, o, a] = Dl(e);
        super(i.length === 1 ? i[0] : i, { classes: ((n = t == null ? void 0 : t.classes) != null ? n : "") + " vlist-t" + (i.length === 2 ? " vlist-t2" : ""), height: o, depth: a, type: t == null ? void 0 : t.type });
      }
    };
    function Tn(r, e) {
      var c, u, d, m, h;
      let t = r.metrics, i = new v(e.base), o = (c = e.baseShift) != null ? c : 0, a = (u = e.slant) != null ? u : 0, n = 0, s = 0;
      e.above && (n = (d = e.aboveShift) != null ? d : Math.max(t.bigOpSpacing1, t.bigOpSpacing3 - e.above.depth)), e.below && (s = (m = e.belowShift) != null ? m : Math.max(t.bigOpSpacing2, t.bigOpSpacing4 - e.below.height));
      let l = null;
      if (e.below && e.above) {
        let f = t.bigOpSpacing5 + e.below.height + e.below.depth + s + i.depth + o;
        l = new Q({ bottom: f, children: [t.bigOpSpacing5, { box: e.below, marginLeft: -a, classes: ["ML__center"] }, s, { box: i, classes: ["ML__center"] }, n, { box: e.above, marginLeft: a, classes: ["ML__center"] }, t.bigOpSpacing5] }).wrap(r);
      } else if (e.below && !e.above)
        l = new Q({ top: i.height - o, children: [t.bigOpSpacing5, { box: e.below, marginLeft: -a, classes: ["ML__center"] }, s, { box: i, classes: ["ML__center"] }] }).wrap(r);
      else if (!e.below && e.above) {
        let f = i.depth + o;
        l = new Q({ bottom: f, children: [{ box: i, classes: ["ML__center"] }, n, { box: e.above, marginLeft: a, classes: ["ML__center"] }, t.bigOpSpacing5] }).wrap(r);
      } else {
        let f = i.depth + o;
        l = new Q({ bottom: f, children: [{ box: i }, t.bigOpSpacing5] }).wrap(r);
      }
      return e.type, new v(l, { type: (h = e.type) != null ? h : "mop" });
    }
    function Bl(r) {
      let e = [];
      for (let t = 0; t < r.length; t++) {
        let i = r.charCodeAt(t);
        if (i === 13 && r.charCodeAt(t + 1) === 10 && (i = 10, t++), (i === 13 || i === 12) && (i = 10), i === 0 && (i = 65533), i >= 55296 && i <= 56319) {
          let o = r.charCodeAt(t + 1);
          if (o >= 56320 && o <= 57343) {
            let a = i - 55296, n = o - 56320;
            i = 2 ** 16 + a * 2 ** 10 + n, t++;
          }
        }
        e.push(i);
      }
      return e;
    }
    var Zi = 8205, Ol = [[Zi, 1], [65038, 2], [127995, 5], [129456, 4], [917536, 96]], Xi, En = [127462, 127487];
    function Pn(r) {
      var e;
      if (Xi === void 0) {
        Xi = {};
        for (let t of Ol)
          for (let i = t[0]; i <= t[0] + t[1] - 1; i++)
            Xi[i] = true;
      }
      return (e = Xi[r]) != null ? e : false;
    }
    function zl(r) {
      return r >= En[0] && r <= En[1];
    }
    function Yi(r) {
      if (/^[\u0020-\u00FF]*$/.test(r))
        return r;
      let e = [], t = Bl(r), i = 0;
      for (; i < t.length; ) {
        let o = t[i++], a = t[i];
        if (a === Zi) {
          let n = i - 1;
          for (i += 2; t[i] === Zi; )
            i += 2;
          e.push(String.fromCodePoint(...t.slice(n, i - n + 1)));
        } else if (Pn(a)) {
          let n = i - 1;
          for (; Pn(t[i]); )
            i += t[i] === Zi ? 2 : 1;
          e.push(String.fromCodePoint(...t.slice(n, 2 * i - n - 1)));
        } else
          zl(o) ? (i += 1, e.push(String.fromCodePoint(...t.slice(i - 2, 2)))) : e.push(String.fromCodePoint(o));
      }
      return e;
    }
    var Yo = class {
      constructor(e) {
        this.s = Yi(e), this.pos = 0, this.obeyspaces = false;
      }
      end() {
        return this.pos >= this.s.length;
      }
      get() {
        return this.pos < this.s.length ? this.s[this.pos++] : "";
      }
      peek() {
        return this.s[this.pos];
      }
      match(e) {
        let t = typeof this.s == "string" ? e.exec(this.s.slice(this.pos)) : e.exec(this.s.slice(this.pos).join(""));
        return t != null && t[0] ? (this.pos += t[0].length, t[0]) : "";
      }
      next() {
        if (this.end())
          return null;
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]+/) || this.obeyspaces && this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]/))
          return "<space>";
        let e = this.get();
        if (e === "\\") {
          if (!this.end()) {
            let t = this.match(/^[a-zA-Z\*]+/);
            if (t)
              this.match(/^[ \f\n\r\t\v\u00A0\u2028\u2029]*/);
            else if (t = this.get(), t === " ")
              return "<space>";
            return "\\" + t;
          }
        } else {
          if (e === "{")
            return "<{>";
          if (e === "}")
            return "<}>";
          if (e === "^") {
            if (this.peek() === "^") {
              this.get();
              let t = this.match(/^(\^(\^(\^(\^[\da-f])?[\da-f])?[\da-f])?[\da-f])?[\da-f]{2}/);
              if (t)
                return String.fromCodePoint(Number.parseInt(t.slice(t.lastIndexOf("^") + 1), 16));
            }
            return e;
          } else if (e === "#") {
            if (!this.end()) {
              let t = false;
              if (/[\d?@]/.test(this.peek()) && (t = true, this.pos + 1 < this.s.length)) {
                let i = this.s[this.pos + 1];
                t = /[^\dA-Za-z]/.test(i);
              }
              return t ? "#" + this.get() : "#";
            }
          } else if (e === "$")
            return this.peek() === "$" ? (this.get(), "<$$>") : "<$>";
        }
        return e;
      }
    };
    function Rl(r, e) {
      var o, a, n, s;
      let t = [], i = r.next();
      if (i && i !== "\\relax") {
        if (i === "\\noexpand")
          i = r.next(), i && t.push(i);
        else if (i === "\\obeyspaces")
          r.obeyspaces = true;
        else if (i === "\\space" || i === "~")
          t.push("<space>");
        else if (i === "\\bgroup")
          t.push("<{>");
        else if (i === "\\egroup")
          t.push("<}>");
        else if (i === "\\string") {
          if (i = r.next(), i)
            if (i.startsWith("\\"))
              for (let l of i)
                t.push(l === "\\" ? "\\backslash" : l);
            else
              i === "<{>" ? t.push("\\{") : i === "<space>" ? t.push("~") : i === "<}>" && t.push("\\}");
        } else if (i === "\\csname") {
          for (; r.peek() === "<space>"; )
            r.next();
          let l = "", c = false, u = [];
          do {
            if (u.length === 0)
              if (/^#[\d?@]$/.test(r.peek())) {
                let d = r.get().slice(1);
                u = xr((a = (o = e == null ? void 0 : e(d)) != null ? o : e == null ? void 0 : e("?")) != null ? a : "\\placeholder{}", e), i = u[0];
              } else
                i = r.next(), u = i ? [i] : [];
            c = u.length === 0, !c && i === "\\endcsname" && (c = true, u.shift()), c || (c = i === "<$>" || i === "<$$>" || i === "<{>" || i === "<}>" || typeof i == "string" && i.length > 1 && i.startsWith("\\")), c || (l += u.shift());
          } while (!c);
          l && t.push("\\" + l), t.push(...u);
        } else if (i !== "\\endcsname")
          if (i.length > 1 && i.startsWith("#")) {
            let l = i.slice(1);
            t.push(...xr((s = (n = e == null ? void 0 : e(l)) != null ? n : e == null ? void 0 : e("?")) != null ? s : "\\placeholder{}", e));
          } else
            t.push(i);
      }
      return t;
    }
    function xr(r, e = null) {
      let t = [], i = "";
      for (let n of r.toString().split(/\r?\n/)) {
        i && t.push(i), i = " ";
        let s = n.match(/((?:\\%)|[^%])*/);
        s !== null && t.push(s[0]);
      }
      let o = new Yo(t.join("")), a = [];
      do
        a.push(...Rl(o, e));
      while (!o.end());
      return a;
    }
    function j(r) {
      let e = "", t = [];
      for (let i of r)
        i && (/[a-zA-Z\*]/.test(i[0]) && t.push(e), t.push(i), /\\[a-zA-Z]+\*?[\"\'][^\ ]+$/.test(i) && t.push(" "), e = /\\[a-zA-Z]+\*?$/.test(i) ? " " : "");
      return t.join("");
    }
    function Ir(r) {
      return j(r.map((e) => {
        var t;
        return (t = { "<space>": " ", "<$$>": "$$", "<$>": "$", "<{>": "{", "<}>": "}" }[e]) != null ? t : e;
      }));
    }
    var Qo = { 119893: 8462, 119965: 8492, 119968: 8496, 119969: 8497, 119971: 8459, 119972: 8464, 119975: 8466, 119976: 8499, 119981: 8475, 119994: 8495, 119996: 8458, 120004: 8500, 120070: 8493, 120075: 8460, 120076: 8465, 120085: 8476, 120093: 8488, 120122: 8450, 120127: 8461, 120133: 8469, 120135: 8473, 120136: 8474, 120137: 8477, 120145: 8484 }, Kn = [{ start: 119808, len: 26, offset: 65, style: "bold" }, { start: 119834, len: 26, offset: 97, style: "bold" }, { start: 119860, len: 26, offset: 65, style: "italic" }, { start: 119886, len: 26, offset: 97, style: "italic" }, { start: 119912, len: 26, offset: 65, style: "bolditalic" }, { start: 119938, len: 26, offset: 97, style: "bolditalic" }, { start: 119964, len: 26, offset: 65, variant: "script" }, { start: 119990, len: 26, offset: 97, variant: "script" }, { start: 120016, len: 26, offset: 65, variant: "script", style: "bold" }, { start: 120042, len: 26, offset: 97, variant: "script", style: "bold" }, { start: 120068, len: 26, offset: 65, variant: "fraktur" }, { start: 120094, len: 26, offset: 97, variant: "fraktur" }, { start: 120172, len: 26, offset: 65, variant: "fraktur", style: "bold" }, { start: 120198, len: 26, offset: 97, variant: "fraktur", style: "bold" }, { start: 120120, len: 26, offset: 65, variant: "double-struck" }, { start: 120146, len: 26, offset: 97, variant: "double-struck" }, { start: 120224, len: 26, offset: 65, variant: "sans-serif" }, { start: 120250, len: 26, offset: 97, variant: "sans-serif" }, { start: 120276, len: 26, offset: 65, variant: "sans-serif", style: "bold" }, { start: 120302, len: 26, offset: 97, variant: "sans-serif", style: "bold" }, { start: 120328, len: 26, offset: 65, variant: "sans-serif", style: "italic" }, { start: 120354, len: 26, offset: 97, variant: "sans-serif", style: "italic" }, { start: 120380, len: 26, offset: 65, variant: "sans-serif", style: "bolditalic" }, { start: 120406, len: 26, offset: 97, variant: "sans-serif", style: "bolditalic" }, { start: 120432, len: 26, offset: 65, variant: "monospace" }, { start: 120458, len: 26, offset: 97, variant: "monospace" }, { start: 120488, len: 25, offset: 913, style: "bold" }, { start: 120514, len: 25, offset: 945, style: "bold" }, { start: 120546, len: 25, offset: 913, style: "italic" }, { start: 120572, len: 25, offset: 945, style: "italic" }, { start: 120604, len: 25, offset: 913, style: "bolditalic" }, { start: 120630, len: 25, offset: 945, style: "bolditalic" }, { start: 120662, len: 25, offset: 913, variant: "sans-serif", style: "bold" }, { start: 120688, len: 25, offset: 945, variant: "sans-serif", style: "bold" }, { start: 120720, len: 25, offset: 913, variant: "sans-serif", style: "bolditalic" }, { start: 120746, len: 25, offset: 945, variant: "sans-serif", style: "bolditalic" }, { start: 120782, len: 10, offset: 48, variant: "main", style: "bold" }, { start: 120792, len: 10, offset: 48, variant: "double-struck" }, { start: 120803, len: 10, offset: 48, variant: "sans-serif" }, { start: 120812, len: 10, offset: 48, variant: "sans-serif", style: "bold" }, { start: 120822, len: 10, offset: 48, variant: "monospace" }];
    function Dn(r, e, t) {
      if (!/[A-Za-z\d]/.test(r) || !e && !t)
        return r;
      let i = r.codePointAt(0);
      if (i === void 0)
        return r;
      for (let o of Kn)
        if ((!e || o.variant === e) && (!t || o.style === t) && i >= o.offset && i < o.offset + o.len) {
          let a = o.start + i - o.offset;
          return String.fromCodePoint(Qo[a] || a);
        }
      return r;
    }
    function Bn(r) {
      var e;
      if ((r < 119808 || r > 120831) && (r < 8448 || r > 8527))
        return { char: String.fromCodePoint(r) };
      for (let t in Qo)
        if (Qo[t] === r) {
          r = (e = t.codePointAt(0)) != null ? e : 0;
          break;
        }
      for (let t of Kn)
        if (r >= t.start && r < t.start + t.len)
          return { char: String.fromCodePoint(r - t.start + t.offset), variant: t.variant, style: t.style };
      return { char: String.fromCodePoint(r) };
    }
    var lt = {}, eo = { 60: "\\lt", 62: "\\gt", 111: "o", 38: "\\&", 123: "\\lbrace", 125: "\\rbrace", 91: "\\lbrack", 93: "\\rbrack", 58: "\\colon", 160: "~", 172: "\\neg", 183: "\\cdot", 188: "\\frac{1}{4}", 189: "\\frac{1}{2}", 190: "\\frac{3}{4}", 8304: "^{0}", 8305: "^{i}", 185: "^{1}", 178: "^{2}", 179: "^{3}", 8224: "\\dagger", 8225: "\\ddagger", 8230: "\\ldots", 8308: "^{4}", 8309: "^{5}", 8310: "^{6}", 8311: "^{7}", 8312: "^{8}", 8313: "^{9}", 8314: "^{+}", 8315: "^{-}", 8316: "^{=}", 8319: "^{n}", 8320: "_{0}", 8321: "_{1}", 8322: "_{2}", 8323: "_{3}", 8324: "_{4}", 8325: "_{5}", 8326: "_{6}", 8327: "_{7}", 8328: "_{8}", 8329: "_{9}", 8330: "_{+}", 8331: "_{-}", 8332: "_{=}", 8336: "_{a}", 8337: "_{e}", 8338: "_{o}", 8339: "_{x}", 8242: "\\prime", 39: "\\prime", 8592: "\\gets", 8594: "\\to", 9651: "\\triangle", 9661: "\\triangledown", 8715: "\\owns", 8727: "\\ast", 8739: "\\vert", 8741: "\\Vert", 8743: "\\land", 8744: "\\lor", 8901: "\\cdot", 8904: "\\bowtie", 8800: "\\ne", 8804: "\\le", 8805: "\\ge", 8869: "\\bot", 10231: "\\biconditional", 10232: "\\impliedby", 10233: "\\implies", 10234: "\\iff", 8450: "\\mathbb{C}", 8469: "\\mathbb{N}", 8473: "\\mathbb{P}", 8474: "\\mathbb{Q}", 8477: "\\mathbb{R}", 8484: "\\mathbb{Z}", 8461: "\\mathbb{H}", 8476: "\\Re", 8465: "\\Im", 42: "\\ast", 11036: "\\square", 9633: "\\square", 8720: "\\coprod", 8716: "\\not\\ni", 9671: "\\diamond", 8846: "\\uplus", 8851: "\\sqcap", 8852: "\\sqcup", 8768: "\\wr", 8750: "\\oint", 8226: "\\textbullet", 8722: "-", 978: "\\Upsilon" }, st = {}, io = {}, Fl = { darr: "\\downarrow", dArr: "\\Downarrow", Darr: "\\Downarrow", lang: "\\langle", rang: "\\rangle", uarr: "\\uparrow", uArr: "\\Uparrow", Uarr: "\\Uparrow", N: "\\mathbb{N}", R: "\\mathbb{R}", Z: "\\mathbb{Z}", alef: "\\aleph", alefsym: "\\aleph", Alpha: "\\mathrm{A}", Beta: "\\mathrm{B}", bull: "\\bullet", Chi: "\\mathrm{X}", clubs: "\\clubsuit", cnums: "\\mathbb{C}", Complex: "\\mathbb{C}", Dagger: "\\ddagger", diamonds: "\\diamondsuit", empty: "\\emptyset", Epsilon: "\\mathrm{E}", Eta: "\\mathrm{H}", exist: "\\exists", harr: "\\leftrightarrow", hArr: "\\Leftrightarrow", Harr: "\\Leftrightarrow", hearts: "\\heartsuit", image: "\\Im", infin: "\\infty", Iota: "\\mathrm{I}", isin: "\\in", Kappa: "\\mathrm{K}", larr: "\\leftarrow", lArr: "\\Leftarrow", Larr: "\\Leftarrow", lrarr: "\\leftrightarrow", lrArr: "\\Leftrightarrow", Lrarr: "\\Leftrightarrow", Mu: "\\mathrm{M}", natnums: "\\mathbb{N}", Nu: "\\mathrm{N}", Omicron: "\\mathrm{O}", plusmn: "\\pm", rarr: "\\rightarrow", rArr: "\\Rightarrow", Rarr: "\\Rightarrow", real: "\\Re", reals: "\\mathbb{R}", Reals: "\\mathbb{R}", Rho: "\\mathrm{P}", sdot: "\\cdot", sect: "\\S", spades: "\\spadesuit", sub: "\\subset", sube: "\\subseteq", supe: "\\supseteq", Tau: "\\mathrm{T}", thetasym: "\\vartheta", weierp: "\\wp", Zeta: "\\mathrm{Z}" }, Nl = { varGamma: "\\mathit{\\Gamma}", varDelta: "\\mathit{\\Delta}", varTheta: "\\mathit{\\Theta}", varLambda: "\\mathit{\\Lambda}", varXi: "\\mathit{\\Xi}", varPi: "\\mathit{\\Pi}", varSigma: "\\mathit{\\Sigma}", varUpsilon: "\\mathit{\\Upsilon}", varPhi: "\\mathit{\\Phi}", varPsi: "\\mathit{\\Psi}", varOmega: "\\mathit{\\Omega}", pmod: { def: "\\quad(\\operatorname{mod}\\ #1)", args: 1, expand: false }, mod: { def: "\\quad\\operatorname{mod}\\,\\,#1", args: 1, expand: false }, bmod: { def: "\\;\\mathbin{\\operatorname{mod }}", expand: false } }, Il = { bra: "\\mathinner{\\langle{#1}|}", ket: "\\mathinner{|{#1}\\rangle}", braket: "\\mathinner{\\langle{#1}\\rangle}", set: "\\mathinner{\\lbrace #1 \\rbrace}", Bra: "\\left\\langle #1\\right|", Ket: "\\left|#1\\right\\rangle", Braket: "\\left\\langle{#1}\\right\\rangle", Set: "\\left\\lbrace #1 \\right\\rbrace" }, $l = { iff: "\\;⟺\\;", nicefrac: "^{#1}\\!\\!/\\!_{#2}", rd: "\\mathrm{d}", rD: "\\mathrm{D}", doubleStruckCapitalN: "\\mathbb{N}", doubleStruckCapitalR: "\\mathbb{R}", doubleStruckCapitalQ: "\\mathbb{Q}", doubleStruckCapitalZ: "\\mathbb{Z}", doubleStruckCapitalP: "\\mathbb{P}", scriptCapitalE: "\\mathscr{E}", scriptCapitalH: "\\mathscr{H}", scriptCapitalL: "\\mathscr{L}", gothicCapitalC: "\\mathfrak{C}", gothicCapitalH: "\\mathfrak{H}", gothicCapitalI: "\\mathfrak{I}", gothicCapitalR: "\\mathfrak{R}", imaginaryI: "\\mathrm{i}", imaginaryJ: "\\mathrm{j}", exponentialE: "\\mathrm{e}", differentialD: "\\mathrm{d}", capitalDifferentialD: "\\mathrm{D}", "braket.sty": { package: Il }, "amsmath.sty": { package: Nl, expand: false }, "texvc.sty": { package: Fl, expand: false } }, At = { " ": 32, "\\#": 35, "\\&": 38, "\\$": 36, "\\%": 37, "\\_": 95, "\\euro": 8364, "\\maltese": 10016, "\\{": 123, "\\}": 125, "\\nobreakspace": 160, "\\ldots": 8230, "\\textellipsis": 8230, "\\backslash": 92, "`": 8216, "'": 8217, "``": 8220, "''": 8221, "\\degree": 176, "\\textasciicircum": 94, "\\textasciitilde": 126, "\\textasteriskcentered": 42, "\\textbackslash": 92, "\\textbraceleft": 123, "\\textbraceright": 125, "\\textbullet": 8226, "\\textdollar": 36, "\\textsterling": 163, "\\textdagger": 8224, "\\textdaggerdbl": 8225, "–": 8211, "—": 8212, "‘": 8216, "’": 8217, "“": 8220, "”": 8221, '"': 8221, "\\ss": 223, "\\ae": 230, "\\oe": 339, "\\AE": 198, "\\OE": 338, "\\O": 216, "\\i": 305, "\\j": 567, "\\aa": 229, "\\AA": 197 }, Rn = /[\w!@*()-=+{}[\]\\';:?/.,~<>`|$%#&^" ]/, Fn = Vo() ? new RegExp("\\p{Letter}", "u") : /[a-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒößÖẞìíòúÌÍÒÚáñÁÑ]/, $r = Vo() ? new RegExp("[0-9\\p{Letter}]", "u") : /[\da-zA-ZаАбБвВгГдДеЕёЁжЖзЗиИйЙкКлЛмМнНоОпПрРсСтТуУфФхХцЦчЧшШщЩъЪыЫьЬэЭюЮяĄąĆćĘęŁłŃńÓóŚśŹźŻżàâäôéèëêïîçùûüÿæœÀÂÄÔÉÈËÊÏÎŸÇÙÛÜÆŒößÖẞìíòúÌÍÒÚáñÁÑ]/;
    function ea(r, e, t = "mord", i) {
      e !== void 0 && (lt[r] = { definitionType: "symbol", type: t, variant: i, codepoint: e }, eo[e] || (eo[e] = r), At[r] || (At[r] = e));
    }
    function ve(r, e, t) {
      if (typeof r == "string") {
        for (let i = 0; i < r.length; i++) {
          let o = r.charAt(i);
          ea(o, o.codePointAt(0));
        }
        return;
      }
      for (let [i, o, a, n] of r)
        ea(i, o, a != null ? a : e, n != null ? n : t);
    }
    function ta(r, e) {
      for (let t = r; t <= e; t++)
        ea(String.fromCodePoint(t), t);
    }
    function Nn(r) {
      var e;
      return (e = io[r]) != null ? e : null;
    }
    function In(r, e) {
      var o, a;
      if (e === "\\")
        return [];
      if (!e.startsWith("\\"))
        return [];
      let t = [];
      for (let n in st)
        n.startsWith(e) && !st[n].infix && t.push({ match: n, frequency: (o = st[n].frequency) != null ? o : 0 });
      for (let n in lt)
        n.startsWith(e) && t.push({ match: n, frequency: (a = lt[n].frequency) != null ? a : 0 });
      let i = e.substring(1);
      for (let n of Object.keys(r.options.macros))
        n.startsWith(i) && t.push({ match: "\\" + n, frequency: 0 });
      return t.sort((n, s) => {
        var l, c;
        return n.frequency === s.frequency ? n.match.length === s.match.length ? n.match < s.match ? -1 : 1 : n.match.length - s.match.length : ((l = s.frequency) != null ? l : 0) - ((c = n.frequency) != null ? c : 0);
      }), t.map((n) => n.match);
    }
    function On(r) {
      let e = "auto", t = r.match(/:([^=]+)/);
      return t && (e = t[1].trim()), e;
    }
    function to(r) {
      if (!r)
        return [];
      let e = [], t = r.split("]");
      if (t[0].startsWith("[")) {
        e.push({ isOptional: true, type: On(t[0].slice(1)) });
        for (let i = 1; i <= t.length; i++)
          e.push(...to(t[i]));
      } else if (t = r.split("}"), t[0].startsWith("{")) {
        e.push({ isOptional: false, type: On(t[0].slice(1)) });
        for (let i = 1; i <= t.length; i++)
          e.push(...to(t[i]));
      }
      return e;
    }
    function ra(r) {
      if (!r)
        return "";
      let e = "", t = true;
      for (let i of r)
        typeof i.value == "string" ? e += i.value : t = false;
      return t ? e : "";
    }
    function bi(r, e, t, i = false) {
      typeof r == "string" && (r = [r]);
      let o = to(e), a = { tabular: i, params: o, createAtom: t };
      for (let n of r)
        io[n] = a;
    }
    function ht(r, e, t) {
      bi(r, e, t, true);
    }
    function x(r, e, t) {
      var o, a;
      t || (t = {});
      let i = { definitionType: "function", params: to(e), ifMode: t.ifMode, isFunction: (o = t.isFunction) != null ? o : false, applyMode: t.applyMode, infix: (a = t.infix) != null ? a : false, createAtom: t.createAtom, applyStyle: t.applyStyle };
      if (typeof r == "string")
        st["\\" + r] = i;
      else
        for (let n of r)
          st["\\" + n] = i;
    }
    var Qi;
    function qr(r) {
      return Qi || (Qi = ro($l)), r ? ro(b(b({}, Qi), r)) : Qi;
    }
    function zn(r, e) {
      var t, i, o, a;
      if (typeof r == "string") {
        let n = 0, s = r;
        return /(^|[^\\])#1/.test(s) && (n = 1), /(^|[^\\])#2/.test(s) && (n = 2), /(^|[^\\])#3/.test(s) && (n = 3), /(^|[^\\])#4/.test(s) && (n = 4), /(^|[^\\])#5/.test(s) && (n = 5), /(^|[^\\])#6/.test(s) && (n = 6), /(^|[^\\])#7/.test(s) && (n = 7), /(^|[^\\])#8/.test(s) && (n = 8), /(^|[^\\])#9/.test(s) && (n = 9), { expand: (t = e == null ? void 0 : e.expand) != null ? t : true, captureSelection: (i = e == null ? void 0 : e.captureSelection) != null ? i : true, args: n, def: s };
      }
      return b({ expand: (o = e == null ? void 0 : e.expand) != null ? o : true, captureSelection: (a = e == null ? void 0 : e.captureSelection) != null ? a : true, args: 0 }, r);
    }
    function ro(r) {
      if (!r)
        return {};
      let e = {};
      for (let t of Object.keys(r)) {
        let i = r[t];
        if (i == null)
          delete e[t];
        else if (typeof i == "object" && "package" in i)
          for (let o of Object.keys(i.package))
            e[o] = zn(i.package[o], { expand: i.expand, captureSelection: i.captureSelection });
        else
          e[t] = zn(i);
      }
      return e;
    }
    function Vr(r) {
      if (r.length === 1) {
        let e = r[0];
        if (e.type === "mbin")
          return "mbin";
        if (e.type === "mrel")
          return "mrel";
      }
      return "mord";
    }
    function xi(r, e = "math") {
      if (!r || r.length === 0)
        return null;
      let t = null;
      if (r.startsWith("\\")) {
        if (t = st[r], t)
          return t;
        e === "math" ? t = lt[r] : At[r] && (t = { definitionType: "symbol", type: "mord", codepoint: At[r] });
      } else if (e === "math") {
        if (t = lt[r], !t && r.length === 1) {
          let i = yi("math", r.codePointAt(0));
          return i.startsWith("\\") ? E(b({}, xi(i, "math")), { command: i }) : null;
        }
      } else
        At[r] ? t = { definitionType: "symbol", type: "mord", codepoint: At[r] } : e === "text" && (t = { definitionType: "symbol", type: "mord", codepoint: r.codePointAt(0) });
      return t && t.definitionType === "symbol" && t.type === "mord" && (t.codepoint === 102 || t.codepoint === 103 || t.codepoint === 104) && (t.isFunction = true), t != null ? t : null;
    }
    function oo(r, e) {
      if (!r.startsWith("\\"))
        return null;
      let t = r.slice(1);
      return e[t];
    }
    function $n(r, e) {
      var a;
      if (r === "text")
        return (a = yi(r, e.codePointAt(0))) != null ? a : e;
      let t;
      if (t = yi(r, e.codePointAt(0)), t)
        return t;
      let i = e.codePointAt(0), o = Bn(i);
      return !o.style && !o.variant ? "" : (t = o.char, o.variant && (t = "\\" + o.variant + "{" + t + "}"), o.style === "bold" ? t = "\\mathbf{" + t + "}" : o.style === "italic" ? t = "\\mathit{" + t + "}" : o.style === "bolditalic" && (t = "\\mathbfit{" + t + "}"), "\\mathord{" + t + "}");
    }
    function yi(r, e) {
      if (e === void 0)
        return "";
      if (r === "math" && eo[e])
        return eo[e];
      if (r === "text") {
        let t = Object.keys(At).find((i) => At[i] === e);
        if (!t) {
          let i = e.toString(16);
          t = "^".repeat(i.length) + i;
        }
        return t;
      }
      return String.fromCodePoint(e);
    }
    var ao = 7, wi = 6, ia = 5, Hr = 4, vi = 3, ct = 2, Gr = 1, Fe = 0, Lt = class {
      constructor(e, t, i) {
        this.id = e, this.sizeDelta = t, this.cramped = i;
        let o = { "-4": 2, "-3": 1, 0: 0 }[t];
        this.metrics = Object.keys(Uo).reduce((a, n) => E(b({}, a), { [n]: Uo[n][o] }), {});
      }
      getFontSize(e) {
        return Math.max(1, e + this.sizeDelta);
      }
      get sup() {
        return Se[[Fe, Gr, Fe, Gr, ct, vi, ct, vi][this.id]];
      }
      get sub() {
        return Se[[Fe, Fe, Fe, Fe, ct, ct, ct, ct][this.id]];
      }
      get fracNum() {
        return Se[[Fe, Gr, Fe, Gr, ct, vi, Hr, ia][this.id]];
      }
      get fracDen() {
        return Se[[Fe, Fe, Fe, Fe, ct, ct, Hr, Hr][this.id]];
      }
      get cramp() {
        return Se[[Fe, Fe, ct, ct, Hr, Hr, wi, wi][this.id]];
      }
      get isTight() {
        return this.sizeDelta < 0;
      }
    }, Se = { 7: new Lt(ao, 0, false), 6: new Lt(wi, 0, true), 5: new Lt(ia, 0, false), 4: new Lt(Hr, 0, true), 3: new Lt(vi, -3, false), 2: new Lt(ct, -3, true), 1: new Lt(Gr, -4, false), 0: new Lt(Fe, -4, true) };
    Se.displaystyle = Se[ao];
    Se.textstyle = Se[ia];
    Se.scriptstyle = Se[vi];
    Se.scriptscriptstyle = Se[Gr];
    function ql(r, e) {
      var i;
      if (!r)
        return 0;
      let t = { pt: 1, mm: 7227 / 2540, cm: 7227 / 254, ex: 35271 / 8192, px: 3 / 4, em: Zt, bp: 803 / 800, dd: 1238 / 1157, pc: 12, in: 72.27, mu: 10 / 18 }[(i = r.unit) != null ? i : "pt"];
      if (Number.isFinite(e)) {
        let o = 10 ** e;
        return Math.round(r.dimension / Zt * t * o) / o;
      }
      return r.dimension * t;
    }
    function Ae(r, e) {
      return r === null ? 0 : ql(r, e) / Zt;
    }
    function qn(r) {
      return Ae(r.glue);
    }
    function no(r) {
      var e;
      return `${r.dimension}${(e = r.unit) != null ? e : "pt"}`;
    }
    var P = class {
      constructor(e, t, i) {
        var n, s, l, c, u, d;
        e instanceof P || (t == null || t.fontSize), e instanceof P && (this.parent = e), e instanceof P || (this.registers = (n = e.registers) != null ? n : {}), this.isPhantom = (c = (l = t == null ? void 0 : t.isPhantom) != null ? l : (s = this.parent) == null ? void 0 : s.isPhantom) != null ? c : false;
        let o = b({}, e);
        t && (t.letterShapeStyle && t.letterShapeStyle !== "auto" && (o.letterShapeStyle = t.letterShapeStyle), t.color && t.color !== "none" && (o.color = t.color), t.backgroundColor && t.backgroundColor !== "none" && (o.backgroundColor = t.backgroundColor), t.fontSize && t.fontSize !== "auto" && t.fontSize !== ((u = this.parent) == null ? void 0 : u._size) && (this._size = t.fontSize)), this.letterShapeStyle = (d = o.letterShapeStyle) != null ? d : "tex", this.color = o.color, this.backgroundColor = o.backgroundColor;
        let a;
        if (typeof i == "string") {
          if (e instanceof P)
            switch (i) {
              case "cramp":
                a = e.mathstyle.cramp;
                break;
              case "superscript":
                a = e.mathstyle.sup;
                break;
              case "subscript":
                a = e.mathstyle.sub;
                break;
              case "numerator":
                a = e.mathstyle.fracNum;
                break;
              case "denominator":
                a = e.mathstyle.fracDen;
                break;
            }
          switch (i) {
            case "textstyle":
              a = Se.textstyle;
              break;
            case "displaystyle":
              a = Se.displaystyle;
              break;
            case "scriptstyle":
              a = Se.scriptstyle;
              break;
            case "scriptscriptstyle":
              a = Se.scriptscriptstyle;
              break;
          }
        }
        this._mathstyle = a, this.atomIdsSettings = e.atomIdsSettings, this.renderPlaceholder = o.renderPlaceholder, !(e instanceof P) || (this.atomIdsSettings, e.atomIdsSettings);
      }
      get mathstyle() {
        let e = this._mathstyle, t = this.parent;
        for (; !e; )
          e = t._mathstyle, t = t.parent;
        return e;
      }
      getRegister(e) {
        var t;
        if ((t = this.registers) != null && t[e])
          return this.registers[e];
        if (this.parent)
          return this.parent.getRegister(e);
      }
      getRegisterAsGlue(e) {
        var t;
        if ((t = this.registers) != null && t[e]) {
          let i = this.registers[e];
          return typeof i == "object" && "glue" in i ? i : typeof i == "object" && "dimension" in i ? { glue: { dimension: i.dimension } } : typeof i == "number" ? { glue: { dimension: i } } : void 0;
        }
        if (this.parent)
          return this.parent.getRegisterAsGlue(e);
      }
      getRegisterAsEm(e) {
        return Ae(this.getRegisterAsDimension(e));
      }
      getRegisterAsDimension(e) {
        var t;
        if ((t = this.registers) != null && t[e]) {
          let i = this.registers[e];
          return typeof i == "object" && "glue" in i ? i.glue : typeof i == "object" && "dimension" in i ? i : typeof i == "number" ? { dimension: i } : void 0;
        }
        if (this.parent)
          return this.parent.getRegisterAsDimension(e);
      }
      setRegister(e, t) {
        if (t === void 0) {
          delete this.registers[e];
          return;
        }
        this.registers[e] = t;
      }
      setGlobalRegister(e, t) {
        let i = this;
        for (; i.parent; )
          i.setRegister(e, void 0), i = i.parent;
        i.setRegister(e, t);
      }
      get size() {
        let e = this._size, t = this.parent;
        for (; !e; )
          e = t._size, t = t.parent;
        return e;
      }
      makeID() {
        if (!this.atomIdsSettings)
          return;
        if (this.atomIdsSettings.overrideID)
          return this.atomIdsSettings.overrideID;
        if (typeof this.atomIdsSettings.seed != "number")
          return Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
        let e = this.atomIdsSettings.seed.toString(36);
        return this.atomIdsSettings.seed += 1, e;
      }
      scale(e) {
        return e * this.effectiveFontSize;
      }
      get scalingFactor() {
        return this.parent ? this.effectiveFontSize / this.parent.effectiveFontSize : 1;
      }
      get isDisplayStyle() {
        return this.mathstyle.id === ao || this.mathstyle.id === wi;
      }
      get isCramped() {
        return this.mathstyle.cramped;
      }
      get isTight() {
        return this.mathstyle.isTight;
      }
      get effectiveFontSize() {
        return fi[Math.max(1, this.size + this.mathstyle.sizeDelta)];
      }
      get computedColor() {
        let e = this.color, t = this.parent;
        return !e && t && (e = t.color, t = t.parent), e != null ? e : "";
      }
      get computedBackgroundColor() {
        let e = this.backgroundColor, t = this.parent;
        return !e && t && (e = t.backgroundColor, t = t.parent), e != null ? e : "";
      }
      get metrics() {
        return this.mathstyle.metrics;
      }
    };
    var oa = {}, Rt = ["above", "body", "below", "superscript", "subscript"];
    function Qt(r) {
      return typeof r == "string" && Rt.includes(r);
    }
    function ki(r) {
      return r !== void 0 && Array.isArray(r) && r.length === 2;
    }
    var g = class {
      constructor(e, t, i) {
        this.id = void 0;
        this.verbatimLatex = void 0;
        this._isDirty = false;
        this._changeCounter = 0;
        this.subsupPlacement = void 0;
        this.explicitSubsupPlacement = false;
        this.skipBoundary = false;
        this.captureSelection = false;
        var o, a, n, s, l, c;
        this.type = e, this.context = t, typeof (i == null ? void 0 : i.value) == "string" && (this.value = i.value), this.command = (a = (o = i == null ? void 0 : i.command) != null ? o : this.value) != null ? a : "", this.mode = (n = i == null ? void 0 : i.mode) != null ? n : "math", this.isFunction = (s = i == null ? void 0 : i.isFunction) != null ? s : false, this.subsupPlacement = i == null ? void 0 : i.limits, this.style = (l = i == null ? void 0 : i.style) != null ? l : {}, this.displayContainsHighlight = (c = i == null ? void 0 : i.displayContainsHighlight) != null ? c : false, i != null && i.serialize && (i.command, oa[i.command] = i.serialize);
      }
      static createBox(e, t, i) {
        var s, l, c;
        if (!t)
          return null;
        let o = Vl(t);
        if (o.length === 1) {
          let u = o[0];
          return u[0].style ? aa(e, u, E(b({}, i), { style: { color: u[0].style.color, backgroundColor: u[0].style.backgroundColor, fontSize: u[0].style.fontSize } })) : aa(e, u, i);
        }
        let a = [], n = i == null ? void 0 : i.newList;
        for (let u of o) {
          let d = new P(e, { color: (s = u[0].style) == null ? void 0 : s.color, backgroundColor: (l = u[0].style) == null ? void 0 : l.backgroundColor, fontSize: (c = u[0].style) == null ? void 0 : c.fontSize }), m = aa(d, u, { newList: n });
          m && (n = false, a.push(m));
        }
        return a.length === 0 ? null : a.length === 1 && !(i != null && i.classes) && !(i != null && i.type) ? a[0].wrap(e) : new v(a, { classes: i == null ? void 0 : i.classes, type: i == null ? void 0 : i.type, newList: i == null ? void 0 : i.newList }).wrap(e);
      }
      static serialize(e, t) {
        return Y(e) ? er(e, t) : typeof e == "number" || typeof e == "boolean" ? e.toString() : typeof e == "string" ? e.replace(/\s/g, "~") : e === void 0 ? "" : !t.expandMacro && typeof e.verbatimLatex == "string" ? e.verbatimLatex : e.command && oa[e.command] ? oa[e.command](e, t) : e.serialize(t);
      }
      static commonAncestor(e, t) {
        if (e === t || e.parent === t.parent)
          return e.parent;
        let i = /* @__PURE__ */ new WeakSet(), { parent: o } = e;
        for (; o; )
          i.add(o), o = o.parent;
        for (o = t.parent; o; ) {
          if (i.has(o))
            return o;
          o = o.parent;
        }
      }
      static fromJson(e, t) {
        let i = new g(e.type, t, e);
        for (let o of Rt)
          e[o] && i.setChildren(e[o], o);
        return i;
      }
      toJson() {
        let e = { type: this.type };
        if (this.mode !== "math" && (e.mode = this.mode), this.command && this.command !== this.value && (e.command = this.command), this.value !== void 0 && (e.value = this.value), this.style && Object.keys(this.style).length > 0 && (e.style = b({}, this.style)), this.verbatimLatex !== void 0 && (e.verbatimLatex = this.verbatimLatex), this.subsupPlacement && (e.subsupPlacement = this.subsupPlacement), this.explicitSubsupPlacement && (e.explicitSubsupPlacement = true), this.isFunction && (e.isFunction = true), this.displayContainsHighlight && (e.displayContainsHighlight = true), this.isExtensibleSymbol && (e.isExtensibleSymbol = true), this.skipBoundary && (e.skipBoundary = true), this.captureSelection && (e.captureSelection = true), this._branches)
          for (let t of Object.keys(this._branches))
            this._branches[t] && (e[t] = this._branches[t].filter((i) => i.type !== "first").map((i) => i.toJson()));
        return e;
      }
      get changeCounter() {
        return this._changeCounter;
      }
      get isDirty() {
        return this._isDirty;
      }
      set isDirty(e) {
        if (this._isDirty = e, e) {
          this._changeCounter++, this.verbatimLatex = void 0, this._children = void 0;
          let { parent: t } = this;
          for (; t; )
            t._isDirty = true, t._changeCounter++, t.verbatimLatex = void 0, t._children = void 0, t = t.parent;
        }
      }
      serialize(e) {
        var t;
        return this.body && this.command ? j([this.command, "{", this.bodyToLatex(e), "}", this.supsubToLatex(e)]) : this.body ? j([this.bodyToLatex(e), this.supsubToLatex(e)]) : this.value && this.value !== "​" ? (t = this.command) != null ? t : $n(this.mode, this.value) : "";
      }
      bodyToLatex(e) {
        return er(this.body, e);
      }
      aboveToLatex(e) {
        return er(this.above, e);
      }
      belowToLatex(e) {
        return er(this.below, e);
      }
      supsubToLatex(e) {
        let t = "";
        if (this.branch("subscript") !== void 0) {
          let i = er(this.subscript, e);
          i.length === 0 ? t += "_{}" : i.length === 1 ? t += "_" + i : t += `_{${i}}`;
        }
        if (this.branch("superscript") !== void 0) {
          let i = er(this.superscript, e);
          i.length === 0 ? t += "^{}" : i.length === 1 ? i === "′" ? t += "^\\prime " : i === "″" ? t += "^\\doubleprime " : t += "^" + i : t += `^{${i}}`;
        }
        return t;
      }
      get treeDepth() {
        let e = 1, t = this.parent;
        for (; t; )
          t = t.parent, e += 1;
        return e;
      }
      get inCaptureSelection() {
        let e = this;
        for (; e; ) {
          if (e.captureSelection)
            return true;
          e = e.parent;
        }
        return false;
      }
      get parentPrompt() {
        let e = this;
        for (; e; ) {
          if (e.type === "prompt" && !e.captureSelection)
            return e;
          e = e.parent;
        }
        return null;
      }
      branch(e) {
        if (Qt(e) && this._branches)
          return this._branches[e];
      }
      get branches() {
        if (!this._branches)
          return [];
        let e = [];
        for (let t of Rt)
          this._branches[t] && e.push(t);
        return e;
      }
      createBranch(e) {
        return Qt(e) ? (this._branches ? this._branches[e] || (this._branches[e] = [this.makeFirstAtom(e)]) : this._branches = { [e]: [this.makeFirstAtom(e)] }, this.isDirty = true, this._branches[e]) : [];
      }
      get row() {
        return ki(this.treeBranch) ? this.treeBranch[0] : -1;
      }
      get col() {
        return ki(this.treeBranch) ? this.treeBranch[1] : -1;
      }
      get body() {
        var e;
        return (e = this._branches) == null ? void 0 : e.body;
      }
      set body(e) {
        this.setChildren(e, "body");
      }
      get superscript() {
        var e;
        return (e = this._branches) == null ? void 0 : e.superscript;
      }
      set superscript(e) {
        this.setChildren(e, "superscript");
      }
      get subscript() {
        var e;
        return (e = this._branches) == null ? void 0 : e.subscript;
      }
      set subscript(e) {
        this.setChildren(e, "subscript");
      }
      get above() {
        var e;
        return (e = this._branches) == null ? void 0 : e.above;
      }
      set above(e) {
        this.setChildren(e, "above");
      }
      get below() {
        var e;
        return (e = this._branches) == null ? void 0 : e.below;
      }
      set below(e) {
        this.setChildren(e, "below");
      }
      get computedStyle() {
        var o;
        if (!this.parent)
          return b({}, (o = this.style) != null ? o : {});
        let e = this.style.verbatimColor !== void 0, t = this.style.verbatimBackgroundColor !== void 0, i = b(b({}, this.parent.computedStyle), this.style);
        return delete i.variant, delete i.variantStyle, t || delete i.verbatimBackgroundColor, e || delete i.verbatimColor, i;
      }
      applyStyle(e) {
        this.isDirty = true, this.style = b(b({}, this.style), e), this.style.fontFamily === "none" && delete this.style.fontFamily, this.style.fontShape === "auto" && delete this.style.fontShape, this.style.fontSeries === "auto" && delete this.style.fontSeries, this.style.color === "none" && (delete this.style.color, delete this.style.verbatimColor), this.style.backgroundColor === "none" && (delete this.style.backgroundColor, delete this.style.verbatimBackgroundColor), this.style.fontSize === "auto" && delete this.style.fontSize;
        for (let t of this.children)
          t.applyStyle(e);
      }
      getInitialBaseElement() {
        var t;
        let e;
        return this.hasEmptyBranch("body") || ((t = this.body) == null || t[0].type, e = this.body[1].getInitialBaseElement()), e != null ? e : this;
      }
      getFinalBaseElement() {
        return this.hasEmptyBranch("body") ? this : this.body[this.body.length - 1].getFinalBaseElement();
      }
      isCharacterBox() {
        if (this.type === "leftright")
          return false;
        let e = this.getInitialBaseElement();
        return /mord/.test(e.type);
      }
      hasEmptyBranch(e) {
        let t = this.branch(e);
        return t ? (t.length > 0, t[0].type, t.length === 1) : true;
      }
      setChildren(e, t) {
        var o;
        if (!e || !Qt(t))
          return;
        (o = e[0]) == null || o.type;
        let i = [this.makeFirstAtom(t), ...e];
        this._branches ? this._branches[t] = i : this._branches = { [t]: i };
        for (let a of e)
          a.parent = this, a.treeBranch = t;
        this.isDirty = true;
      }
      makeFirstAtom(e) {
        let t = new g("first", this.context, { mode: this.mode });
        return t.parent = this, t.treeBranch = e, t;
      }
      addChild(e, t) {
        e.type, this.createBranch(t).push(e), this.isDirty = true, e.parent = this, e.treeBranch = t;
      }
      addChildBefore(e, t) {
        t.treeBranch;
        let i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t), 0, e), this.isDirty = true, e.parent = this, e.treeBranch = t.treeBranch;
      }
      addChildAfter(e, t) {
        t.treeBranch;
        let i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t) + 1, 0, e), this.isDirty = true, e.parent = this, e.treeBranch = t.treeBranch;
      }
      addChildren(e, t) {
        for (let i of e)
          this.addChild(i, t);
      }
      addChildrenAfter(e, t) {
        e.length === 0 || e[0].type, t.treeBranch;
        let i = this.createBranch(t.treeBranch);
        i.splice(i.indexOf(t) + 1, 0, ...e), this.isDirty = true;
        for (let o of e)
          o.parent = this, o.treeBranch = t.treeBranch;
        return e[e.length - 1];
      }
      removeBranch(e) {
        let t = this.branch(e);
        if (Qt(e) && (this._branches[e] = void 0), !t)
          return [];
        for (let i of t)
          i.parent = void 0, i.treeBranch = void 0;
        return t[0].type, t.shift(), this.isDirty = true, t;
      }
      removeChild(e) {
        if (e.parent, e.type === "first")
          return;
        let t = this.branch(e.treeBranch), i = t.indexOf(e);
        t.splice(i, 1), this.isDirty = true, e.parent = void 0, e.treeBranch = void 0;
      }
      get siblings() {
        return this.type === "root" ? [] : this.parent.branch(this.treeBranch);
      }
      get firstSibling() {
        return this.siblings[0];
      }
      get lastSibling() {
        let { siblings: e } = this;
        return e[e.length - 1];
      }
      get isFirstSibling() {
        return this === this.firstSibling;
      }
      get isLastSibling() {
        return this === this.lastSibling;
      }
      get hasNoSiblings() {
        return this.siblings.length === 1;
      }
      get leftSibling() {
        this.parent;
        let e = this.parent.branch(this.treeBranch);
        return e[e.indexOf(this) - 1];
      }
      get rightSibling() {
        this.parent;
        let e = this.parent.branch(this.treeBranch);
        return e[e.indexOf(this) + 1];
      }
      get hasChildren() {
        return !!(this._branches && this.children.length > 0);
      }
      get firstChild() {
        return this.hasChildren, this.children[0];
      }
      get lastChild() {
        this.hasChildren;
        let { children: e } = this;
        return e[e.length - 1];
      }
      get children() {
        if (this._children)
          return this._children;
        if (!this._branches)
          return [];
        let e = [];
        for (let t of Rt)
          if (this._branches[t])
            for (let i of this._branches[t])
              e.push(...i.children), e.push(i);
        return this._children = e, e;
      }
      render(e, t) {
        if (this.type === "first" && !e.atomIdsSettings)
          return null;
        let i = new P(e, this.style), o = "";
        this.type === "root" && (o += " ML__base"), this.isSelected && (o += " ML__selected");
        let a = this.createBox(i, { classes: o, newList: (t == null ? void 0 : t.newList) === true || this.type === "first" });
        return a ? (!this.subsupPlacement && (this.superscript || this.subscript) && (a = this.attachSupsub(i, { base: a })), a.wrap(i)) : null;
      }
      attachSupsub(e, t) {
        var y, w;
        let i = t.base, o = this.superscript, a = this.subscript;
        if (!o && !a)
          return i;
        let n = null, s = null, l = (y = t.isCharacterBox) != null ? y : this.isCharacterBox(), c = 0;
        if (o) {
          let k = new P(e, void 0, "superscript");
          n = g.createBox(k, o, { newList: true }), l || (c = i.height - e.metrics.supDrop * k.scalingFactor);
        }
        let u = 0;
        if (a) {
          let k = new P(e, void 0, "subscript");
          s = g.createBox(k, a, { newList: true }), l || (u = i.depth + e.metrics.subDrop * k.scalingFactor);
        }
        let d;
        e.isDisplayStyle ? d = e.metrics.sup1 : e.isCramped ? d = e.metrics.sup3 : d = e.metrics.sup2;
        let m = 0.5 / Zt / e.scalingFactor, h = null;
        if (s && n) {
          c = Math.max(c, d, n.depth + 0.25 * e.metrics.xHeight), u = Math.max(u, e.metrics.sub2);
          let k = e.metrics.defaultRuleThickness;
          if (c - n.depth - (s.height - u) < 4 * k) {
            u = 4 * k - (c - n.depth) + s.height;
            let T = 0.8 * e.metrics.xHeight - (c - n.depth);
            T > 0 && (c += T, u -= T);
          }
          let S = this.isExtensibleSymbol && i.italic ? -i.italic : 0;
          h = new Q({ individualShift: [{ box: s, shift: u, marginLeft: S }, { box: n, shift: -c }] }).wrap(e);
        } else
          s && !n ? (u = Math.max(u, e.metrics.sub1, s.height - 0.8 * St), h = new Q({ shift: u, children: [{ box: s, marginRight: m, marginLeft: this.isCharacterBox() ? -((w = i.italic) != null ? w : 0) : 0 }] })) : !s && n && (c = Math.max(c, d, n.depth + 0.25 * St), h = new Q({ shift: -c, children: [{ box: n, marginRight: m }] }), h.wrap(e));
        let f = new v(h, { classes: "msubsup" + (this.isSelected ? " ML__selected" : "") });
        return this.caret && (f.caret = this.caret), new v([i, f], { type: t.type });
      }
      attachLimits(e, t) {
        var a;
        let i = this.superscript ? g.createBox(new P(e, this.style, "superscript"), this.superscript, { newList: true }) : null, o = this.subscript ? g.createBox(new P(e, this.style, "subscript"), this.subscript, { newList: true }) : null;
        return !i && !o ? t.base.wrap(e) : Tn(e, E(b({}, t), { above: i, below: o, type: (a = t == null ? void 0 : t.type) != null ? a : "mop" }));
      }
      bind(e, t) {
        if (!t || e.isPhantom || this.value === "​")
          return t;
        let i = this.parent;
        for (; i && !i.captureSelection; )
          i = i.parent;
        return i != null && i.captureSelection || (this.id || (this.id = e.makeID()), t.atomID = this.id), t;
      }
      createBox(e, t) {
        var s, l, c;
        let i = (s = this.value) != null ? s : this.body, o = An(this.type) ? this.type : void 0, a = (l = t == null ? void 0 : t.classes) != null ? l : "";
        this.mode === "text" && (a += " ML__text");
        let n = typeof i == "string" || i === void 0 ? new v(i != null ? i : null, { type: o, mode: this.mode, maxFontSize: e.scalingFactor, style: E(b({ variant: "normal" }, this.style), { letterShapeStyle: e.letterShapeStyle, fontSize: Math.max(1, e.size + e.mathstyle.sizeDelta) }), classes: a, newList: t == null ? void 0 : t.newList }) : (c = g.createBox(e, i, { type: o, mode: this.mode, style: this.style, classes: a, newList: t == null ? void 0 : t.newList })) != null ? c : new v(null);
        return e.isTight && (n.isTight = true), (this.mode !== "math" || this.style.variant === "main") && (n.italic = 0), n.right = n.italic, this.bind(e, n), this.caret && !this.superscript && !this.subscript && (n.caret = this.caret), n;
      }
      isDigit() {
        var e;
        return this.type === "mord" && this.value ? /^[\d,.]$/.test(this.value) : this.type === "group" && ((e = this.body) == null ? void 0 : e.length) === 2 ? this.body[0].type === "first" && this.body[1].value === "," : false;
      }
      asDigit() {
        var e;
        return this.type === "mord" && this.value && /^[\d,.]$/.test(this.value) ? this.value : this.type === "group" && ((e = this.body) == null ? void 0 : e.length) === 2 && this.body[0].type === "first" && this.body[1].value === "," ? "." : "";
      }
    };
    function er(r, e) {
      if (!r || r.length === 0)
        return "";
      if (r[0].type === "first") {
        if (r.length === 1)
          return "";
        r = r.slice(1);
      }
      return r.length === 0 ? "" : j(Re(r, "cssClass").map((t) => j(Re(t, "color").map((i) => j(Sn(i).map((o) => Te.serialize(o, e)))))));
    }
    function Vl(r) {
      let e, t = [], i = [];
      for (let o of r)
        if (!e && !o.style)
          i.push(o);
        else {
          let a = o.computedStyle;
          e && a.color === e.color && a.backgroundColor === e.backgroundColor && a.fontSize === e.fontSize ? i.push(o) : (i.length > 0 && t.push(i), i = [o], e = a);
        }
      return i.length > 0 && t.push(i), t;
    }
    function aa(r, e, t) {
      var c, u, d, m, h;
      function i(f) {
        return f.mode === "text";
      }
      if (!e || e.length === 0)
        return null;
      let o = new P(r, t == null ? void 0 : t.style), a = !((c = o.atomIdsSettings) != null && c.groupNumbers), n = [], s = (u = t == null ? void 0 : t.newList) != null ? u : false;
      if (e.length === 1) {
        let f = e[0], y = f.render(o, { newList: s });
        y && (a && f.isSelected && y.selected(true), n = [y]);
      } else {
        let f = "", y = true;
        for (let w of e) {
          (d = o.atomIdsSettings) != null && d.groupNumbers && f && (y && w.isDigit() || !y && i(w)) && (o.atomIdsSettings.overrideID = f);
          let k = w.render(o, { newList: s });
          o.atomIdsSettings && (o.atomIdsSettings.overrideID = void 0), k && (s = w.type === "group" && !w.boxType, (m = o.atomIdsSettings) != null && m.groupNumbers && ((w.isDigit() || i(w)) && (!f || y !== w.isDigit()) && (y = w.isDigit(), f = (h = w.id) != null ? h : ""), f && (!(w.isDigit() || i(w)) || !w.hasEmptyBranch("superscript") || !w.hasEmptyBranch("subscript")) && (f = "")), a && w.isSelected && k.selected(true), n.push(k));
        }
      }
      if (n.length === 0)
        return null;
      let l;
      return t || o.isTight || n.length > 1 ? (l = new v(n, b({ isTight: o.isTight }, t != null ? t : {})), l.isSelected = n.every((f) => f.isSelected)) : l = n[0], l.wrap(o).wrap(r);
    }
    var Ct = class extends g {
      constructor(t, i, o, a) {
        super("accent", o, { command: t, style: a.style });
        a.accentChar ? this.accent = a.accentChar : this.svgAccent = a == null ? void 0 : a.svgAccent, this.body = i, this.skipBoundary = true, this.captureSelection = true;
      }
      static fromJson(t, i) {
        return new Ct(t.command, t.body, i, { accentChar: t.accentChar, svgAccent: t.svgAccent, style: t.style });
      }
      toJson() {
        return E(b({}, super.toJson()), { accentChar: this.accent, svgAccent: this.svgAccent });
      }
      render(t) {
        var c;
        let i = new P(t, this.style, "cramp"), o = (c = g.createBox(i, this.body)) != null ? c : new v(null), a = 0;
        !this.hasEmptyBranch("body") && this.body.length === 2 && this.body[1].isCharacterBox() && (a = o.skew);
        let n = Math.min(o.height, St), s;
        if (this.svgAccent)
          s = Nr(this.svgAccent), n = i.metrics.bigOpSpacing1 - n;
        else if (this.accent) {
          let u = new v(this.accent, { fontFamily: "Main-Regular" });
          u.italic = 0;
          let d = this.accent === 8407 ? " ML__accent-vec" : "";
          s = new v(new v(u), { classes: "ML__accent-body" + d });
        }
        s = new Q({ shift: 0, children: [{ box: new v(o) }, -n, { box: s, marginLeft: o.left + 2 * a, classes: ["ML__center"] }] });
        let l = new v(s, { newList: true, type: "mord" });
        return this.caret && (l.caret = this.caret), this.bind(i, l.wrap(i)), this.attachSupsub(i, { base: l });
      }
    };
    var tr = { "(": ")", "{": "}", "[": "]", "|": "|", "\\lbrace": "\\rbrace", "\\lparen": "\\rparen", "\\{": "\\}", "\\langle": "\\rangle", "\\lfloor": "\\rfloor", "\\lceil": "\\rceil", "\\vert": "\\vert", "\\lvert": "\\rvert", "\\Vert": "\\Vert", "\\lVert": "\\rVert", "\\lbrack": "\\rbrack", "\\ulcorner": "\\urcorner", "\\llcorner": "\\lrcorner", "\\lgroup": "\\rgroup", "\\lmoustache": "\\rmoustache" }, na = Object.fromEntries(Object.entries(tr).map(([r, e]) => [e, r]));
    function so(r) {
      var e;
      return (e = { "[": 91, "]": 93, "(": 40, ")": 41, "\\mid": 8739, "|": 8739, "∣": 8739, "∥": 8741, "\\|": 8739, "\\{": 123, "\\}": 125, "\\lbrace": 123, "\\rbrace": 125, "\\lparen": 40, "\\rparen": 41, "\\lbrack": 91, "\\rbrack": 93, "\\vert": 8739, "\\lvert": 8739, "\\mvert": 8739, "\\rvert": 8739, "\\Vert": 8741, "\\lVert": 8741, "\\mVert": 8741, "\\rVert": 8741, "\\parallel": 8741, "\\shortparallel": 8741, "\\langle": 10216, "\\rangle": 10217, "\\lfloor": 8970, "\\rfloor": 8971, "\\lceil": 8968, "\\rceil": 8969, "\\ulcorner": 9484, "\\urcorner": 9488, "\\llcorner": 9492, "\\lrcorner": 9496, "\\lgroup": 10222, "\\rgroup": 10223, "\\lmoustache": 9136, "\\rmoustache": 9137, "\\surd": 8730 }[r]) != null ? e : r.codePointAt(0);
    }
    function Hl(r, e, t, i) {
      let a = new v(so(r), { fontFamily: "Main-Regular" }).wrap(e, i);
      return t && a.setTop((1 - e.scalingFactor) * ze), a;
    }
    function Vn(r, e, t, i, o) {
      let a = new P(i, o == null ? void 0 : o.style, "textstyle"), n = new v(so(r), { fontFamily: "Size" + e + "-Regular", classes: "ML__delim-size" + e }).wrap(a);
      return t && n.setTop((1 - a.scalingFactor) * ze), n;
    }
    function Hn(r, e, t, i, o) {
      var Wt;
      let a, n, s, l;
      a = s = l = so(r), n = null;
      let c = "Size1-Regular";
      r === "\\vert" || r === "\\lvert" || r === "\\rvert" || r === "\\mvert" || r === "\\mid" ? s = a = l = 8739 : r === "\\Vert" || r === "\\lVert" || r === "\\rVert" || r === "\\mVert" || r === "\\|" ? s = a = l = 8741 : r === "\\uparrow" ? s = l = 9168 : r === "\\Uparrow" ? s = l = 8214 : r === "\\downarrow" ? a = s = 9168 : r === "\\Downarrow" ? a = s = 8214 : r === "\\updownarrow" ? (a = 8593, s = 9168, l = 8595) : r === "\\Updownarrow" ? (a = 8657, s = 8214, l = 8659) : r === "[" || r === "\\lbrack" ? (a = 9121, s = 9122, l = 9123, c = "Size4-Regular") : r === "]" || r === "\\rbrack" ? (a = 9124, s = 9125, l = 9126, c = "Size4-Regular") : r === "\\lfloor" || r === "⌊" ? (s = a = 9122, l = 9123, c = "Size4-Regular") : r === "\\lceil" || r === "⌈" ? (a = 9121, s = l = 9122, c = "Size4-Regular") : r === "\\rfloor" || r === "⌋" ? (s = a = 9125, l = 9126, c = "Size4-Regular") : r === "\\rceil" || r === "⌉" ? (a = 9124, s = l = 9125, c = "Size4-Regular") : r === "(" || r === "\\lparen" ? (a = 9115, s = 9116, l = 9117, c = "Size4-Regular") : r === ")" || r === "\\rparen" ? (a = 9118, s = 9119, l = 9120, c = "Size4-Regular") : r === "\\{" || r === "\\lbrace" ? (a = 9127, n = 9128, l = 9129, s = 9130, c = "Size4-Regular") : r === "\\}" || r === "\\rbrace" ? (a = 9131, n = 9132, l = 9133, s = 9130, c = "Size4-Regular") : r === "\\lgroup" || r === "⟮" ? (a = 9127, l = 9129, s = 9130, c = "Size4-Regular") : r === "\\rgroup" || r === "⟯" ? (a = 9131, l = 9133, s = 9130, c = "Size4-Regular") : r === "\\lmoustache" || r === "⎰" ? (a = 9127, l = 9133, s = 9130, c = "Size4-Regular") : r === "\\rmoustache" || r === "⎱" ? (a = 9131, l = 9129, s = 9130, c = "Size4-Regular") : r === "\\surd" ? (a = 57345, l = 9143, s = 57344, c = "Size4-Regular") : r === "\\ulcorner" ? (a = 9484, s = l = 32) : r === "\\urcorner" ? (a = 9488, s = l = 32) : r === "\\llcorner" ? (l = 9492, s = a = 32) : r === "\\lrcorner" && (a = 9496, s = a = 32);
      let u = zt(a, c), d = u.height + u.depth, m = zt(s, c), h = m.height + m.depth, f = zt(l, c), y = f.height + f.depth, w = 0, k = 1;
      if (n !== null) {
        let _e = zt(n, c);
        w = _e.height + _e.depth, k = 2;
      }
      let S = d + y + w, T = Math.max(0, Math.ceil((e - S) / (k * h))), C = S + T * k * h, K = ze;
      t && (K = K * i.scalingFactor);
      let M = C / 2 - K, R = 8e-3, F = [];
      F.push({ box: new v(l, { fontFamily: c }) }), F.push(-R);
      let Le = new v(s, { fontFamily: c });
      if (n === null)
        for (let _e = 0; _e < T; _e++)
          F.push({ box: Le });
      else {
        for (let _e = 0; _e < T; _e++)
          F.push({ box: Le });
        F.push(-R), F.push({ box: new v(n, { fontFamily: c }) }), F.push(-R);
        for (let _e = 0; _e < T; _e++)
          F.push({ box: Le });
      }
      F.push(-R), F.push({ box: new v(a, { fontFamily: c }) });
      let Pe = "";
      c === "Size1-Regular" ? Pe = " delim-size1" : c === "Size4-Regular" && (Pe = " delim-size4");
      let vt = new Q({ bottom: M, children: F }, { classes: Pe });
      return new v(vt, E(b({}, o != null ? o : {}), { classes: ((Wt = o == null ? void 0 : o.classes) != null ? Wt : "") + " ML__delim-mult" }));
    }
    var Gn = /* @__PURE__ */ new Set(["(", ")", "\\lparen", "\\rparen", "[", "]", "\\lbrack", "\\rbrack", "\\{", "\\}", "\\lbrace", "\\rbrace", "\\lfloor", "\\rfloor", "\\lceil", "\\rceil", "\\surd", "⌊", "⌋", "⌈", "⌉"]), Gl = /* @__PURE__ */ new Set(["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\mvert", "\\mid", "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache", "⟮", "⟯", "⎰", "⎱"]), Jn = /* @__PURE__ */ new Set(["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"]), Jl = [0, 1.2, 1.8, 2.4, 3];
    function Wn(r, e, t, i) {
      var o;
      return r === void 0 || r === "." ? Ft(t, (o = i.type) != null ? o : "minner", i.classes) : (r === "<" || r === "\\lt" || r === "⟨" ? r = "\\langle" : (r === ">" || r === "\\gt" || r === "⟩") && (r = "\\rangle"), Gn.has(r) || Jn.has(r) ? Vn(r, e, false, t, i) : Gl.has(r) ? Hn(r, Jl[e], false, t, i) : null);
    }
    var Wl = [{ type: "small", mathstyle: "scriptscriptstyle" }, { type: "small", mathstyle: "scriptstyle" }, { type: "small", mathstyle: "textstyle" }, { type: "large", size: 1 }, { type: "large", size: 2 }, { type: "large", size: 3 }, { type: "large", size: 4 }], Ul = [{ type: "small", mathstyle: "scriptscriptstyle" }, { type: "small", mathstyle: "scriptscriptstyle" }, { type: "small", mathstyle: "textstyle" }, { type: "stack" }], jl = [{ type: "small", mathstyle: "scriptscriptstyle" }, { type: "small", mathstyle: "scriptstyle" }, { type: "small", mathstyle: "textstyle" }, { type: "large", size: 1 }, { type: "large", size: 2 }, { type: "large", size: 3 }, { type: "large", size: 4 }, { type: "stack" }];
    function Xl(r) {
      return r.type === "small" ? "Main-Regular" : r.type === "large" ? "Size" + r.size + "-Regular" : (r.type, "Size4-Regular");
    }
    function Zl(r, e, t, i) {
      let o = { "-4": 0, "-3": 1, 0: 2 }[i.mathstyle.sizeDelta];
      for (let a = o; a < t.length && t[a].type !== "stack"; a++) {
        let n = zt(r, Xl(t[a]));
        if (n.defaultMetrics)
          return { type: "small", mathstyle: "scriptstyle" };
        let s = n.height + n.depth;
        if (t[a].type === "small" && (t[a].mathstyle === "scriptscriptstyle" ? s *= fi[Math.max(1, i.size - 2)] : t[a].mathstyle === "scriptstyle" && (s *= fi[Math.max(1, i.size - 1)])), s > e)
          return t[a];
      }
      return t[t.length - 1];
    }
    function Jr(r, e, t, i, o, a) {
      var c;
      if (!e || e.length === 0 || e === ".")
        return Ft(o, r, r);
      e === "<" || e === "\\lt" ? e = "\\langle" : (e === ">" || e === "\\gt") && (e = "\\rangle");
      let n;
      Jn.has(e) ? n = Wl : Gn.has(e) ? n = jl : n = Ul;
      let s = Zl(so(e), t, n, o), l = new P(o, a == null ? void 0 : a.style, s.mathstyle);
      return s.type === "small" ? Hl(e, l, i, { type: r, classes: "ML__small-delim " + ((c = a == null ? void 0 : a.classes) != null ? c : "") }) : s.type === "large" ? Vn(e, s.size, i, l, E(b({}, a), { type: r })) : (s.type, Hn(e, t, i, l, E(b({}, a), { type: r })));
    }
    function vr(r, e, t, i, o, a) {
      if (e === ".")
        return Ft(o, r, a == null ? void 0 : a.classes);
      let n = ze * o.scalingFactor, s = 901, l = 5 / Zt, c = Math.max(t - n, i + n), u = Math.max(c / 500 * s, 2 * c - l);
      return Jr(r, e, u, true, o, a);
    }
    function Ft(r, e, t) {
      let i = new P(r, void 0, "textstyle");
      return new v(null, { classes: " nulldelimiter " + (t != null ? t : ""), type: e }).wrap(i);
    }
    var be = class extends g {
      constructor(t, i, o) {
        var a, n, s, l;
        super("overunder", i, { command: t, serialize: o.serialize, style: o.style });
        this.skipBoundary = (a = o.skipBoundary) != null ? a : true, this.subsupPlacement = o.supsubPlacement, this.body = o.body, this.svgAbove = o.svgAbove, this.svgBelow = o.svgBelow, this.svgBody = o.svgBody, this.above = o.above, this.below = o.below, this.boxType = (n = o.boxType) != null ? n : "mord", this.paddedBody = (s = o.paddedBody) != null ? s : false, this.paddedLabels = (l = o.paddedLabels) != null ? l : false;
      }
      static fromJson(t, i) {
        return new be(t.command, i, t);
      }
      toJson() {
        let t = {};
        return this.skipBoundary || (t.skipBoundary = false), this.subsupPlacement && (t.subsupPlacement = this.subsupPlacement), this.svgAbove && (t.svgAbove = this.svgAbove), this.svgBelow && (t.svgBelow = this.svgBelow), this.svgBody && (t.svgBody = this.svgBody), this.boxType !== "mord" && (t.boxType = this.boxType), this.paddedBody && (t.paddedBody = true), this.paddedLabels && (t.paddedLabels = true), b(b({}, super.toJson()), t);
      }
      render(t) {
        let i = this.svgBody ? Nr(this.svgBody) : g.createBox(t, this.body, { newList: true }), o = new P(t, this.style, "scriptstyle"), a = null;
        this.svgAbove ? a = Nr(this.svgAbove) : this.above && (a = g.createBox(o, this.above, { newList: true }));
        let n = null;
        this.svgBelow ? n = Nr(this.svgBelow) : this.below && (n = g.createBox(o, this.below, { newList: true })), this.paddedBody && (i = new v([Ft(t, "mopen"), i, Ft(t, "mclose")], { newList: true }));
        let s = Yl(t, { base: i, above: a, below: n, type: this.boxType === "mbin" || this.boxType === "mrel" ? this.boxType : "mord", paddedAboveBelow: this.paddedLabels });
        return s ? (this.subsupPlacement === "over-under" ? s = this.attachLimits(t, { base: s, type: s.type }) : s = this.attachSupsub(t, { base: s }), this.caret && (s.caret = this.caret), this.bind(t, s)) : null;
      }
    };
    function Yl(r, e) {
      if (!e.base)
        return null;
      if (!e.above && !e.below) {
        let s = new v(e.base, { type: e.type });
        return s.setStyle("position", "relative"), s;
      }
      let t = 0;
      e.above && (t = -e.above.depth + r.metrics.bigOpSpacing2);
      let i = null, o = e.base, a = 0, n = ["ML__center"];
      if (e.paddedAboveBelow && n.push("ML__label_padding"), e.below && e.above) {
        let s = r.metrics.bigOpSpacing5 + e.below.height + e.below.depth + o.depth + a;
        i = new Q({ bottom: s, children: [r.metrics.bigOpSpacing5, { box: e.below, classes: n }, { box: o, classes: ["ML__center"] }, t, { box: e.above, classes: n }, r.metrics.bigOpSpacing5] });
      } else
        e.below ? i = new Q({ top: o.height - a, children: [r.metrics.bigOpSpacing5, { box: e.below, classes: n }, { box: o, classes: ["ML__center"] }] }) : e.above && (i = new Q({ bottom: o.depth + a, children: [{ box: o, classes: ["ML__center"] }, t, { box: e.above, classes: n }, r.metrics.bigOpSpacing5] }));
      return new v(i, { type: e.type });
    }
    var Un = { acute: 714, grave: 715, dot: 729, ddot: 168, mathring: 730, tilde: 126, bar: 713, breve: 728, check: 711, hat: 94, vec: 8407 };
    x(Object.keys(Un), "{body:auto}", { createAtom: (r, e, t, i) => new Ct(r, e[0], i, { accentChar: Un[r.slice(1)], style: t }) });
    x(["widehat", "widecheck", "widetilde"], "{body:auto}", { createAtom: (r, e, t, i) => {
      let o = ra(e[0]);
      return new Ct(r, e[0], i, { style: t, svgAccent: r.slice(1) + (o.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][o.length]) });
    } });
    x(["overarc", "overparen", "wideparen"], "{body:auto}", { createAtom: (r, e, t, i) => new Ct(r, e[0], i, { style: t, svgAccent: "overarc" }) });
    x(["underarc", "underparen"], "{body:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[0], style: t, svgBelow: "underarc" }) });
    x("utilde", "{body:auto}", { createAtom: (r, e, t, i) => {
      let o = ra(e[0]), a = "widetilde" + (o.length > 5 ? "4" : ["1", "1", "2", "2", "3", "3"][o.length]);
      return new be(r, i, { body: e[0], svgBelow: a, style: t, boxType: Vr(e[0]) });
    } });
    x("^", "{:string}", { createAtom: (r, e, t, i) => {
      var o;
      return new g("mord", i, { command: r, isFunction: false, limits: "adjacent", style: t, value: e[0] && (o = { a: "â", e: "ê", i: "î", o: "ô", u: "û", A: "Â", E: "Ê", I: "Î", O: "Ô", U: "Û" }[e[0]]) != null ? o : "^" });
    } });
    x("`", "{:string}", { createAtom: (r, e, t, i) => {
      var o;
      return new g("mord", i, { command: r, isFunction: false, limits: "adjacent", style: t, value: e[0] && (o = { a: "à", e: "è", i: "ì", o: "ò", u: "ù", A: "À", E: "È", I: "Ì", O: "Ò", U: "Ù" }[e[0]]) != null ? o : "`" });
    } });
    x("'", "{:string}", { createAtom: (r, e, t, i) => {
      var o;
      return new g("mord", i, { command: r, isFunction: false, limits: "adjacent", style: t, value: e[0] && (o = { a: "á", e: "é", i: "í", o: "ó", u: "ú", A: "Á", E: "É", I: "Í", O: "Ó", U: "Ú" }[e[0]]) != null ? o : "^" });
    } });
    x("~", "{:string}", { createAtom: (r, e, t, i) => {
      var o;
      return new g("mord", i, { command: r, isFunction: false, limits: "adjacent", style: t, value: e[0] && (o = { n: "ñ", N: "Ñ", a: "ã", o: "õ", A: "Ã", O: "Õ" }[e[0]]) != null ? o : "´" });
    } });
    x("c", "{:string}", { createAtom: (r, e, t, i) => {
      var o;
      return new g("mord", i, { command: r, isFunction: false, limits: "adjacent", style: t, value: e[0] && (o = { c: "ç", C: "Ç" }[e[0]]) != null ? o : "" });
    } });
    var rr = class extends g {
      constructor(e, t) {
        super("error", t, { value: e, command: e, mode: "math" }), this.verbatimLatex = e;
      }
      static fromJson(e, t) {
        return new rr(e.command, t);
      }
      toJson() {
        return super.toJson();
      }
      render(e) {
        let t = this.createBox(e, { classes: "ML__error" });
        return this.caret && (t.caret = this.caret), t;
      }
    };
    var se = class extends g {
      constructor(t, i, o) {
        var a, s, l;
        super("group", i, { command: o == null ? void 0 : o.command, mode: (a = o == null ? void 0 : o.mode) != null ? a : "math", serialize: o == null ? void 0 : o.serialize, style: o == null ? void 0 : o.style });
        this.body = t, this.mathstyleName = o == null ? void 0 : o.mathstyleName, !(o != null && o.serialize) || !(o != null && o.latexClose) || o != null && o.latexOpen, (o == null ? void 0 : o.command) != null, this.latexOpen = o == null ? void 0 : o.latexOpen, this.latexClose = o == null ? void 0 : o.latexClose, this.cssId = o == null ? void 0 : o.cssId, this.htmlData = o == null ? void 0 : o.htmlData, this.htmlStyle = o == null ? void 0 : o.htmlStyle, this.customClass = o == null ? void 0 : o.customClass, this.boxType = o == null ? void 0 : o.boxType, this.skipBoundary = true, this.captureSelection = (s = o == null ? void 0 : o.captureSelection) != null ? s : false, this.changeMode = (l = o == null ? void 0 : o.changeMode) != null ? l : false, this.displayContainsHighlight = false, t && t.length === 1 && t[0].command === "," && (this.captureSelection = true);
      }
      static fromJson(t, i) {
        return new se(t.body, i, t);
      }
      toJson() {
        let t = {};
        return this.mathstyleName && (t.mathstyleName = this.mathstyleName), this.latexOpen && (t.latexOpen = this.latexOpen), this.latexClose && (t.latexClose = this.latexClose), this.cssId && (t.cssId = this.cssId), this.htmlData && (t.htmlData = this.htmlData), this.htmlStyle && (t.htmlStyle = this.htmlStyle), this.customClass && (t.customClass = this.customClass), this.boxType && (t.boxType = this.boxType), this.captureSelection && (t.captureSelection = true), this.changeMode && (t.changeMode = true), b(b({}, super.toJson()), t);
      }
      render(t) {
        let i = new P(t, this.style, this.mathstyleName), o = g.createBox(i, this.body, { type: this.boxType, classes: this.customClass, mode: this.mode, style: { backgroundColor: this.style.backgroundColor }, newList: !this.boxType });
        return o ? (this.cssId && (o.cssId = this.cssId), this.htmlData && (o.htmlData = this.htmlData), this.htmlStyle && (o.htmlStyle = this.htmlStyle), this.caret && (o.caret = this.caret), this.bind(t, o)) : null;
      }
      serialize(t) {
        let i = this.bodyToLatex(t);
        return typeof this.latexOpen == "string" && (i = this.latexOpen + i + this.latexClose), this.htmlData && (i = `\\htmlData{${this.htmlData}}{${i}}`), this.htmlStyle && (i = `\\htmlStyle{${this.htmlStyle}}{${i}}`), this.customClass && (i = `\\class{${this.customClass}}{${i}}`), this.cssId && (i = `\\cssId{${this.cssId}}{${i}}`), i;
      }
    };
    var oe = class extends g {
      constructor(t, i, o, a) {
        super("leftright", o, { style: a.style, displayContainsHighlight: true });
        this.variant = t, this.body = i, this.leftDelim = a.leftDelim, this.rightDelim = a.rightDelim;
      }
      static fromJson(t, i) {
        var o;
        return new oe((o = t.variant) != null ? o : "", t.body, i, t);
      }
      toJson() {
        let t = super.toJson();
        return this.variant && (t.variant = this.variant), this.leftDelim && (t.leftDelim = this.leftDelim), this.rightDelim && (t.rightDelim = this.rightDelim), t;
      }
      serialize(t) {
        var o, a;
        let i = this.matchingRightDelim();
        return this.variant === "left...right" ? j(["\\left" + ((o = this.leftDelim) != null ? o : "."), this.bodyToLatex(t), "\\right" + i]) : this.variant === "mleft...mright" ? j(["\\mleft" + ((a = this.leftDelim) != null ? a : "."), this.bodyToLatex(t), "\\mright" + i]) : j([!this.leftDelim || this.leftDelim === "." ? "" : this.leftDelim, this.bodyToLatex(t), i]);
      }
      matchingRightDelim() {
        var i, o;
        if (this.rightDelim && this.rightDelim !== "?")
          return this.rightDelim;
        let t = (i = this.leftDelim) != null ? i : ".";
        return (o = tr[t]) != null ? o : t;
      }
      render(t) {
        var d, m, h;
        let i = new P(t, this.style);
        this.body;
        let o = new P(t, this.style, "textstyle"), a = (d = g.createBox(i, this.body, { newList: true })) != null ? d : new v(null, { newList: true }), n = a.height / o.scalingFactor, s = a.depth / o.scalingFactor, l = [];
        if (this.leftDelim && l.push(this.bind(o, vr("mopen", this.leftDelim, n, s, o, { classes: "ML__open" + (this.containsCaret ? " ML__contains-caret" : ""), mode: this.mode, style: this.style }))), a) {
          if (a.children)
            for (let f = 0; f < a.children.length; f++) {
              let y = a.children[f];
              if (y.delim) {
                let w = y.caret;
                a.children[f] = this.bind(i, vr("minner", y.delim, n, s, i)), a.children[f].caret = w;
              }
            }
          l.push(a);
        }
        if (this.rightDelim) {
          let f = this.containsCaret ? " ML__contains-caret" : "", y = this.rightDelim;
          y === "?" && (this.context.smartFence ? (y = this.matchingRightDelim(), f += " ML__smart-fence__close") : y = "."), l.push(this.bind(o, vr("mclose", y, n, s, o, { classes: f + " ML__close", mode: this.mode, style: this.style })));
        }
        let c = (h = this.variant === "mleft...mright" || ((m = this.leftSibling) == null ? void 0 : m.isFunction)) != null ? h : false, u = new v(l, { type: c ? "mclose" : "minner", classes: "left-right" });
        return this.caret && (u.caret = this.caret), this.bind(i, u.wrap(i));
      }
    };
    var ir = class extends g {
      constructor(t, i, o) {
        var a, n;
        super("macro", i, { command: t });
        this.body = o.body, o.captureSelection === void 0 ? o.args ? this.captureSelection = false : this.captureSelection = true : this.captureSelection = o.captureSelection, this.macroArgs = (a = o.args) != null ? a : "", this.expand = (n = o.expand) != null ? n : false;
      }
      static fromJson(t, i) {
        return new ir(t.command, i, t);
      }
      toJson() {
        let t = super.toJson();
        return this.expand && (t.expand = true), this.captureSelection !== void 0 && (t.captureSelection = this.captureSelection), this.macroArgs && (t.args = this.macroArgs), t;
      }
      serialize(t) {
        return t.expandMacro && this.expand ? this.bodyToLatex(t) : this.command + this.macroArgs;
      }
      render(t) {
        let i = g.createBox(t, this.body);
        return i ? (this.caret && (i.caret = this.caret), this.bind(t, i)) : null;
      }
    };
    var or = class extends g {
      constructor(t, i, o, a = false, n, s) {
        var l;
        super("prompt", t, { mode: (l = s == null ? void 0 : s.mode) != null ? l : "math", style: s == null ? void 0 : s.style, command: "\\placeholder" });
        this.body = n, this.correctness = o, this.placeholderId = i, this.locked = a, this.captureSelection = this.locked;
      }
      static fromJson(t, i) {
        return new or(i, t.placeholderId, t.correctness, t.locked, t.body, t);
      }
      toJson() {
        let t = super.toJson();
        return this.placeholderId && (t.placeholderId = this.placeholderId), this.body || delete t.body, this.body && (t.body = this.body.filter((i) => i.type !== "first").map((i) => i.toJson())), this.correctness && (t.correctness = this.correctness), t.locked = this.locked, t;
      }
      render(t) {
        let i = new P(t), o = Ae(i.getRegisterAsDimension("fboxsep")), a = o, n = g.createBox(t, this.body);
        if (!n)
          return null;
        n.height || (n.height = 0.5), n.setStyle("vertical-align", -n.height, "em"), this.correctness === "correct" ? n.setStyle("color", "var(--correct-color, var(--ML__correct-color))") : this.correctness === "incorrect" && n.setStyle("color", "var(--incorrect-color, var(--ML__incorrect-color))");
        let s = new v(n, { type: "mord" }), l = "ML__prompt ";
        this.locked ? l += " ML__lockedPromptBox " : l += " ML__editablePromptBox ", this.correctness === "correct" ? l += " ML__correctPromptBox " : this.correctness === "incorrect" && (l += " ML__incorrectPromptBox "), this.containsCaret && (l += " ML__focusedPromptBox ");
        let c = new v(null, { classes: l });
        c.height = s.height + a, c.depth = s.depth + a, c.setStyle("box-sizing", "border-box"), c.setStyle("position", "absolute"), c.setStyle("height", s.height + s.depth + 2 * a, "em"), a === 0 ? c.setStyle("width", "100%") : (c.setStyle("width", `calc(100% + ${2 * a}em)`), c.setStyle("top", o, "em"), c.setStyle("left", -a, "em"));
        let u = "";
        this.correctness === "incorrect" && (u += '<line x1="3%"  y1="97%" x2="97%" y2="3%" stroke-width="0.5" stroke="var(--incorrect-color, var(--ML__incorrect-color))" stroke-linecap="round" />'), u && ji(c, u, ""), s.setStyle("display", "inline-block"), s.setStyle("height", n.height + n.depth, "em"), s.setStyle("vertical-align", -a, "em");
        let d = new v([c, s], { classes: "ML__prompt-atom" });
        return d.setStyle("position", "relative"), d.setStyle("display", "inline-block"), d.setStyle("line-height", 0), d.height = s.height + a + 0.2, d.depth = s.depth + a, d.left = a, d.right = a, d.setStyle("height", s.height + a, "em"), d.setStyle("top", s.depth - s.height, "em"), d.setStyle("vertical-align", s.depth + a, "em"), d.setStyle("margin-left", 0.5, "em"), d.setStyle("margin-right", 0.5, "em"), this.caret && (d.caret = this.caret), this.bind(i, this.attachSupsub(t, { base: d }));
      }
      serialize(t) {
        var s;
        let i = (s = this.bodyToLatex(t)) != null ? s : "";
        i === this.context.placeholderSymbol && (i = "");
        let o = this.placeholderId ? `[${this.placeholderId}]` : "", a;
        this.correctness === "correct" ? a = "[correct]" : this.correctness === "incorrect" ? a = "[incorrect]" : a = "";
        let n = this.locked ? "[locked]" : "";
        return `\\placeholder${o}${a}${n}{${i}}`;
      }
    };
    var ie = class extends g {
      constructor(t, i) {
        var a;
        let o = (i == null ? void 0 : i.value) || t.placeholderSymbol;
        super("placeholder", t, { mode: (a = i == null ? void 0 : i.mode) != null ? a : "math", style: i == null ? void 0 : i.style, value: o, command: "\\placeholder" });
        this.captureSelection = true;
      }
      static fromJson(t, i) {
        return new ie(i, t);
      }
      toJson() {
        let t = super.toJson();
        return this.value === this.context.placeholderSymbol && delete t.value, this.defaultValue && (t.defaultValue = this.defaultValue.map((i) => i.toJson())), t;
      }
      render(t) {
        if (typeof t.renderPlaceholder == "function")
          return t.renderPlaceholder(t);
        let i = "";
        return this.caret && (i += "ML__placeholder-selected "), this.isSelected && (i += " ML__selected "), this.createBox(t, { classes: i });
      }
      serialize(t) {
        let i = this.value;
        return i === this.context.placeholderSymbol && (i = ""), `\\placeholder{${this.value}}`;
      }
    };
    var Ge = class extends g {
      constructor(t, i, o, a) {
        super("spacing", o, { command: t, style: i });
        this.width = a;
      }
      static fromJson(t, i) {
        return new Ge(t.command, t.style, i, t.width);
      }
      toJson() {
        let t = {};
        return this.width && (t.width = this.width), b(b({}, super.toJson()), t);
      }
      render(t) {
        var o;
        let i;
        if (this.width)
          i = new v(null, { classes: "mspace" }), i.left = qn(this.width);
        else {
          let a = (o = { "\\qquad": "qquad", "\\quad": "quad", "\\enspace": "enspace", "\\;": "thickspace", "\\:": "mediumspace", "\\,": "thinspace", "\\!": "negativethinspace" }[this.command]) != null ? o : "mediumspace";
          i = new v(null, { classes: a });
        }
        return i = this.bind(t, i), this.caret && (i.caret = this.caret), i;
      }
      serialize(t) {
        var o;
        let i = (o = this.command) != null ? o : "";
        return this.command === "\\hspace" || this.command === "\\hspace*" ? Number.isFinite(this.width) ? i += `{${this.width}em'}` : i += "{0pt}" : Number.isFinite(this.width) && (i += ` ${this.width}em`), i;
      }
    };
    var ft = class extends g {
      constructor(e, t) {
        super("msubsup", e, { style: t == null ? void 0 : t.style });
      }
      static fromJson(e, t) {
        let i = new ft(t, e);
        for (let o of Rt)
          e[o] && i.setChildren(e[o], o);
        return i;
      }
      toJson() {
        return super.toJson();
      }
      render(e) {
        var n;
        this.subsupPlacement;
        let t = this.leftSibling, i = new P(e, { isPhantom: true }), o = (n = t.render(i)) != null ? n : new v(null), a = new v(null, { height: o.height, depth: o.depth });
        return this.attachSupsub(e, { base: a, isCharacterBox: t.isCharacterBox(), type: "supsub" });
      }
      serialize(e) {
        return this.supsubToLatex(e);
      }
    };
    var Je = class extends g {
      constructor(e, t, i, o) {
        super("text", o, { command: e, mode: "text", displayContainsHighlight: true }), this.value = t, this.verbatimLatex = t, this.applyStyle(i);
      }
      static fromJson(e, t) {
        return new Je(e.command, e.value, e.style, t);
      }
      toJson() {
        return super.toJson();
      }
      render(e) {
        let t = this.createBox(e);
        return this.caret && (t.caret = this.caret), t;
      }
      serialize(e) {
        var t;
        return (t = this.verbatimLatex) != null ? t : yi("text", this.value.codePointAt(0));
      }
    };
    function lo(r) {
      return !/^<({|}|\$|\$\$|space)>$/.test(r);
    }
    var Wr = class {
      constructor(e, t, i) {
        this.index = 0;
        this.endCount = 0;
        var o, a, n, s, l;
        this.tokens = e, this.context = t, this.errors = [], this.args = (o = i.args) != null ? o : null, this.smartFence = (a = i.smartFence) != null ? a : t.smartFence, this._currentParsingContext = { parent: void 0, mathlist: [], style: (n = i.style) != null ? n : {}, parseMode: (s = i.parseMode) != null ? s : "math", mathstyle: (l = i.mathstyle) != null ? l : "displaystyle", registers: t.registers, tabular: false };
      }
      get currentContext() {
        return this._currentParsingContext;
      }
      get rootContext() {
        let e = this._currentParsingContext;
        for (; e.parent; )
          e = e.parent;
        return e;
      }
      beginContext(e) {
        var i, o, a;
        let t = { parent: this.currentContext, mathlist: [], style: b({}, this.currentContext.style), parseMode: (i = e == null ? void 0 : e.mode) != null ? i : this.currentContext.parseMode, mathstyle: (o = e == null ? void 0 : e.mathstyle) != null ? o : this.currentContext.mathstyle, registers: null, tabular: (a = e == null ? void 0 : e.tabular) != null ? a : false };
        this._currentParsingContext = t;
      }
      endContext() {
        this._currentParsingContext = this._currentParsingContext.parent;
      }
      onError(e) {
        this.errors.push(b({ before: Ir(this.tokens.slice(this.index, this.index + 10)), after: Ir(this.tokens.slice(Math.max(0, this.index - 10), this.index)) }, e));
      }
      get mathlist() {
        return this.currentContext.mathlist;
      }
      set mathlist(e) {
        this.currentContext.mathlist = e;
      }
      get parseMode() {
        return this.currentContext.parseMode;
      }
      set parseMode(e) {
        this.currentContext.parseMode = e;
      }
      get tabularMode() {
        return this.currentContext.tabular;
      }
      get style() {
        let e = this.currentContext;
        for (; e; ) {
          if (e.style)
            return e.style;
          e = e.parent;
        }
        return {};
      }
      set style(e) {
        this.currentContext.style = e;
      }
      getRegister(e) {
        var i, o, a;
        if (e[0], e.startsWith("global "))
          return (o = (i = this.rootContext.registers) == null ? void 0 : i[e.slice(7)]) != null ? o : 0;
        let t = this.currentContext;
        for (; t; ) {
          if ((a = t.registers) != null && a[e])
            return t.registers[e];
          t = t.parent;
        }
        return 0;
      }
      setRegister(e, t) {
        var i;
        if (e.startsWith("global ")) {
          e = e.slice(7);
          let o = this.currentContext;
          for (; o; )
            (i = o.registers) != null && i[e] && delete o.registers[e], o = o.parent;
          this.rootContext.registers[e] = t;
          return;
        }
        this.currentContext.registers || (this.currentContext.registers = {}), this.currentContext.registers[e] = t;
      }
      end() {
        return this.endCount++, this.index >= this.tokens.length || this.endCount > 1e3;
      }
      get() {
        return this.endCount = 0, this.index < this.tokens.length ? this.tokens[this.index++] : "";
      }
      peek() {
        return this.tokens[this.index];
      }
      match(e) {
        return this.tokens[this.index] === e ? (this.index++, true) : false;
      }
      lastSubsupAtom() {
        let e;
        return this.mathlist.length > 0 && (e = this.mathlist[this.mathlist.length - 1], e.type === "msubsup" || e.subsupPlacement !== void 0) || (e = new ft(this.context, { style: this.style }), this.mathlist.push(e)), e;
      }
      hasPattern(e) {
        return e.test(this.tokens[this.index]);
      }
      hasInfixCommand() {
        var t;
        let { index: e } = this;
        if (e < this.tokens.length && this.tokens[e].startsWith("\\")) {
          let i = this.context.getDefinition(this.tokens[e], this.parseMode);
          return !i || i.definitionType === "symbol" || i.ifMode && !i.ifMode.includes(this.parseMode) ? false : (t = i.infix) != null ? t : false;
        }
        return false;
      }
      matchColumnSeparator() {
        let { index: e } = this;
        return this.tabularMode && this.tokens[e] === "&" ? (this.index++, true) : false;
      }
      matchRowSeparator() {
        let { index: e } = this;
        return this.tabularMode && (this.tokens[e] === "\\\\" || this.tokens[e] === "\\cr") ? (this.index++, true) : false;
      }
      placeholder() {
        var t;
        let e = (t = this.args) == null ? void 0 : t.call(this, "?");
        return e ? pe(e, this.context, { parseMode: this.parseMode, mathstyle: "textstyle" }) : [new ie(this.context, { mode: this.parseMode, style: this.style })];
      }
      matchWhitespace() {
        let e = false;
        for (; this.match("<space>"); )
          e = true;
        return e;
      }
      skipUntilToken(e) {
        let t = this.tokens[this.index];
        for (; t && t !== e; )
          t = this.tokens[++this.index];
        t === e && this.index++;
      }
      skipFiller() {
        let e = false;
        do {
          let t = this.matchWhitespace(), i = this.match("\\relax");
          e = !t && !i;
        } while (!e);
      }
      matchKeyword(e) {
        let t = this.index, i = this.end(), o = "";
        for (; !i; ) {
          let n = this.get();
          lo(n) ? (o += n, i = this.end() || o.length >= e.length) : i = true;
        }
        let a = e.toUpperCase() === o.toUpperCase();
        return a || (this.index = t), a;
      }
      scanString() {
        let e = "";
        for (; !this.end(); )
          if (this.match("<space>"))
            e += " ";
          else {
            let t = this.peek();
            if (t === "]")
              break;
            if (lo(t))
              e += this.get();
            else if (t.startsWith("\\"))
              this.onError({ code: "unbalanced-braces" }), e += this.get();
            else
              break;
          }
        return e;
      }
      scanBalancedString() {
        let e = "", t = this.end(), i = 1;
        for (; !t; ) {
          if (this.match("<space>"))
            e += " ";
          else {
            let o = this.get();
            o === "<{>" ? (e += "{", i += 1) : o === "<}>" ? (i -= 1, i > 0 ? e += "}" : this.index -= 1) : o === "<$>" ? e += "$" : o === "<$$>" ? e += "$$" : e += o;
          }
          t = i === 0 || this.end();
        }
        return e;
      }
      matchLiteralArg() {
        var t;
        let e = "";
        if (this.match("<{>")) {
          let i = 1;
          for (; i > 0 && !this.end(); ) {
            let o = this.get();
            o === "<}>" ? (i -= 1, i > 0 && (e += "}")) : o === "<{>" ? (i += 1, e += "{") : e += (t = { "<space>": " ", "<$$>": "$$", "<$>": "$" }[o]) != null ? t : o;
          }
        }
        return e;
      }
      scanNumber(e = true) {
        var l, c;
        let t = false, i = this.peek();
        for (; i === "<space>" || i === "+" || i === "-"; )
          this.get(), i === "-" && (t = !t), i = this.peek();
        e = !!e;
        let o = 10, a = /\d/;
        if (this.match("'"))
          o = 8, a = /[0-7]/, e = true;
        else if (this.match('"') || this.match("x"))
          o = 16, a = /[\dA-F]/, e = true;
        else if (this.match("`"))
          return i = this.get(), i ? i.startsWith("\\") && i.length === 2 ? (t ? -1 : 1) * ((l = i.codePointAt(1)) != null ? l : 0) : (t ? -1 : 1) * ((c = i.codePointAt(0)) != null ? c : 0) : null;
        let n = "";
        for (; this.hasPattern(a); )
          n += this.get();
        if (!e && (this.match(".") || this.match(",")))
          for (n += "."; this.hasPattern(a); )
            n += this.get();
        let s = e ? Number.parseInt(n, o) : Number.parseFloat(n);
        return Number.isNaN(s) ? null : t ? -s : s;
      }
      scanDimen() {
        var i, o, a;
        let e = this.scanNumber(false);
        if (e === null)
          if ((i = this.peek()) != null && i.startsWith("\\"))
            e = 1;
          else
            return null;
        this.matchWhitespace();
        let t;
        return this.matchKeyword("pt") ? t = { dimension: e, unit: "pt" } : this.matchKeyword("mm") ? t = { dimension: e, unit: "mm" } : this.matchKeyword("cm") ? t = { dimension: e, unit: "cm" } : this.matchKeyword("ex") ? t = { dimension: e, unit: "ex" } : this.matchKeyword("px") ? t = { dimension: e, unit: "px" } : this.matchKeyword("em") ? t = { dimension: e, unit: "em" } : this.matchKeyword("bp") ? t = { dimension: e, unit: "bp" } : this.matchKeyword("dd") ? t = { dimension: e, unit: "dd" } : this.matchKeyword("pc") ? t = { dimension: e, unit: "pc" } : this.matchKeyword("in") ? t = { dimension: e, unit: "in" } : this.matchKeyword("mu") ? t = { dimension: e, unit: "mu" } : (o = this.peek()) != null && o.startsWith("\\") ? (t = (a = wr(this.getRegister(this.get().slice(1)), this.context)) != null ? a : { dimension: 0 }, t.dimension *= e) : (this.match("\\relax") || this.onError({ code: "missing-unit" }), t = { dimension: e, unit: "pt" }), t;
      }
      scanGlue() {
        let e = this.scanDimen();
        if (e === null)
          return null;
        let t = { glue: e };
        return this.matchWhitespace(), this.match("\\relax") || (this.matchKeyword("plus") && this.scanDimen(), this.matchWhitespace(), this.match("\\relax")) || (this.matchWhitespace(), this.matchKeyword("minus") && this.scanDimen()), t;
      }
      scanColspec() {
        this.matchWhitespace();
        let e = [];
        for (; !this.end() && !(this.peek() === "<}>" || this.peek() === "]"); ) {
          let t = this.get();
          t === "c" || t === "r" || t === "l" ? e.push({ align: t }) : t === "|" ? e.push({ separator: "solid" }) : t === ":" ? e.push({ separator: "dashed" }) : t === "@" && (this.match("<{>") && (this.beginContext({ mode: "math" }), e.push({ gap: this.parse((i) => i === "<}>") }), this.endContext()), this.match("<}>") || this.onError({ code: "unbalanced-braces" }));
        }
        return e;
      }
      parseModeSet() {
        let e = "";
        if (this.match("\\(") && (e = "\\)"), !e && this.match("\\[") && (e = "\\]"), !e)
          return null;
        this.beginContext({ mode: "math", mathstyle: e === "\\)" ? "textstyle" : "displaystyle" });
        let t = new se(this.parse((i) => i === e), this.context, { mathstyleName: e === "\\)" ? "textstyle" : "displaystyle", latexOpen: e === "\\]" ? "\\[" : "\\(", latexClose: e, boxType: "mord" });
        return this.match(e) || this.onError({ code: "unbalanced-mode-shift" }), this.endContext(), t.hasEmptyBranch("body") ? null : t;
      }
      parseModeShift() {
        let e = "";
        if (this.match("<$>") && (e = "<$>"), !e && this.match("<$$>") && (e = "<$$>"), !e)
          return null;
        this.beginContext({ mode: "math", mathstyle: "textstyle" });
        let t = new se(this.parse((i) => i === e), this.context, { mathstyleName: e === "<$>" ? "textstyle" : "displaystyle", latexOpen: e === "<$>" ? "$ " : "$$ ", latexClose: e === "<$>" ? " $" : " $$" });
        return this.match(e) || this.onError({ code: "unbalanced-mode-shift" }), this.endContext(), t.hasEmptyBranch("body") ? null : t;
      }
      parseEnvironment() {
        if (!this.match("\\begin"))
          return null;
        let e = this.parseArgument("string");
        if (!e)
          return null;
        let t = Nn(e);
        if (!t)
          return this.onError({ code: "unknown-environment", arg: e }), null;
        let i = [];
        if (t.params)
          for (let l of t.params)
            if (l.isOptional)
              i.push(this.parseOptionalArgument(l.type));
            else {
              let c = this.parseArgument(l.type);
              c || this.onError({ code: "missing-argument", arg: e }), i.push(c);
            }
        this.beginContext({ tabular: t.tabular });
        let o = [], a = [], n = [], s = false;
        do
          if (this.end() && (this.onError({ code: "unbalanced-environment", arg: e }), s = true), !s && this.match("\\end") && (this.parseArgument("string") !== e && this.onError({ code: "unbalanced-environment", arg: e }), s = true), !s)
            if (this.matchColumnSeparator())
              n.push(this.mathlist), this.mathlist = [];
            else if (this.matchRowSeparator()) {
              n.push(this.mathlist), this.mathlist = [];
              let l = null;
              this.matchWhitespace(), this.match("[") && (l = this.scanDimen(), this.matchWhitespace(), this.match("]")), a.push(l != null ? l : { dimension: 0 }), o.push(n), n = [];
            } else
              this.mathlist.push(...this.parse((l) => l === "<}>" || l === "&" || l === "\\end" || l === "\\cr" || l === "\\\\"));
        while (!s);
        return n.push(this.mathlist), n.length > 0 && o.push(n), this.endContext(), t.createAtom(this.context, e, o, a, i);
      }
      parse(e) {
        this.beginContext(), e || (e = (l) => l === "<}>");
        let t = "", i = null, o = [], a = null, n = this.mathlist;
        for (this.mathlist = []; !this.end() && !e(this.peek()); )
          this.hasInfixCommand() && !t ? (t = this.get(), i = this.context.getDefinition(t, "math"), i && (o = this.parseArguments(i)[1]), a = this.mathlist, this.mathlist = []) : this.parseToken();
        let s;
        return t ? (o.unshift(this.mathlist), this.mathlist = n, a && o.unshift(a), s = [i.createAtom(t, o, this.style, this.context)]) : (s = this.mathlist, this.mathlist = n), this.endContext(), s;
      }
      parseGroup() {
        if (!this.match("<{>"))
          return null;
        let e = new se(this.parse((t) => t === "<}>"), this.context, { mode: this.parseMode, latexOpen: "{", latexClose: "}" });
        return this.match("<}>") || this.onError({ code: "unbalanced-braces" }), e;
      }
      scanSmartFence() {
        if (this.matchWhitespace(), !this.match("("))
          return null;
        this.beginContext();
        let e = 1;
        for (; !this.end() && e !== 0; )
          this.match("(") && (e += 1), this.match(")") && (e -= 1), e !== 0 && this.parseToken();
        e === 0 && this.match(")");
        let t = new oe("", this.mathlist, this.context, { leftDelim: "(", rightDelim: e === 0 ? ")" : "?" });
        return this.endContext(), t;
      }
      scanDelim() {
        this.matchWhitespace();
        let e = this.get();
        if (!e)
          return this.onError({ code: "unexpected-end-of-string" }), null;
        let t = ".";
        (e.startsWith("\\") || lo(e)) && (t = e);
        let i = this.context.getDefinition(t, "math");
        return i ? i.definitionType === "function" && i.ifMode && !i.ifMode.includes(this.parseMode) ? (this.onError({ code: "unexpected-delimiter", arg: t }), null) : i.definitionType === "symbol" && (i.type === "mopen" || i.type === "mclose") || /^(\.|\?|\||<|>|\\vert|\\Vert|\\\||\\surd|\\uparrow|\\downarrow|\\Uparrow|\\Downarrow|\\updownarrow|\\Updownarrow|\\mid|\\mvert|\\mVert)$/.test(t) ? t : (this.onError({ code: "unexpected-delimiter", arg: t }), null) : (this.onError({ code: "unknown-command", arg: t }), null);
      }
      parseLeftRight() {
        var a;
        if (this.match("\\right") || this.match("\\mright"))
          return this.onError({ code: "unbalanced-braces" }), null;
        let e = "\\right";
        if (!this.match("\\left")) {
          if (!this.match("\\mleft"))
            return null;
          e = "\\mright";
        }
        let t = this.scanDelim();
        if (!t)
          return null;
        for (this.beginContext(); !this.end() && !this.match(e); )
          this.parseToken();
        let i = this.mathlist;
        this.endContext();
        let o = (a = this.scanDelim()) != null ? a : ".";
        return new oe(e === "\\right" ? "left...right" : "mleft...mright", i, this.context, { leftDelim: t, rightDelim: o, style: this.style });
      }
      parseSupSub() {
        if (this.parseMode !== "math")
          return false;
        let e = this.peek();
        if (e !== "^" && e !== "_" && e !== "'")
          return false;
        for (; e === "^" || e === "_" || e === "'"; ) {
          if (this.match("'"))
            this.match("'") ? this.lastSubsupAtom().addChild(new g("mord", this.context, { command: "\\doubleprime", mode: "math", value: "′′" }), "superscript") : this.lastSubsupAtom().addChild(new g("mord", this.context, { command: "\\prime", mode: "math", value: "′" }), "superscript");
          else if (this.match("^") || this.match("_")) {
            let t = this.parseArgument("math");
            t ? this.lastSubsupAtom().addChildren(t, e === "_" ? "subscript" : "superscript") : this.lastSubsupAtom().createBranch(e === "_" ? "subscript" : "superscript");
          }
          e = this.peek();
        }
        return true;
      }
      parseLimits() {
        let e = this.match("\\limits"), t = !e && this.match("\\nolimits"), i = !t && !e && this.match("\\displaylimits");
        if (!e && !t && !i)
          return false;
        let o = this.mathlist.length > 0 ? this.mathlist[this.mathlist.length - 1] : null;
        return o === null || o.type !== "mop" ? false : e ? (o.subsupPlacement = "over-under", o.explicitSubsupPlacement = true, true) : t ? (o.subsupPlacement = "adjacent", o.explicitSubsupPlacement = true, true) : i ? (o.subsupPlacement = "auto", o.explicitSubsupPlacement = true, true) : false;
      }
      parseArguments(e) {
        if (!(e != null && e.params))
          return [void 0, []];
        let t, i = [], o = e.infix ? 2 : 0;
        for (; o < e.params.length; ) {
          let a = e.params[o];
          if (a.type === "rest")
            i.push(this.parse((n) => n === "<}>" || n === "&" || n === "\\end" || n === "\\cr" || n === "\\\\"));
          else if (a.isOptional)
            i.push(this.parseOptionalArgument(a.type));
          else if (a.type.endsWith("*"))
            t = a.type.slice(0, -1);
          else {
            let n = this.parseArgument(a.type);
            if (n !== null)
              i.push(n);
            else
              switch (this.onError({ code: "missing-argument" }), a.type) {
                case "number":
                  i.push(0);
                  break;
                case "dimen":
                  i.push({ dimension: 0, unit: "pt" });
                  break;
                case "glue":
                  i.push({ glue: { dimension: 0, unit: "pt" } });
                  break;
                case "string":
                case "balanced-string":
                  i.push("");
                  break;
                case "delim":
                  i.push(".");
                  break;
                case "colspec":
                  i.push("llllllllll");
                  break;
                case "auto":
                default:
                  i.push(this.placeholder());
                  break;
              }
          }
          o += 1;
        }
        return [t, i];
      }
      parseArgument(e) {
        var a, n;
        this.skipFiller(), e === "auto" && (e = this.parseMode);
        let t = null, i = this.peek() === "<{>";
        if (!i) {
          if (e === "delim")
            return (a = this.scanDelim()) != null ? a : ".";
          if (e === "text" || e === "math") {
            this.beginContext();
            let s = this.parseSimpleToken();
            return this.endContext(), s;
          }
        }
        if (i && this.get(), e === "text" || e === "math") {
          this.beginContext({ mode: e });
          do
            this.mathlist.push(...this.parse());
          while (!this.match("<}>") && !this.end());
        } else if (this.beginContext(), e === "string" ? t = this.scanString() : e === "balanced-string" ? t = this.scanBalancedString() : e === "number" ? t = this.scanNumber() : e === "colspec" ? t = this.scanColspec() : e === "dimen" ? t = this.scanDimen() : e === "glue" ? t = this.scanGlue() : e === "delim" && (t = (n = this.scanDelim()) != null ? n : "."), i && this.skipUntilToken("<}>"), t === null)
          return this.endContext(), null;
        let o = this.mathlist;
        return this.endContext(), t != null ? t : o;
      }
      parseOptionalArgument(e) {
        var i, o;
        if (e = e === "auto" ? this.parseMode : e, this.matchWhitespace(), !this.match("["))
          return null;
        let t = null;
        for (; !this.end() && !this.match("]"); )
          if (e === "string")
            t = this.scanString();
          else if (e === "number")
            t = this.scanNumber();
          else if (e === "dimen")
            t = this.scanDimen();
          else if (e === "glue")
            t = this.scanGlue();
          else if (e === "colspec")
            t = this.scanColspec();
          else if (e === "bbox") {
            let a = this.scanString().toLowerCase().trim().split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/), n = {};
            for (let s of a) {
              let l = (o = (i = this.context).backgroundColorMap) == null ? void 0 : o.call(i, s);
              if (l)
                n.backgroundcolor = l;
              else {
                let c = s.match(/^\s*([\d.]+)\s*([a-z]{2})/);
                if (c)
                  n.padding = c[0];
                else {
                  let u = s.match(/^\s*border\s*:\s*(.*)/);
                  u && (n.border = u[1]);
                }
              }
            }
            t = n;
          } else
            e === "math" && (this.beginContext({ mode: "math" }), t = this.mathlist.concat(this.parse((a) => a === "]")), this.endContext());
        return t;
      }
      parseCommand(e) {
        var a, n, s, l, c, u;
        if (e === "\\placeholder") {
          let d = this.parseOptionalArgument("string"), m = this.parseOptionalArgument("math"), h = er(m, { defaultMode: "math" }), f = [], y;
          !y && h === "correct" ? y = "correct" : !y && h === "incorrect" ? y = "incorrect" : h !== "" && (f = m);
          let w = this.parseOptionalArgument("string") === "locked", k = this.parseArgument("auto"), S;
          return k && k.length > 0 ? S = k : S = f, d ? [new or(this.context, d, y, w, S != null ? S : f, { mode: this.parseMode, style: this.style })] : [new ie(this.context, { mode: this.parseMode, placeholderId: d, style: this.style })];
        }
        let t = null;
        if (e === "\\char") {
          let d = this.index, m = Math.floor((a = this.scanNumber(true)) != null ? a : Number.NaN);
          (!Number.isFinite(m) || m < 0 || m > 1114111) && (m = 10067);
          let h = "\\char" + Ir(this.tokens.slice(d, this.index));
          return t = new g(this.parseMode === "math" ? "mord" : "text", this.context, { command: "\\char", mode: this.parseMode, value: String.fromCodePoint(m), serialize: (f) => {
            var y;
            return (y = f.verbatimLatex) != null ? y : `\\char"${f.value.codePointAt(0).toString(16).toUpperCase()}`;
          } }), t.verbatimLatex = h, [t];
        }
        if (e === "\\hskip" || e === "\\kern") {
          let d = this.scanGlue();
          return d ? [new Ge(e, this.style, this.context, d)] : null;
        }
        if (t = this.scanMacro(e), t)
          return [t];
        let i = this.context.getDefinition(e, this.parseMode);
        if (!i)
          return this.onError({ code: "unknown-command", arg: e }), [new rr(e, this.context)];
        let o = this.index;
        if (i.definitionType === "symbol") {
          let d = b({}, this.style);
          i.variant && (d.variant = i.variant), t = new g((n = i.type) != null ? n : "mop", this.context, { command: e, style: d, value: String.fromCodePoint(i.codepoint), mode: this.parseMode });
        } else {
          if (i.ifMode && !i.ifMode.includes(this.parseMode))
            return [];
          let d = this.parseMode;
          i.applyMode && (this.parseMode = i.applyMode);
          let [m, h] = this.parseArguments(i);
          if (this.parseMode = d, !h)
            return null;
          if (i.applyMode && !i.applyStyle && !i.createAtom)
            return h[0];
          if (i.infix)
            return this.onError({ code: "too-many-infix-commands", arg: e }), null;
          if (typeof i.createAtom == "function")
            t = i.createAtom(e, h, this.style, this.context), m && (t.body = (s = this.parseArgument(m)) != null ? s : void 0);
          else if (typeof i.applyStyle == "function") {
            let f = i.applyStyle(e, h, this.context), y = this.parseMode;
            if (i.applyMode && (this.parseMode = i.applyMode), m) {
              let w = this.style;
              this.style = b(b({}, this.style), f);
              let k = this.parseArgument(m);
              return this.style = w, this.parseMode = y, k;
            }
            this.style = b(b({}, this.style), f), this.parseMode = y;
          } else
            t = new g("mop", this.context, { command: (l = i.command) != null ? l : e, style: b({}, this.style), value: e, mode: (c = i.applyMode) != null ? c : this.parseMode });
        }
        if (t instanceof g && t.verbatimLatex === void 0 && !/^\\(llap|rlap|class|cssId|htmlData)$/.test(e) && (t.verbatimLatex = ((u = t.command) != null ? u : "") + Ir(this.tokens.slice(o, this.index)), t.verbatimLatex.length === 0 && (t.verbatimLatex = void 0), t.isFunction && this.smartFence)) {
          let d = this.scanSmartFence();
          if (d)
            return [t, d];
        }
        return t ? [t] : null;
      }
      parseLiteral(e) {
        let t = Te.createAtom(this.parseMode, e, this.context, b({}, this.style));
        if (!t)
          return null;
        if (t.isFunction && this.smartFence) {
          let i = this.scanSmartFence();
          if (i)
            return [t, i];
        }
        return [t];
      }
      parseSimpleToken() {
        let e = this.get();
        return e ? e === "<space>" ? this.parseMode === "text" ? [new Je(" ", " ", this.style, this.context)] : null : e.startsWith("\\") ? this.parseCommand(e) : lo(e) ? this.parseLiteral(e) : (e === "<}>" ? this.onError({ latex: "", code: "unbalanced-braces" }) : this.onError({ latex: "", code: "unexpected-token", arg: e }), null) : null;
      }
      scanMacro(e) {
        var n;
        let t = this.context.getMacro(e);
        if (!t)
          return null;
        let i = this.index, o = t.args, a = { "?": (n = this.args) == null ? void 0 : n.call(this, "?") };
        for (let s = 1; s <= o; s++)
          a[s] = this.matchLiteralArg();
        return new ir(e, this.context, { expand: t.expand, captureSelection: t.captureSelection, args: Ir(this.tokens.slice(i, this.index)), body: pe(t.def, this.context, { parseMode: this.parseMode, args: (s) => a[s], mathstyle: this.currentContext.mathstyle }) });
      }
      parseToken() {
        var t, i, o, a;
        let e = (a = (o = (i = (t = this.parseEnvironment()) != null ? t : this.parseModeShift()) != null ? i : this.parseModeSet()) != null ? o : this.parseGroup()) != null ? a : this.parseLeftRight();
        if (e === null) {
          if (this.parseSupSub() || this.parseLimits())
            return true;
          e = this.parseSimpleToken();
        }
        return Y(e) ? this.mathlist.push(...e) : e && this.mathlist.push(e), e !== null;
      }
    };
    function pe(r, e, t) {
      var n, s, l;
      let i = (n = t == null ? void 0 : t.args) != null ? n : null, o = new Wr(xr(r, i), e, { args: i, mathstyle: (s = t == null ? void 0 : t.mathstyle) != null ? s : "displaystyle", parseMode: (l = t == null ? void 0 : t.parseMode) != null ? l : "math" }), a = [];
      for (; !o.end(); )
        a.push(...o.parse());
      return a;
    }
    function co(r, e, t) {
      var o;
      let i = new Wr(xr(r, null), e, { args: null, mathstyle: "displaystyle", parseMode: (o = t == null ? void 0 : t.parseMode) != null ? o : "math" });
      for (; !i.end(); )
        i.parse();
      return i.errors;
    }
    function jn(r, e) {
      return typeof r == "object" && "glue" in r ? r : typeof r == "object" && "dimension" in r ? { glue: r } : typeof r == "number" ? { glue: { dimension: r } } : new Wr(xr(r), e, {}).scanGlue();
    }
    function wr(r, e) {
      return typeof r == "number" ? { dimension: r, unit: "pt" } : (typeof r == "object" && "glue" in r && (r = r.glue), typeof r == "object" && "dimension" in r ? r : new Wr(xr(r), e, {}).scanDimen());
    }
    var gt = class extends g {
      constructor(t, i, o, a, n) {
        super("enclose", a, { command: t, style: n.style });
        this.body = i, this.backgroundcolor = n.backgroundcolor, o.updiagonalarrow && (o.updiagonalstrike = false), o.box && (o.left = false, o.right = false, o.bottom = false, o.top = false), this.notation = o, this.shadow = n.shadow, this.strokeWidth = n.strokeWidth, this.strokeStyle = n.strokeStyle, this.svgStrokeStyle = n.svgStrokeStyle, this.strokeColor = n.strokeColor, this.borderStyle = n.borderStyle, this.padding = n.padding, this.captureSelection = true;
      }
      static fromJson(t, i) {
        return new gt(t.command, t.body, t.notation, i, t);
      }
      toJson() {
        return E(b({}, super.toJson()), { notation: this.notation, shadow: this.shadow, strokeWidth: this.strokeWidth, strokeStyle: this.strokeStyle, svgStrokeStyle: this.svgStrokeStyle, strokeColor: this.strokeColor, borderStyle: this.borderStyle, padding: this.padding });
      }
      serialize(t) {
        var o;
        let i = (o = this.command) != null ? o : "";
        if (this.command === "\\enclose") {
          i += "{" + Object.keys(this.notation).join(" ") + "}";
          let a = "", n = "";
          this.backgroundcolor && this.backgroundcolor !== "transparent" && (a += n + 'mathbackground="' + this.backgroundcolor + '"', n = ","), this.shadow && this.shadow !== "auto" && (a += n + 'shadow="' + this.shadow + '"', n = ","), this.strokeWidth || this.strokeStyle !== "solid" ? (a += n + this.borderStyle, n = ",") : this.strokeColor && this.strokeColor !== "currentColor" && (a += n + 'mathcolor="' + this.strokeColor + '"', n = ","), a && (i += `[${a}]`);
        }
        return i += `{${this.bodyToLatex(t)}}`, i;
      }
      render(t) {
        var u;
        let i = new P(t, this.style), o = g.createBox(i, this.body);
        if (!o)
          return null;
        let a = (u = Ae(this.padding && this.padding !== "auto" ? wr(this.padding, E(b({}, this.context), { registers: t.registers })) : i.getRegisterAsDimension("fboxsep"))) != null ? u : 0, n = Ql(this.borderStyle), s = new v(null, { classes: "ML__notation" });
        s.setStyle("box-sizing", "border-box"), s.setStyle("top", `calc(-${n} / 2 - ${a}em)`), s.setStyle("left", `calc(-${n} / 2 - ${a}em)`), s.setStyle("height", `calc(100% + ${2 * a}em + 2 * ${n})`), s.height = o.height + a, s.depth = o.depth + a, s.setStyle("width", `calc(100% + ${2 * a}em + 2 * ${n})`), this.backgroundcolor && s.setStyle("background-color", this.backgroundcolor), this.notation.box && s.setStyle("border", this.borderStyle), this.notation.actuarial && (s.setStyle("border-top", this.borderStyle), s.setStyle("border-right", this.borderStyle)), this.notation.madruwb && (s.setStyle("border-bottom", this.borderStyle), s.setStyle("border-right", this.borderStyle)), this.notation.roundedbox && (s.setStyle("border-radius", "8px"), s.setStyle("border", this.borderStyle)), this.notation.circle && (s.setStyle("border-radius", "50%"), s.setStyle("border", this.borderStyle)), this.notation.top && s.setStyle("border-top", this.borderStyle), this.notation.left && s.setStyle("border-left", this.borderStyle), this.notation.right && s.setStyle("border-right", this.borderStyle), this.notation.bottom && s.setStyle("border-bottom", this.borderStyle);
        let l = "";
        if (this.notation.horizontalstrike && (l += '<line x1="3%"  y1="50%" x2="97%" y2="50%"', l += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, l += ' stroke-linecap="round"', this.svgStrokeStyle && (l += ` stroke-dasharray="${this.svgStrokeStyle}"`), l += "/>"), this.notation.verticalstrike && (l += '<line x1="50%"  y1="3%" x2="50%" y2="97%"', l += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, l += ' stroke-linecap="round"', this.svgStrokeStyle && (l += ` stroke-dasharray="${this.svgStrokeStyle}"`), l += "/>"), this.notation.updiagonalstrike && (l += '<line x1="3%"  y1="97%" x2="97%" y2="3%"', l += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, l += ' stroke-linecap="round"', this.svgStrokeStyle && (l += ` stroke-dasharray="${this.svgStrokeStyle}"`), l += "/>"), this.notation.downdiagonalstrike && (l += '<line x1="3%"  y1="3%" x2="97%" y2="97%"', l += ` stroke-width="${this.strokeWidth}" stroke="${this.strokeColor}"`, l += ' stroke-linecap="round"', this.svgStrokeStyle && (l += ` stroke-dasharray="${this.svgStrokeStyle}"`), l += "/>"), l) {
          let d;
          this.shadow !== "none" && (d = this.shadow === "auto" ? "filter: drop-shadow(0 0 .5px rgba(255, 255, 255, .7)) drop-shadow(1px 1px 2px #333)" : "filter: drop-shadow(" + this.shadow + ")"), ji(s, l, d);
        }
        let c = new v([s, o]);
        return c.setStyle("position", "relative"), c.setStyle("display", "inline"), c.height = o.height + a, c.depth = o.depth + a, c.left = a, c.right = a, this.caret && (c.caret = this.caret), c.wrap(i);
      }
    };
    function Ql(r) {
      if (!r)
        return "1px";
      let e = r.match(/([0-9][a-zA-Z\%]+)/);
      return e === null ? "1px" : e[1];
    }
    x("enclose", "{notation:string}[style:string]{body:auto}", { createAtom: (r, e, t, i) => {
      var n;
      let o = { strokeColor: "currentColor", strokeWidth: "", strokeStyle: "solid", backgroundcolor: "transparent", padding: "auto", shadow: "auto", svgStrokeStyle: void 0, borderStyle: void 0, style: t };
      if (e[1]) {
        let s = e[1].split(/,(?![^(]*\)(?:(?:[^(]*\)){2})*[^"]*$)/);
        for (let l of s) {
          let c = l.match(/\s*(\S+)\s+(\S+)\s+(.*)/);
          if (c)
            o.strokeWidth = c[1], o.strokeStyle = c[2], o.strokeColor = c[3];
          else {
            let u = l.match(/\s*([a-z]*)\s*=\s*"(.*)"/);
            u && (u[1] === "mathbackground" ? o.backgroundcolor = u[2] : u[1] === "mathcolor" ? o.strokeColor = u[2] : u[1] === "padding" ? o.padding = u[2] : u[1] === "shadow" && (o.shadow = u[2]));
          }
        }
        o.strokeStyle === "dashed" ? o.svgStrokeStyle = "5,5" : o.strokeStyle === "dotted" && (o.svgStrokeStyle = "1,5");
      }
      o.borderStyle = `${o.strokeWidth} ${o.strokeStyle} ${o.strokeColor}`;
      let a = {};
      return ((n = e[0]) != null ? n : "").split(/[, ]/).filter((s) => s.length > 0).forEach((s) => {
        a[s.toLowerCase()] = true;
      }), new gt(r, e[2], a, i, o);
    } });
    x("cancel", "{body:auto}", { createAtom: (r, e, t, i) => new gt(r, e[0], { updiagonalstrike: true }, i, { strokeColor: "currentColor", strokeWidth: "", strokeStyle: "solid", borderStyle: "1px solid currentColor", backgroundcolor: "transparent", padding: "auto", shadow: "auto", style: t }) });
    x("bcancel", "{body:auto}", { createAtom: (r, e, t, i) => new gt(r, e[0], { downdiagonalstrike: true }, i, { strokeColor: "currentColor", strokeWidth: "", strokeStyle: "solid", borderStyle: "1px solid currentColor", backgroundcolor: "transparent", padding: "auto", shadow: "auto", style: t }) });
    x("xcancel", "{body:auto}", { createAtom: (r, e, t, i) => new gt(r, e[0], { updiagonalstrike: true, downdiagonalstrike: true }, i, { strokeColor: "currentColor", strokeWidth: "", strokeStyle: "solid", borderStyle: "1px solid currentColor", backgroundcolor: "transparent", padding: "auto", shadow: "auto", style: t }) });
    function ec(r, e, t, i) {
      let o = 0;
      for (let u of i)
        "align" in u && (o += 1);
      let a = 0, n = [];
      for (let u of t) {
        let d = 0;
        for (a = Math.max(a, Math.min(u.length, o)); d < u.length; ) {
          let m = [], h = Math.min(u.length, d + o);
          for (; d < h; )
            u[d].length === 0 ? m.push([new g("first", r, { mode: e.mode })]) : u[d][0].type !== "first" ? m.push([new g("first", r, { mode: e.mode }), ...u[d]]) : m.push(u[d]), d += 1;
          n.push(m);
        }
      }
      n[n.length - 1].length === 1 && n[n.length - 1][0].length === 0 && n.pop();
      let s = [];
      for (let u of n) {
        if (u.length !== a)
          for (let d = u.length; d < a; d++)
            u.push([new g("first", r, { mode: e.mode }), new ie(r)]);
        s.push(u);
      }
      let l = 0, c = 0;
      for (let u of s) {
        c = 0;
        for (let d of u) {
          for (let m of d)
            m.parent = e, m.treeBranch = [l, c];
          c += 1;
        }
        l += 1;
      }
      return e.isDirty = true, s;
    }
    var X = class extends g {
      constructor(t, i, o, a, n = {}) {
        var s, l;
        super("array", t);
        this.environmentName = i, this.rowGaps = a, n.mathstyleName && (this.mathstyleName = n.mathstyleName), n.columns && (n.columns.length === 0 ? this.colFormat = [{ align: "l" }] : this.colFormat = n.columns), this.colFormat || (this.colFormat = [{ align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }, { align: "l" }]), this.array = ec(t, this, o, this.colFormat), n.leftDelim && (this.leftDelim = n.leftDelim), n.rightDelim && (this.rightDelim = n.rightDelim), n.jot !== void 0 && (this.jot = n.jot), n.arraycolsep && (this.arraycolsep = n.arraycolsep), this.colSeparationType = n.colSeparationType, this.arraystretch = (s = n.arraystretch) != null ? s : 1, this.minColumns = (l = n.minColumns) != null ? l : 1;
      }
      static fromJson(t, i) {
        return new X(i, t.environmentName, t.array, t.rowGaps, t);
      }
      toJson() {
        let t = E(b({}, super.toJson()), { environmentName: this.environmentName, array: this.array.map((i) => i.map((o) => o.map((a) => a.toJson()))), rowGaps: this.rowGaps, columns: this.colFormat, colSeparationType: this.colSeparationType });
        return this.arraystretch !== 1 && (t.arraystretch = this.arraystretch), this.arraycolsep && (t.arraycolsep = this.arraycolsep), this.leftDelim && (t.leftDelim = this.leftDelim), this.rightDelim && (t.rightDelim = this.rightDelim), this.jot !== void 0 && (t.jot = this.jot), t;
      }
      branch(t) {
        var i;
        if (ki(t))
          return (i = this.array[t[0]][t[1]]) != null ? i : void 0;
      }
      get branches() {
        let t = super.branches;
        return this.array.forEach((i, o) => {
          this.array[o].forEach((a, n) => {
            this.array[o][n] && t.push([o, n]);
          });
        }), t;
      }
      createBranch(t) {
        var i;
        return ki(t) ? (this.isDirty = true, (i = this.branch(t)) != null ? i : []) : [];
      }
      get rowCount() {
        return this.array.length;
      }
      get colCount() {
        return this.array[0].length;
      }
      get maxColumns() {
        return this.colFormat.filter((t) => !!t.align).length;
      }
      removeBranch(t) {
        if (Qt(t))
          return super.removeBranch(t);
        let i = this.branch(t);
        return this.array[t[0]][t[1]] = void 0, i.forEach((o) => {
          o.parent = void 0, o.treeBranch = void 0;
        }), i[0].type, i.shift(), this.isDirty = true, i;
      }
      get hasChildren() {
        return this.children.length > 0;
      }
      get children() {
        let t = [];
        for (let i of this.array)
          for (let o of i)
            if (o)
              for (let a of o)
                t.push(...a.children), t.push(a);
        return [...t, ...super.children];
      }
      render(t) {
        var Jt, Wt, _e, di, mi;
        let i = new P(t, this.style, this.mathstyleName), o = i.getRegisterAsEm("arrayrulewidth"), a = i.getRegisterAsEm("arraycolsep"), n = i.getRegisterAsEm("doublerulesep"), s = (Jt = this.arraystretch) != null ? Jt : 1, l = typeof this.arraycolsep == "number" ? this.arraycolsep : a;
        this.colSeparationType === "small" && (l = 0.2778 * (new P(t, void 0, "scriptstyle").scalingFactor / t.scalingFactor));
        let c = s * xn, u = 0.7 * c, d = 0.3 * c, m = 0, h = [], f = 0, y = this.array.length;
        for (let me = 0; me < y; ++me) {
          let ke = this.array[me];
          f = Math.max(f, ke.length);
          let Ke = new P(i, this.style, this.mathstyleName), pt = u / Ke.scalingFactor, wt = d / Ke.scalingFactor, Ut = { cells: [], height: 0, depth: 0, pos: 0 };
          for (let Gi of ke) {
            let Ye = (Wt = g.createBox(Ke, Gi, { newList: true })) != null ? Wt : new v(null, { newList: true });
            wt = Math.max(wt, Ye.depth), pt = Math.max(pt, Ye.height), Ut.cells.push(Ye);
          }
          let jt = (_e = Ae(this.rowGaps[me])) != null ? _e : 0;
          jt > 0 && (jt += d, wt = Math.max(wt, jt), jt = 0), this.jot !== void 0 && (wt += this.jot), Ut.height = pt, Ut.depth = wt, m += pt, Ut.pos = m, m += wt + jt, h.push(Ut);
        }
        let w = m / 2 + ze, k = [];
        for (let me = 0; me < f; me++) {
          let ke = [];
          for (let Ke of h) {
            let pt = Ke.cells[me];
            pt.depth = Ke.depth, pt.height = Ke.height, ke.push({ box: pt, shift: Ke.pos - w });
          }
          ke.length > 0 && k.push(new Q({ individualShift: ke }));
        }
        let S = [], T = false, C = false, K = 0, M = !this.leftDelim, { colFormat: R } = this;
        for (let me of R) {
          if ("align" in me && K >= k.length)
            break;
          if ("align" in me)
            T ? S.push(mo(2 * l)) : (C || M) && S.push(mo(l)), S.push(new v(k[K], { classes: "col-align-" + me.align })), K++, T = true, C = false, M = false;
          else if ("gap" in me) {
            if (typeof me.gap == "number")
              S.push(mo(me.gap));
            else {
              let ke = tc(t, h, w, me.gap);
              ke && S.push(ke);
            }
            T = false, C = false, M = false;
          } else if ("separator" in me) {
            let ke = new v(null, { classes: "vertical-separator" });
            ke.setStyle("height", m, "em"), ke.setStyle("border-right", `${o}em ${me.separator} currentColor`), ke.setStyle("vertical-align", -(m - w), "em");
            let Ke = 0;
            C ? Ke = n - o : T && (Ke = l - o), ke.left = Ke, S.push(ke), T = false, C = true, M = false;
          }
        }
        T && !this.rightDelim && S.push(mo(l));
        let F = new v(S, { classes: "mtable" });
        if ((!this.leftDelim || this.leftDelim === ".") && (!this.rightDelim || this.rightDelim === "."))
          return this.caret && (F.caret = this.caret), F;
        let Le = F.height, Pe = F.depth, vt = this.bind(t, new v([this.bind(t, vr("mopen", (di = this.leftDelim) != null ? di : ".", Le, Pe, i)), F, this.bind(t, vr("mclose", (mi = this.rightDelim) != null ? mi : ".", Le, Pe, i))], { type: "mord" }));
        return vt ? (this.caret && (vt.caret = this.caret), this.attachSupsub(t, { base: vt })) : null;
      }
      serialize(t) {
        let i = "\\begin{" + this.environmentName + "}";
        if (this.environmentName === "array") {
          if (i += "{", this.colFormat !== void 0)
            for (let o of this.colFormat)
              "align" in o ? i += o.align : "separator" in o && o.separator === "solid" ? i += "|" : "separator" in o && o.separator === "dashed" && (i += ":");
          i += "}";
        }
        for (let o = 0; o < this.array.length; o++) {
          for (let a = 0; a < this.array[o].length; a++)
            a > 0 && (i += " & "), i = j([i, g.serialize(this.array[o][a], t)]);
          o < this.array.length - 1 && (i += " \\\\ ");
        }
        return i += "\\end{" + this.environmentName + "}", i;
      }
      getCell(t, i) {
        return this.array[t][i];
      }
      setCell(t, i, o) {
        this.type === "array" && Array.isArray(this.array) && this.array[t][i];
        for (let n of this.array[t][i])
          n.parent = void 0, n.treeBranch = void 0;
        let a = o;
        (o.length === 0 || o[0].type !== "first") && (a = [new g("first", this.context, { mode: this.mode }), ...o]), this.array[t][i] = a;
        for (let n of a)
          n.parent = this, n.treeBranch = [t, i];
        this.isDirty = true;
      }
      addRowBefore(t) {
        this.type === "array" && Array.isArray(this.array);
        let i = [];
        for (let o = 0; o < this.colCount; o++)
          i.push(uo(this));
        this.array.splice(t, 0, i);
        for (let o = t; o < this.rowCount; o++)
          for (let a = 0; a < this.colCount; a++) {
            let n = this.array[o][a];
            if (n)
              for (let s of n)
                s.treeBranch = [o, a];
          }
        this.isDirty = true;
      }
      addRowAfter(t) {
        this.type === "array" && Array.isArray(this.array);
        let i = [];
        for (let o = 0; o < this.colCount; o++)
          i.push(uo(this));
        this.array.splice(t + 1, 0, i);
        for (let o = t + 1; o < this.rowCount; o++)
          for (let a = 0; a < this.colCount; a++) {
            let n = this.array[o][a];
            if (n)
              for (let s of n)
                s.treeBranch = [o, a];
          }
        this.isDirty = true;
      }
      removeRow(t) {
        this.type === "array" && Array.isArray(this.array) && this.rowCount > t;
        let i = this.array.splice(t, 1);
        for (let o of i)
          for (let a of o)
            if (a)
              for (let n of a)
                n.parent = void 0, n.treeBranch = void 0;
        for (let o = t; o < this.rowCount; o++)
          for (let a = 0; a < this.colCount; a++) {
            let n = this.array[o][a];
            if (n)
              for (let s of n)
                s.treeBranch = [o, a];
          }
        this.isDirty = true;
      }
      addColumnBefore(t) {
        this.type === "array" && Array.isArray(this.array);
        for (let i of this.array)
          i.splice(t, 0, uo(this));
        for (let i = 0; i < this.rowCount; i++)
          for (let o = t; o < this.colCount; o++) {
            let a = this.array[i][o];
            if (a)
              for (let n of a)
                n.treeBranch = [i, o];
          }
        this.isDirty = true;
      }
      addColumnAfter(t) {
        this.type === "array" && Array.isArray(this.array);
        for (let i of this.array)
          i.splice(t + 1, 0, uo(this));
        for (let i = 0; i < this.rowCount; i++)
          for (let o = t + 1; o < this.colCount; o++) {
            let a = this.array[i][o];
            if (a)
              for (let n of a)
                n.treeBranch = [i, o];
          }
        this.isDirty = true;
      }
      addColumn() {
        this.addColumnAfter(this.colCount - 1);
      }
      removeColumn(t) {
        this.type === "array" && Array.isArray(this.array) && this.colCount > t;
        for (let i of this.array) {
          let o = i.splice(t, 1);
          for (let a of o)
            if (a)
              for (let n of a)
                n.parent = void 0, n.treeBranch = void 0;
        }
        for (let i = 0; i < this.rowCount; i++)
          for (let o = t; o < this.colCount; o++) {
            let a = this.array[i][o];
            if (a)
              for (let n of a)
                n.treeBranch = [i, o];
          }
        this.isDirty = true;
      }
      get cells() {
        let t = [];
        for (let i of this.array)
          for (let o of i)
            o && t.push(o);
        return t;
      }
    };
    function uo(r) {
      let e = new g("first", r.context, { mode: r.mode });
      e.parent = r;
      let t = new ie(r.context, { mode: r.mode });
      return t.parent = r, [e, t];
    }
    function mo(r) {
      let e = new v(null, { classes: "arraycolsep" });
      return e.width = r, e;
    }
    function tc(r, e, t, i) {
      if (!i)
        return null;
      let o = [];
      for (let a of e) {
        let n = g.createBox(r, i, { newList: true });
        n && (n.depth = a.depth, n.height = a.height, o.push({ box: n, shift: a.pos - t }));
      }
      return new Q({ individualShift: o }).wrap(r);
    }
    bi("math", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { mathstyleName: "textstyle" })));
    bi("displaymath", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { mathstyleName: "textstyle" })));
    ht("array", "{columns:colspec}", (r, e, t, i, o) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: o[0], mathstyleName: "textstyle" })));
    ht(["equation", "equation*", "subequations"], "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: [{ align: "c" }] })));
    ht("multline", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: [{ align: "m" }] })));
    ht(["align", "align*", "aligned", "eqnarray"], "", (r, e, t, i) => {
      let o = 0;
      Qe(t) && (t = [[[new g("first", r), new ie(r)], [new g("first", r), new ie(r)]]]);
      for (let s of t)
        o = Math.max(o, s.length);
      let a = [{ gap: 0 }, { align: "r" }, { gap: 0.25 }, { align: "l" }], n = 2;
      for (; n < o; )
        a.push({ gap: 1 }), a.push({ align: "r" }), a.push({ gap: 0.25 }), a.push({ align: "l" }), n += 2;
      return a.push({ gap: 0 }), new X(r, e, t, i, { arraycolsep: 0, columns: a, colSeparationType: "align", jot: 0.3, minColumns: 2 });
    });
    ht("split", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)], [new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: [{ align: "r" }, { align: "l" }], minColumns: 2 })));
    ht(["gather", "gathered"], "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: [{ gap: 0.25 }, { align: "c" }, { gap: 0 }], colSeparationType: "gather" })));
    ht(["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"], "[columns:colspec]", (r, e, t, i, o) => {
      var s;
      Qe(t) && (t = [[[new g("first", r), new ie(r)]]]);
      let a = ".", n = ".";
      switch (e) {
        case "pmatrix":
        case "pmatrix*":
          a = "(", n = ")";
          break;
        case "bmatrix":
        case "bmatrix*":
          a = "[", n = "]";
          break;
        case "Bmatrix":
        case "Bmatrix*":
          a = "\\lbrace", n = "\\rbrace";
          break;
        case "vmatrix":
        case "vmatrix*":
          a = "\\vert", n = "\\vert";
          break;
        case "Vmatrix":
        case "Vmatrix*":
          a = "\\Vert", n = "\\Vert";
          break;
        case "matrix":
        case "matrix*":
          a = ".", n = ".";
          break;
      }
      return new X(r, e, t, i, { mathstyleName: "textstyle", leftDelim: a, rightDelim: n, columns: (s = o[0]) != null ? s : [{ align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }] });
    });
    ht(["smallmatrix", "smallmatrix*"], "[columns:colspec]", (r, e, t, i, o) => {
      var a;
      return Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { mathstyleName: "scriptstyle", columns: (a = o[0]) != null ? a : [{ align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }, { align: "c" }], colSeparationType: "small", arraystretch: 0.5 });
    });
    ht(["cases", "dcases"], "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { mathstyleName: e === "dcases" ? "displaystyle" : "textstyle", arraystretch: 1.2, leftDelim: "\\lbrace", rightDelim: ".", columns: [{ align: "l" }, { gap: 1 }, { align: "l" }] })));
    ht("rcases", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { arraystretch: 1.2, leftDelim: ".", rightDelim: "\\rbrace", columns: [{ align: "l" }, { gap: 1 }, { align: "l" }] })));
    bi("center", "", (r, e, t, i) => (Qe(t) && (t = [[[new g("first", r), new ie(r)]]]), new X(r, e, t, i, { columns: [{ align: "c" }] })));
    function Qe(r) {
      for (let e of r)
        for (let t of e)
          if (t.length > 0)
            return false;
      return true;
    }
    x(["overrightarrow", "overleftarrow", "Overrightarrow", "overleftharpoon", "overrightharpoon", "overleftrightarrow", "overlinesegment", "overgroup"], "{:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[0], skipBoundary: false, supsubPlacement: "over-under", paddedBody: true, boxType: "mrel", style: t, svgAbove: r.slice(1) }) });
    x("overbrace", "{:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[0], skipBoundary: false, supsubPlacement: "over-under", paddedBody: true, boxType: "mord", style: t, svgAbove: r.slice(1) }) });
    x(["underrightarrow", "underleftarrow", "underleftrightarrow", "underlinesegment", "undergroup"], "{:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[0], skipBoundary: false, supsubPlacement: "over-under", paddedBody: true, boxType: "mrel", style: t, svgBelow: r.slice(1) }) });
    x(["underbrace"], "{:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[0], skipBoundary: false, supsubPlacement: "over-under", paddedBody: true, boxType: "mord", style: t, svgBelow: r.slice(1) }) });
    x(["xrightarrow", "xleftarrow", "xRightarrow", "xLeftarrow", "xleftharpoonup", "xleftharpoondown", "xrightharpoonup", "xrightharpoondown", "xlongequal", "xtwoheadleftarrow", "xtwoheadrightarrow", "xleftrightarrow", "xLeftrightarrow", "xrightleftharpoons", "xleftrightharpoons", "xhookleftarrow", "xhookrightarrow", "xmapsto", "xtofrom", "xrightleftarrows", "xrightequilibrium", "xleftequilibrium"], "[:auto]{:auto}", { createAtom: (r, e, t, i) => {
      var o, a;
      return new be(r, i, { style: t, svgBody: r.slice(1), above: ((o = e[1]) == null ? void 0 : o.length) === 0 ? void 0 : e[1], below: (a = e[0]) != null ? a : null, skipBoundary: false, supsubPlacement: "over-under", paddedBody: true, paddedLabels: true, boxType: "mrel", serialize: (n, s) => r + (n.hasEmptyBranch("below") ? "" : `[${n.belowToLatex(s)}]`) + `{${n.aboveToLatex(s)}}${n.supsubToLatex(s)}` });
    } });
    var we = class extends g {
      constructor(t, i, o, a) {
        var n, s, l, c;
        super((n = a.type) != null ? n : "mop", o, { command: t, style: a.style, isFunction: a == null ? void 0 : a.isFunction });
        typeof i == "string" ? this.value = i : this.body = i, this.captureSelection = (s = a.captureSelection) != null ? s : false, this.hasArgument = (l = a.hasArgument) != null ? l : false, this.variant = a == null ? void 0 : a.variant, this.variantStyle = a == null ? void 0 : a.variantStyle, this.subsupPlacement = a == null ? void 0 : a.limits, this.isExtensibleSymbol = (c = a == null ? void 0 : a.isExtensibleSymbol) != null ? c : false;
      }
      static fromJson(t, i) {
        return new we(t.command, t.body ? t.body : t.value, i, t);
      }
      toJson() {
        let t = super.toJson();
        return this.hasArgument && (t.hasArgument = true), this.variant && (t.variant = this.variant), this.variantStyle && (t.variantStyle = this.variantStyle), this.subsupPlacement && (t.limits = this.subsupPlacement), this.isExtensibleSymbol && (t.isExtensibleSymbol = true), this.value && (t.symbol = this.value), t;
      }
      render(t) {
        var s;
        let i, o = 0, a = 0;
        if (this.isExtensibleSymbol) {
          let l = t.isDisplayStyle && this.value !== "\\smallint";
          if (i = new v(this.value, { fontFamily: l ? "Size2-Regular" : "Size1-Regular", classes: "op-symbol " + (l ? "large-op" : "small-op"), type: "mop", maxFontSize: t.scalingFactor }), !i)
            return null;
          i.right = i.italic, o = (i.height - i.depth) / 2 - ze * t.scalingFactor, a = i.italic, i.setStyle("color", this.style.color), i.setStyle("background-color", this.style.backgroundColor);
        } else if (this.body) {
          if (i = g.createBox(t, this.body, { newList: true }), !i)
            return null;
          i.setStyle("color", this.style.color), i.setStyle("background-color", this.style.backgroundColor);
        } else
          this.type, i = new v(this.value, { type: "mop", mode: "math", maxFontSize: t.scalingFactor, style: { color: this.style.color, backgroundColor: this.style.backgroundColor, letterShapeStyle: t.letterShapeStyle, variant: this.variant, variantStyle: this.variantStyle } });
        this.isExtensibleSymbol && i.setTop(o);
        let n = i;
        if (this.superscript || this.subscript) {
          let l = (s = this.subsupPlacement) != null ? s : "auto";
          n = l === "over-under" || l === "auto" && t.isDisplayStyle ? this.attachLimits(t, { base: i, baseShift: o, slant: a }) : this.attachSupsub(t, { base: i });
        }
        return this.caret && (n.caret = this.caret), new v(this.bind(t, n), { type: "mop", classes: "op-group" + (this.isSelected ? " ML__selected" : "") });
      }
      serialize(t) {
        if (this.value === "​")
          return this.supsubToLatex(t);
        let i = [];
        return i.push(this.command), this.hasArgument && i.push(`{${this.bodyToLatex(t)}}`), this.explicitSubsupPlacement && (this.subsupPlacement === "over-under" && i.push("\\limits"), this.subsupPlacement === "adjacent" && i.push("\\nolimits"), this.subsupPlacement === "auto" && i.push("\\displaylimits")), i.push(this.supsubToLatex(t)), j(i);
      }
    };
    var ar = class extends g {
      constructor(e, t, i) {
        var o;
        super("surd", t, { command: e, mode: (o = i.mode) != null ? o : "math", style: i.style, displayContainsHighlight: true }), this.body = i.body, this.above = i.index;
      }
      static fromJson(e, t) {
        return new ar(e.command, t, E(b({}, e), { index: e.above }));
      }
      toJson() {
        return super.toJson();
      }
      serialize(e) {
        let t = "";
        return this.above && (t += `[${this.aboveToLatex(e)}]`), t += `{${this.bodyToLatex(e)}}`, this.command + t;
      }
      render(e) {
        var T;
        let t = new P(e, this.style, "cramp"), i = (T = g.createBox(t, this.body, { style: this.style, newList: true })) != null ? T : new v(null), o = t.scalingFactor, a = t.metrics.defaultRuleThickness / o, n = e.isDisplayStyle ? St : a, s = new v(null, { classes: "ML__sqrt-line", style: this.style, height: a }), l = o * (a + n / 4), u = Math.max(o * 2 * n, i.height + i.depth) + l + a, d = new P(e, this.style), m = this.isSelected ? " ML__selected" : "", h = this.bind(d, new v(Jr("", "\\surd", u, false, d, { classes: m }), { classes: "ML__sqrt-sign" + m, style: this.style }));
        if (!h)
          return null;
        let f = h.height + h.depth - a;
        f > i.height + i.depth + l && (l = (l + f - (i.height + i.depth)) / 2), h.setTop(h.height - i.height - l);
        let y = this.bind(e, new Q({ firstBaseline: [{ box: new v(i) }, l - 2 * a, { box: s }, a] }).wrap(e)), w = g.createBox(new P(e, this.style, "scriptscriptstyle"), this.above, { style: this.style, newList: true });
        if (!w) {
          let C = new v([h, y], { classes: this.containsCaret ? "ML__contains-caret" : "", type: "mord" });
          return this.caret && (C.caret = this.caret), this.bind(e, C.wrap(e));
        }
        let k = new Q({ shift: -0.6 * (Math.max(h.height, y.height) - Math.max(h.depth, y.depth)), children: [{ box: w }] }), S = new v([new v(k, { classes: "ML__sqrt-index" }), h, y], { type: "mord", classes: this.containsCaret ? "ML__contains-caret" : "" });
        return S.height = h.height, S.depth = h.depth, this.caret && (S.caret = this.caret), this.bind(e, S.wrap(e));
      }
    };
    var ut = class extends g {
      constructor(t, i, o, a, n) {
        var s, l;
        super("genfrac", a, { style: n.style, command: t, serialize: n.serialize, displayContainsHighlight: true });
        this.above = i, this.below = o, this.hasBarLine = (s = n == null ? void 0 : n.hasBarLine) != null ? s : true, this.continuousFraction = (l = n == null ? void 0 : n.continuousFraction) != null ? l : false, this.numerPrefix = n == null ? void 0 : n.numerPrefix, this.denomPrefix = n == null ? void 0 : n.denomPrefix, this.mathstyleName = n == null ? void 0 : n.mathstyleName, this.leftDelim = n == null ? void 0 : n.leftDelim, this.rightDelim = n == null ? void 0 : n.rightDelim;
      }
      static fromJson(t, i) {
        return new ut(t.command, t.above, t.below, i, t);
      }
      toJson() {
        let t = {};
        return this.continuousFraction && (t.continuousFraction = true), this.numerPrefix && (t.numerPrefix = this.numerPrefix), this.denomPrefix && (t.denomPrefix = this.denomPrefix), this.leftDelim && (t.leftDelim = this.leftDelim), this.rightDelim && (t.rightDelim = this.rightDelim), this.hasBarLine || (t.hasBarLine = false), this.mathstyleName && (t.mathstyleName = this.mathstyleName), b(b({}, super.toJson()), t);
      }
      serialize(t) {
        return this.command + `{${this.aboveToLatex(t)}}{${this.belowToLatex(t)}}`;
      }
      get children() {
        if (this._children)
          return this._children;
        let t = [];
        if (this.context.fractionNavigationOrder === "numerator-denominator") {
          for (let i of this.above)
            t.push(...i.children), t.push(i);
          for (let i of this.below)
            t.push(...i.children), t.push(i);
        } else {
          for (let i of this.below)
            t.push(...i.children), t.push(i);
          for (let i of this.above)
            t.push(...i.children), t.push(i);
        }
        return this._children = t, t;
      }
      render(t) {
        var M, R;
        let i = new P(t, this.style, this.mathstyleName), o = i.metrics, a = new P(i, this.style, this.continuousFraction ? "" : "numerator"), n = this.numerPrefix ? new v([new v(this.numerPrefix), g.createBox(a, this.above)], { isTight: a.isTight, newList: true }) : (M = g.createBox(a, this.above, { newList: true })) != null ? M : new v(null, { newList: true }), s = new P(i, this.style, this.continuousFraction ? "" : "denominator"), l = this.denomPrefix ? new v([new v(this.denomPrefix), g.createBox(s, this.below, { newList: true })]) : (R = g.createBox(s, this.below, { newList: true })) != null ? R : new v(null, { newList: true }), c = this.hasBarLine ? o.defaultRuleThickness : 0, u, d = 0, m;
        i.isDisplayStyle ? (u = o.num1, d = c > 0 ? 3 * c : 7 * c, m = o.denom1) : (c > 0 ? (u = o.num2, d = c) : (u = o.num3, d = 3 * c), m = o.denom2);
        let h = [];
        this.isSelected && h.push("ML__selected");
        let f = n.depth, y = l.height, w;
        if (c <= 0) {
          let F = u - f - (y - m);
          F < d && (u += (d - F) / 2, m += (d - F) / 2), w = new Q({ individualShift: [{ box: n, shift: -u, classes: [...h, "ML__center"] }, { box: l, shift: m, classes: [...h, "ML__center"] }] }).wrap(i);
        } else {
          let F = ze + c / 2, Le = ze - c / 2;
          u < d + f + F && (u = d + f + F), m < d + y - Le && (m = d + y - Le);
          let Pe = new v(null, { classes: "ML__frac-line", mode: this.mode, style: this.style });
          Pe.height = c / 2, Pe.depth = c / 2, w = new Q({ individualShift: [{ box: l, shift: m, classes: [...h, "ML__center"] }, { box: Pe, shift: -Le + c / 2, classes: h }, { box: n, shift: -u, classes: [...h, "ML__center"] }] }).wrap(i);
        }
        let k = i.isDisplayStyle ? o.delim1 : o.delim2, S = this.isSelected ? " ML__selected" : "", T = this.leftDelim ? this.bind(t, Jr("mopen", this.leftDelim, k, true, t, { style: this.style, mode: this.mode, classes: S })) : Ft(i, "mopen"), C = null;
        this.continuousFraction ? C = new v(null, { type: "mclose" }) : this.rightDelim ? C = this.bind(t, Jr("mclose", this.rightDelim, k, true, t, { style: this.style, mode: this.mode, classes: S })) : C = Ft(i, "mclose");
        let K = this.bind(t, new v([T, w, C], { isTight: i.isTight, type: "mord", classes: "mfrac" }));
        return K ? (this.caret && (K.caret = this.caret), this.attachSupsub(t, { base: K })) : null;
      }
    };
    var nr = class extends g {
      constructor(t, i, o, a) {
        super("delim", o, { command: t, style: a == null ? void 0 : a.style });
        this.value = i, this.size = a == null ? void 0 : a.size;
      }
      static fromJson(t, i) {
        return new nr(t.command, t.delim, i, t);
      }
      toJson() {
        return E(b({}, super.toJson()), { delim: this.value, size: this.size });
      }
      render(t) {
        let i = new v(null);
        return i.delim = this.value, i;
      }
      serialize(t) {
        return this.value.length === 1 ? this.command + this.value : `${this.command}{${this.value}}`;
      }
    }, sr = class extends g {
      constructor(t, i, o, a) {
        super("sizeddelim", o, { command: t, style: a.style });
        this.value = i, this.delimClass = a.delimClass, this.size = a.size;
      }
      static fromJson(t, i) {
        return new sr(t.command, t.delim, i, t);
      }
      toJson() {
        return E(b({}, super.toJson()), { delim: this.value, size: this.size, delimClass: this.delimClass });
      }
      render(t) {
        let i = Wn(this.value, this.size, t, { classes: this.delimClass });
        return i ? (i = this.bind(t, i), this.caret && (i.caret = this.caret), i) : null;
      }
      serialize(t) {
        return this.value.length === 1 ? this.command + this.value : `${this.command}{${this.value}}`;
      }
    };
    x(["arccos", "arcsin", "arctan", "arctg", "arcctg", "arg", "ch", "cos", "cosh", "cot", "cotg", "coth", "ctg", "cth", "csc", "cosec", "dim", "exp", "hom", "inf", "ker", "lb", "lg", "ln", "log", "Pr", "sec", "sh", "sin", "sinh", "sup", "tan", "tanh", "tg", "th", "arcsec", "arccsc", "arsinh", "arcosh", "artanh", "arcsech", "arccsch"], "", { isFunction: true, createAtom: (r, e, t, i) => new we(r, r.slice(1), i, { limits: "adjacent", isFunction: true, variant: "main", variantStyle: "up", style: t }) });
    x(["liminf", "limsup"], "", { createAtom: (r, e, t, i) => new we(r, { "\\liminf": "lim inf", "\\limsup": "lim sup" }[r], i, { limits: "over-under", variant: "main", style: t }) });
    x(["lim", "mod"], "", { createAtom: (r, e, t, i) => new we(r, r.slice(1), i, { limits: "over-under", variant: "main", style: t }) });
    x(["det", "max", "min"], "", { isFunction: true, createAtom: (r, e, t, i) => new we(r, r.slice(1), i, { limits: "over-under", isFunction: true, variant: "main", style: t }) });
    x(["ang"], "{:math}", { isFunction: true, createAtom: (r, e, t, i) => new se([...e[0], new g("mord", i, { value: "°", style: t })], i, { mode: "math", latexOpen: "\\ang{", latexClose: "}", style: t }) });
    x("sqrt", "[index:auto]{radicand:auto}", { createAtom: (r, e, t, i) => new ar(r, i, { body: e[1], index: e[0], style: t }) });
    x(["frac", "dfrac", "tfrac", "cfrac", "binom", "dbinom", "tbinom"], "{numerator}{denominator}", { createAtom: (r, e, t, i) => {
      let o = { style: t };
      switch (r) {
        case "\\dfrac":
        case "\\frac":
        case "\\tfrac":
          o.hasBarLine = true;
          break;
        case "\\atopfrac":
          o.hasBarLine = false;
          break;
        case "\\dbinom":
        case "\\binom":
        case "\\tbinom":
          o.hasBarLine = false, o.leftDelim = "(", o.rightDelim = ")";
          break;
      }
      switch (r) {
        case "\\dfrac":
        case "\\dbinom":
          o.mathstyleName = "displaystyle";
          break;
        case "\\tfrac":
        case "\\tbinom":
          o.mathstyleName = "textstyle";
          break;
        case "\\cfrac":
          o.hasBarLine = true, o.continuousFraction = true;
          break;
      }
      return new ut(r, e[0], e[1], i, o);
    } });
    x(["brace", "brack"], "", { infix: true, createAtom: (r, e, t, i) => new ut(r, e[0], e[1], i, { hasBarLine: false, leftDelim: r === "\\brace" ? "\\lbrace" : "\\lbrack", rightDelim: r === "\\brace" ? "\\rbrace" : "\\rbrack", style: t, serialize: (o, a) => j([o.aboveToLatex(a), o.command, o.belowToLatex(a)]) }) });
    x(["over", "atop", "choose"], "", { infix: true, createAtom: (r, e, t, i) => {
      let o, a;
      return r === "\\choose" && (o = "(", a = ")"), new ut(r, e[0], e[1], i, { hasBarLine: r === "\\over", leftDelim: o, rightDelim: a, style: t, serialize: (n, s) => j([n.aboveToLatex(s), n.command, n.belowToLatex(s)]) });
    } });
    x(["overwithdelims", "atopwithdelims"], "{numer:auto}{denom:auto}{left-delim:delim}{right-delim:delim}", { infix: true, createAtom: (r, e, t, i) => new ut(r, e[0], e[1], i, { leftDelim: e[2], rightDelim: e[3], hasBarLine: false, style: t, serialize: (o, a) => `${o.aboveToLatex(a)} ${o.command}${o.leftDelim}${o.rightDelim}${o.belowToLatex(a)}` }) });
    x("pdiff", "{numerator}{denominator}", { createAtom: (r, e, t, i) => new ut(r, e[0], e[1], i, { hasBarLine: true, numerPrefix: "∂", denomPrefix: "∂", style: t }) });
    x(["sum", "prod", "bigcup", "bigcap", "coprod", "bigvee", "bigwedge", "biguplus", "bigotimes", "bigoplus", "bigodot", "bigsqcup", "intop"], "", { createAtom: (r, e, t, i) => new we(r, { coprod: "∐", bigvee: "⋁", bigwedge: "⋀", biguplus: "⨄", bigcap: "⋂", bigcup: "⋃", intop: "∫", prod: "∏", sum: "∑", bigotimes: "⨂", bigoplus: "⨁", bigodot: "⨀", bigsqcup: "⨆", smallint: "∫" }[r.slice(1)], i, { isExtensibleSymbol: true, limits: "auto", variant: "main", style: t }) });
    x("smallint", "", { createAtom: (r, e, t, i) => new we(r, "∫", i, { limits: "adjacent", isExtensibleSymbol: false, style: t, variant: "main" }) });
    var sa = { int: "∫", iint: "∬", iiint: "∭", oint: "∮", oiint: "∯", oiiint: "∰", intclockwise: "∱", varointclockwise: "∲", ointctrclockwise: "∳", intctrclockwise: "⨑", sqcup: "⊔", sqcap: "⊓", uplus: "⊎", wr: "≀", amalg: "⨿", Cap: "⋒", Cup: "⋓", doublecap: "⋒", doublecup: "⋓" };
    x(Object.keys(sa), "", { createAtom: (r, e, t, i) => new we(r, sa[r.slice(1)], i, { limits: "adjacent", isExtensibleSymbol: true, style: t, variant: { "⋒": "ams", "⋓": "ams" }[sa[r.slice(1)]] }) });
    x(["Re", "Im"], "", { createAtom: (r, e, t, i) => new we(r, { "\\Re": "ℜ", "\\Im": "ℑ" }[r], i, { limits: "adjacent", style: t, isFunction: true, variant: "fraktur" }) });
    x("middle", "{:delim}", { createAtom: (r, e, t, i) => new nr(r, e[0], i, { size: 1, style: t }) });
    var kr = class extends g {
      constructor(t, i, o) {
        super("chem", o, { command: t, mode: "math" });
        let a = ne.go(_.go(i, t === "\\pu" ? "pu" : "ce"), false);
        this.body = pe(a, o), this.verbatimLatex = t + "{" + i + "}", this.arg = i, this.captureSelection = true;
      }
      static fromJson(t, i) {
        return new kr(t.command, t.arg, i);
      }
      toJson() {
        return E(b({}, super.toJson()), { arg: this.arg });
      }
      render(t) {
        let i = g.createBox(t, this.body, { type: "chem", newList: true });
        return this.caret && (i.caret = this.caret), this.bind(t, i);
      }
      serialize(t) {
        return this.verbatimLatex;
      }
    };
    x(["ce", "pu"], "{chemformula:balanced-string}", { createAtom: (r, e, t, i) => new kr(r, e[0], i) });
    var _ = { go: function(r, e) {
      if (!r)
        return [];
      e === void 0 && (e = "ce");
      var t = "0", i = {};
      i.parenthesisLevel = 0, r = r.replace(/\n/g, " "), r = r.replace(/[\u2212\u2013\u2014\u2010]/g, "-"), r = r.replace(/[\u2026]/g, "...");
      for (var o, a = 10, n = []; ; ) {
        o !== r ? (a = 10, o = r) : a--;
        var s = _.stateMachines[e], l = s.transitions[t] || s.transitions["*"];
        e:
          for (var c = 0; c < l.length; c++) {
            var u = _.patterns.match_(l[c].pattern, r);
            if (u) {
              for (var d = l[c].task, m = 0; m < d.action_.length; m++) {
                var h;
                if (s.actions[d.action_[m].type_])
                  h = s.actions[d.action_[m].type_](i, u.match_, d.action_[m].option);
                else if (_.actions[d.action_[m].type_])
                  h = _.actions[d.action_[m].type_](i, u.match_, d.action_[m].option);
                else
                  throw ["MhchemBugA", "mhchem bug A. Please report. (" + d.action_[m].type_ + ")"];
                _.concatArray(n, h);
              }
              if (t = d.nextState || t, r.length > 0) {
                if (d.revisit || (r = u.remainder), !d.toContinue)
                  break e;
              } else
                return n;
            }
          }
        if (a <= 0)
          throw ["MhchemBugU", "mhchem bug U. Please report."];
      }
    }, concatArray: function(r, e) {
      if (e)
        if (Array.isArray(e))
          for (var t = 0; t < e.length; t++)
            r.push(e[t]);
        else
          r.push(e);
    }, patterns: { patterns: { empty: /^$/, else: /^./, else2: /^./, space: /^\s/, "space A": /^\s(?=[A-Z\\$])/, space$: /^\s$/, "a-z": /^[a-z]/, x: /^x/, x$: /^x$/, i$: /^i$/, letters: /^(?:[a-zA-Z\u03B1-\u03C9\u0391-\u03A9?@]|(?:\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))))+/, "\\greek": /^\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega|Gamma|Delta|Theta|Lambda|Xi|Pi|Sigma|Upsilon|Phi|Psi|Omega)(?:\s+|\{\}|(?![a-zA-Z]))/, "one lowercase latin letter $": /^(?:([a-z])(?:$|[^a-zA-Z]))$/, "$one lowercase latin letter$ $": /^\$(?:([a-z])(?:$|[^a-zA-Z]))\$$/, "one lowercase greek letter $": /^(?:\$?[\u03B1-\u03C9]\$?|\$?\\(?:alpha|beta|gamma|delta|epsilon|zeta|eta|theta|iota|kappa|lambda|mu|nu|xi|omicron|pi|rho|sigma|tau|upsilon|phi|chi|psi|omega)\s*\$?)(?:\s+|\{\}|(?![a-zA-Z]))$/, digits: /^[0-9]+/, "-9.,9": /^[+\-]?(?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))/, "-9.,9 no missing 0": /^[+\-]?[0-9]+(?:[.,][0-9]+)?/, "(-)(9.,9)(e)(99)": function(r) {
      var e = r.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))?(\((?:[0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+))\))?(?:([eE]|\s*(\*|x|\\times|\u00D7)\s*10\^)([+\-]?[0-9]+|\{[+\-]?[0-9]+\}))?/);
      return e && e[0] ? { match_: e.splice(1), remainder: r.substr(e[0].length) } : null;
    }, "(-)(9)^(-9)": function(r) {
      var e = r.match(/^(\+\-|\+\/\-|\+|\-|\\pm\s?)?([0-9]+(?:[,.][0-9]+)?|[0-9]*(?:\.[0-9]+)?)\^([+\-]?[0-9]+|\{[+\-]?[0-9]+\})/);
      return e && e[0] ? { match_: e.splice(1), remainder: r.substr(e[0].length) } : null;
    }, "state of aggregation $": function(r) {
      var e = _.patterns.findObserveGroups(r, "", /^\([a-z]{1,3}(?=[\),])/, ")", "");
      if (e && e.remainder.match(/^($|[\s,;\)\]\}])/))
        return e;
      var t = r.match(/^(?:\((?:\\ca\s?)?\$[amothc]\$\))/);
      return t ? { match_: t[0], remainder: r.substr(t[0].length) } : null;
    }, "_{(state of aggregation)}$": /^_\{(\([a-z]{1,3}\))\}/, "{[(": /^(?:\\\{|\[|\()/, ")]}": /^(?:\)|\]|\\\})/, ", ": /^[,;]\s*/, ",": /^[,;]/, ".": /^[.]/, ". ": /^([.\u22C5\u00B7\u2022])\s*/, "...": /^\.\.\.(?=$|[^.])/, "* ": /^([*])\s*/, "^{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "^{", "", "", "}");
    }, "^($...$)": function(r) {
      return _.patterns.findObserveGroups(r, "^", "$", "$", "");
    }, "^a": /^\^([0-9]+|[^\\_])/, "^\\x{}{}": function(r) {
      return _.patterns.findObserveGroups(r, "^", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
    }, "^\\x{}": function(r) {
      return _.patterns.findObserveGroups(r, "^", /^\\[a-zA-Z]+\{/, "}", "");
    }, "^\\x": /^\^(\\[a-zA-Z]+)\s*/, "^(-1)": /^\^(-?\d+)/, "'": /^'/, "_{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "_{", "", "", "}");
    }, "_($...$)": function(r) {
      return _.patterns.findObserveGroups(r, "_", "$", "$", "");
    }, _9: /^_([+\-]?[0-9]+|[^\\])/, "_\\x{}{}": function(r) {
      return _.patterns.findObserveGroups(r, "_", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
    }, "_\\x{}": function(r) {
      return _.patterns.findObserveGroups(r, "_", /^\\[a-zA-Z]+\{/, "}", "");
    }, "_\\x": /^_(\\[a-zA-Z]+)\s*/, "^_": /^(?:\^(?=_)|\_(?=\^)|[\^_]$)/, "{}": /^\{\}/, "{...}": function(r) {
      return _.patterns.findObserveGroups(r, "", "{", "}", "");
    }, "{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "{", "", "", "}");
    }, "$...$": function(r) {
      return _.patterns.findObserveGroups(r, "", "$", "$", "");
    }, "${(...)}$": function(r) {
      return _.patterns.findObserveGroups(r, "${", "", "", "}$");
    }, "$(...)$": function(r) {
      return _.patterns.findObserveGroups(r, "$", "", "", "$");
    }, "=<>": /^[=<>]/, "#": /^[#\u2261]/, "+": /^\+/, "-$": /^-(?=[\s_},;\]/]|$|\([a-z]+\))/, "-9": /^-(?=[0-9])/, "- orbital overlap": /^-(?=(?:[spd]|sp)(?:$|[\s,;\)\]\}]))/, "-": /^-/, "pm-operator": /^(?:\\pm|\$\\pm\$|\+-|\+\/-)/, operator: /^(?:\+|(?:[\-=<>]|<<|>>|\\approx|\$\\approx\$)(?=\s|$|-?[0-9]))/, arrowUpDown: /^(?:v|\(v\)|\^|\(\^\))(?=$|[\s,;\)\]\}])/, "\\bond{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\bond{", "", "", "}");
    }, "->": /^(?:<->|<-->|->|<-|<=>>|<<=>|<=>|[\u2192\u27F6\u21CC])/, CMT: /^[CMT](?=\[)/, "[(...)]": function(r) {
      return _.patterns.findObserveGroups(r, "[", "", "", "]");
    }, "1st-level escape": /^(&|\\\\|\\hline)\s*/, "\\,": /^(?:\\[,\ ;:])/, "\\x{}{}": function(r) {
      return _.patterns.findObserveGroups(r, "", /^\\[a-zA-Z]+\{/, "}", "", "", "{", "}", "", true);
    }, "\\x{}": function(r) {
      return _.patterns.findObserveGroups(r, "", /^\\[a-zA-Z]+\{/, "}", "");
    }, "\\ca": /^\\ca(?:\s+|(?![a-zA-Z]))/, "\\x": /^(?:\\[a-zA-Z]+\s*|\\[_&{}%])/, orbital: /^(?:[0-9]{1,2}[spdfgh]|[0-9]{0,2}sp)(?=$|[^a-zA-Z])/, others: /^[\/~|]/, "\\frac{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\frac{", "", "", "}", "{", "", "", "}");
    }, "\\overset{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\overset{", "", "", "}", "{", "", "", "}");
    }, "\\underset{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\underset{", "", "", "}", "{", "", "", "}");
    }, "\\underbrace{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\underbrace{", "", "", "}_", "{", "", "", "}");
    }, "\\color{(...)}0": function(r) {
      return _.patterns.findObserveGroups(r, "\\color{", "", "", "}");
    }, "\\color{(...)}{(...)}1": function(r) {
      return _.patterns.findObserveGroups(r, "\\color{", "", "", "}", "{", "", "", "}");
    }, "\\color(...){(...)}2": function(r) {
      return _.patterns.findObserveGroups(r, "\\color", "\\", "", /^(?=\{)/, "{", "", "", "}");
    }, "\\ce{(...)}": function(r) {
      return _.patterns.findObserveGroups(r, "\\ce{", "", "", "}");
    }, oxidation$: /^(?:[+-][IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/, "d-oxidation$": /^(?:[+-]?\s?[IVX]+|\\pm\s*0|\$\\pm\$\s*0)$/, "roman numeral": /^[IVX]+/, "1/2$": /^[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+(?:\$[a-z]\$|[a-z])?$/, amount: function(r) {
      var e;
      if (e = r.match(/^(?:(?:(?:\([+\-]?[0-9]+\/[0-9]+\)|[+\-]?(?:[0-9]+|\$[a-z]\$|[a-z])\/[0-9]+|[+\-]?[0-9]+[.,][0-9]+|[+\-]?\.[0-9]+|[+\-]?[0-9]+)(?:[a-z](?=\s*[A-Z]))?)|[+\-]?[a-z](?=\s*[A-Z])|\+(?!\s))/), e)
        return { match_: e[0], remainder: r.substr(e[0].length) };
      var t = _.patterns.findObserveGroups(r, "", "$", "$", "");
      return t && (e = t.match_.match(/^\$(?:\(?[+\-]?(?:[0-9]*[a-z]?[+\-])?[0-9]*[a-z](?:[+\-][0-9]*[a-z]?)?\)?|\+|-)\$$/), e) ? { match_: e[0], remainder: r.substr(e[0].length) } : null;
    }, amount2: function(r) {
      return this.amount(r);
    }, "(KV letters),": /^(?:[A-Z][a-z]{0,2}|i)(?=,)/, formula$: function(r) {
      if (r.match(/^\([a-z]+\)$/))
        return null;
      var e = r.match(/^(?:[a-z]|(?:[0-9\ \+\-\,\.\(\)]+[a-z])+[0-9\ \+\-\,\.\(\)]*|(?:[a-z][0-9\ \+\-\,\.\(\)]+)+[a-z]?)$/);
      return e ? { match_: e[0], remainder: r.substr(e[0].length) } : null;
    }, uprightEntities: /^(?:pH|pOH|pC|pK|iPr|iBu)(?=$|[^a-zA-Z])/, "/": /^\s*(\/)\s*/, "//": /^\s*(\/\/)\s*/, "*": /^\s*[*.]\s*/ }, findObserveGroups: function(r, e, t, i, o, a, n, s, l, c) {
      var u = function(k, S) {
        if (typeof S == "string")
          return k.indexOf(S) !== 0 ? null : S;
        var T = k.match(S);
        return T ? T[0] : null;
      }, d = function(k, S, T) {
        for (var C = 0; S < k.length; ) {
          var K = k.charAt(S), M = u(k.substr(S), T);
          if (M !== null && C === 0)
            return { endMatchBegin: S, endMatchEnd: S + M.length };
          if (K === "{")
            C++;
          else if (K === "}") {
            if (C === 0)
              throw ["ExtraCloseMissingOpen", "Extra close brace or missing open brace"];
            C--;
          }
          S++;
        }
        return null;
      }, m = u(r, e);
      if (m === null || (r = r.substr(m.length), m = u(r, t), m === null))
        return null;
      var h = d(r, m.length, i || o);
      if (h === null)
        return null;
      var f = r.substring(0, i ? h.endMatchEnd : h.endMatchBegin);
      if (a || n) {
        var y = this.findObserveGroups(r.substr(h.endMatchEnd), a, n, s, l);
        if (y === null)
          return null;
        var w = [f, y.match_];
        return { match_: c ? w.join("") : w, remainder: y.remainder };
      } else
        return { match_: f, remainder: r.substr(h.endMatchEnd) };
    }, match_: function(r, e) {
      var t = _.patterns.patterns[r];
      if (t === void 0)
        throw ["MhchemBugP", "mhchem bug P. Please report. (" + r + ")"];
      if (typeof t == "function")
        return _.patterns.patterns[r](e);
      var i = e.match(t);
      if (i) {
        var o;
        return i[2] ? o = [i[1], i[2]] : i[1] ? o = i[1] : o = i[0], { match_: o, remainder: e.substr(i[0].length) };
      }
      return null;
    } }, actions: { "a=": function(r, e) {
      r.a = (r.a || "") + e;
    }, "b=": function(r, e) {
      r.b = (r.b || "") + e;
    }, "p=": function(r, e) {
      r.p = (r.p || "") + e;
    }, "o=": function(r, e) {
      r.o = (r.o || "") + e;
    }, "q=": function(r, e) {
      r.q = (r.q || "") + e;
    }, "d=": function(r, e) {
      r.d = (r.d || "") + e;
    }, "rm=": function(r, e) {
      r.rm = (r.rm || "") + e;
    }, "text=": function(r, e) {
      r.text_ = (r.text_ || "") + e;
    }, insert: function(r, e, t) {
      return { type_: t };
    }, "insert+p1": function(r, e, t) {
      return { type_: t, p1: e };
    }, "insert+p1+p2": function(r, e, t) {
      return { type_: t, p1: e[0], p2: e[1] };
    }, copy: function(r, e) {
      return e;
    }, rm: function(r, e) {
      return { type_: "rm", p1: e || "" };
    }, text: function(r, e) {
      return _.go(e, "text");
    }, "{text}": function(r, e) {
      var t = ["{"];
      return _.concatArray(t, _.go(e, "text")), t.push("}"), t;
    }, "tex-math": function(r, e) {
      return _.go(e, "tex-math");
    }, "tex-math tight": function(r, e) {
      return _.go(e, "tex-math tight");
    }, bond: function(r, e, t) {
      return { type_: "bond", kind_: t || e };
    }, "color0-output": function(r, e) {
      return { type_: "color0", color: e[0] };
    }, ce: function(r, e) {
      return _.go(e);
    }, "1/2": function(r, e) {
      var t = [];
      e.match(/^[+\-]/) && (t.push(e.substr(0, 1)), e = e.substr(1));
      var i = e.match(/^([0-9]+|\$[a-z]\$|[a-z])\/([0-9]+)(\$[a-z]\$|[a-z])?$/);
      return i[1] = i[1].replace(/\$/g, ""), t.push({ type_: "frac", p1: i[1], p2: i[2] }), i[3] && (i[3] = i[3].replace(/\$/g, ""), t.push({ type_: "tex-math", p1: i[3] })), t;
    }, "9,9": function(r, e) {
      return _.go(e, "9,9");
    } }, createTransitions: function(r) {
      var e, t, i, o, a = {};
      for (e in r)
        for (t in r[e])
          for (i = t.split("|"), r[e][t].stateArray = i, o = 0; o < i.length; o++)
            a[i[o]] = [];
      for (e in r)
        for (t in r[e])
          for (i = r[e][t].stateArray || [], o = 0; o < i.length; o++) {
            var n = r[e][t];
            if (n.action_) {
              n.action_ = [].concat(n.action_);
              for (var s = 0; s < n.action_.length; s++)
                typeof n.action_[s] == "string" && (n.action_[s] = { type_: n.action_[s] });
            } else
              n.action_ = [];
            for (var l = e.split("|"), c = 0; c < l.length; c++)
              if (i[o] === "*")
                for (var u in a)
                  a[u].push({ pattern: l[c], task: n });
              else
                a[i[o]].push({ pattern: l[c], task: n });
          }
      return a;
    }, stateMachines: {} };
    _.stateMachines = { ce: { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, else: { "0|1|2": { action_: "beginsWithBond=false", revisit: true, toContinue: true } }, oxidation$: { 0: { action_: "oxidation-output" } }, CMT: { r: { action_: "rdt=", nextState: "rt" }, rd: { action_: "rqt=", nextState: "rdt" } }, arrowUpDown: { "0|1|2|as": { action_: ["sb=false", "output", "operator"], nextState: "1" } }, uprightEntities: { "0|1|2": { action_: ["o=", "output"], nextState: "1" } }, orbital: { "0|1|2|3": { action_: "o=", nextState: "o" } }, "->": { "0|1|2|3": { action_: "r=", nextState: "r" }, "a|as": { action_: ["output", "r="], nextState: "r" }, "*": { action_: ["output", "r="], nextState: "r" } }, "+": { o: { action_: "d= kv", nextState: "d" }, "d|D": { action_: "d=", nextState: "d" }, q: { action_: "d=", nextState: "qd" }, "qd|qD": { action_: "d=", nextState: "qd" }, dq: { action_: ["output", "d="], nextState: "d" }, 3: { action_: ["sb=false", "output", "operator"], nextState: "0" } }, amount: { "0|2": { action_: "a=", nextState: "a" } }, "pm-operator": { "0|1|2|a|as": { action_: ["sb=false", "output", { type_: "operator", option: "\\pm" }], nextState: "0" } }, operator: { "0|1|2|a|as": { action_: ["sb=false", "output", "operator"], nextState: "0" } }, "-$": { "o|q": { action_: ["charge or bond", "output"], nextState: "qd" }, d: { action_: "d=", nextState: "d" }, D: { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" }, q: { action_: "d=", nextState: "qd" }, qd: { action_: "d=", nextState: "qd" }, "qD|dq": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" } }, "-9": { "3|o": { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "3" } }, "- orbital overlap": { o: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" }, d: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" } }, "-": { "0|1|2": { action_: [{ type_: "output", option: 1 }, "beginsWithBond=true", { type_: "bond", option: "-" }], nextState: "3" }, 3: { action_: { type_: "bond", option: "-" } }, a: { action_: ["output", { type_: "insert", option: "hyphen" }], nextState: "2" }, as: { action_: [{ type_: "output", option: 2 }, { type_: "bond", option: "-" }], nextState: "3" }, b: { action_: "b=" }, o: { action_: { type_: "- after o/d", option: false }, nextState: "2" }, q: { action_: { type_: "- after o/d", option: false }, nextState: "2" }, "d|qd|dq": { action_: { type_: "- after o/d", option: true }, nextState: "2" }, "D|qD|p": { action_: ["output", { type_: "bond", option: "-" }], nextState: "3" } }, amount2: { "1|3": { action_: "a=", nextState: "a" } }, letters: { "0|1|2|3|a|as|b|p|bp|o": { action_: "o=", nextState: "o" }, "q|dq": { action_: ["output", "o="], nextState: "o" }, "d|D|qd|qD": { action_: "o after d", nextState: "o" } }, digits: { o: { action_: "q=", nextState: "q" }, "d|D": { action_: "q=", nextState: "dq" }, q: { action_: ["output", "o="], nextState: "o" }, a: { action_: "o=", nextState: "o" } }, "space A": { "b|p|bp": {} }, space: { a: { nextState: "as" }, 0: { action_: "sb=false" }, "1|2": { action_: "sb=true" }, "r|rt|rd|rdt|rdq": { action_: "output", nextState: "0" }, "*": { action_: ["output", "sb=true"], nextState: "1" } }, "1st-level escape": { "1|2": { action_: ["output", { type_: "insert+p1", option: "1st-level escape" }] }, "*": { action_: ["output", { type_: "insert+p1", option: "1st-level escape" }], nextState: "0" } }, "[(...)]": { "r|rt": { action_: "rd=", nextState: "rd" }, "rd|rdt": { action_: "rq=", nextState: "rdq" } }, "...": { "o|d|D|dq|qd|qD": { action_: ["output", { type_: "bond", option: "..." }], nextState: "3" }, "*": { action_: [{ type_: "output", option: 1 }, { type_: "insert", option: "ellipsis" }], nextState: "1" } }, ". |* ": { "*": { action_: ["output", { type_: "insert", option: "addition compound" }], nextState: "1" } }, "state of aggregation $": { "*": { action_: ["output", "state of aggregation"], nextState: "1" } }, "{[(": { "a|as|o": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" }, "0|1|2|3": { action_: ["o=", "output", "parenthesisLevel++"], nextState: "2" }, "*": { action_: ["output", "o=", "output", "parenthesisLevel++"], nextState: "2" } }, ")]}": { "0|1|2|3|b|p|bp|o": { action_: ["o=", "parenthesisLevel--"], nextState: "o" }, "a|as|d|D|q|qd|qD|dq": { action_: ["output", "o=", "parenthesisLevel--"], nextState: "o" } }, ", ": { "*": { action_: ["output", "comma"], nextState: "0" } }, "^_": { "*": {} }, "^{(...)}|^($...$)": { "0|1|2|as": { action_: "b=", nextState: "b" }, p: { action_: "b=", nextState: "bp" }, "3|o": { action_: "d= kv", nextState: "D" }, q: { action_: "d=", nextState: "qD" }, "d|D|qd|qD|dq": { action_: ["output", "d="], nextState: "D" } }, "^a|^\\x{}{}|^\\x{}|^\\x|'": { "0|1|2|as": { action_: "b=", nextState: "b" }, p: { action_: "b=", nextState: "bp" }, "3|o": { action_: "d= kv", nextState: "d" }, q: { action_: "d=", nextState: "qd" }, "d|qd|D|qD": { action_: "d=" }, dq: { action_: ["output", "d="], nextState: "d" } }, "_{(state of aggregation)}$": { "d|D|q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" } }, "_{(...)}|_($...$)|_9|_\\x{}{}|_\\x{}|_\\x": { "0|1|2|as": { action_: "p=", nextState: "p" }, b: { action_: "p=", nextState: "bp" }, "3|o": { action_: "q=", nextState: "q" }, "d|D": { action_: "q=", nextState: "dq" }, "q|qd|qD|dq": { action_: ["output", "q="], nextState: "q" } }, "=<>": { "0|1|2|3|a|as|o|q|d|D|qd|qD|dq": { action_: [{ type_: "output", option: 2 }, "bond"], nextState: "3" } }, "#": { "0|1|2|3|a|as|o": { action_: [{ type_: "output", option: 2 }, { type_: "bond", option: "#" }], nextState: "3" } }, "{}": { "*": { action_: { type_: "output", option: 1 }, nextState: "1" } }, "{...}": { "0|1|2|3|a|as|b|p|bp": { action_: "o=", nextState: "o" }, "o|d|D|q|qd|qD|dq": { action_: ["output", "o="], nextState: "o" } }, "$...$": { a: { action_: "a=" }, "0|1|2|3|as|b|p|bp|o": { action_: "o=", nextState: "o" }, "as|o": { action_: "o=" }, "q|d|D|qd|qD|dq": { action_: ["output", "o="], nextState: "o" } }, "\\bond{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "bond"], nextState: "3" } }, "\\frac{(...)}": { "*": { action_: [{ type_: "output", option: 1 }, "frac-output"], nextState: "3" } }, "\\overset{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "overset-output"], nextState: "3" } }, "\\underset{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "underset-output"], nextState: "3" } }, "\\underbrace{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "underbrace-output"], nextState: "3" } }, "\\color{(...)}{(...)}1|\\color(...){(...)}2": { "*": { action_: [{ type_: "output", option: 2 }, "color-output"], nextState: "3" } }, "\\color{(...)}0": { "*": { action_: [{ type_: "output", option: 2 }, "color0-output"] } }, "\\ce{(...)}": { "*": { action_: [{ type_: "output", option: 2 }, "ce"], nextState: "3" } }, "\\,": { "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "1" } }, "\\x{}{}|\\x{}|\\x": { "0|1|2|3|a|as|b|p|bp|o|c0": { action_: ["o=", "output"], nextState: "3" }, "*": { action_: ["output", "o=", "output"], nextState: "3" } }, others: { "*": { action_: [{ type_: "output", option: 1 }, "copy"], nextState: "3" } }, else2: { a: { action_: "a to o", nextState: "o", revisit: true }, as: { action_: ["output", "sb=true"], nextState: "1", revisit: true }, "r|rt|rd|rdt|rdq": { action_: ["output"], nextState: "0", revisit: true }, "*": { action_: ["output", "copy"], nextState: "3" } } }), actions: { "o after d": function(r, e) {
      var t;
      if ((r.d || "").match(/^[0-9]+$/)) {
        var i = r.d;
        r.d = void 0, t = this.output(r), r.b = i;
      } else
        t = this.output(r);
      return _.actions["o="](r, e), t;
    }, "d= kv": function(r, e) {
      r.d = e, r.dType = "kv";
    }, "charge or bond": function(r, e) {
      if (r.beginsWithBond) {
        var t = [];
        return _.concatArray(t, this.output(r)), _.concatArray(t, _.actions.bond(r, e, "-")), t;
      } else
        r.d = e;
    }, "- after o/d": function(r, e, t) {
      var i = _.patterns.match_("orbital", r.o || ""), o = _.patterns.match_("one lowercase greek letter $", r.o || ""), a = _.patterns.match_("one lowercase latin letter $", r.o || ""), n = _.patterns.match_("$one lowercase latin letter$ $", r.o || ""), s = e === "-" && (i && i.remainder === "" || o || a || n);
      s && !r.a && !r.b && !r.p && !r.d && !r.q && !i && a && (r.o = "$" + r.o + "$");
      var l = [];
      return s ? (_.concatArray(l, this.output(r)), l.push({ type_: "hyphen" })) : (i = _.patterns.match_("digits", r.d || ""), t && i && i.remainder === "" ? (_.concatArray(l, _.actions["d="](r, e)), _.concatArray(l, this.output(r))) : (_.concatArray(l, this.output(r)), _.concatArray(l, _.actions.bond(r, e, "-")))), l;
    }, "a to o": function(r) {
      r.o = r.a, r.a = void 0;
    }, "sb=true": function(r) {
      r.sb = true;
    }, "sb=false": function(r) {
      r.sb = false;
    }, "beginsWithBond=true": function(r) {
      r.beginsWithBond = true;
    }, "beginsWithBond=false": function(r) {
      r.beginsWithBond = false;
    }, "parenthesisLevel++": function(r) {
      r.parenthesisLevel++;
    }, "parenthesisLevel--": function(r) {
      r.parenthesisLevel--;
    }, "state of aggregation": function(r, e) {
      return { type_: "state of aggregation", p1: _.go(e, "o") };
    }, comma: function(r, e) {
      var t = e.replace(/\s*$/, ""), i = t !== e;
      return i && r.parenthesisLevel === 0 ? { type_: "comma enumeration L", p1: t } : { type_: "comma enumeration M", p1: t };
    }, output: function(r, e, t) {
      var i;
      if (!r.r)
        i = [], !r.a && !r.b && !r.p && !r.o && !r.q && !r.d && !t || (r.sb && i.push({ type_: "entitySkip" }), !r.o && !r.q && !r.d && !r.b && !r.p && t !== 2 ? (r.o = r.a, r.a = void 0) : !r.o && !r.q && !r.d && (r.b || r.p) ? (r.o = r.a, r.d = r.b, r.q = r.p, r.a = r.b = r.p = void 0) : r.o && r.dType === "kv" && _.patterns.match_("d-oxidation$", r.d || "") ? r.dType = "oxidation" : r.o && r.dType === "kv" && !r.q && (r.dType = void 0), i.push({ type_: "chemfive", a: _.go(r.a, "a"), b: _.go(r.b, "bd"), p: _.go(r.p, "pq"), o: _.go(r.o, "o"), q: _.go(r.q, "pq"), d: _.go(r.d, r.dType === "oxidation" ? "oxidation" : "bd"), dType: r.dType }));
      else {
        var o;
        r.rdt === "M" ? o = _.go(r.rd, "tex-math") : r.rdt === "T" ? o = [{ type_: "text", p1: r.rd || "" }] : o = _.go(r.rd);
        var a;
        r.rqt === "M" ? a = _.go(r.rq, "tex-math") : r.rqt === "T" ? a = [{ type_: "text", p1: r.rq || "" }] : a = _.go(r.rq), i = { type_: "arrow", r: r.r, rd: o, rq: a };
      }
      for (var n in r)
        n !== "parenthesisLevel" && n !== "beginsWithBond" && delete r[n];
      return i;
    }, "oxidation-output": function(r, e) {
      var t = ["{"];
      return _.concatArray(t, _.go(e, "oxidation")), t.push("}"), t;
    }, "frac-output": function(r, e) {
      return { type_: "frac-ce", p1: _.go(e[0]), p2: _.go(e[1]) };
    }, "overset-output": function(r, e) {
      return { type_: "overset", p1: _.go(e[0]), p2: _.go(e[1]) };
    }, "underset-output": function(r, e) {
      return { type_: "underset", p1: _.go(e[0]), p2: _.go(e[1]) };
    }, "underbrace-output": function(r, e) {
      return { type_: "underbrace", p1: _.go(e[0]), p2: _.go(e[1]) };
    }, "color-output": function(r, e) {
      return { type_: "color", color1: e[0], color2: _.go(e[1]) };
    }, "r=": function(r, e) {
      r.r = e;
    }, "rdt=": function(r, e) {
      r.rdt = e;
    }, "rd=": function(r, e) {
      r.rd = e;
    }, "rqt=": function(r, e) {
      r.rqt = e;
    }, "rq=": function(r, e) {
      r.rq = e;
    }, operator: function(r, e, t) {
      return { type_: "operator", kind_: t || e };
    } } }, a: { transitions: _.createTransitions({ empty: { "*": {} }, "1/2$": { 0: { action_: "1/2" } }, else: { 0: { nextState: "1", revisit: true } }, "$(...)$": { "*": { action_: "tex-math tight", nextState: "1" } }, ",": { "*": { action_: { type_: "insert", option: "commaDecimal" } } }, else2: { "*": { action_: "copy" } } }), actions: {} }, o: { transitions: _.createTransitions({ empty: { "*": {} }, "1/2$": { 0: { action_: "1/2" } }, else: { 0: { nextState: "1", revisit: true } }, letters: { "*": { action_: "rm" } }, "\\ca": { "*": { action_: { type_: "insert", option: "circa" } } }, "\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } }, "${(...)}$|$(...)$": { "*": { action_: "tex-math" } }, "{(...)}": { "*": { action_: "{text}" } }, else2: { "*": { action_: "copy" } } }), actions: {} }, text: { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, "{...}": { "*": { action_: "text=" } }, "${(...)}$|$(...)$": { "*": { action_: "tex-math" } }, "\\greek": { "*": { action_: ["output", "rm"] } }, "\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: ["output", "copy"] } }, else: { "*": { action_: "text=" } } }), actions: { output: function(r) {
      if (r.text_) {
        var e = { type_: "text", p1: r.text_ };
        for (var t in r)
          delete r[t];
        return e;
      }
    } } }, pq: { transitions: _.createTransitions({ empty: { "*": {} }, "state of aggregation $": { "*": { action_: "state of aggregation" } }, i$: { 0: { nextState: "!f", revisit: true } }, "(KV letters),": { 0: { action_: "rm", nextState: "0" } }, formula$: { 0: { nextState: "f", revisit: true } }, "1/2$": { 0: { action_: "1/2" } }, else: { 0: { nextState: "!f", revisit: true } }, "${(...)}$|$(...)$": { "*": { action_: "tex-math" } }, "{(...)}": { "*": { action_: "text" } }, "a-z": { f: { action_: "tex-math" } }, letters: { "*": { action_: "rm" } }, "-9.,9": { "*": { action_: "9,9" } }, ",": { "*": { action_: { type_: "insert+p1", option: "comma enumeration S" } } }, "\\color{(...)}{(...)}1|\\color(...){(...)}2": { "*": { action_: "color-output" } }, "\\color{(...)}0": { "*": { action_: "color0-output" } }, "\\ce{(...)}": { "*": { action_: "ce" } }, "\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } }, else2: { "*": { action_: "copy" } } }), actions: { "state of aggregation": function(r, e) {
      return { type_: "state of aggregation subscript", p1: _.go(e, "o") };
    }, "color-output": function(r, e) {
      return { type_: "color", color1: e[0], color2: _.go(e[1], "pq") };
    } } }, bd: { transitions: _.createTransitions({ empty: { "*": {} }, x$: { 0: { nextState: "!f", revisit: true } }, formula$: { 0: { nextState: "f", revisit: true } }, else: { 0: { nextState: "!f", revisit: true } }, "-9.,9 no missing 0": { "*": { action_: "9,9" } }, ".": { "*": { action_: { type_: "insert", option: "electron dot" } } }, "a-z": { f: { action_: "tex-math" } }, x: { "*": { action_: { type_: "insert", option: "KV x" } } }, letters: { "*": { action_: "rm" } }, "'": { "*": { action_: { type_: "insert", option: "prime" } } }, "${(...)}$|$(...)$": { "*": { action_: "tex-math" } }, "{(...)}": { "*": { action_: "text" } }, "\\color{(...)}{(...)}1|\\color(...){(...)}2": { "*": { action_: "color-output" } }, "\\color{(...)}0": { "*": { action_: "color0-output" } }, "\\ce{(...)}": { "*": { action_: "ce" } }, "\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "copy" } }, else2: { "*": { action_: "copy" } } }), actions: { "color-output": function(r, e) {
      return { type_: "color", color1: e[0], color2: _.go(e[1], "bd") };
    } } }, oxidation: { transitions: _.createTransitions({ empty: { "*": {} }, "roman numeral": { "*": { action_: "roman-numeral" } }, "${(...)}$|$(...)$": { "*": { action_: "tex-math" } }, else: { "*": { action_: "copy" } } }), actions: { "roman-numeral": function(r, e) {
      return { type_: "roman numeral", p1: e || "" };
    } } }, "tex-math": { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, "\\ce{(...)}": { "*": { action_: ["output", "ce"] } }, "{...}|\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "o=" } }, else: { "*": { action_: "o=" } } }), actions: { output: function(r) {
      if (r.o) {
        var e = { type_: "tex-math", p1: r.o };
        for (var t in r)
          delete r[t];
        return e;
      }
    } } }, "tex-math tight": { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, "\\ce{(...)}": { "*": { action_: ["output", "ce"] } }, "{...}|\\,|\\x{}{}|\\x{}|\\x": { "*": { action_: "o=" } }, "-|+": { "*": { action_: "tight operator" } }, else: { "*": { action_: "o=" } } }), actions: { "tight operator": function(r, e) {
      r.o = (r.o || "") + "{" + e + "}";
    }, output: function(r) {
      if (r.o) {
        var e = { type_: "tex-math", p1: r.o };
        for (var t in r)
          delete r[t];
        return e;
      }
    } } }, "9,9": { transitions: _.createTransitions({ empty: { "*": {} }, ",": { "*": { action_: "comma" } }, else: { "*": { action_: "copy" } } }), actions: { comma: function() {
      return { type_: "commaDecimal" };
    } } }, pu: { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, space$: { "*": { action_: ["output", "space"] } }, "{[(|)]}": { "0|a": { action_: "copy" } }, "(-)(9)^(-9)": { 0: { action_: "number^", nextState: "a" } }, "(-)(9.,9)(e)(99)": { 0: { action_: "enumber", nextState: "a" } }, space: { "0|a": {} }, "pm-operator": { "0|a": { action_: { type_: "operator", option: "\\pm" }, nextState: "0" } }, operator: { "0|a": { action_: "copy", nextState: "0" } }, "//": { d: { action_: "o=", nextState: "/" } }, "/": { d: { action_: "o=", nextState: "/" } }, "{...}|else": { "0|d": { action_: "d=", nextState: "d" }, a: { action_: ["space", "d="], nextState: "d" }, "/|q": { action_: "q=", nextState: "q" } } }), actions: { enumber: function(r, e) {
      var t = [];
      return e[0] === "+-" || e[0] === "+/-" ? t.push("\\pm ") : e[0] && t.push(e[0]), e[1] && (_.concatArray(t, _.go(e[1], "pu-9,9")), e[2] && (e[2].match(/[,.]/) ? _.concatArray(t, _.go(e[2], "pu-9,9")) : t.push(e[2])), e[3] = e[4] || e[3], e[3] && (e[3] = e[3].trim(), e[3] === "e" || e[3].substr(0, 1) === "*" ? t.push({ type_: "cdot" }) : t.push({ type_: "times" }))), e[3] && t.push("10^{" + e[5] + "}"), t;
    }, "number^": function(r, e) {
      var t = [];
      return e[0] === "+-" || e[0] === "+/-" ? t.push("\\pm ") : e[0] && t.push(e[0]), _.concatArray(t, _.go(e[1], "pu-9,9")), t.push("^{" + e[2] + "}"), t;
    }, operator: function(r, e, t) {
      return { type_: "operator", kind_: t || e };
    }, space: function() {
      return { type_: "pu-space-1" };
    }, output: function(r) {
      var e, t = _.patterns.match_("{(...)}", r.d || "");
      t && t.remainder === "" && (r.d = t.match_);
      var i = _.patterns.match_("{(...)}", r.q || "");
      if (i && i.remainder === "" && (r.q = i.match_), r.d && (r.d = r.d.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), r.d = r.d.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F")), r.q) {
        r.q = r.q.replace(/\u00B0C|\^oC|\^{o}C/g, "{}^{\\circ}C"), r.q = r.q.replace(/\u00B0F|\^oF|\^{o}F/g, "{}^{\\circ}F");
        var o = { d: _.go(r.d, "pu"), q: _.go(r.q, "pu") };
        r.o === "//" ? e = { type_: "pu-frac", p1: o.d, p2: o.q } : (e = o.d, o.d.length > 1 || o.q.length > 1 ? e.push({ type_: " / " }) : e.push({ type_: "/" }), _.concatArray(e, o.q));
      } else
        e = _.go(r.d, "pu-2");
      for (var a in r)
        delete r[a];
      return e;
    } } }, "pu-2": { transitions: _.createTransitions({ empty: { "*": { action_: "output" } }, "*": { "*": { action_: ["output", "cdot"], nextState: "0" } }, "\\x": { "*": { action_: "rm=" } }, space: { "*": { action_: ["output", "space"], nextState: "0" } }, "^{(...)}|^(-1)": { 1: { action_: "^(-1)" } }, "-9.,9": { 0: { action_: "rm=", nextState: "0" }, 1: { action_: "^(-1)", nextState: "0" } }, "{...}|else": { "*": { action_: "rm=", nextState: "1" } } }), actions: { cdot: function() {
      return { type_: "tight cdot" };
    }, "^(-1)": function(r, e) {
      r.rm += "^{" + e + "}";
    }, space: function() {
      return { type_: "pu-space-2" };
    }, output: function(r) {
      var e = [];
      if (r.rm) {
        var t = _.patterns.match_("{(...)}", r.rm || "");
        t && t.remainder === "" ? e = _.go(t.match_, "pu") : e = { type_: "rm", p1: r.rm };
      }
      for (var i in r)
        delete r[i];
      return e;
    } } }, "pu-9,9": { transitions: _.createTransitions({ empty: { 0: { action_: "output-0" }, o: { action_: "output-o" } }, ",": { 0: { action_: ["output-0", "comma"], nextState: "o" } }, ".": { 0: { action_: ["output-0", "copy"], nextState: "o" } }, else: { "*": { action_: "text=" } } }), actions: { comma: function() {
      return { type_: "commaDecimal" };
    }, "output-0": function(r) {
      var e = [];
      if (r.text_ = r.text_ || "", r.text_.length > 4) {
        var t = r.text_.length % 3;
        t === 0 && (t = 3);
        for (var i = r.text_.length - 3; i > 0; i -= 3)
          e.push(r.text_.substr(i, 3)), e.push({ type_: "1000 separator" });
        e.push(r.text_.substr(0, t)), e.reverse();
      } else
        e.push(r.text_);
      for (var o in r)
        delete r[o];
      return e;
    }, "output-o": function(r) {
      var e = [];
      if (r.text_ = r.text_ || "", r.text_.length > 4) {
        for (var t = r.text_.length - 3, i = 0; i < t; i += 3)
          e.push(r.text_.substr(i, 3)), e.push({ type_: "1000 separator" });
        e.push(r.text_.substr(i));
      } else
        e.push(r.text_);
      for (var o in r)
        delete r[o];
      return e;
    } } } };
    var ne = { go: function(r, e) {
      if (!r)
        return "";
      for (var t = "", i = false, o = 0; o < r.length; o++) {
        var a = r[o];
        typeof a == "string" ? t += a : (t += ne._go2(a), a.type_ === "1st-level escape" && (i = true));
      }
      return !e && !i && t && (t = "{" + t + "}"), t;
    }, _goInner: function(r) {
      return r && ne.go(r, true);
    }, _go2: function(r) {
      var e;
      switch (r.type_) {
        case "chemfive":
          e = "";
          var t = { a: ne._goInner(r.a), b: ne._goInner(r.b), p: ne._goInner(r.p), o: ne._goInner(r.o), q: ne._goInner(r.q), d: ne._goInner(r.d) };
          t.a && (t.a.match(/^[+\-]/) && (t.a = "{" + t.a + "}"), e += t.a + "\\,"), (t.b || t.p) && (e += "{\\vphantom{X}}", e += "^{\\hphantom{" + (t.b || "") + "}}_{\\hphantom{" + (t.p || "") + "}}", e += "{\\vphantom{X}}", e += "^{\\smash[t]{\\vphantom{2}}\\mathllap{" + (t.b || "") + "}}", e += "_{\\vphantom{2}\\mathllap{\\smash[t]{" + (t.p || "") + "}}}"), t.o && (t.o.match(/^[+\-]/) && (t.o = "{" + t.o + "}"), e += t.o), r.dType === "kv" ? ((t.d || t.q) && (e += "{\\vphantom{X}}"), t.d && (e += "^{" + t.d + "}"), t.q && (e += "_{\\smash[t]{" + t.q + "}}")) : r.dType === "oxidation" ? (t.d && (e += "{\\vphantom{X}}", e += "^{" + t.d + "}"), t.q && (e += "{\\vphantom{X}}", e += "_{\\smash[t]{" + t.q + "}}")) : (t.q && (e += "{\\vphantom{X}}", e += "_{\\smash[t]{" + t.q + "}}"), t.d && (e += "{\\vphantom{X}}", e += "^{" + t.d + "}"));
          break;
        case "rm":
          e = "\\mathrm{" + r.p1 + "}";
          break;
        case "text":
          r.p1.match(/[\^_]/) ? (r.p1 = r.p1.replace(" ", "~").replace("-", "\\text{-}"), e = "\\mathrm{" + r.p1 + "}") : e = "\\text{" + r.p1 + "}";
          break;
        case "roman numeral":
          e = "\\mathrm{" + r.p1 + "}";
          break;
        case "state of aggregation":
          e = "\\mskip2mu " + ne._goInner(r.p1);
          break;
        case "state of aggregation subscript":
          e = "\\mskip1mu " + ne._goInner(r.p1);
          break;
        case "bond":
          if (e = ne._getBond(r.kind_), !e)
            throw ["MhchemErrorBond", "mhchem Error. Unknown bond type (" + r.kind_ + ")"];
          break;
        case "frac":
          var i = "\\frac{" + r.p1 + "}{" + r.p2 + "}";
          e = "\\mathchoice{\\textstyle" + i + "}{" + i + "}{" + i + "}{" + i + "}";
          break;
        case "pu-frac":
          var o = "\\frac{" + ne._goInner(r.p1) + "}{" + ne._goInner(r.p2) + "}";
          e = "\\mathchoice{\\textstyle" + o + "}{" + o + "}{" + o + "}{" + o + "}";
          break;
        case "tex-math":
          e = r.p1 + " ";
          break;
        case "frac-ce":
          e = "\\frac{" + ne._goInner(r.p1) + "}{" + ne._goInner(r.p2) + "}";
          break;
        case "overset":
          e = "\\overset{" + ne._goInner(r.p1) + "}{" + ne._goInner(r.p2) + "}";
          break;
        case "underset":
          e = "\\underset{" + ne._goInner(r.p1) + "}{" + ne._goInner(r.p2) + "}";
          break;
        case "underbrace":
          e = "\\underbrace{" + ne._goInner(r.p1) + "}_{" + ne._goInner(r.p2) + "}";
          break;
        case "color":
          e = "{\\color{" + r.color1 + "}{" + ne._goInner(r.color2) + "}}";
          break;
        case "color0":
          e = "\\color{" + r.color + "}";
          break;
        case "arrow":
          var a = { rd: ne._goInner(r.rd), rq: ne._goInner(r.rq) }, n = "\\x" + ne._getArrow(r.r);
          a.rq && (n += "[{" + a.rq + "}]"), a.rd ? n += "{" + a.rd + "}" : n += "{}", e = n;
          break;
        case "operator":
          e = ne._getOperator(r.kind_);
          break;
        case "1st-level escape":
          e = r.p1 + " ";
          break;
        case "space":
          e = " ";
          break;
        case "entitySkip":
          e = "~";
          break;
        case "pu-space-1":
          e = "~";
          break;
        case "pu-space-2":
          e = "\\mkern3mu ";
          break;
        case "1000 separator":
          e = "\\mkern2mu ";
          break;
        case "commaDecimal":
          e = "{,}";
          break;
        case "comma enumeration L":
          e = "{" + r.p1 + "}\\mkern6mu ";
          break;
        case "comma enumeration M":
          e = "{" + r.p1 + "}\\mkern3mu ";
          break;
        case "comma enumeration S":
          e = "{" + r.p1 + "}\\mkern1mu ";
          break;
        case "hyphen":
          e = "\\text{-}";
          break;
        case "addition compound":
          e = "\\,{\\cdot}\\,";
          break;
        case "electron dot":
          e = "\\mkern1mu \\bullet\\mkern1mu ";
          break;
        case "KV x":
          e = "{\\times}";
          break;
        case "prime":
          e = "\\prime ";
          break;
        case "cdot":
          e = "\\cdot ";
          break;
        case "tight cdot":
          e = "\\mkern1mu{\\cdot}\\mkern1mu ";
          break;
        case "times":
          e = "\\times ";
          break;
        case "circa":
          e = "{\\sim}";
          break;
        case "^":
          e = "uparrow";
          break;
        case "v":
          e = "downarrow";
          break;
        case "ellipsis":
          e = "\\ldots ";
          break;
        case "/":
          e = "/";
          break;
        case " / ":
          e = "\\,/\\,";
          break;
        default:
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
      return e;
    }, _getArrow: function(r) {
      switch (r) {
        case "->":
          return "rightarrow";
        case "→":
          return "rightarrow";
        case "⟶":
          return "rightarrow";
        case "<-":
          return "leftarrow";
        case "<->":
          return "leftrightarrow";
        case "<-->":
          return "rightleftarrows";
        case "<=>":
          return "rightleftharpoons";
        case "⇌":
          return "rightleftharpoons";
        case "<=>>":
          return "rightequilibrium";
        case "<<=>":
          return "leftequilibrium";
        default:
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }, _getBond: function(r) {
      switch (r) {
        case "-":
          return "{-}";
        case "1":
          return "{-}";
        case "=":
          return "{=}";
        case "2":
          return "{=}";
        case "#":
          return "{\\equiv}";
        case "3":
          return "{\\equiv}";
        case "~":
          return "{\\tripledash}";
        case "~-":
          return "{\\mathrlap{\\raisebox{-.1em}{$-$}}\\raisebox{.1em}{$\\tripledash$}}";
        case "~=":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
        case "~--":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$\\tripledash$}}-}";
        case "-~-":
          return "{\\mathrlap{\\raisebox{-.2em}{$-$}}\\mathrlap{\\raisebox{.2em}{$-$}}\\tripledash}";
        case "...":
          return "{{\\cdot}{\\cdot}{\\cdot}}";
        case "....":
          return "{{\\cdot}{\\cdot}{\\cdot}{\\cdot}}";
        case "->":
          return "{\\rightarrow}";
        case "<-":
          return "{\\leftarrow}";
        case "<":
          return "{<}";
        case ">":
          return "{>}";
        default:
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    }, _getOperator: function(r) {
      switch (r) {
        case "+":
          return " {}+{} ";
        case "-":
          return " {}-{} ";
        case "=":
          return " {}={} ";
        case "<":
          return " {}<{} ";
        case ">":
          return " {}>{} ";
        case "<<":
          return " {}\\ll{} ";
        case ">>":
          return " {}\\gg{} ";
        case "\\pm":
          return " {}\\pm{} ";
        case "\\approx":
          return " {}\\approx{} ";
        case "$\\approx$":
          return " {}\\approx{} ";
        case "v":
          return " \\downarrow{} ";
        case "(v)":
          return " \\downarrow{} ";
        case "^":
          return " \\uparrow{} ";
        case "(^)":
          return " \\uparrow{} ";
        default:
          throw ["MhchemBugT", "mhchem bug T. Please report."];
      }
    } };
    var et = class extends g {
      constructor(t, i, o, a) {
        super("box", o, { command: t, serialize: a.serialize, style: a.style });
        this.body = i, this.framecolor = a.framecolor, this.verbatimFramecolor = a.verbatimBackgroundcolor, this.backgroundcolor = a.backgroundcolor, this.verbatimBackgroundcolor = a.verbatimBackgroundcolor, this.padding = a.padding, this.border = a.border;
      }
      static fromJson(t, i) {
        return new et(t.command, t.body, i, t);
      }
      toJson() {
        return E(b({}, super.toJson()), { framecolor: this.framecolor, verbatimFramecolor: this.verbatimFramecolor, backgroundcolor: this.backgroundcolor, verbatimBackgroundcolor: this.verbatimBackgroundcolor, padding: this.padding, border: this.border });
      }
      render(t) {
        let i = new P(t, this.style), o = Ae(i.getRegisterAsDimension("fboxsep")), a = this.padding === void 0 ? o : Ae(wr(this.padding, E(b({}, this.context), { registers: t.registers }))), n = g.createBox(t, this.body);
        if (!n)
          return null;
        n.setStyle("vertical-align", -n.height, "em");
        let s = new v(n, { type: "mord" }), l = new v(null, { classes: "ML__box" });
        l.height = s.height + a, l.depth = s.depth + a, l.setStyle("box-sizing", "border-box"), l.setStyle("position", "absolute"), l.setStyle("height", s.height + s.depth + 2 * a, "em"), a === 0 ? l.setStyle("width", "100%") : (l.setStyle("width", `calc(100% + ${2 * a}em)`), l.setStyle("top", o, "em"), l.setStyle("left", -a, "em")), this.backgroundcolor && l.setStyle("background-color", this.backgroundcolor), this.framecolor && l.setStyle("border", `${Ae(i.getRegisterAsDimension("fboxrule"))}em solid ${this.framecolor}`), this.border && l.setStyle("border", this.border), s.setStyle("display", "inline-block"), s.setStyle("height", n.height + n.depth, "em"), s.setStyle("vertical-align", -a, "em");
        let c = new v([l, s]);
        return c.setStyle("position", "relative"), c.setStyle("display", "inline-block"), c.setStyle("line-height", 0), c.height = s.height + a, c.depth = s.depth + a, c.left = a, c.right = a, c.setStyle("height", s.height + a, "em"), c.setStyle("top", s.depth - s.height, "em"), c.setStyle("vertical-align", s.depth + a, "em"), this.caret && (c.caret = this.caret), this.attachSupsub(t, { base: c });
      }
    };
    var lr = class extends g {
      constructor(e, t, i) {
        var o;
        super("composition", t, { mode: (o = i == null ? void 0 : i.mode) != null ? o : "math", value: e });
      }
      static fromJson(e, t) {
        return new lr(e.value, t, e);
      }
      toJson() {
        return super.toJson();
      }
      get computedStyle() {
        return {};
      }
      render(e) {
        let t = new v(this.value, { classes: "ML__composition", type: "composition" });
        return this.bind(e, t), this.caret && (t.caret = this.caret), t;
      }
      serialize(e) {
        return "";
      }
    };
    var ae = class extends g {
      constructor(t, i, o) {
        var a;
        super("latex", i, { value: t, mode: "latex" });
        this.isSuggestion = (a = o == null ? void 0 : o.isSuggestion) != null ? a : false, this.isError = false, this.verbatimLatex = t;
      }
      static fromJson(t, i) {
        let o = new ae(t.command, i);
        return t.isSuggestion && (o.isSuggestion = true), t.isError && (o.isError = true), o;
      }
      toJson() {
        let t = {};
        return this.isSuggestion && (t.isSuggestion = true), this.isError && (t.isError = true), b(b({}, super.toJson()), t);
      }
      get computedStyle() {
        return {};
      }
      render(t) {
        let i = new v(this.value, { classes: this.isSuggestion ? "ML__suggestion" : this.isError ? "ML__error" : "", type: "latex", maxFontSize: 1 });
        return i ? (this.caret && (i.caret = this.caret), this.bind(t, i)) : null;
      }
    }, We = class extends g {
      constructor(e, t) {
        super("latexgroup", t, { mode: "latex" }), this.body = [...e].map((i) => new ae(i, t)), this.skipBoundary = false;
      }
      static fromJson(e, t) {
        return new We("", t);
      }
      toJson() {
        return super.toJson();
      }
      render(e) {
        let t = g.createBox(e, this.body, { newList: true });
        return t ? (this.caret && (t.caret = this.caret), this.bind(e, t)) : null;
      }
      serialize(e) {
        var t, i;
        return (i = (t = this.body) == null ? void 0 : t.map((o) => o.value).join("")) != null ? i : "";
      }
    };
    var Nt = class extends g {
      constructor(t, i, o, a) {
        super("line", o, { command: t, style: a.style });
        this.skipBoundary = true, this.body = i, this.position = a.position;
      }
      static fromJson(t, i) {
        return new Nt(t.command, t.body, i, t);
      }
      toJson() {
        return E(b({}, super.toJson()), { position: this.position });
      }
      render(t) {
        let i = new P(t, this.style, "cramp"), o = g.createBox(i, this.body);
        if (!o)
          return null;
        let a = i.metrics.defaultRuleThickness / i.scalingFactor, n = new v(null, { classes: this.position + "-line" });
        n.height = a, n.maxFontSize = a * 1.125 * i.scalingFactor;
        let s;
        return this.position === "overline" ? s = new Q({ shift: 0, children: [{ box: o }, 3 * a, { box: n }, a] }) : s = new Q({ top: o.height, children: [a, { box: n }, 3 * a, { box: o }] }), this.caret && (s.caret = this.caret), new v(s, { classes: this.position, type: "mord" });
      }
    };
    var tt = class extends g {
      constructor(t, i, o, a) {
        var n, s;
        super("overlap", o, { command: t, style: a == null ? void 0 : a.style });
        this.skipBoundary = true, typeof i == "string" ? this.body = [new g("mord", o, { value: i })] : this.body = i, this.align = (n = a == null ? void 0 : a.align) != null ? n : "left", this.boxType = (s = a == null ? void 0 : a.boxType) != null ? s : "mord";
      }
      static fromJson(t, i) {
        return new tt(t.command, t.body, i, t);
      }
      toJson() {
        let t = {};
        return this.align && (t.align = this.align), this.boxType && (t.boxType = this.boxType), b(b({}, super.toJson()), t);
      }
      render(t) {
        let i = g.createBox(t, this.body, { classes: "inner" });
        return i ? (this.caret && (i.caret = this.caret), this.bind(t, new v([i, new v(null, { classes: "fix" })], { classes: this.align === "left" ? "llap" : "rlap", type: this.boxType }))) : null;
      }
    };
    var dt = class extends g {
      constructor(t, i, o, a) {
        var n, s, l, c;
        super("phantom", o, { command: t, style: a.style });
        this.captureSelection = true, this.body = i, this.isInvisible = (n = a.isInvisible) != null ? n : false, this.smashDepth = (s = a.smashDepth) != null ? s : false, this.smashHeight = (l = a.smashHeight) != null ? l : false, this.smashWidth = (c = a.smashWidth) != null ? c : false;
      }
      static fromJson(t, i) {
        return new dt(t.command, t.body, i, t);
      }
      toJson() {
        let t = {};
        return this.isInvisible && (t.isInvisible = true), this.smashDepth && (t.smashDepth = true), this.smashHeight && (t.smashHeight = true), this.smashWidth && (t.smashWidth = true), b(b({}, super.toJson()), t);
      }
      render(t) {
        let i = new P(t, { isPhantom: true });
        if (!this.smashDepth && !this.smashHeight && !this.smashWidth)
          return this.isInvisible, g.createBox(i, this.body, { classes: "inner" });
        let o = g.createBox(this.isInvisible ? i : t, this.body);
        if (!o)
          return null;
        if (this.smashWidth) {
          let a = new v(null, { classes: "fix" });
          return new v([o, a], { classes: "rlap" }).wrap(t);
        }
        if (!this.smashHeight && !this.smashDepth)
          return o;
        if (this.smashHeight && (o.height = 0), this.smashDepth && (o.depth = 0), o.children)
          for (let a of o.children)
            this.smashHeight && (a.height = 0), this.smashDepth && (a.depth = 0);
        return new Q({ firstBaseline: [{ box: o }] }, { type: "mord" }).wrap(t);
      }
    };
    var cr = class extends g {
      constructor(t, i, o) {
        var a;
        super("rule", i, { command: t, style: o.style });
        this.shift = (a = o.shift) != null ? a : { dimension: 0 }, this.height = o.height, this.width = o.width;
      }
      static fromJson(t, i) {
        return new cr(t.command, i, t);
      }
      toJson() {
        let t = { height: this.height, width: this.width };
        return this.shift && (t.shift = this.shift), b(b({}, super.toJson()), t);
      }
      render(t) {
        let i = new P(t, this.style, "textstyle"), o = Ae(this.shift), a = Ae(this.width), n = Ae(this.height), s = new v(null, { classes: "rule", type: "mord" });
        return s.setStyle("border-right-width", a, "em"), s.setStyle("border-top-width", n, "em"), s.setStyle("border-color", this.style.color), s.setStyle("vertical-align", o, "em"), this.isSelected && s.setStyle("opacity", "50%"), s.width = a, s.height = n + o, s.depth = -o, this.bind(t, s), this.caret && (s.caret = this.caret), s.wrap(i);
      }
      serialize(t) {
        var o;
        let i = (o = this.command) != null ? o : "";
        return this.shift && (i += `[${no(this.shift)}]`), i += `{${no(this.width)}}{${no(this.height)}}`, i;
      }
    };
    var Xn = { "p@": "1pt ", "z@": "0pt", maxdimen: "16383.99999pt", hfuzz: "0.1pt", vfuzz: "0.1pt", overfullrule: "5pt", hsize: "6.5in", vsize: "8.9in", parindent: "20pt", maxdepth: "4pt", splitmaxdepth: "\\maxdimen", boxmaxdepth: "\\maxdimen", delimitershortfall: "5pt", nulldelimiterspace: "1.2pt", scriptspace: "0.5pt", topskip: "10pt", splittopskip: "10pt", normalbaselineskip: "12pt", normallineskip: "1pt", normallineskiplimit: "0pt", jot: "3pt", doublerulesep: "2pt", arrayrulewidth: "0.4pt", arraycolsep: "5pt", fboxsep: "3pt", fboxrule: "0.4pt" }, Zn = { "z@skip": "0pt plust0pt minus0pt", hideskip: "-1000pt plust 1fill", "@flushglue": "0pt plust 1fill", parskip: "0pt plus 1pt", abovedisplayskip: "12pt plus 3pt minus 9pt", abovedisplayshortskip: "0pt plus 3pt", belowdisplayskip: "12pt plus 3pt minus 9pt", belowdisplayshortskip: "7pt plus 3pt minus 4pt", parfillskip: "0pt plus 1fil", thinmuskip: "3mu", medmuskip: "4mu plus 2mu minus 4mu", thickmuskip: "5mu plus 5mu", smallskipamount: "3pt plus1pt minus1pt", medskipamount: "6pt plus2pt minus2pt", bigskipamount: "12pt plus4pt minus4pt" }, rc = { pretolerance: 100, tolerance: 200, hbadness: 1e3, vbadness: 1e3, linepenalty: 10, hyphenpenalty: 50, exhyphenpenalty: 50, binoppenalty: 700, relpenalty: 500, clubpenalty: 150, widowpenalty: 150, displaywidowpenalty: 50, brokenpenalty: 100, predisplaypenalty: 1e4, doublehyphendemerits: 1e4, finalhyphendemerits: 5e3, adjdemerits: 1e4, tracinglostchars: 1, uchyph: 1, delimiterfactor: 901, defaulthyphenchar: "\\-", defaultskewchar: -1, newlinechar: -1, showboxbreadth: 5, showboxdepth: 3, errorcontextlines: 5, interdisplaylinepenalty: 100, interfootnotelinepenalty: 100, baselineSkip: 1.2, arraystretch: "", month: new Date().getMonth() + 1, day: new Date().getDate(), year: new Date().getFullYear() }, ur;
    function po(r) {
      var e, t;
      if (ur)
        return ur;
      ur = b({}, rc);
      for (let i of Object.keys(Xn))
        ur[i] = (e = wr(Xn[i], E(b({}, r), { registers: ur }))) != null ? e : 0;
      for (let i of Object.keys(Zn))
        ur[i] = (t = jn(Zn[i], E(b({}, r), { registers: ur }))) != null ? t : 0;
      return ur;
    }
    function Tt() {
      let r = { registers: {}, smartFence: false, fractionNavigationOrder: "numerator-denominator", placeholderSymbol: "▢", letterShapeStyle: U.locale.startsWith("fr") ? "french" : "tex", colorMap: br, backgroundColorMap: Rr, getDefinition: xi, getMacro(e) {
        return oo(e, qr());
      } };
      return E(b({}, r), { registers: po(r) });
    }
    var It = class extends g {
      constructor(t, i, o, a) {
        super("tooltip", o, { command: a == null ? void 0 : a.command, mode: "math", serialize: a == null ? void 0 : a.serialize, style: a == null ? void 0 : a.style, displayContainsHighlight: true });
        this.body = t;
        let n = Tt();
        this.tooltip = new g("root", n, { style: {} }), this.tooltip.body = i, this.skipBoundary = true, this.captureSelection = false;
      }
      static fromJson(t, i) {
        return new It(t.body, Ue(t.tooltip, i), i, t);
      }
      toJson() {
        var i;
        let t = (i = this.tooltip.body) == null ? void 0 : i.filter((o) => o.type !== "first").map((o) => o.toJson());
        return E(b({}, super.toJson()), { tooltip: t });
      }
      render(t) {
        let i = g.createBox(t, this.body, { style: this.style });
        if (!i)
          return null;
        let o = new P({ registers: t.registers }, { fontSize: nt }, "displaystyle"), a = Yt(Mt(new v(this.tooltip.render(o), { classes: "ML__tooltip-content" }), o)), n = new v([a, i], { classes: "ML__tooltip-container" });
        return this.caret && (n.caret = this.caret), this.bind(t, n);
      }
      serialize(t) {
        return `${this.command}{${this.bodyToLatex(t)}}{${g.serialize(this.tooltip.body, t)}}`;
      }
    };
    function Ue(r, e) {
      if (Y(r))
        return r.map((o) => Ue(o, e));
      r = b({}, r);
      for (let o of Rt)
        r[o] && (r[o] = Ue(r[o], e));
      r.array && (r.array = Ue(r.array, e));
      let t = r.type, i;
      t === "accent" && (i = Ct.fromJson(r, e)), t === "array" && (i = X.fromJson(r, e)), t === "box" && (i = et.fromJson(r, e)), t === "chem" && (i = kr.fromJson(r, e)), t === "choice" && (i = dr.fromJson(r, e)), t === "composition" && (i = lr.fromJson(r, e)), t === "delim" && (i = nr.fromJson(r, e)), t === "enclose" && (i = gt.fromJson(r, e)), t === "error" && (i = rr.fromJson(r, e)), t === "genfrac" && (i = ut.fromJson(r, e)), t === "group" && (i = se.fromJson(r, e)), t === "latex" && (i = ae.fromJson(r, e)), t === "latexgroup" && (i = We.fromJson(r, e)), t === "leftright" && (i = oe.fromJson(r, e)), t === "line" && (i = Nt.fromJson(r, e)), t === "macro" && (i = ir.fromJson(r, e)), t === "msubsup" && (i = ft.fromJson(r, e)), t === "overlap" && (i = tt.fromJson(r, e)), t === "overunder" && (i = be.fromJson(r, e)), t === "placeholder" && (i = ie.fromJson(r, e)), t === "prompt" && (i = or.fromJson(r, e)), t === "phantom" && (i = dt.fromJson(r, e)), t === "rule" && (i = cr.fromJson(r, e)), t === "sizeddelim" && (i = sr.fromJson(r, e)), t === "spacing" && (i = Ge.fromJson(r, e)), t === "surd" && (i = ar.fromJson(r, e)), t === "text" && (i = Je.fromJson(r, e)), t === "tooltip" && (i = It.fromJson(r, e)), t === "mop" && (i = we.fromJson(r, e)), i || (i = g.fromJson(r, e));
      for (let o of Rt)
        r[o] && i.setChildren(r[o], o);
      return r.verbatimLatex !== void 0 && (i.verbatimLatex = r.verbatimLatex), r.subsupPlacement && (i.subsupPlacement = r.subsupPlacement), r.explicitSubsupPlacement && (i.explicitSubsupPlacement = true), r.isFunction && (i.isFunction = true), r.isExtensibleSymbol && (i.isExtensibleSymbol = true), r.skipBoundary && (i.skipBoundary = true), r.captureSelection && (i.captureSelection = true), i;
    }
    var dr = class extends g {
      constructor(t, i) {
        super("choice", i);
        this.choices = t, this.skipBoundary = true;
      }
      static fromJson(t, i) {
        return new dr([Ue(t.choices[0], i), Ue(t.choices[1], i), Ue(t.choices[2], i), Ue(t.choices[3], i)], i);
      }
      toJson() {
        let t = [];
        for (let i of this.choices)
          t.push(i.filter((o) => o.type !== "first").map((o) => o.toJson()));
        return E(b({}, super.toJson()), { choices: t });
      }
      render(t) {
        let i = g.createBox(t, this.choices[Math.floor(t.mathstyle.id / 2)]);
        return i ? (this.caret && (i.caret = this.caret), this.bind(t, i)) : null;
      }
      serialize(t) {
        return `\\mathchoice{${g.serialize(this.choices[0], t)}}{${g.serialize(this.choices[1], t)}}{${g.serialize(this.choices[2], t)}}{${g.serialize(this.choices[3], t)}}`;
      }
    };
    x("mathtip", "{:math}{:math}", { createAtom: (r, e, t, i) => new It(e[0], e[1], i, { command: r, content: "math", style: t }) });
    x("texttip", "{:math}{:text}", { createAtom: (r, e, t, i) => new It(e[0], e[1], i, { command: r, content: "text", style: t }) });
    x("error", "{:math}", { createAtom: (r, e, t, i) => new se(e[0], i, { mode: "math", command: "\\error", customClass: "ML__error", style: t, serialize: (o, a) => `\\error{${o.bodyToLatex(a)}}` }) });
    x("ensuremath", "{:math}", { createAtom: (r, e, t, i) => new se(e[0], i, { mode: "math", latexOpen: "\\ensuremath{", latexClose: "}", style: t }) });
    x("color", "{:string}", { applyStyle: (r, e, t) => {
      var o, a;
      let i = e[0];
      return { verbatimColor: e[0], color: (a = (o = t.colorMap) == null ? void 0 : o.call(t, i)) != null ? a : i };
    } });
    x("textcolor", "{:string}{content:auto*}", { applyStyle: (r, e, t) => {
      var o, a;
      let i = e[0];
      return { verbatimColor: i, color: (a = (o = t.colorMap) == null ? void 0 : o.call(t, i)) != null ? a : i };
    } });
    x("boxed", "{content:math}", { createAtom: (r, e, t, i) => new et(r, e[0], i, { framecolor: "black", style: t }) });
    x("colorbox", "{:string}{content:auto*}", { applyMode: "text", applyStyle: (r, e, t) => {
      var o, a;
      let i = e[0];
      return { verbatimBackgroundColor: e[0], backgroundColor: (a = (o = t.backgroundColorMap) == null ? void 0 : o.call(t, i)) != null ? a : i };
    } });
    x("fcolorbox", "{frame-color:string}{background-color:string}{content:auto}", { applyMode: "text", createAtom: (r, e, t, i) => {
      var n, s, l, c;
      let o = e[0], a = e[1];
      return new et(r, e[2], i, { verbatimFramecolor: o, framecolor: (s = (n = i.colorMap) == null ? void 0 : n.call(i, o)) != null ? s : o, verbatimBackgroundcolor: e[1], backgroundcolor: (c = (l = i.backgroundColorMap) == null ? void 0 : l.call(i, a)) != null ? c : a, style: t, serialize: (u, d) => {
        var m, h;
        return `${u.command}{${(m = u.verbatimFramecolor) != null ? m : u.framecolor}{${(h = u.verbatimBackgroundcolor) != null ? h : u.backgroundcolor}}{${u.bodyToLatex(d)}}`;
      } });
    } });
    x("bbox", "[:bbox]{body:auto}", { createAtom: (r, e, t, i) => {
      if (e[0]) {
        let o = e[0];
        return new et(r, e[1], i, { padding: o.padding, border: o.border, backgroundcolor: o.backgroundcolor, style: t, serialize: (a, n) => {
          var l;
          let s = r;
          if (Number.isFinite(a.padding) || a.border !== void 0 || a.backgroundcolor !== void 0) {
            let c = [];
            a.padding && c.push(a.padding), a.border && c.push(`border: ${a.border}`), (a.verbatimBackgroundcolor || a.backgroundcolor) && c.push((l = a.verbatimBackgroundcolor) != null ? l : a.backgroundcolor), s += `[${c.join(",")}]`;
          }
          return s + `{${a.bodyToLatex(n)}}`;
        } });
      }
      return new et(r, e[1], i, { style: t });
    } });
    x(["displaystyle", "textstyle", "scriptstyle", "scriptscriptstyle"], "{:rest}", { createAtom: (r, e, t, i) => new se(e[0], i, { latexOpen: `{${r} `, latexClose: "}", style: t, mathstyleName: r.slice(1) }) });
    x(["tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"], "", { applyStyle: (r, e) => ({ fontSize: { "\\tiny": 1, "\\scriptsize": 2, "\\footnotesize": 3, "\\small": 4, "\\normalsize": 5, "\\large": 6, "\\Large": 7, "\\LARGE": 8, "\\huge": 9, "\\Huge": 10 }[r] }) });
    x("fontseries", "{:string}", { ifMode: "text", applyStyle: (r, e) => ({ fontSeries: e[0] }) });
    x("fontshape", "{:string}", { ifMode: "text", applyStyle: (r, e) => ({ fontShape: e[0] }) });
    x("fontfamily", "{:string}", { ifMode: "text", applyStyle: (r, e) => ({ fontFamily: e[0] }) });
    x("selectfont", "", { ifMode: "text", applyStyle: (r, e) => ({}) });
    x("bf", "", { applyStyle: (r, e) => ({ fontSeries: "b", fontShape: "n", fontFamily: "cmr" }) });
    x(["boldsymbol", "bm"], "{:math*}", { applyMode: "math", createAtom: (r, e, t, i) => new se(e[0], i, { latexOpen: `${r}{`, latexClose: "}", style: t, customClass: "ML__boldsymbol" }) });
    x("bold", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variantStyle: "bold" }) });
    x("bfseries", "", { applyMode: "text", applyStyle: (r, e) => ({ fontSeries: "b" }) });
    x("mdseries", "", { applyMode: "text", applyStyle: (r, e) => ({ fontSeries: "m" }) });
    x("upshape", "", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "n" }) });
    x("slshape", "", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "sl" }) });
    x("scshape", "", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "sc" }) });
    x("textbf", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontSeries: "b" }) });
    x("textmd", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontSeries: "m" }) });
    x("textup", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "n" }) });
    x("textnormal", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "n", fontSeries: "m" }) });
    x("textsl", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "sl" }) });
    x("textit", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "it" }) });
    x("textsc", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontShape: "sc" }) });
    x("textrm", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontFamily: "roman" }) });
    x("textsf", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontFamily: "sans-serif" }) });
    x("texttt", "{:text*}", { applyMode: "text", applyStyle: (r, e) => ({ fontFamily: "monospace" }) });
    x("mathbf", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "normal", variantStyle: "bold" }) });
    x("mathit", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "main", variantStyle: "italic" }) });
    x("mathnormal", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "normal", variantStyle: "italic" }) });
    x("mathbfit", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "main", variantStyle: "bolditalic" }) });
    x("mathrm", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "normal", variantStyle: "up" }) });
    x("mathsf", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "sans-serif", variantStyle: "up" }) });
    x("mathtt", "{:math*}", { applyMode: "math", applyStyle: (r, e) => ({ variant: "monospace", variantStyle: "up" }) });
    x("it", "", { applyStyle: (r, e) => ({ fontSeries: "m", fontShape: "it", fontFamily: "cmr", variantStyle: "italic" }) });
    x("rmfamily", "", { applyStyle: (r, e) => ({ fontFamily: "roman" }) });
    x("sffamily", "", { applyStyle: (r, e) => ({ fontFamily: "sans-serif" }) });
    x("ttfamily", "", { applyStyle: (r, e) => ({ fontFamily: "monospace" }) });
    x(["Bbb", "mathbb"], "{:math*}", { applyStyle: (r, e) => ({ variant: "double-struck", variantStyle: "up" }) });
    x(["frak", "mathfrak"], "{:math*}", { applyStyle: (r, e) => ({ variant: "fraktur", variantStyle: "up" }) });
    x("mathcal", "{:math*}", { applyStyle: (r, e) => ({ variant: "calligraphic", variantStyle: "up" }) });
    x("mathscr", "{:math*}", { applyStyle: (r, e) => ({ variant: "script", variantStyle: "up" }) });
    x("mbox", "{:text}", { ifMode: "math", createAtom: (r, e, t, i) => new se(e[0], i, { changeMode: true, style: t, mode: "text", command: r, serialize: (o, a) => `\\mbox{${o.bodyToLatex(E(b({}, a), { skipModeCommand: true }))}}` }) });
    x("text", "{:text}", { ifMode: "math", applyMode: "text" });
    x("class", "{name:string}{content:auto*}", { createAtom: (r, e, t, i) => new se(e[1], i, { customClass: e[0], style: t }) });
    x("cssId", "{id:string}{content:auto}", { createAtom: (r, e, t, i) => new se(e[1], i, { cssId: e[0], style: t }) });
    x("htmlData", "{data:string}{content:auto}", { createAtom: (r, e, t, i) => new se(e[1], i, { htmlData: e[0], style: t }) });
    x("htmlStyle", "{data:string}{content:auto}", { createAtom: (r, e, t, i) => new se(e[1], i, { htmlStyle: e[0], style: t }) });
    x("em", "{:auto*}", { createAtom: (r, e, t, i) => new se(e[0], i, { latexOpen: "\\em", latexClose: "", customClass: "ML__emph", style: t }) });
    x("emph", "{:auto}", { createAtom: (r, e, t, i) => new se(e[0], i, { latexOpen: "\\emph{", latexClose: "}", customClass: "ML__emph", style: t }) });
    var Yn = { "\\bigl": { mclass: "mopen", size: 1 }, "\\Bigl": { mclass: "mopen", size: 2 }, "\\biggl": { mclass: "mopen", size: 3 }, "\\Biggl": { mclass: "mopen", size: 4 }, "\\bigr": { mclass: "mclose", size: 1 }, "\\Bigr": { mclass: "mclose", size: 2 }, "\\biggr": { mclass: "mclose", size: 3 }, "\\Biggr": { mclass: "mclose", size: 4 }, "\\bigm": { mclass: "mrel", size: 1 }, "\\Bigm": { mclass: "mrel", size: 2 }, "\\biggm": { mclass: "mrel", size: 3 }, "\\Biggm": { mclass: "mrel", size: 4 }, "\\big": { mclass: "mord", size: 1 }, "\\Big": { mclass: "mord", size: 2 }, "\\bigg": { mclass: "mord", size: 3 }, "\\Bigg": { mclass: "mord", size: 4 } };
    x(["bigl", "Bigl", "biggl", "Biggl", "bigr", "Bigr", "biggr", "Biggr", "bigm", "Bigm", "biggm", "Biggm", "big", "Big", "bigg", "Bigg"], "{:delim}", { createAtom: (r, e, t, i) => new sr(r, e[0], i, { size: Yn[r].size, delimClass: Yn[r].mclass, style: t }) });
    x(["hspace", "hspace*"], "{width:glue}", { createAtom: (r, e, t, i) => {
      var o;
      return new Ge(r, t, i, (o = e[0]) != null ? o : { glue: { dimension: 0 } });
    } });
    x(["mkern", "kern"], "{width:glue}", { createAtom: (r, e, t, i) => {
      var o;
      return new Ge(r, t, i, (o = e[0]) != null ? o : { glue: { dimension: 0 } });
    } });
    x("mspace", "{width:glue}", { createAtom: (r, e, t, i) => {
      var o;
      return new Ge(r, t, i, (o = e[0]) != null ? o : { glue: { dimension: 0 } });
    } });
    x("mathop", "{:auto}", { createAtom: (r, e, t, i) => new we(r, e[0], i, { type: "mop", captureSelection: true, limits: "over-under", isFunction: true, hasArgument: true, style: t }) });
    x("mathchoice", "{:math}{:math}{:math}{:math}", { createAtom: (r, e, t, i) => new dr(e, i) });
    x(["mathbin", "mathrel", "mathopen", "mathclose", "mathpunct", "mathord", "mathinner"], "{:auto}", { createAtom: (r, e, t, i) => new we(r, e[0], i, { type: { "\\mathbin": "mbin", "\\mathrel": "mrel", "\\mathopen": "mopen", "\\mathclose": "mclose", "\\mathpunct": "mpunct", "\\mathord": "mord", "\\mathinner": "minner" }[r], captureSelection: true, hasArgument: true, style: t }) });
    x(["operatorname", "operatorname*"], "{operator:math}", { createAtom: (r, e, t, i) => {
      let o = new we(r, e[0], i, { isFunction: true, hasArgument: true, limits: r === "\\operatorname" ? "adjacent" : "over-under", style: t });
      return o.captureSelection = true, o.body && o.body.forEach((a) => {
        var n;
        a.type !== "first" && (a.type = "mord", a.value = (n = { "∗": "*", "−": "-" }[a.value]) != null ? n : a.value, a.isFunction = false, !a.style.variant && !a.style.variantStyle && (a.style.variant = "main", a.style.variantStyle = "up"));
      }), o;
    } });
    var la = class extends g {
      constructor(t, i, o) {
        let a = Number.parseInt(t);
        Number.isFinite(a) || (a = 10067);
        super("mord", o, { value: String.fromCodePoint(a), style: i });
        this.codepoint = a;
      }
      serialize(t) {
        return '\\unicode"' + ("000000" + this.codepoint.toString(16)).toUpperCase().slice(-6);
      }
    };
    x("unicode", "{charcode:number}", { createAtom: (r, e, t, i) => new la(e[0], t, i) });
    x("rule", "[raise:dimen]{width:dimen}{thickness:dimen}", { createAtom: (r, e, t, i) => new cr(r, i, { shift: e[0], width: e[1], height: e[2], style: t }) });
    x("overline", "{:auto}", { createAtom: (r, e, t, i) => new Nt(r, e[0], i, { position: "overline", style: t }) });
    x("underline", "{:auto}", { createAtom: (r, e, t, i) => new Nt(r, e[0], i, { position: "underline", style: t }) });
    x("overset", "{above:auto}{base:auto}", { createAtom: (r, e, t, i) => new be(r, i, { above: e[0], body: e[1], skipBoundary: false, style: t, boxType: Vr(e[1]), serialize: (o, a) => `${o.command}{${o.aboveToLatex(a)}}{${o.bodyToLatex(a)}}` }) });
    x("underset", "{below:auto}{base:auto}", { createAtom: (r, e, t, i) => new be(r, i, { below: e[0], body: e[1], skipBoundary: false, style: t, boxType: Vr(e[1]), serialize: (o, a) => `${r}{${o.belowToLatex(a)}}{${o.bodyToLatex(a)}}` }) });
    x("overunderset", "{above:auto}{below:auto}{base:auto}", { createAtom: (r, e, t, i) => new be(r, i, { above: e[0], below: e[1], body: e[2], skipBoundary: false, style: t, boxType: Vr(e[2]), serialize: (o, a) => `${o.command}{${o.aboveToLatex(a)}}{${o.bodyToLatex(a)}}` }) });
    x(["stackrel", "stackbin"], "[below:auto]{above:auto}{base:auto}", { createAtom: (r, e, t, i) => new be(r, i, { body: e[2], above: e[1], below: e[0], skipBoundary: false, style: t, boxType: r === "\\stackrel" ? "mrel" : "mbin", serialize: (o, a) => `${o.command}{${o.aboveToLatex(a)}}{${o.bodyToLatex(a)}}` }) });
    x("smash", "[:string]{:auto}", { createAtom: (r, e, t, i) => e[0] ? new dt(r, e[1], i, { smashHeight: e[0].includes("t"), smashDepth: e[0].includes("b"), style: t }) : new dt(r, e[1], i, { smashHeight: true, smashDepth: true, style: t }) });
    x(["vphantom"], "{:auto*}", { createAtom: (r, e, t, i) => new dt(r, e[1], i, { isInvisible: true, smashWidth: true, style: t }) });
    x(["hphantom"], "{:auto*}", { createAtom: (r, e, t, i) => new dt(r, e[1], i, { isInvisible: true, smashHeight: true, smashDepth: true, style: t }) });
    x(["phantom"], "{:auto*}", { createAtom: (r, e, t, i) => new dt(r, e[1], i, { isInvisible: true, style: t }) });
    x("not", "{:math}", { createAtom: (r, e, t, i) => {
      if (e.length < 1 || e[0] === null)
        return new g("mrel", i, { command: r, style: t, value: "" });
      let o = e[0];
      return new se([new tt(r, "", i, { align: "right", style: t, boxType: "mrel" }), ...o], i, { boxType: "mrel", captureSelection: true, command: "\\not", serialize: (a, n) => {
        let s = g.serialize(o, n);
        return s.length === 1 && !/[a-zA-Z]/.test(s) ? "\\not" + s : `\\not{${s}}`;
      } });
    } });
    x(["ne", "neq"], "", { createAtom: (r, e, t, i) => new se([new tt(r, "", i, { align: "right", style: t, boxType: "mrel" }), new g("mrel", i, { style: t, value: "=" })], i, { boxType: "mrel", captureSelection: true, serialize: () => r, command: r }) });
    x("rlap", "{:auto}", { createAtom: (r, e, t, i) => new tt(r, e[0], i, { align: "right", style: t }) });
    x("llap", "{:auto}", { createAtom: (r, e, t, i) => new tt(r, e[0], i, { style: t }) });
    x("mathllap", "{:auto}", { createAtom: (r, e, t, i) => new tt(r, e[0], i, { style: t }) });
    x("mathrlap", "{:auto}", { createAtom: (r, e, t, i) => new tt(r, e[0], i, { align: "right", style: t }) });
    ve("0123456789/@.?!");
    ta(65, 90);
    ta(97, 122);
    ve([["\\forall", 8704], ["\\exists", 8707], ["\\nexists", 8708, "mord", "ams"], ["\\mid", 8739, "mrel"], ["\\top", 8868], ["\\bot", 8869]]);
    ve([["\\sharp", 9839], ["\\flat", 9837], ["\\natural", 9838], ["\\#", 35], ["\\&", 38], ["\\clubsuit", 9827], ["\\heartsuit", 9825], ["\\spadesuit", 9824], ["\\diamondsuit", 9826], ["\\parallelogram", 9649]]);
    ve([["\\backslash", 92], ["\\nabla", 8711], ["\\partial", 8706], ["\\ell", 8467], ["\\hbar", 8463], ["\\Q", 81, "mord", "double-struck"], ["\\C", 67, "mord", "double-struck"], ["\\P", 80, "mord", "double-struck"], ["\\pounds", 163], ["\\euro", 8364]]);
    ve([["\\rightarrow", 8594], ["\\to", 8594], ["\\leftarrow", 8592], ["\\gets", 8592], ["\\Rightarrow", 8658], ["\\Leftarrow", 8656], ["\\longrightarrow", 10230], ["\\longleftarrow", 10229], ["\\Longrightarrow", 10233], ["\\implies", 10233], ["\\Longleftarrow", 10232], ["\\impliedby", 10232], ["\\longleftrightarrow", 10231], ["\\biconditional", 10231], ["\\Longleftrightarrow", 10234], ["\\mapsto", 8614], ["\\longmapsto", 10236], ["\\uparrow", 8593], ["\\downarrow", 8595], ["\\Uparrow", 8657], ["\\Downarrow", 8659], ["\\updownarrow", 8597], ["\\Updownarrow", 8661], ["\\hookrightarrow", 8618], ["\\hookleftarrow", 8617], ["\\rightharpoonup", 8640], ["\\leftharpoonup", 8636], ["\\rightharpoondown", 8641], ["\\leftharpoondown", 8637], ["\\searrow", 8600], ["\\nearrow", 8599], ["\\swarrow", 8601], ["\\nwarrow", 8598], ["\\originalof", 8886], ["\\laplace", 8886], ["\\imageof", 8887], ["\\Laplace", 8887]], "mrel");
    ve([["\\lbrace", 123, "mopen"], ["\\rbrace", 125, "mclose"], ["\\lparen", 40, "mopen"], ["\\rparen", 41, "mclose"], ["\\langle", 10216, "mopen"], ["\\rangle", 10217, "mclose"], ["\\lfloor", 8970, "mopen"], ["\\rfloor", 8971, "mclose"], ["\\lceil", 8968, "mopen"], ["\\rceil", 8969, "mclose"], ["\\vert", 8739], ["\\lvert", 8739, "mopen"], ["\\rvert", 8739, "mclose"], ["\\|", 8741], ["\\Vert", 8741], ["\\mVert", 8741], ["\\lVert", 8741, "mopen"], ["\\rVert", 8741, "mclose"], ["\\lbrack", 91, "mopen"], ["\\rbrack", 93, "mclose"], ["\\{", 123, "mopen"], ["\\}", 125, "mclose"], ["(", 40, "mopen"], [")", 41, "mclose"], ["[", 91, "mopen"], ["]", 93, "mclose"], ["\\ulcorner", 9484, "mopen", "ams"], ["\\urcorner", 9488, "mclose", "ams"], ["\\llcorner", 9492, "mopen", "ams"], ["\\lrcorner", 9496, "mclose", "ams"], ["\\lgroup", 10222, "mopen"], ["\\rgroup", 10223, "mclose"], ["\\lmoustache", 9136, "mopen"], ["\\rmoustache", 9137, "mclose"]]);
    ve([["\\dashrightarrow", 8674], ["\\dashleftarrow", 8672], ["\\Rrightarrow", 8667], ["\\Lleftarrow", 8666], ["\\leftrightarrows", 8646], ["\\rightleftarrows", 8644], ["\\curvearrowright", 8631], ["\\curvearrowleft", 8630], ["\\rightrightarrows", 8649], ["\\leftleftarrows", 8647], ["\\upuparrows", 8648], ["\\downdownarrows", 8650], ["\\vartriangle", 9651], ["\\triangleq", 8796], ["\\vartriangleleft", 8882], ["\\trianglelefteq", 8884], ["\\ntriangleleft", 8938], ["\\ntrianglelefteq", 8940], ["\\vartriangleright", 8883], ["\\trianglerighteq", 8885], ["\\ntriangleright", 8939], ["\\ntrianglerighteq", 8941], ["\\blacktriangleleft", 9664], ["\\blacktriangleright", 9654], ["\\leftarrowtail", 8610], ["\\rightarrowtail", 8611], ["\\looparrowright", 8620], ["\\looparrowleft", 8619], ["\\twoheadleftarrow", 8606], ["\\twoheadrightarrow", 8608], ["\\rightleftharpoons", 8652], ["\\leftrightharpoons", 8651], ["\\Rsh", 8625], ["\\Lsh", 8624], ["\\circlearrowright", 8635], ["\\circlearrowleft", 8634], ["\\restriction", 8638], ["\\upharpoonright", 8638], ["\\upharpoonleft", 8639], ["\\downharpoonright", 8642], ["\\downharpoonleft", 8643], ["\\rightsquigarrow", 8669], ["\\leadsto", 8669], ["\\leftrightsquigarrow", 8621], ["\\multimap", 8888], ["\\nrightarrow", 8603], ["\\nleftarrow", 8602], ["\\nRightarrow", 8655], ["\\nLeftarrow", 8653], ["\\nleftrightarrow", 8622], ["\\nLeftrightarrow", 8654], ["\\shortparallel", 8741], ["\\nless", 8814], ["\\nleqslant", 57360], ["\\lneq", 10887], ["\\lneqq", 8808], ["\\nleqq", 57361], ["\\lvertneqq", 57356], ["\\lnsim", 8934], ["\\lnapprox", 10889], ["\\nprec", 8832], ["\\npreceq", 8928], ["\\precnsim", 8936], ["\\precnapprox", 10937], ["\\nsim", 8769], ["\\nshortmid", 57350], ["\\nmid", 8740], ["\\nvdash", 8876], ["\\nvDash", 8877], ["\\ngtr", 8815], ["\\ngeqslant", 57359], ["\\ngeqq", 57358], ["\\gneq", 10888], ["\\gneqq", 8809], ["\\gvertneqq", 57357], ["\\gnsim", 8935], ["\\gnapprox", 10890], ["\\nsucc", 8833], ["\\nsucceq", 8929], ["\\succnsim", 8937], ["\\succnapprox", 10938], ["\\ncong", 8774], ["\\nshortparallel", 57351], ["\\nparallel", 8742], ["\\nVDash", 8879], ["\\nsupseteqq", 57368], ["\\supsetneq", 8843], ["\\varsupsetneq", 57371], ["\\supsetneqq", 10956], ["\\varsupsetneqq", 57369], ["\\nVdash", 8878], ["\\precneqq", 10933], ["\\succneqq", 10934], ["\\nsubseteqq", 57366], ["\\leqslant", 10877], ["\\geqslant", 10878], ["\\gtrsim", 8819], ["\\approxeq", 8778], ["\\thickapprox", 8776], ["\\lessapprox", 10885], ["\\gtrapprox", 10886], ["\\precapprox", 10935], ["\\succapprox", 10936], ["\\thicksim", 8764], ["\\succsim", 8831], ["\\precsim", 8830], ["\\backsim", 8765], ["\\eqsim", 8770], ["\\backsimeq", 8909], ["\\lesssim", 8818], ["\\nleq", 8816], ["\\ngeq", 8817], ["\\smallsmile", 8995], ["\\smallfrown", 8994], ["\\leqq", 8806], ["\\eqslantless", 10901], ["\\lll", 8920], ["\\lessgtr", 8822], ["\\lesseqgtr", 8922], ["\\lesseqqgtr", 10891], ["\\risingdotseq", 8787], ["\\fallingdotseq", 8786], ["\\subseteqq", 10949], ["\\Subset", 8912], ["\\sqsubset", 8847], ["\\preccurlyeq", 8828], ["\\curlyeqprec", 8926], ["\\vDash", 8872], ["\\Vvdash", 8874], ["\\bumpeq", 8783], ["\\Bumpeq", 8782], ["\\geqq", 8807], ["\\eqslantgtr", 10902], ["\\ggg", 8921], ["\\gtrless", 8823], ["\\gtreqless", 8923], ["\\gtreqqless", 10892], ["\\supseteqq", 10950], ["\\Supset", 8913], ["\\sqsupset", 8848], ["\\succcurlyeq", 8829], ["\\curlyeqsucc", 8927], ["\\Vdash", 8873], ["\\shortmid", 8739], ["\\between", 8812], ["\\pitchfork", 8916], ["\\varpropto", 8733], ["\\backepsilon", 8717], ["\\llless", 8920], ["\\gggtr", 8921], ["\\doteqdot", 8785], ["\\Doteq", 8785], ["\\eqcirc", 8790], ["\\circeq", 8791], ["\\therefore", 8756], ["\\because", 8757]], "mrel", "ams");
    ve([["+", 43], ["-", 8722], ["−", 8722], ["\\pm", 177], ["\\mp", 8723], ["*", 8727], ["\\times", 215], ["\\div", 247], ["\\divides", 8739], ["\\cdot", 8901], ["\\cap", 8745], ["\\cup", 8746], ["\\setminus", 8726], ["\\land", 8743], ["\\wedge", 8743], ["\\lor", 8744], ["\\vee", 8744], ["\\circ", 8728], ["\\bigcirc", 9711], ["\\bullet", 8729], ["\\oplus", 8853], ["\\ominus", 8854], ["\\otimes", 8855], ["\\odot", 8857], ["\\oslash", 8856], ["\\bigtriangleup", 9651], ["\\bigtriangledown", 9661], ["\\triangleleft", 9667], ["\\triangleright", 9657], ["\\And", 38], ["\\dagger", 8224], ["\\dag", 8224], ["\\ddag", 8225], ["\\ddagger", 8225], ["\\ast", 8727], ["\\star", 8902], ["\\bigstar", 9733], ["\\diamond", 8900]], "mbin");
    ve([["\\lhd", 8882], ["\\rhd", 8883], ["\\lessdot", 8918], ["\\gtrdot", 8919], ["\\ltimes", 8905], ["\\rtimes", 8906], ["\\leftthreetimes", 8907], ["\\rightthreetimes", 8908], ["\\intercal", 8890], ["\\dotplus", 8724], ["\\doublebarwedge", 10846], ["\\divideontimes", 8903], ["\\centerdot", 8901], ["\\smallsetminus", 8726], ["\\barwedge", 8892], ["\\veebar", 8891], ["\\nor", 8891], ["\\curlywedge", 8911], ["\\curlyvee", 8910], ["\\boxminus", 8863], ["\\boxplus", 8862], ["\\boxtimes", 8864], ["\\boxdot", 8865], ["\\circleddash", 8861], ["\\circledast", 8859], ["\\circledcirc", 8858], ["\\unlhd", 8884], ["\\unrhd", 8885]], "mbin", "ams");
    ve([["\\surd", 8730], ["\\infty", 8734], ["\\prime", 8242], ["\\doubleprime", 8243], ["\\angle", 8736], ["`", 8216], ["\\$", 36], ["\\%", 37], ["\\_", 95], ["\\alpha", 945], ["\\beta", 946], ["\\gamma", 947], ["\\delta", 948], ["\\epsilon", 1013], ["\\varepsilon", 949], ["\\zeta", 950], ["\\eta", 951], ["\\theta", 952], ["\\vartheta", 977], ["\\iota", 953], ["\\kappa", 954], ["\\varkappa", 1008, "mord", "ams"], ["\\lambda", 955], ["\\mu", 956], ["\\nu", 957], ["\\xi", 958], ["\\omicron", 111], ["\\pi", 960], ["\\varpi", 982], ["\\rho", 961], ["\\varrho", 1009], ["\\sigma", 963], ["\\varsigma", 962], ["\\tau", 964], ["\\phi", 981], ["\\varphi", 966], ["\\upsilon", 965], ["\\chi", 967], ["\\psi", 968], ["\\omega", 969], ["\\Gamma", 915], ["\\Delta", 916], ["\\Theta", 920], ["\\Lambda", 923], ["\\Xi", 926], ["\\Pi", 928], ["\\Sigma", 931], ["\\Upsilon", 933], ["\\Phi", 934], ["\\Psi", 936], ["\\Omega", 937], ["\\digamma", 989, "mord", "ams"], ["\\emptyset", 8709]]);
    ve([["=", 61], ["<", 60], ["\\lt", 60], [">", 62], ["\\gt", 62], ["\\le", 8804], ["\\leq", 8804], ["\\ge", 8805], ["\\geq", 8805], ["\\ll", 8810], ["\\gg", 8811], ["\\coloneq", 8788], ["\\measeq", 8797], ["\\eqdef", 8798], ["\\questeq", 8799], [":", 58], ["\\cong", 8773], ["\\equiv", 8801], ["\\prec", 8826], ["\\preceq", 10927], ["\\succ", 8827], ["\\succeq", 10928], ["\\perp", 8869], ["\\propto", 8733], ["\\Colon", 8759], ["\\smile", 8995], ["\\frown", 8994], ["\\sim", 8764], ["\\doteq", 8784], ["\\bowtie", 8904], ["\\Join", 8904], ["\\asymp", 8781], ["\\sqsubseteq", 8849], ["\\sqsupseteq", 8850], ["\\approx", 8776], ["\\~", 126], ["\\leftrightarrow", 8596], ["\\Leftrightarrow", 8660], ["\\models", 8872], ["\\vdash", 8866], ["\\dashv", 8867], ["\\roundimplies", 10608], ["\\in", 8712], ["\\notin", 8713], ["\\ni", 8715], ["\\owns", 8715], ["\\subset", 8834], ["\\supset", 8835], ["\\subseteq", 8838], ["\\supseteq", 8839], ["\\differencedelta", 8710], ["\\mvert", 8739], ["\\parallel", 8741], ["\\simeq", 8771]], "mrel");
    ve([["\\lnot", 172], ["\\neg", 172], ["\\triangle", 9651], ["\\subsetneq", 8842], ["\\varsubsetneq", 57370], ["\\subsetneqq", 10955], ["\\varsubsetneqq", 57367], ["\\nsubset", 8836], ["\\nsupset", 8837], ["\\nsubseteq", 8840], ["\\nsupseteq", 8841]], "mrel", "ams");
    ve([["\\wp", 8472], ["\\aleph", 8501]]);
    ve([["\\blacktriangle", 9650], ["\\hslash", 8463], ["\\Finv", 8498], ["\\Game", 8513], ["\\eth", 240], ["\\mho", 8487], ["\\Bbbk", 107], ["\\yen", 165], ["\\square", 9633], ["\\Box", 9633], ["\\blacksquare", 9632], ["\\circledS", 9416], ["\\circledR", 174], ["\\triangledown", 9661], ["\\blacktriangledown", 9660], ["\\checkmark", 10003], ["\\diagup", 9585], ["\\measuredangle", 8737], ["\\sphericalangle", 8738], ["\\backprime", 8245], ["\\backdoubleprime", 8246], ["\\Diamond", 9674], ["\\lozenge", 9674], ["\\blacklozenge", 10731], ["\\varnothing", 8709], ["\\complement", 8705], ["\\maltese", 10016], ["\\beth", 8502], ["\\daleth", 8504], ["\\gimel", 8503]], "mord", "ams");
    ve([["\\ ", 160], ["~", 160], ["\\space", 160]], "space");
    x(["!", ",", ":", ";", "enskip", "enspace", "quad", "qquad"], "", { createAtom: (r, e, t, i) => new Ge(r, t, i) });
    ve([["\\colon", 58], ["\\cdotp", 8901], ["\\vdots", 8942, "mord"], ["\\ldotp", 46], [",", 44], [";", 59]], "mpunct");
    ve([["\\cdots", 8943], ["\\ddots", 8945], ["\\ldots", 8230], ["\\mathellipsis", 8230]], "minner");
    ve([["\\/", 47], ["|", 8739, "mord"], ["\\imath", 305], ["\\jmath", 567], ["\\degree", 176], ["'", 8242], ['"', 8221]]);
    function Qn(r, e) {
      if (r.direction === e.direction) {
        let t = r.ranges.length;
        if (e.ranges.length === t) {
          let i = 0;
          for (; i < t && ic(r.ranges[i], e.ranges[i]) === "equal"; )
            i++;
          return i === t ? "equal" : "different";
        }
      }
      return "different";
    }
    function ic(r, e) {
      return r[0] === e[0] && r[1] === e[1] ? "equal" : "different";
    }
    function xe(r) {
      let e = 1 / 0, t = -1 / 0;
      for (let i of r.ranges)
        e = Math.min(e, i[0], i[1]), t = Math.max(t, i[0], i[1]);
      return [e, t];
    }
    function oc(r, e) {
      if (!e)
        return "";
      if (typeof e == "string")
        return e;
      if (!r || e.after === void 0)
        return e.value;
      let t = false, i = false, o = false, a = false, n = false, s = false, l = false, c = false, u = false, d = false, m = false, h = false, f = false, y = false, w = false, k = r[0], S = 0;
      for (; k && /msubsup|placeholder/.test(k.type); )
        S += 1, k = r[S];
      return t = !k || k.type === "first", k && (y = k.mode === "text", i = !y && k.type === "mord" && Fn.test(k.value), o = !y && k.type === "mord" && /\d+$/.test(k.value), a = !y && k.isFunction, n = k.type === "genfrac", s = k.type === "surd", l = k.type === "mbin", c = k.type === "mrel", u = k.type === "mop", d = k.type === "mpunct" || k.type === "minner", m = k.type === "array", h = k.type === "mopen", f = k.type === "mclose" || k.type === "leftright", w = k.type === "space"), e.after.includes("nothing") && t || e.after.includes("letter") && i || e.after.includes("digit") && o || e.after.includes("function") && a || e.after.includes("frac") && n || e.after.includes("surd") && s || e.after.includes("binop") && l || e.after.includes("relop") && c || e.after.includes("operator") && u || e.after.includes("punct") && d || e.after.includes("array") && m || e.after.includes("openfence") && h || e.after.includes("closefence") && f || e.after.includes("text") && y || e.after.includes("space") && w ? e.value : "";
    }
    function Si(r, e, t) {
      return t ? oc(r, t[e]) : "";
    }
    var ho = { "&": "\\&", "%": "\\%", "''": "^{\\doubleprime}", alpha: "\\alpha", delta: "\\delta", Delta: "\\Delta", pi: "\\pi", Pi: "\\Pi", theta: "\\theta", Theta: "\\Theta", ii: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\imaginaryI" }, jj: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\imaginaryJ" }, ee: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\exponentialE" }, nabla: "\\nabla", grad: "\\nabla", del: "\\partial", deg: { after: "digit+space", value: "\\degree" }, infty: "\\infty", "∞": "\\infty", oo: { after: "nothing+digit+frac+surd+binop+relop+punct+array+openfence+closefence+space", value: "\\infty" }, "∑": "\\sum", sum: "\\sum_{#?}^{#?}", int: "\\int_{#?}^{#?}", prod: "\\prod_{#?}^{#?}", sqrt: "\\sqrt{#?}", "∆": "\\differentialD", "∂": "\\differentialD", arcsin: "\\arcsin", arccos: "\\arccos", arctan: "\\arctan", arcsec: "\\arcsec", arccsc: "\\arccsc", arsinh: "\\arsinh", arcosh: "\\arcosh", artanh: "\\artanh", arcsech: "\\arcsech", arccsch: "\\arccsch", arg: "\\arg", ch: "\\ch", cosec: "\\cosec", cosh: "\\cosh", cot: "\\cot", cotg: "\\cotg", coth: "\\coth", csc: "\\csc", ctg: "\\ctg", cth: "\\cth", sec: "\\sec", sinh: "\\sinh", sh: "\\sh", tanh: "\\tanh", tg: "\\tg", th: "\\th", sin: "\\sin", cos: "\\cos", tan: "\\tan", lg: "\\lg", lb: "\\lb", log: "\\log", ln: "\\ln", exp: "\\exp", lim: "\\lim_{#?}", dx: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\differentialD x" }, dy: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\differentialD y" }, dt: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\differentialD t" }, AA: "\\forall", EE: "\\exists", "!EE": "\\nexists", "&&": "\\land", xin: { after: "nothing+text+relop+punct+openfence+space", value: "x \\in" }, in: { after: "nothing+letter+closefence", value: "\\in" }, "!in": "\\notin", NN: "\\mathbb{N}", ZZ: "\\Z", QQ: "\\Q", RR: "\\R", CC: "\\C", xx: "\\times", "+-": "\\pm", "≠": "\\ne", "!=": "\\ne", "≥": "\\ge", ">=": "\\ge", "≤": "\\le", "<=": "\\le", "<<": "\\ll", ">>": "\\gg", "~~": "\\approx", "≈": "\\approx", "?=": "\\questeq", "÷": "\\div", "¬": "\\neg", ":=": "\\coloneq", "::": "\\Colon", "(:": "\\langle", ":)": "\\rangle", beta: "\\beta", chi: "\\chi", epsilon: "\\epsilon", varepsilon: "\\varepsilon", eta: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\eta" }, gamma: "\\gamma", Gamma: "\\Gamma", iota: "\\iota", kappa: "\\kappa", lambda: "\\lambda", Lambda: "\\Lambda", mu: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\mu" }, nu: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\nu" }, µ: "\\mu", phi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\phi" }, Phi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\Phi" }, varphi: "\\varphi", psi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\psi" }, Psi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\Psi" }, rho: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\rho" }, sigma: "\\sigma", Sigma: "\\Sigma", tau: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\tau" }, vartheta: "\\vartheta", upsilon: "\\upsilon", xi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space", value: "\\xi" }, Xi: { after: "nothing+digit+function+frac+surd+binop+relop+punct+array+openfence+closefence+space+text", value: "\\Xi" }, zeta: "\\zeta", omega: "\\omega", Omega: "\\Omega", Ω: "\\omega", forall: "\\forall", exists: "\\exists", "!exists": "\\nexists", ":.": "\\therefore", liminf: "\\liminf_{#?}", limsup: "\\limsup_{#?}", argmin: "\\operatorname*{arg~min}_{#?}", argmax: "\\operatorname*{arg~max}_{#?}", det: "\\det", mod: "\\mod", max: "\\max", min: "\\min", erf: "\\operatorname{erf}", erfc: "\\operatorname{erfc}", bessel: "\\operatorname{bessel}", mean: "\\operatorname{mean}", median: "\\operatorname{median}", fft: "\\operatorname{fft}", lcm: "\\operatorname{lcm}", gcd: "\\operatorname{gcd}", randomReal: "\\operatorname{randomReal}", randomInteger: "\\operatorname{randomInteger}", Re: "\\operatorname{Re}", Im: "\\operatorname{Im}", mm: { after: "nothing+digit+operator", value: "\\operatorname{mm}" }, cm: { after: "nothing+digit+operator", value: "\\operatorname{cm}" }, km: { after: "nothing+digit+operator", value: "\\operatorname{km}" }, kg: { after: "nothing+digit+operator", value: "\\operatorname{kg}" }, "...": "\\ldots", "+...": "+\\cdots", "-...": "-\\cdots", "->...": "\\to\\cdots", "->": "\\to", "|->": "\\mapsto", "-->": "\\longrightarrow", "<--": "\\longleftarrow", "=>": "\\Rightarrow", "==>": "\\Longrightarrow", "<=>": "\\Leftrightarrow", "<->": "\\leftrightarrow", "(.)": "\\odot", "(+)": "\\oplus", "(/)": "\\oslash", "(*)": "\\otimes", "(-)": "\\ominus", "||": "\\Vert", "{": "\\{", "}": "\\}", "*": "\\cdot" };
    function _r(r, e) {
      var i;
      let t = (i = e == null ? void 0 : e.format) != null ? i : "auto";
      return t === "auto" && ([t, r] = ac(r)), t === "ascii-math" ? (r = r.replace(/\u2061/gu, ""), r = r.replace(/\u3016/gu, "{"), r = r.replace(/\u3017/gu, "}"), r = r.replace(/([^\\])sinx/g, "$1\\sin x"), r = r.replace(/([^\\])cosx/g, "$1\\cos x "), r = r.replace(/\u2013/g, "-"), ["ascii-math", Ne(r, { inlineShortcuts: e == null ? void 0 : e.inlineShortcuts })]) : ["latex", r];
    }
    function Ne(r, e) {
      var a, n, s;
      if (!r)
        return "";
      let t = false, i, o = (a = e.inlineShortcuts) != null ? a : ho;
      if (!t && (r.startsWith("^") || r.startsWith("_")) && (i = Sr(r.slice(1), { inlineShortcuts: o, noWrap: true }), r = r[0] + "{" + i.match + "}", r += Ne(i.rest, e), t = true), t || (i = r.match(/^(sqrt|\u221A)(.*)/), i && (i = Sr(i[2], { inlineShortcuts: o, noWrap: true }), r = "\\sqrt{" + ((n = i.match) != null ? n : "\\placeholder{}") + "}", r += Ne(i.rest, e), t = true)), t || (i = r.match(/^(\\cbrt|\u221B)(.*)/), i && (i = Sr(i[2], { inlineShortcuts: o, noWrap: true }), r = "\\sqrt[3]{" + ((s = i.match) != null ? s : "\\placeholder{}") + "}", r += Ne(i.rest, e), t = true)), t || (i = r.match(/^abs(.*)/), i && (i = Sr(i[1], { inlineShortcuts: o, noWrap: true }), r = "\\left|" + i.match + "\\right|", r += Ne(i.rest, e), t = true)), t || (i = r.match(/^["”“](.*?)["”“](.*)/), i && (r = "\\text{" + i[1] + "}", r += Ne(i[2], e), t = true)), t || (i = r.match(/^([^a-zA-Z\(\{\[\_\^\\\s"]+)(.*)/), i && (r = es(i[1], o), r += Ne(i[2], e), t = true)), !t && /^([fgh])[^a-zA-Z]/.test(r) && (i = Sr(r.slice(1), { inlineShortcuts: o, noWrap: true }), r = r[1] === "(" ? r[0] + "\\left(" + i.match + "\\right)" : r[0] + i.match, r += Ne(i.rest, e), t = true), t || (i = r.match(/^([a-zA-Z]+)(.*)/), i && (r = es(i[1], o), r += Ne(i[2], e), t = true)), !t)
        if (i = Sr(r, { inlineShortcuts: o, noWrap: true }), i.match && i.rest[0] === "/") {
          let l = Sr(i.rest.slice(1), { inlineShortcuts: o, noWrap: true });
          l.match && (r = "\\frac{" + i.match + "}{" + l.match + "}" + Ne(l.rest, e)), t = true;
        } else
          i.match && (r = r.startsWith("(") ? "\\left(" + i.match + "\\right)" + Ne(i.rest, e) : i.match + Ne(i.rest, e), t = true);
      return t || (i = r.match(/^(\s+)(.*)$/), i && (r = " " + Ne(i[2], e), t = true)), r;
    }
    function Sr(r, e) {
      let t = "";
      r = r.trim();
      let i = r, o = r.charAt(0), a = { "(": ")", "{": "}", "[": "]" }[o];
      if (a) {
        let n = 1, s = 1;
        for (; s < r.length && n > 0; )
          r[s] === o && n++, r[s] === a && n--, s++;
        n === 0 ? (e.noWrap && o === "(" ? t = Ne(r.substring(1, s - 1), e) : (o === "{" && a === "}" && (o = "\\{", a = "\\}"), t = "\\left" + o + Ne(r.substring(1, s - 1), e) + "\\right" + a), i = r.slice(Math.max(0, s))) : (t = r.substring(1, s), i = "");
      } else {
        let n = r.match(/^([a-zA-Z]+)/);
        if (n) {
          let s = Si(null, r, e.inlineShortcuts);
          if (s)
            return s = s.replace("_{#?}", ""), s = s.replace("^{#?}", ""), { match: s, rest: r.slice(s.length) };
        }
        if (n = r.match(/^([a-zA-Z])/), n)
          return { match: n[1], rest: r.slice(1) };
        if (n = r.match(/^(-)?\d+(\.\d*)?/), n)
          return { match: n[0], rest: r.slice(n[0].length) };
        /^\\(left|right)/.test(r) || (n = r.match(/^(\\[a-zA-Z]+)/), n && (i = r.slice(n[1].length), t = n[1]));
      }
      return { match: t, rest: i };
    }
    function es(r, e) {
      let t = Si(null, r, e);
      return t ? (t = t.replace("_{#?}", ""), t = t.replace("^{#?}", ""), t += " ") : t = r, t;
    }
    var ca = [["\\[", "\\]"], ["\\(", "\\)"], ["$$", "$$"], ["$", "$"], ["\\begin{math}", "\\end{math}"], ["\\begin{displaymath}", "\\end{displaymath}"], ["\\begin{equation}", "\\end{equation}"], ["\\begin{equation*}", "\\end{equation*}"]];
    function fo(r) {
      let e = r.trim();
      for (let t of ca)
        if (e.startsWith(t[0]) && e.endsWith(t[1]))
          return [true, e.substring(t[0].length, e.length - t[1].length)];
      return [false, r];
    }
    function ac(r) {
      if (r = r.trim(), r.length <= 1)
        return ["latex", r];
      let e;
      return [e, r] = fo(r), e ? ["latex", r] : r.startsWith("`") && r.endsWith("`") ? (r = r.substring(1, r.length - 1), ["ascii-math", r]) : r.includes("\\") ? ["latex", r] : /\$.+\$/.test(r) ? ["latex", `\\text{${r}}`] : [void 0, r];
    }
    var nc = "$$", sc = "$$", ts = (r, e, t) => (ca.some((i) => e.startsWith(i[0]) && e.endsWith(i[1])) || (e = `${nc} ${e} ${sc}`), e), _i = class {
      constructor(e) {
        _i._registry[e] = this;
      }
      static onPaste(e, t, i) {
        var a;
        if (!t.contentEditable && t.userSelect === "none")
          return t.model.announce("plonk"), false;
        if (typeof i == "string") {
          let n = new DataTransfer();
          n.setData("text/plain", i), i = n;
        }
        let o = new ClipboardEvent("paste", { clipboardData: i, cancelable: true });
        return (a = t.host) != null && a.dispatchEvent(o) ? _i._registry[e].onPaste(t, i) : false;
      }
      static onCopy(e, t) {
        if (!t.clipboardData)
          return;
        if (!e.contentEditable && e.userSelect === "none") {
          e.model.announce("plonk");
          return;
        }
        let i = e.model, o = i.selectionIsCollapsed ? [0, i.lastOffset] : xe(i.selection), a = i.getAtoms(o);
        if (a.every((n) => n.mode === "text" || !n.mode))
          t.clipboardData.setData("text/plain", a.filter((n) => n instanceof Je).map((n) => n.value).join(""));
        else if (a.every((n) => n.mode === "latex"))
          t.clipboardData.setData("text/plain", i.getAtoms(o, { includeChildren: true }).map((n) => {
            var s;
            return (s = n.value) != null ? s : "";
          }).join(""));
        else {
          let n;
          a.length === 1 && a[0].verbatimLatex !== void 0 ? n = a[0].verbatimLatex : n = i.getValue(o, "latex-expanded"), t.clipboardData.setData("application/x-latex", n);
          try {
            t.clipboardData.setData("text/plain", e.options.onExport(e, n, o));
          } catch (l) {
          }
          a.length === 1 && (a[0].type === "root" || a[0].type === "group") && (a = a[0].body.filter((l) => l.type !== "first"));
          try {
            t.clipboardData.setData("application/json+mathlive", JSON.stringify(a.map((l) => l.toJson())));
          } catch (l) {
          }
          let s = window.MathfieldElement.computeEngine;
          if (s)
            try {
              s.jsonSerializationOptions = { metadata: ["latex"] };
              let l = s.parse(n), c = JSON.stringify(l.json);
              c && t.clipboardData.setData("application/json", c);
            } catch (l) {
            }
        }
        t.preventDefault();
      }
      static insert(e, t, i, o = {}) {
        return _i._registry[e].insert(t, i, o);
      }
      onPaste(e, t) {
        return false;
      }
      insert(e, t, i) {
        return false;
      }
    }, Z = _i;
    Z._registry = {};
    var go = [{ key: "left", command: "moveToPreviousChar" }, { key: "right", command: "moveToNextChar" }, { key: "up", command: "moveUp" }, { key: "down", command: "moveDown" }, { key: "shift+[ArrowLeft]", command: "extendSelectionBackward" }, { key: "shift+[ArrowRight]", command: "extendSelectionForward" }, { key: "shift+[ArrowUp]", command: "extendSelectionUpward" }, { key: "shift+[ArrowDown]", command: "extendSelectionDownward" }, { key: "[Backspace]", command: "deleteBackward" }, { key: "alt+[Delete]", command: "deleteBackward" }, { key: "[Delete]", command: "deleteForward" }, { key: "alt+[Backspace]", command: "deleteForward" }, { key: "alt+[ArrowLeft]", command: "moveToPreviousWord" }, { key: "alt+[ArrowRight]", command: "moveToNextWord" }, { key: "shift+alt+[ArrowLeft]", command: "extendToPreviousWord" }, { key: "shift+alt+[ArrowRight]", command: "extendToNextWord" }, { key: "ctrl+[ArrowLeft]", command: "moveToGroupStart" }, { key: "ctrl+[ArrowRight]", command: "moveToGroupEnd" }, { key: "shift+ctrl+[ArrowLeft]", command: "extendToGroupStart" }, { key: "shift+ctrl+[ArrowRight]", command: "extendToGroupEnd" }, { key: "[Space]", ifMode: "math", command: "moveAfterParent" }, { key: "shift+[Space]", ifMode: "math", command: "moveBeforeParent" }, { key: "[Home]", command: "moveToMathfieldStart" }, { key: "cmd+[ArrowLeft]", command: "moveToMathfieldStart" }, { key: "shift+[Home]", command: "extendToMathFieldStart" }, { key: "shift+cmd+[ArrowLeft]", command: "extendToMathFieldStart" }, { key: "[End]", command: "moveToMathfieldEnd" }, { key: "cmd+[ArrowRight]", command: "moveToMathfieldEnd" }, { key: "shift+[End]", command: "extendToMathFieldEnd" }, { key: "shift+cmd+[ArrowRight]", command: "extendToMathFieldEnd" }, { key: "[Pageup]", command: "moveToGroupStart" }, { key: "[Pagedown]", command: "moveToGroupEnd" }, { key: "[Tab]", ifMode: "math", command: "moveToNextPlaceholder" }, { key: "shift+[Tab]", ifMode: "math", command: "moveToPreviousPlaceholder" }, { key: "[Tab]", ifMode: "text", command: "moveToNextPlaceholder" }, { key: "shift+[Tab]", ifMode: "text", command: "moveToPreviousPlaceholder" }, { key: "[Escape]", ifMode: "math", command: ["switchMode", "latex"] }, { key: "[Escape]", ifMode: "text", command: ["switchMode", "latex"] }, { key: "[Escape]", ifMode: "latex", command: ["complete", "complete", { selectItem: "true" }] }, { key: "\\", ifMode: "math", command: ["switchMode", "latex", "\\"] }, { key: "[IntlBackslash]", ifMode: "math", command: ["switchMode", "latex", "\\"] }, { key: "[Tab]", ifMode: "latex", command: ["complete", "accept-suggestion"] }, { key: "[Return]", ifMode: "latex", command: "complete" }, { key: "[Enter]", ifMode: "latex", command: "complete" }, { key: "shift+[Escape]", ifMode: "latex", command: ["complete", "reject"] }, { key: "[ArrowDown]", ifMode: "latex", command: "nextSuggestion" }, { key: "[ArrowUp]", ifMode: "latex", command: "previousSuggestion" }, { key: "ctrl+a", ifPlatform: "!macos", command: "selectAll" }, { key: "cmd+a", command: "selectAll" }, { key: "[Cut]", command: "cutToClipboard" }, { key: "[Copy]", command: "copyToClipboard" }, { key: "[Paste]", command: "pasteFromClipboard" }, { key: "[Clear]", command: "deleteBackward" }, { key: "[Undo]", command: "undo" }, { key: "[Redo]", command: "redo" }, { key: "[EraseEof]", command: "deleteToGroupEnd" }, { key: "ctrl+x", command: "cutToClipboard" }, { key: "cmd+x", command: "cutToClipboard" }, { key: "ctrl+c", command: "copyToClipboard" }, { key: "cmd+c", command: "copyToClipboard" }, { key: "ctrl+v", command: "pasteFromClipboard" }, { key: "cmd+v", command: "pasteFromClipboard" }, { key: "ctrl+z", ifPlatform: "!macos", command: "undo" }, { key: "cmd+z", command: "undo" }, { key: "ctrl+y", ifPlatform: "!macos", command: "redo" }, { key: "shift+cmd+y", command: "redo" }, { key: "shift+ctrl+z", ifPlatform: "!macos", command: "redo" }, { key: "shift+cmd+z", command: "redo" }, { key: "ctrl+b", ifPlatform: "macos", command: "moveToPreviousChar" }, { key: "ctrl+f", ifPlatform: "macos", command: "moveToNextChar" }, { key: "ctrl+p", ifPlatform: "macos", command: "moveUp" }, { key: "ctrl+n", ifPlatform: "macos", command: "moveDown" }, { key: "ctrl+a", ifPlatform: "macos", command: "moveToMathfieldStart" }, { key: "ctrl+e", ifPlatform: "macos", command: "moveToMathfieldEnd" }, { key: "shift+ctrl+b", ifPlatform: "macos", command: "extendSelectionBackward" }, { key: "shift+ctrl+f", ifPlatform: "macos", command: "extendSelectionForward" }, { key: "shift+ctrl+p", ifPlatform: "macos", command: "extendSelectionUpward" }, { key: "shift+ctrl+n", ifPlatform: "macos", command: "extendSelectionDownward" }, { key: "shift+ctrl+a", ifPlatform: "macos", command: "extendToMathFieldStart" }, { key: "shift+ctrl+e", ifPlatform: "macos", command: "extendToMathFieldEnd" }, { key: "alt+ctrl+b", ifPlatform: "macos", command: "moveToPreviousWord" }, { key: "alt+ctrl+f", ifPlatform: "macos", command: "moveToNextWord" }, { key: "shift+alt+ctrl+b", ifPlatform: "macos", command: "extendToPreviousWord" }, { key: "shift+alt+ctrl+f", ifPlatform: "macos", command: "extendToNextWord" }, { key: "ctrl+h", ifPlatform: "macos", command: "deleteBackward" }, { key: "ctrl+d", ifPlatform: "macos", command: "deleteForward" }, { key: "ctrl+l", ifPlatform: "macos", command: "scrollIntoView" }, { key: "ctrl+[Digit2]", ifMode: "math", command: ["insert", "\\sqrt{#0}"] }, { key: "ctrl+[Digit5]", ifMode: "math", command: "moveToOpposite" }, { key: "ctrl+[Digit6]", ifMode: "math", command: "moveToSuperscript" }, { key: "ctrl+[Return]", ifMode: "math", command: "addRowAfter" }, { key: "ctrl+[Enter]", ifMode: "math", command: "addRowAfter" }, { key: "cmd+[Return]", ifMode: "math", command: "addRowAfter" }, { key: "cmd+[Enter]", ifMode: "math", command: "addRowAfter" }, { key: "alt+p", ifMode: "math", command: ["insert", "\\pi"] }, { key: "alt+v", ifMode: "math", command: ["insert", "\\sqrt{#0}"] }, { key: "alt+w", ifMode: "math", command: ["insert", "\\sum_{i=#?}^{#?}"] }, { key: "alt+b", command: ["insert", "\\int_{#?}^{#?}"] }, { key: "alt+u", ifMode: "math", command: ["insert", "\\cup"] }, { key: "alt+n", ifMode: "math", command: ["insert", "\\cap"] }, { key: "alt+o", ifMode: "math", command: ["insert", "\\emptyset"] }, { key: "alt+d", ifMode: "math", command: ["insert", "\\differentialD"] }, { key: "shift+alt+o", ifMode: "math", command: ["insert", "\\varnothing"] }, { key: "shift+alt+d", ifMode: "math", command: ["insert", "\\partial"] }, { key: "shift+alt+p", ifMode: "math", command: ["insert", "\\prod_{i=#?}^{#?}"] }, { key: "shift+alt+u", ifMode: "math", command: ["insert", "\\bigcup"] }, { key: "shift+alt+n", ifMode: "math", command: ["insert", "\\bigcap"] }, { key: "shift+alt+a", ifMode: "math", command: ["insert", "\\forall"] }, { key: "shift+alt+e", ifMode: "math", command: ["insert", "\\exists"] }, { key: "alt+[Backslash]", ifMode: "math", command: ["insert", "\\backslash"] }, { key: "[NumpadDivide]", ifMode: "math", command: ["insert", "\\frac{#@}{#?}"] }, { key: "alt+[NumpadDivide]", ifMode: "math", command: ["insert", "\\frac{#?}{#@}"] }, { key: "shift+alt+k", command: "toggleKeystrokeCaption" }, { key: "alt+[Space]", command: "toggleVirtualKeyboard" }, { key: "alt+ctrl+[ArrowUp]", command: ["speak", "all", { withHighlighting: false }] }, { key: "alt+ctrl+[ArrowDown]", command: ["speak", "selection", { withHighlighting: false }] }, { key: "alt+[Equal]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["applyStyle", { mode: "text" }] }, { key: "alt+[Equal]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "text", command: ["applyStyle", { mode: "math" }] }, { key: "shift+[Quote]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["switchMode", "text", "", ""] }, { key: "shift+alt+[KeyT]", ifMode: "math", command: ["switchMode", "text", "", ""] }, { key: "shift+alt+[KeyT]", ifMode: "text", command: ["switchMode", "math", "", ""] }, { key: "shift+[Quote]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "text", command: ["switchMode", "math", "", ""] }, { key: "/", ifMode: "math", command: ["insert", "\\frac{#@}{#?}"] }, { key: "alt+/", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\/"] }, { key: "alt+[BracketLeft]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\left\\lbrack #0 \\right\\rbrack"] }, { key: "ctrl+[Minus]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "moveToSubscript" }, { key: "shift+alt+[BracketLeft]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\left\\lbrace #0 \\right\\rbrace"] }, { key: "ctrl+;", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addRowAfter" }, { key: "cmd+;", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addRowAfter" }, { key: "shift+ctrl+;", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addRowBefore" }, { key: "shift+cmd+;", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addRowBefore" }, { key: "ctrl+[Backspace]", ifMode: "math", command: "removeRow" }, { key: "cmd+[Backspace]", ifMode: "math", command: "removeRow" }, { key: "ctrl+[Comma]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addColumnAfter" }, { key: "cmd+[Comma]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addColumnAfter" }, { key: "shift+ctrl+[Comma]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addColumnBefore" }, { key: "shift+cmd+[Comma]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: "addColumnBefore" }, { key: "shift+[Backspace]", ifMode: "math", command: "removeColumn" }, { key: "alt+[Digit5]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "$\\infty"] }, { key: "alt+[Digit6]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\wedge"] }, { key: "shift+alt+[Digit6]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\vee"] }, { key: "alt+[Digit9]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "("] }, { key: "alt+[Digit0]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", ")"] }, { key: "alt+|", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "|"] }, { key: "shift+[Backquote]", ifLayout: ["apple.en-intl", "windows.en-intl", "linux.en"], ifMode: "math", command: ["insert", "\\~"] }, { key: "[Backquote]", ifLayout: ["windows.french", "linux.french"], ifMode: "math", command: ["insert", "^2"] }], rs = { "\\theta": "alt+q", "\\sqrt": ["alt+v", "ctrl+[Digit2]"], "\\pi": "alt+p", "\\prod": "shift+alt+p", "\\sum": "alt+w", "\\int": "alt+b", "\\cup": "alt+u", "\\cap": "alt+n", "\\bigcup": "shift+alt+u", "\\bigcap": "shift+alt+n", "\\forall": "shift+alt+a", "\\exists": "shift+alt+e", "\\infty": "alt+[Digit5]", "\\wedge": "alt+[Digit6]", "\\vee": "shift+alt+[Digit6]", "\\differentialD": "alt+d", "\\partial": "shift+alt+d", "\\frac": "Slash", "\\emptyset": "alt+o", "\\varnothing": "shift+alt+o", "\\~": "~" };
    function Ur(r, e) {
      let t = Et(r, Object.keys(r));
      for (let i of Object.keys(e))
        switch (i) {
          case "scriptDepth":
            if (Y(e.scriptDepth))
              t.scriptDepth = [e.scriptDepth[0], e.scriptDepth[1]];
            else if (typeof e.scriptDepth == "number")
              t.scriptDepth = [e.scriptDepth, e.scriptDepth];
            else
              throw new TypeError("Unexpected value for scriptDepth");
            break;
          case "mathVirtualKeyboardPolicy":
            let o = e.mathVirtualKeyboardPolicy.toLowerCase();
            t.mathVirtualKeyboardPolicy = o;
            break;
          case "letterShapeStyle":
            e.letterShapeStyle === "auto" ? U.locale.startsWith("fr") ? t.letterShapeStyle = "french" : t.letterShapeStyle = "tex" : t.letterShapeStyle = e.letterShapeStyle;
            break;
          case "defaultMode":
            ["text", "math", "inline-math"].includes(e.defaultMode) ? t.defaultMode = e.defaultMode : (console.error('MathLive 0.90.9:  valid values for defaultMode are "text", "math" or "inline-math"'), t.defaultMode = "math");
            break;
          case "macros":
            t.macros = ro(e.macros);
            break;
          default:
            Y(e[i]) ? t[i] = [...e[i]] : typeof e[i] == "object" ? t[i] = b({}, e[i]) : t[i] = e[i];
        }
      return t;
    }
    function Et(r, e) {
      let t;
      typeof e == "string" ? t = [e] : e === void 0 ? t = Object.keys(r) : t = e;
      let i = {};
      for (let o of t)
        r[o] === null ? i[o] = null : Y(r[o]) ? i[o] = [...r[o]] : typeof r[o] == "object" && !(r[o] instanceof Element) && o !== "computeEngine" ? i[o] = b({}, r[o]) : i[o] = r[o];
      return typeof e == "string" ? i[e] : i;
    }
    function jr() {
      return { readOnly: false, defaultMode: "math", macros: qr(), registers: {}, colorMap: br, backgroundColorMap: Rr, letterShapeStyle: U.locale.startsWith("fr") ? "french" : "tex", smartMode: false, smartFence: true, smartSuperscript: true, scriptDepth: [1 / 0, 1 / 0], removeExtraneousParentheses: true, mathModeSpace: "", placeholderSymbol: "▢", popoverPolicy: "auto", keybindings: go, inlineShortcuts: ho, inlineShortcutTimeout: 0, mathVirtualKeyboardPolicy: "auto", virtualKeyboardTargetOrigin: window == null ? void 0 : window.origin, originValidator: "none", onInlineShortcut: () => "", onExport: ts, value: "" };
    }
    function yo(r) {
      return r.defaultMode === "inline-math" ? "math" : r.defaultMode;
    }
    function Pt(r) {
      return typeof r == "number" && !Number.isNaN(r);
    }
    function Mr(r) {
      return Array.isArray(r) && r.length === 2;
    }
    function Xr(r) {
      return r != null && typeof r == "object" && "ranges" in r && Array.isArray(r.ranges);
    }
    var is = { main: ["Main-Regular", "ML__cmr"], "main-italic": ["Main-Italic", "ML__cmr ML__it"], "main-bold": ["Main-Bold", "ML__cmr ML__bold"], "main-bolditalic": ["Main-BoldItalic", "ML__cmr ML__bold ML__it"], normal: ["Main-Regular", "ML__cmr"], "normal-bold": ["Main-Bold", "ML__mathbf"], "normal-italic": ["Math-Italic", "ML__mathit"], "normal-bolditalic": ["Math-BoldItalic", "ML__mathbfit"], ams: ["AMS-Regular", "ML__ams"], "ams-bold": ["AMS-Regular", "ML__ams"], "ams-italic": ["AMS-Regular", "ML__ams"], "ams-bolditalic": ["AMS-Regular", "ML__ams"], "sans-serif": ["SansSerif-Regular", "ML__sans"], "sans-serif-bold": ["SansSerif-Regular", "ML__sans ML__bold"], "sans-serif-italic": ["SansSerif-Regular", "ML__sans"], "sans-serif-bolditalic": ["SansSerif-Regular", "ML__sans"], calligraphic: ["Caligraphic-Regular", "ML__cal"], "calligraphic-bold": ["Caligraphic-Regular", "ML__cal ML__bold"], "calligraphic-italic": ["Caligraphic-Regular", "ML__cal ML__it"], "calligraphic-bolditalic": ["Caligraphic-Regular", "ML__cal ML__bold ML__it"], script: ["Script-Regular", "ML__script"], "script-bold": ["Script-Regular", "ML__script ML__bold"], "script-italic": ["Script-Regular", "ML__script ML__it"], "script-bolditalic": ["Script-Regular", "ML__script ML__bold ML__it"], fraktur: ["Fraktur-Regular", "ML__frak"], "fraktur-bold": ["Fraktur-Regular", "ML__frak"], "fraktur-italic": ["Fraktur-Regular", "ML__frak"], "fraktur-bolditalic": ["Fraktur-Regular", "ML__frak"], monospace: ["Typewriter-Regular", "ML__tt"], "monospace-bold": ["Typewriter-Regular", "ML__tt ML__bold"], "monospace-italic": ["Typewriter-Regular", "ML__tt ML__it"], "monospace-bolditalic": ["Typewriter-Regular", "ML__tt ML__bold ML__it"], "double-struck": ["AMS-Regular", "ML__bb"], "double-struck-bold": ["AMS-Regular", "ML__bb"], "double-struck-italic": ["AMS-Regular", "ML__bb"], "double-struck-bolditalic": ["AMS-Regular", "ML__bb"] }, os = { "double-struck": /^[A-Z ]$/, script: /^[A-Z ]$/, calligraphic: /^[\dA-Z ]$/, fraktur: /^[\dA-Za-z ]$|^[!"#$%&'()*+,\-./:;=?[]^’‘]$/, monospace: /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/, "sans-serif": /^[\dA-Za-z ]$|^[!"&'()*+,\-./:;=?@[\]^_~\u0131\u0237\u0393\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A8\u03A9]$/ }, as = /^[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5]$/, lc = /^[\u0393|\u0394\u0398\u039B\u039E\u03A0\u03A3\u03A5\u03A6\u03A8\u03A9]$/, cc = [/^[a-z]$/, /^[A-Z]$/, as, lc], uc = { iso: ["it", "it", "it", "it"], tex: ["it", "it", "it", "up"], french: ["it", "up", "up", "up"], upright: ["up", "up", "up", "up"] }, da = class extends Te {
      constructor() {
        super("math");
      }
      createAtom(e, t, i) {
        var n, s, l, c, u;
        let o = t.getDefinition(e, "math");
        if (o === null)
          return new g("mord", t, { mode: "math", command: e, value: e, style: i });
        if (o.definitionType === "symbol") {
          let d = new g((n = o.type) != null ? n : "mord", t, { mode: "math", command: (s = o.command) != null ? s : e, value: String.fromCodePoint(o.codepoint), style: i });
          return (l = o.isFunction) != null && l && (d.isFunction = true), e.startsWith("\\") && (d.verbatimLatex = e), d;
        }
        let a = new g("mord", t, { mode: "math", command: (c = o.command) != null ? c : e, value: e, style: i });
        return (u = o.isFunction) != null && u && (a.isFunction = true), e.startsWith("\\") && (a.verbatimLatex = e), a;
      }
      serialize(e, t) {
        let { parent: i } = e[0], o = i == null ? void 0 : i.computedStyle.fontSize;
        return j(Re(e, "fontSize").map((a) => {
          let n = pc(a, t), s = a[0].computedStyle.fontSize;
          return s && (!i || o !== s) ? "\\" + ["", "tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"][s] + " " + n : n;
        }));
      }
      applyStyle(e, t) {
        if (t.variant === void 0)
          return "";
        let i = t.letterShapeStyle === "auto" || !t.letterShapeStyle ? "tex" : t.letterShapeStyle, { variant: o } = t, { variantStyle: a } = t;
        o === "normal" && !a && /[\u00A3\u0131\u0237]/.test(e.value) && (o = "main", a = "italic"), o === "normal" && !a && e.value.length === 1 && cc.forEach((c, u) => {
          c.test(e.value) && uc[i][u] === "it" && (a = "italic");
        }), a === "up" && (a = void 0);
        let n = a ? o + "-" + a : o;
        let [s, l] = is[n];
        return os[o] && !os[o].test(e.value) ? (e.value = Dn(e.value, o, a), null) : (as.test(e.value) && (e.classes += " lcGreek"), l && (e.classes += " " + l), s);
      }
    };
    function dc(r, e) {
      var a;
      let { parent: t } = r[0], i = ua(t), o = (a = t == null ? void 0 : t.mode) != null ? a : "math";
      return j(Re(r, "variant").map((n) => {
        let s = ua(n[0]);
        if (n.every((c) => {
          let u = c.context.getDefinition(c.command, o);
          return !u || u.definitionType === "function" || !u.variant ? false : ua(c) === s;
        }))
          return j(n.map((c) => g.serialize(c, e)));
        let l = "";
        return s && s !== i && (l = { calligraphic: "\\mathcal{", fraktur: "\\mathfrak{", "double-struck": "\\mathbb{", script: "\\mathscr{", monospace: "\\mathtt{", "sans-serif": "\\mathsf{", normal: "\\mathrm{", "normal-italic": "\\mathnormal{", "normal-bold": "\\mathbf{", "normal-bolditalic": "\\mathbfit{", ams: "", "ams-italic": "\\mathit{", "ams-bold": "\\mathbf{", "ams-bolditalic": "\\mathbfit{", main: "", "main-italic": "\\mathit{", "main-bold": "\\mathbf{", "main-bolditalic": "\\mathbfit{" }[s]), l ? l + j(n.map((c) => g.serialize(c, e))) + "}" : j(n.map((c) => g.serialize(c, e)));
      }));
    }
    function mc(r, e) {
      let { parent: t } = r[0], i = t == null ? void 0 : t.computedStyle.color;
      return j(Re(r, "color").map((o) => {
        var s, l;
        let a = dc(o, e), n = o[0].computedStyle;
        return !((s = e.skipStyles) != null && s) && n.color && (!t || i !== n.color) ? "\\textcolor{" + ((l = n.verbatimColor) != null ? l : n.color) + "}{" + a + "}" : a;
      }));
    }
    function pc(r, e) {
      let { parent: t } = r[0], i = t == null ? void 0 : t.computedStyle.backgroundColor;
      return j(Re(r, "backgroundColor").map((o) => {
        var s, l;
        let a = mc(o, e), n = o[0].computedStyle;
        return !((s = e.skipStyles) != null && s) && a.trim() && n.backgroundColor && (!t || i !== n.backgroundColor) && (o.length > 0 || !(o[0] instanceof et)) && (a = `\\ensuremath{${a}}`, a = `\\colorbox{${(l = n.verbatimBackgroundColor) != null ? l : n.backgroundColor}}{${a}}`), a;
      }));
    }
    function ua(r) {
      if (!r)
        return "";
      let { style: e } = r;
      if (e.variant === void 0)
        return "";
      let t = e.variant;
      return e.variantStyle && e.variantStyle !== "up" && (t += "-" + e.variantStyle), t;
    }
    new da();
    function Zr(r) {
      return [j(r.map((e) => e[0])), r.map((e) => e[1]).some((e) => e === true)];
    }
    function hc(r, e) {
      return [j(r.map((t) => g.serialize(t, e))), true];
    }
    function fc(r, e) {
      return Zr(Re(r, "fontShape").map((t) => {
        let [i, o] = hc(t, e), { fontShape: a } = t[0].style;
        return a === "it" ? ["\\textit{" + i + "}", false] : a === "sl" ? ["\\textsl{" + i + "}", false] : a === "sc" ? ["\\textsc{" + i + "}", false] : a === "n" ? ["\\textup{" + i + "}", false] : a ? [`{\\fontshape{${t[0].style.fontShape}}${i}`, false] : [i, o];
      }));
    }
    function gc(r, e) {
      return Zr(Re(r, "fontSeries").map((t) => {
        let [i, o] = fc(t, e), { fontSeries: a } = t[0].style;
        return a === "b" ? [`\\textbf{${i}}`, false] : a === "l" ? [`\\textlf{${i}}`, false] : a === "m" ? [`\\textmd{${i}}`, false] : a ? [`\\fontseries{${a}}${i}`, false] : [i, o];
      }));
    }
    function yc(r, e) {
      return Zr(Re(r, "fontSize").map((t) => {
        var n, s;
        let [i, o] = gc(t, e), a = (s = ["", "tiny", "scriptsize", "footnotesize", "small", "normalsize", "large", "Large", "LARGE", "huge", "Huge"][(n = t[0].style.fontSize) != null ? n : ""]) != null ? s : "";
        return a ? [`{\\${a} ${i}}`, o] : [i, o];
      }));
    }
    function bc(r, e) {
      return Zr(Re(r, "fontFamily").map((t) => {
        var n, s;
        let [i, o] = yc(t, e), a = (s = { roman: "textrm", monospace: "texttt", "sans-serif": "textsf" }[(n = t[0].style.fontFamily) != null ? n : ""]) != null ? s : "";
        return a ? [`\\${a}{${i}}`, false] : t[0].style.fontFamily ? [`\\fontfamily{${t[0].style.fontFamily}}${i}`, o] : [i, o];
      }));
    }
    function xc(r, e) {
      return bc(r, e);
    }
    function vc(r, e) {
      return Zr(Re(r, "backgroundColor").map((t) => {
        var n, s;
        let [i, o] = wc(t, e), a = t[0].computedStyle;
        return !((n = e.skipStyles) != null && n) && a.backgroundColor && a.backgroundColor !== "none" ? [`\\colorbox{${(s = a.verbatimBackgroundColor) != null ? s : a.backgroundColor}}{${i}}`, false] : [i, o];
      }));
    }
    function wc(r, e) {
      var i;
      if (!r || r.length === 0)
        return ["", false];
      let t = (i = r[0].parent) == null ? void 0 : i.style.color;
      return Zr(Re(r, "color").map((o) => {
        var s, l;
        let [a, n] = xc(o, e);
        return !((s = e.skipStyles) != null && s) && o[0].style.color && o[0].style.color !== "none" && t !== o[0].style.color ? [`\\textcolor{${(l = o[0].style.verbatimColor) != null ? l : o[0].style.color}}{${a}}`, false] : [a, n];
      }));
    }
    var ns = { roman: "", "sans-serif": "ML__sans", monospace: "ML__tt" }, ma = class extends Te {
      constructor() {
        super("text");
      }
      createAtom(e, t, i) {
        let o = t.getDefinition(e, "text");
        return o && o.definitionType === "symbol" ? new Je(e, String.fromCodePoint(o.codepoint), i != null ? i : {}, t) : null;
      }
      serialize(e, t) {
        var a;
        let [i, o] = vc(e, t);
        return ((a = t.skipModeCommand) != null ? a : false) === true && (o = false), o && (i = `\\text{${i}}`), i;
      }
      applyStyle(e, t) {
        var o, a, n, s, l;
        let { fontFamily: i } = t;
        if (ns[i] ? e.classes += " " + ns[i] : i && e.setStyle("font-family", i), t.fontShape && (e.classes += " ", e.classes += (o = { it: "ML__it", sl: "ML__shape_sl", sc: "ML__shape_sc", ol: "ML__shape_ol" }[t.fontShape]) != null ? o : ""), t.fontSeries) {
          let c = t.fontSeries.match(/(.?[lbm])?(.?[cx])?/);
          c && (e.classes += " ", e.classes += (n = { ul: "ML__series_ul", el: "ML__series_el", l: "ML__series_l", sl: "ML__series_sl", m: "", sb: "ML__series_sb", b: "ML__bold", eb: "ML__series_eb", ub: "ML__series_ub" }[(a = c[1]) != null ? a : ""]) != null ? n : "", e.classes += " ", e.classes += (l = { uc: "ML__series_uc", ec: "ML__series_ec", c: "ML__series_c", sc: "ML__series_sc", n: "", sx: "ML__series_sx", x: "ML__series_x", ex: "ML__series_ex", ux: "ML__series_ux" }[(s = c[2]) != null ? s : ""]) != null ? l : "");
        }
        return "Main-Regular";
      }
    };
    new ma();
    var pa = class extends Te {
      constructor() {
        super("latex");
      }
      createAtom(e, t, i) {
        return new ae(e, t);
      }
      serialize(e, t) {
        return e.filter((i) => i instanceof ae && !i.isSuggestion).map((i) => i.value).join("");
      }
      applyStyle() {
        return null;
      }
    };
    new pa();
    var rt = { "\\ne": "<mo>&ne;</mo>", "\\neq": "<mo>&neq;</mo>", "\\pm": "&#177;", "\\times": "&#215;", "\\colon": ":", "\\vert": "|", "\\Vert": "∥", "\\mid": "∣", "\\lbrace": "{", "\\rbrace": "}", "\\lparen": "(", "\\rparen": ")", "\\langle": "⟨", "\\rangle": "⟩", "\\lfloor": "⌊", "\\rfloor": "⌋", "\\lceil": "⌈", "\\rceil": "⌉", "\\vec": "&#x20d7;", "\\acute": "&#x00b4;", "\\grave": "&#x0060;", "\\dot": "&#x02d9;", "\\ddot": "&#x00a8;", "\\tilde": "&#x007e;", "\\bar": "&#x00af;", "\\breve": "&#x02d8;", "\\check": "&#x02c7;", "\\hat": "&#x005e;" }, ss = "<mo>&#x2061;</mo>", fa = "<mo>&#8290;</mo>";
    function bo(r) {
      return r.replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function le(r, e) {
      return !r || !e.generateID ? "" : ` extid="${r}"`;
    }
    function kc(r, e, t) {
      var s, l, c, u, d, m, h, f;
      let i = false;
      e = e != null ? e : r.atoms.length;
      let o = "", a = "", n = r.atoms[r.index];
      if (n.command === "\\operatorname")
        a = Mi(n.body), r.index += 1;
      else {
        let y = (l = (s = n.style) == null ? void 0 : s.variant) != null ? l : "", w = (u = (c = n.style) == null ? void 0 : c.variantStyle) != null ? u : "";
        for (; r.index < e && (n.type === "mord" || n.type === "macro") && !n.isDigit() && y === ((m = (d = n.style) == null ? void 0 : d.variant) != null ? m : "") && w === ((f = (h = n.style) == null ? void 0 : h.variantStyle) != null ? f : ""); )
          a += Mi([n]), r.index += 1, n = r.atoms[r.index];
      }
      return a.length > 0 && (i = true, o = `<mi>${a}</mi>`, (r.lastType === "mi" || r.lastType === "mn" || r.lastType === "mtext" || r.lastType === "fence") && !/^<mo>(.*)<\/mo>$/.test(o) && (o = fa + o), a.endsWith(">f</mi>") || a.endsWith(">g</mi>") ? (o += ss, r.lastType = "applyfunction") : r.lastType = /^<mo>(.*)<\/mo>$/.test(o) ? "mo" : "mi", Ai(a, r, t) || (r.mathML += o)), i;
    }
    function Sc(r) {
      return r.index < r.atoms.length && r.atoms[r.index].superscript && r.atoms[r.index].type === "msubsup";
    }
    function _c(r) {
      let e = -1, t = r.index, i = false, o = false;
      for (; t < r.atoms.length && !i && !o; ) {
        let a = r.atoms[t];
        i = !a.isDigit(), o = !i && a.superscript !== void 0, t++;
      }
      return o && (e = t - 1), e;
    }
    function Ai(r, e, t) {
      var s;
      let i = e.atoms[e.index - 1];
      if (!i)
        return false;
      if (!i.superscript && !i.subscript)
        if (((s = e.atoms[e.index]) == null ? void 0 : s.type) === "msubsup")
          i = e.atoms[e.index], e.index += 1;
        else
          return false;
      let o = V(i.superscript, t), a = V(i.subscript, t);
      if (!o && !a)
        return false;
      let n = "";
      return o && a ? n = `<msubsup>${r}${a}${o}</msubsup>` : o ? n = `<msup>${r}${o}</msup>` : a && (n = `<msub>${r}${a}</msub>`), e.mathML += n, e.lastType = "", true;
    }
    function Mc(r, e, t) {
      e = e != null ? e : r.atoms.length;
      let i = r.index, o = "";
      for (; r.index < e && r.atoms[r.index].mode === "text"; )
        o += r.atoms[r.index].value ? r.atoms[r.index].value : " ", r.index += 1;
      return o.length > 0 ? (r.mathML += `<mtext ${le(r.atoms[i].id, t)}
      >${o}</mtext>`, r.lastType = "mtext", true) : false;
    }
    function Ac(r, e, t) {
      e = e != null ? e : r.atoms.length;
      let i = r.index, o = "", a = _c(r);
      for (a >= 0 && a < e && (e = a); r.index < e && r.atoms[r.index].isDigit(); )
        o += r.atoms[r.index].asDigit(), r.index += 1;
      return o.length <= 0 ? false : (o = "<mn" + le(r.atoms[i].id, t) + ">" + o + "</mn>", a < 0 && Sc(r) && (a = r.index, r.index += 1), Ai(o, r, t) || (r.mathML += o, r.lastType = "mn"), true);
    }
    function Lc(r, e, t) {
      let i = false;
      e = e != null ? e : r.atoms.length;
      let o = "", a = "";
      if (r.index < e && r.atoms[r.index].type === "mopen") {
        let n = false, s = 0, l = r.index, c = -1, u = l + 1;
        for (; u < e && !n; )
          r.atoms[u].type === "mopen" ? s += 1 : r.atoms[u].type === "mclose" && (s -= 1), s === -1 && (n = true, c = u), u += 1;
        n && (o = "<mrow>", o += Ar(r.atoms[l], t), o += V(r.atoms, t, l + 1, c), o += Ar(r.atoms[c], t), o += "</mrow>", r.index = c + 1, (r.lastType === "mi" || r.lastType === "mn" || r.lastType === "mfrac" || r.lastType === "fence") && (r.mathML += fa), Ai(o, r, t) && (i = true, r.lastType = "", o = ""), a = "fence");
      }
      return o.length > 0 && (i = true, r.mathML += o, r.lastType = a), i;
    }
    function Cc(r, e, t) {
      let i = false;
      e = e != null ? e : r.atoms.length;
      let o = "", a = "", n = r.atoms[r.index];
      if (r.index < e && (n.type === "mbin" || n.type === "mrel"))
        o += ha(r.atoms[r.index], t), r.index += 1, a = "mo";
      else if (r.index < e && n.type === "mop") {
        if (n.subsupPlacement === "over-under" && (n.superscript || n.subscript)) {
          let s = Ar(n, t);
          n.superscript && n.subscript ? (o += "<munderover>" + s, o += V(n.subscript, t), o += V(n.superscript, t), o += "</munderover>") : n.superscript ? (o += "<mover>" + s, o += V(n.superscript, t), o += "</mover>") : n.subscript && (o += "<munder>" + s, o += V(n.subscript, t), o += "</munder>"), a = "mo";
        } else {
          let s = r.atoms[r.index], l = s.value === "\\operatorname", c = l ? '<mi class="MathML-Unit"' + le(s.id, t) + ">" + Mi(s.value) + "</mi>" : Ar(s, t);
          o += c, !l && !/^<mo>(.*)<\/mo>$/.test(c) ? (o += ss, a = "applyfunction") : a = l ? "mi" : "mo";
        }
        (r.lastType === "mi" || r.lastType === "mn") && !/^<mo>(.*)<\/mo>$/.test(o) && (o = fa + o), r.index += 1;
      }
      return o.length > 0 && (i = true, Ai(o, r, t) || (r.mathML += o, r.lastType = a)), i;
    }
    function V(r, e, t, i) {
      e != null || (e = {});
      let o = { atoms: [], index: t != null ? t : 0, mathML: "", lastType: "" };
      if (typeof r == "number" || typeof r == "boolean")
        o.mathML = r.toString();
      else if (typeof r == "string")
        o.mathML = r;
      else if (r instanceof g)
        o.mathML = ha(r, e);
      else if (Array.isArray(r)) {
        o.atoms = r;
        let a = 0;
        for (i = i || (r ? r.length : 0); o.index < i; )
          if (Mc(o, i, e) || Ac(o, i, e) || kc(o, i, e) || Cc(o, i, e) || Lc(o, i, e))
            a += 1;
          else if (o.index < i) {
            let n = ha(o.atoms[o.index], e);
            o.lastType === "mn" && n.length > 0 && o.atoms[o.index].type === "genfrac" && (n = "<mo>&#x2064;</mo>" + n), o.atoms[o.index].type === "genfrac" ? o.lastType = "mfrac" : o.lastType = "", o.index += 1, Ai(n, o, e) ? a += 1 : n.length > 0 && (o.mathML += n, a += 1);
          }
        a > 1 && (o.mathML = "<mrow>" + o.mathML + "</mrow>");
      }
      return o.mathML;
    }
    function Ar(r, e) {
      let t = "", i = Mi(r.value);
      return i && (t = "<mo" + le(r.id, e) + ">" + i + "</mo>"), t;
    }
    function Mi(r) {
      if (!r)
        return "";
      if (typeof r == "string")
        return bo(r);
      if (!Array.isArray(r) && typeof r.body == "string")
        return bo(r.body);
      let e = "";
      for (let t of r)
        typeof t.value == "string" && (e += t.value);
      return bo(e);
    }
    function ha(r, e) {
      var w, k, S, T, C, K, M, R, F, Le, Pe, vt, Jt, Wt, _e, di, mi, me, ke, Ke, pt, wt, Ut, jt, Gi;
      let t = { widehat: "^", widecheck: "ˇ", widetilde: "~", utilde: "~", overleftarrow: "←", underleftarrow: "←", xleftarrow: "←", overrightarrow: "→", underrightarrow: "→", xrightarrow: "→", underbrace: "⏟", overbrace: "⏞", overgroup: "⏠", undergroup: "⏡", overleftrightarrow: "↔", underleftrightarrow: "↔", xleftrightarrow: "↔", Overrightarrow: "⇒", xRightarrow: "⇒", overleftharpoon: "↼", xleftharpoonup: "↼", overrightharpoon: "⇀", xrightharpoonup: "⇀", xLeftarrow: "⇐", xLeftrightarrow: "⇔", xhookleftarrow: "↩", xhookrightarrow: "↪", xmapsto: "↦", xrightharpoondown: "⇁", xleftharpoondown: "↽", xrightleftharpoons: "⇌", xleftrightharpoons: "⇋", xtwoheadleftarrow: "↞", xtwoheadrightarrow: "↠", xlongequal: "=", xtofrom: "⇄", xrightleftarrows: "⇄", xrightequilibrium: "⇌", xleftequilibrium: "⇋" }, i = { "\\exponentialE": "&#x02147;", "\\imaginaryI": "&#x2148;", "\\differentialD": "&#x2146;", "\\capitalDifferentialD": "&#x2145;", "\\alpha": "&#x03b1;", "\\pi": "&#x03c0;", "\\infty": "&#x221e;", "\\forall": "&#x2200;", "\\nexists": "&#x2204;", "\\exists": "&#x2203;", "\\hbar": "ℏ", "\\cdotp": "⋅", "\\ldots": "…", "\\cdots": "⋯", "\\ddots": "⋱", "\\vdots": "⋮", "\\ldotp": "." }, o = { cal: "script", frak: "fraktur", bb: "double-struck", scr: "script", cmtt: "monospace", cmss: "sans-serif" }, a = { "\\!": -3 / 18, "\\ ": 6 / 18, "\\,": 3 / 18, "\\:": 4 / 18, "\\;": 5 / 18, "\\enspace": 0.5, "\\quad": 1, "\\qquad": 2, "\\enskip": 0.5 }, n = "", s = "", l, c, u, d, m, h, f = (k = o[(w = r.fontFamily) != null ? w : r.font]) != null ? k : "";
      f && (f = ` mathvariant="${f}"`);
      let { command: y } = r;
      if (r.mode === "text")
        n = `<mi${le(r.id, e)}>${r.value}</mi>`;
      else
        switch (r.type) {
          case "first":
            break;
          case "group":
          case "root":
            rt[r.command] ? n = rt[r.command] : n = V(r.body, e);
            break;
          case "array":
            if ((r.leftDelim && r.leftDelim !== "." || r.rightDelim && r.rightDelim !== ".") && (n += "<mrow>", r.leftDelim && r.leftDelim !== "." && (n += "<mo>" + (rt[r.leftDelim] || r.leftDelim) + "</mo>")), n += "<mtable", r.colFormat) {
              for (n += ' columnalign="', u = 0; u < r.colFormat.length; u++)
                r.colFormat[u].align && (n += { l: "left", c: "center", r: "right" }[r.colFormat[u].align] + " ");
              n += '"';
            }
            for (n += ">", c = 0; c < r.array.length; c++) {
              for (n += "<mtr>", l = 0; l < r.array[c].length; l++)
                n += "<mtd>" + V(r.array[c][l], e) + "</mtd>";
              n += "</mtr>";
            }
            n += "</mtable>", (r.leftDelim && r.leftDelim !== "." || r.rightDelim && r.rightDelim !== ".") && (r.rightDelim && r.rightDelim !== "." && (n += "<mo>" + (rt[r.leftDelim] || r.rightDelim) + "</mo>"), n += "</mrow>");
            break;
          case "genfrac":
            (r.leftDelim || r.rightDelim) && (n += "<mrow>"), r.leftDelim && r.leftDelim !== "." && (n += "<mo" + le(r.id, e) + ">" + (rt[r.leftDelim] || r.leftDelim) + "</mo>"), r.hasBarLine ? (n += "<mfrac>", n += V(r.above, e) || "<mi>&nbsp;</mi>", n += V(r.below, e) || "<mi>&nbsp;</mi>", n += "</mfrac>") : (n += "<mtable" + le(r.id, e) + ">", n += "<mtr>" + V(r.above, e) + "</mtr>", n += "<mtr>" + V(r.below, e) + "</mtr>", n += "</mtable>"), r.rightDelim && r.rightDelim !== "." && (n += "<mo" + le(r.id, e) + ">" + (rt[r.rightDelim] || r.rightDelim) + "</mo>"), (r.leftDelim || r.rightDelim) && (n += "</mrow>");
            break;
          case "surd":
            r.hasEmptyBranch("above") ? (n += "<msqrt" + le(r.id, e) + ">", n += V(r.body, e), n += "</msqrt>") : (n += "<mroot" + le(r.id, e) + ">", n += V(r.body, e), n += V(r.above, e), n += "</mroot>");
            break;
          case "leftright":
            n = "<mrow>", r.leftDelim && r.leftDelim !== "." && (n += "<mo" + le(r.id, e) + ">" + ((S = rt[r.leftDelim]) != null ? S : r.leftDelim) + "</mo>"), r.body && (n += V(r.body, e)), r.rightDelim && r.rightDelim !== "." && (n += "<mo" + le(r.id, e) + ">" + ((T = rt[r.rightDelim]) != null ? T : r.rightDelim) + "</mo>"), n += "</mrow>";
            break;
          case "sizeddelim":
          case "delim":
            n += '<mo separator="true"' + le(r.id, e) + ">" + (rt[r.delim] || r.delim) + "</mo>";
            break;
          case "accent":
            n += '<mover accent="true"' + le(r.id, e) + ">", n += V(r.body, e), n += "<mo>" + (rt[y] || r.accent) + "</mo>", n += "</mover>";
            break;
          case "line":
          case "overlap":
            break;
          case "overunder":
            m = r.above, d = r.below, (r.svgAbove || m) && (r.svgBelow || d) ? h = r.body : m && m.length > 0 ? (h = r.body, (K = (C = r.body) == null ? void 0 : C[0]) != null && K.below ? (d = r.body[0].below, h = r.body[0].body) : ((R = (M = r.body) == null ? void 0 : M[0]) == null ? void 0 : R.type) === "first" && ((Le = (F = r.body) == null ? void 0 : F[1]) != null && Le.below) && (d = r.body[1].below, h = r.body[1].body)) : d && d.length > 0 && (h = r.body, (vt = (Pe = r.body) == null ? void 0 : Pe[0]) != null && vt.above ? (m = r.body[0].above, h = r.body[0].body) : ((Wt = (Jt = r.body) == null ? void 0 : Jt[0]) == null ? void 0 : Wt.type) === "first" && ((di = (_e = r.body) == null ? void 0 : _e[1]) != null && di.above) && (m = r.body[1].overscript, h = r.body[1].body)), (r.svgAbove || m) && (r.svgBelow || d) ? (n += `<munderover ${f} ${le(r.id, e)}>`, n += (mi = t[r.svgBody]) != null ? mi : V(h, e), n += (me = t[r.svgBelow]) != null ? me : V(d, e), n += (ke = t[r.svgAbove]) != null ? ke : V(m, e), n += "</munderover>") : r.svgAbove || m ? (n += `<mover ${f} ${le(r.id, e)}>` + ((Ke = t[r.svgBody]) != null ? Ke : V(h, e)), n += (pt = t[r.svgAbove]) != null ? pt : V(m, e), n += "</mover>") : (r.svgBelow || d) && (n += `<munder ${f} ${le(r.id, e)}>` + ((wt = t[r.svgBody]) != null ? wt : V(h, e)), n += (Ut = t[r.svgBelow]) != null ? Ut : V(d, e), n += "</munder>");
            break;
          case "placeholder":
          case "mord": {
            n = i[y] || y || (typeof r.value == "string" ? r.value : "");
            let Ye = y ? y.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null;
            Ye ? n = "&#x" + Ye[1] + ";" : n.length > 0 && n.startsWith("\\") && (typeof r.value == "string" && r.value.charCodeAt(0) > 255 ? n = "&#x" + ("000000" + r.value.charCodeAt(0).toString(16)).slice(-4) + ";" : typeof r.value == "string" ? n = r.value.charAt(0) : n = "");
            let un = /\d/.test(n) ? "mn" : "mi";
            n = `<${un}${f}${le(r.id, e)}>${bo(n)}</${un}>`;
            break;
          }
          case "mbin":
          case "mrel":
          case "minner":
            y && i[y] ? n = "<mi" + le(r.id, e) + ">" + i[y] + "</mi>" : y && rt[y] ? n = "<mo" + le(r.id, e) + ">" + rt[y] + "</mo>" : n = Ar(r, e);
            break;
          case "mpunct":
            n = '<mo separator="true"' + le(r.id, e) + ">" + ((jt = rt[y]) != null ? jt : y) + "</mo>";
            break;
          case "mop":
            r.body !== "​" && (n = "<mo" + le(r.id, e) + ">", n += y === "\\operatorname" ? r.body : y || r.body, n += "</mo>");
            break;
          case "box":
            n = '<menclose notation="box"', r.backgroundcolor && (n += ' mathbackground="' + r.backgroundcolor + '"'), n += le(r.id, e) + ">" + V(r.body, e) + "</menclose>";
            break;
          case "spacing":
            n += '<mspace width="' + ((Gi = a[y]) != null ? Gi : 0) + 'em"/>';
            break;
          case "enclose":
            n = '<menclose notation="';
            for (let Ye in r.notation)
              Object.prototype.hasOwnProperty.call(r.notation, Ye) && r.notation[Ye] && (n += s + Ye, s = " ");
            n += le(r.id, e) + '">' + V(r.body, e) + "</menclose>";
            break;
          case "prompt":
            n = '<menclose notation="roundexbox""">' + V(r.body, e) + "</menclose>";
            break;
          case "space":
            n += "&nbsp;";
            break;
          case "msubsup":
            break;
          case "phantom":
            break;
          case "composition":
            break;
          case "rule":
            "" + r.type;
            break;
          case "chem":
            break;
          case "mopen":
            n += Ar(r, e);
            break;
          case "mclose":
            n += Ar(r, e);
            break;
          case "macro":
            {
              let Ye = r.command + Mi(r.macroArgs);
              Ye && (n += `<mo ${le(r.id, e)}>${Ye}</mo>`);
            }
            break;
          case "error":
            "" + r.type;
            break;
          case "latexgroup":
            n += V(r.body, e);
            break;
          case "latex":
            n += "<mtext" + le(r.id, e) + ">" + r.value + "</mtext>";
            break;
          case "tooltip":
            n += V(r.body, e);
            break;
          default:
            "" + r.type;
        }
      return n;
    }
    var Li = { "\\ne": "≠", "\\neq": "≠", "−": "-", "-": "-", "\\alpha": "alpha", "\\beta": "beta", "\\gamma": "gamma", "\\delta": "delta", "\\epsilon": "epsilon", "\\varepsilon": "varepsilon", "\\zeta": "zeta", "\\eta": "eta", "\\theta": "theta", "\\vartheta": "vartheta", "\\iota": "iota", "\\kappa": "kappa", "\\lambda": "lambda", "\\mu": "mu", "\\nu": "nu", "\\xi": "xi", "\\pi": "pi", "\\rho": "rho", "\\sigma": "sigma", "\\tau": "tau", "\\upsilon": "upsilon", "\\phi": "phi", "\\varphi": "varphi", "\\chi": "chi", "\\psi": "psi", "\\omega": "omega", "\\Gamma": "Gamma", "\\Delta": "Delta", "\\Theta": "Theta", "\\Lambda": "Lambda", "\\Xi": "Xi", "\\Pi": "Pi", "\\Sigma": "Sigma", "\\Phi": "Phi", "\\Psi": "Psi", "\\Omega": "Omega", "\\exponentialE": "e", "\\imaginaryI": "i", "\\imaginaryJ": "j", "\\!": " ", "\\,": " ", "\\:": " ", "\\;": " ", "\\enskip": " ", "\\enspace": " ", "\\qquad": " ", "\\quad": " " }, ga = { "\\pm": "+-", "\\times": "xx", "\\colon": ":", "\\vert": "|", "\\Vert": "||", "\\mid": "|", "\\lbrace": "{", "\\rbrace": "}", "\\lparen": "(", "\\rparen": ")", "\\langle": "(:", "\\rangle": ":)" };
    function ue(r) {
      var o, a, n, s, l, c, u, d, m, h, f, y, w;
      if (!r)
        return "";
      if (Y(r)) {
        if (r.length === 0 || (r[0].type === "first" && (r = r.slice(1)), r.length === 0))
          return "";
        let k = "";
        if (r[0].mode === "latex")
          for (let S of r)
            k += ue(S);
        else if (r[0].mode === "text") {
          let S = 0;
          for (k = '"'; ((o = r[S]) == null ? void 0 : o.mode) === "text"; )
            k += r[S].body ? ue(r[S].body) : r[S].value, S++;
          k += '"' + ue(r.slice(S));
        } else if (r[0].mode === "math") {
          let S = 0;
          for (; r[S] && r[S].mode === "math"; )
            k += ue(r[S]), S++;
          k += ue(r.slice(S));
        } else
          console.warn("toASCIIMath: Unexpected mode");
        return k.trim();
      }
      if (r.mode === "text")
        return '"' + r.value + '"';
      let e = "", { command: t } = r, i;
      switch (r.type) {
        case "first":
          return "";
        case "group":
        case "root":
          e = (a = Li[t]) != null ? a : ue(r.body);
          break;
        case "genfrac":
          {
            let M = r;
            (M.leftDelim || M.rightDelim) && (e += M.leftDelim === "." || !M.leftDelim ? "{:" : M.leftDelim), M.hasBarLine ? (e += "(", e += ue(M.above), e += ")/(", e += ue(M.below), e += ")") : (e += "(" + ue(M.above) + "),", e += "(" + ue(M.below) + ")"), (M.leftDelim || M.rightDelim) && (e += M.rightDelim === "." || !M.rightDelim ? "{:" : M.rightDelim);
          }
          break;
        case "surd":
          e += r.hasEmptyBranch("above") ? "sqrt(" + ue(r.body) + ")" : "root(" + ue(r.above) + ")(" + ue(r.body) + ")";
          break;
        case "latex":
          e = r.value;
          break;
        case "leftright":
          {
            let M = r;
            e += M.leftDelim === "." || !M.leftDelim ? "{:" : M.leftDelim, e += ue(M.body), e += M.rightDelim === "." || !M.rightDelim ? ":}" : M.rightDelim;
          }
          break;
        case "sizeddelim":
        case "delim":
          break;
        case "overlap":
          break;
        case "overunder":
          break;
        case "mord":
          e = (s = (n = Li[t]) != null ? n : t) != null ? s : typeof r.value == "string" ? r.value : "", e.startsWith("\\") && (e += " "), i = t ? t.match(/{?\\char"([\dabcdefABCDEF]*)}?/) : null, i ? e = String.fromCodePoint(Number.parseInt("0x" + i[1])) : e.length > 0 && e.startsWith("\\") && (e = typeof r.value == "string" ? r.value.charAt(0) : r.command);
          break;
        case "mbin":
        case "mrel":
        case "minner":
          e = (c = (l = Li[t]) != null ? l : ga[t]) != null ? c : r.value;
          break;
        case "mopen":
        case "mclose":
          e += r.value;
          break;
        case "mpunct":
          e = (u = ga[t]) != null ? u : t;
          break;
        case "mop":
          r.value !== "​" && (e = "", e += t === "\\operatorname" ? ue(r.body) : (d = r.value) != null ? d : t, e += " ");
          break;
        case "array":
          let k = r.array, S = r.environmentName, T = (m = { bmatrix: ["[", "]"], "bmatrix*": ["[", "]"] }[S]) != null ? m : ["(", ")"], C = [];
          for (let M of k) {
            let R = [];
            for (let F of M)
              R.push(T[0] + ue(F) + T[1]);
            C.push(R.join(","));
          }
          let K = (h = { bmatrix: ["[", "]"], "bmatrix*": ["[", "]"], cases: ["{", ":}"] }[S]) != null ? h : ["(", ")"];
          e = K[0] + C.join(",") + K[1];
          break;
        case "box":
          break;
        case "spacing":
          e = (f = Li[t]) != null ? f : " ";
          break;
        case "enclose":
          e = "(" + ue(r.body) + ")";
          break;
        case "space":
          e = " ";
          break;
        case "msubsup":
          e = "";
          break;
        case "macro":
          e = (w = (y = Li[t]) != null ? y : ga[t]) != null ? w : ue(r.body);
          break;
      }
      if (!r.hasEmptyBranch("subscript")) {
        e += "_";
        let k = ue(r.subscript);
        e += k.length > 1 ? "(" + k + ")" : k;
      }
      if (!r.hasEmptyBranch("superscript")) {
        e += "^";
        let k = ue(r.superscript);
        e += k.length > 1 ? "(" + k + ")" : k;
      }
      return e;
    }
    var Yr = { "\\alpha": "alpha ", "\\mu": "mew ", "\\sigma": "sigma ", "\\pi": "pie ", "\\imaginaryI": "eye ", "\\sum": "Summation ", "\\prod": "Product ", "+": "plus ", "-": "minus ", ";": '<break time="150ms"/> semi-colon <break time="150ms"/>', ",": '<break time="150ms"/> comma  <break time="150ms"/>', "|": '<break time="150ms"/>Vertical bar<break time="150ms"/>', "(": '<break time="150ms"/>Open paren. <break time="150ms"/>', ")": '<break time="150ms"/> Close paren. <break time="150ms"/>', "=": "equals ", "<": "is less than ", "\\lt": "is less than ", "<=": "is less than or equal to ", "\\le": "is less than or equal to ", "\\gt": "is greater than ", ">": "is greater than ", "\\pm": "plus or minus", "\\mp": "minus or plus", "\\ge": "is greater than or equal to ", "\\geq": "is greater than or equal to ", "\\leq": "is less than or equal to ", "!": "factorial ", "\\sin": "sine ", "\\cos": "cosine ", "​": "", "−": "minus ", ":": '<break time="150ms"/> such that <break time="200ms"/> ', "\\colon": '<break time="150ms"/> such that <break time="200ms"/> ', "\\hbar": "etch bar ", "\\iff": '<break time="200ms"/>if, and only if, <break time="200ms"/>', "\\Longleftrightarrow": '<break time="200ms"/>if, and only if, <break time="200ms"/>', "\\land": "and ", "\\lor": "or ", "\\neg": "not ", "\\div": "divided by ", "\\forall": "for all ", "\\exists": "there exists ", "\\nexists": "there does not exists ", "\\in": "element of ", "\\N": 'the set <break time="150ms"/><say-as interpret-as="character">n</say-as>', "\\C": 'the set <break time="150ms"/><say-as interpret-as="character">c</say-as>', "\\Z": 'the set <break time="150ms"/><say-as interpret-as="character">z</say-as>', "\\Q": 'the set <break time="150ms"/><say-as interpret-as="character">q</say-as>', "\\infty": "infinity ", "\\nabla": "nabla ", "\\partial": "partial derivative of ", "\\cdot": "times ", "\\cdots": "dot dot dot ", "\\Rightarrow": "implies ", "\\lparen": '<break time="150ms"/>open paren<break time="150ms"/>', "\\rparen": '<break time="150ms"/>close paren<break time="150ms"/>', "\\lbrace": '<break time="150ms"/>open brace<break time="150ms"/>', "\\{": '<break time="150ms"/>open brace<break time="150ms"/>', "\\rbrace": '<break time="150ms"/>close brace<break time="150ms"/>', "\\}": '<break time="150ms"/>close brace<break time="150ms"/>', "\\langle": '<break time="150ms"/>left angle bracket<break time="150ms"/>', "\\rangle": '<break time="150ms"/>right angle bracket<break time="150ms"/>', "\\lfloor": '<break time="150ms"/>open floor<break time="150ms"/>', "\\rfloor": '<break time="150ms"/>close floor<break time="150ms"/>', "\\lceil": '<break time="150ms"/>open ceiling<break time="150ms"/>', "\\rceil": '<break time="150ms"/>close ceiling<break time="150ms"/>', "\\vert": '<break time="150ms"/>vertical bar<break time="150ms"/>', "\\mvert": '<break time="150ms"/>divides<break time="150ms"/>', "\\lvert": '<break time="150ms"/>left vertical bar<break time="150ms"/>', "\\rvert": '<break time="150ms"/>right vertical bar<break time="150ms"/>', "\\lbrack": '<break time="150ms"/> open square bracket <break time="150ms"/>', "\\rbrack": '<break time="150ms"/> close square bracket <break time="150ms"/>', mm: "millimeters", cm: "centimeters", km: "kilometers", kg: "kilograms" }, ya = { array: "array", matrix: "matrix", pmatrix: "parenthesis matrix", bmatrix: "square brackets matrix", Bmatrix: "braces matrix", vmatrix: "bars matrix", Vmatrix: "double bars matrix", "matrix*": "matrix", smallmatrix: "small matrix" };
    function Tc(r) {
      let e = "";
      return r.startsWith("\\") && (e = " " + r.replace("\\", "") + " "), e;
    }
    function Ci(r) {
      let e = 0;
      if (Y(r))
        for (let t of r)
          t.type !== "first" && (e += 1);
      return e === 1;
    }
    function Ec(r) {
      if (Y(r)) {
        for (let e of r)
          if (e.type !== "first" && e.id)
            return e.id.toString();
      }
      return "";
    }
    function ls(r) {
      let e = "";
      if (Y(r))
        for (let t of r)
          t.type !== "first" && typeof t.value == "string" && (e += t.value);
      return e;
    }
    function Pc(r) {
      return r ? r.map((e) => e.value).join("") : "";
    }
    function ee(r, e) {
      var a, n, s, l, c;
      function t(u) {
        return window.MathfieldElement.textToSpeechMarkup ? /[a-z]/.test(u) ? ` <say-as interpret-as="character">${u}</say-as>` : /[A-Z]/.test(u) ? `capital <say-as interpret-as="character">${u.toLowerCase()}</say-as>` : u : /[a-z]/.test(u) ? " '" + u.toUpperCase() + "'" : /[A-Z]/.test(u) ? " 'capital " + u.toUpperCase() + "'" : u;
      }
      function i(u) {
        return "<emphasis>" + u + "</emphasis>";
      }
      if (!e)
        return "";
      let o = "";
      if (Y(e)) {
        let u = false, d = false;
        for (let m = 0; m < e.length; m++)
          e[m].type !== "first" && (e[m].mode !== "text" && (d = false), m < e.length - 2 && e[m].type === "mopen" && e[m + 2].type === "mclose" && e[m + 1].type === "mord" ? (o += " of ", o += i(ee(r, e[m + 1])), m += 2) : e[m].mode === "text" ? d ? o += (a = e[m].value) != null ? a : " " : (d = true, o += ee("text", e[m])) : e[m].isDigit() ? u ? o += e[m].asDigit() : (u = true, o += ee(r, e[m])) : (u = false, o += ee(r, e[m])));
      } else if (e.mode === "text")
        e.id && r === "math" && (o += '<mark name="' + e.id.toString() + '"/>'), o += e.value;
      else {
        e.id && r === "math" && (o += '<mark name="' + e.id.toString() + '"/>');
        let u = "", d = "", m = "", h = false, { command: f } = e;
        switch (e.type) {
          case "prompt":
            let y = e.body.length > 1 ? 'start input . <break time="500ms"/> ' + ee(r, e.body) + '. <break time="500ms"/> end input' : "blank";
            o += ' <break time="300ms"/> ' + y + '. <break time="700ms"/>' + ((n = e.correctness) != null ? n : "") + ' . <break time="700ms"/> ';
            break;
          case "accent":
            f === "\\vec" && (o += "vector " + ee(r, e.body));
            break;
          case "array":
            let w = e.array, k = e.environmentName;
            if (Object.keys(ya).includes(k)) {
              o += ` begin ${ya[k]} `;
              for (let K = 0; K < w.length; K++) {
                K > 0 && (o += ","), o += ` row ${K + 1} `;
                for (let M = 0; M < w[K].length; M++)
                  M > 0 && (o += ","), o += ` column ${M + 1}: `, o += ee("math", w[K][M]);
              }
              o += ` end ${ya[k]} `;
            }
            break;
          case "group":
            f === "\\ne" ? o += " not equal " : (f === "\\not" && (o += " not "), o += ee("math", e.body));
            break;
          case "root":
            o += ee("math", e.body);
            break;
          case "genfrac":
            if (u = ee("math", e.above), d = ee("math", e.below), Ci(e.above) && Ci(e.below)) {
              let M = { "1/2": " half ", "1/3": " one third ", "2/3": " two third", "1/4": " one quarter ", "3/4": " three quarter ", "1/5": " one fifth ", "2/5": " two fifths ", "3/5": " three fifths ", "4/5": " four fifths ", "1/6": " one sixth ", "5/6": " five sixths ", "1/8": " one eight ", "3/8": " three eights ", "5/8": " five eights ", "7/8": " seven eights ", "1/9": " one ninth ", "2/9": " two ninths ", "4/9": " four ninths ", "5/9": " five ninths ", "7/9": " seven ninths ", "8/9": " eight ninths " }[ls(e.above) + "/" + ls(e.below)];
              M ? o = M : o += u + " over " + d;
            } else
              o += ' the fraction <break time="150ms"/>' + u + ' over <break time="150ms"/>' + d + '.<break time="150ms"/> End fraction.<break time="150ms"/>';
            break;
          case "surd":
            if (m = ee("math", e.body), e.hasEmptyBranch("above"))
              o += Ci(e.body) ? " the square root of " + m + " , " : ' the square root of <break time="200ms"/>' + m + '. <break time="200ms"/> End square root';
            else {
              let K = ee("math", e.above);
              K = K.trim();
              let M = K.replace(/<mark([^/]*)\/>/g, "");
              M === "3" ? o += ' the cube root of <break time="200ms"/>' + m + '. <break time="200ms"/> End cube root' : M === "n" ? o += ' the nth root of <break time="200ms"/>' + m + '. <break time="200ms"/> End root' : o += ' the root with index: <break time="200ms"/>' + K + ', of <break time="200ms"/>' + m + '. <break time="200ms"/> End root';
            }
            break;
          case "leftright":
            {
              let K = e;
              o += (s = K.leftDelim ? Yr[K.leftDelim] : void 0) != null ? s : K.leftDelim, o += ee("math", e.body), o += (l = K.rightDelim ? Yr[K.rightDelim] : void 0) != null ? l : K.rightDelim;
            }
            break;
          case "rule":
            break;
          case "overunder":
            break;
          case "overlap":
            break;
          case "line":
            let S = e.position;
            o += `${S} `, o += ee("math", e.body), o += ` end ${S} `;
            break;
          case "macro":
            let T = f.replace(/^\\/g, ""), C = qr()[T];
            C && (C != null && C.expand ? o += ee("math", e.body) : o += `${T} `);
            break;
          case "placeholder":
            o += "placeholder ";
            break;
          case "delim":
          case "sizeddelim":
          case "mord":
          case "minner":
          case "mbin":
          case "mrel":
          case "mpunct":
          case "mopen":
          case "mclose": {
            if (f === "\\mathbin" || f === "\\mathrel" || f === "\\mathopen" || f === "\\mathclose" || f === "\\mathpunct" || f === "\\mathord" || f === "\\mathinner") {
              o = ee(r, e.body);
              break;
            }
            let K = e.isDigit() ? e.asDigit() : e.value, M = e.command;
            if ((e.type === "delim" || e.type === "sizeddelim") && (M = e.value, K = M), r === "text")
              o += K;
            else {
              if (e.type === "mbin" && (o += '<break time="150ms"/>'), K) {
                let R = Yr[K] || (M ? Yr[M.trim()] : "");
                if (R)
                  o += " " + R;
                else {
                  let F = M ? Tc(M.trim()) : "";
                  o += F || t(K);
                }
              } else
                o += ee("math", e.body);
              e.type === "mbin" && (o += '<break time="150ms"/>');
            }
            break;
          }
          case "mop":
            if (e.value !== "​") {
              let K = e.command;
              if (K === "\\sum")
                if (!e.hasEmptyBranch("superscript") && !e.hasEmptyBranch("subscript")) {
                  let M = ee("math", e.superscript);
                  M = M.trim();
                  let R = ee("math", e.subscript);
                  R = R.trim(), o += ' the summation from <break time="200ms"/>' + R + '<break time="200ms"/> to  <break time="200ms"/>' + M + '<break time="200ms"/> of <break time="150ms"/>', h = true;
                } else if (e.hasEmptyBranch("subscript"))
                  o += " the summation of";
                else {
                  let M = ee("math", e.subscript);
                  M = M.trim(), o += ' the summation from <break time="200ms"/>' + M + '<break time="200ms"/> of <break time="150ms"/>', h = true;
                }
              else if (K === "\\prod")
                if (!e.hasEmptyBranch("superscript") && !e.hasEmptyBranch("subscript")) {
                  let M = ee("math", e.superscript);
                  M = M.trim();
                  let R = ee("math", e.subscript);
                  R = R.trim(), o += ' the product from <break time="200ms"/>' + R + '<break time="200ms"/> to <break time="200ms"/>' + M + '<break time="200ms"/> of <break time="150ms"/>', h = true;
                } else if (e.hasEmptyBranch("subscript"))
                  o += " the product  of ";
                else {
                  let M = ee("math", e.subscript);
                  M = M.trim(), o += ' the product from <break time="200ms"/>' + M + '<break time="200ms"/> of <break time="150ms"/>', h = true;
                }
              else if (K === "\\int")
                if (!e.hasEmptyBranch("superscript") && !e.hasEmptyBranch("subscript")) {
                  let M = ee("math", e.superscript);
                  M = M.trim();
                  let R = ee("math", e.subscript);
                  R = R.trim(), o += ' the integral from <break time="200ms"/>' + i(R) + '<break time="200ms"/> to <break time="200ms"/>' + i(M) + ' <break time="200ms"/> of ', h = true;
                } else
                  o += ' the integral of <break time="200ms"/> ';
              else if (typeof e.value == "string") {
                let M = (c = Yr[e.value]) != null ? c : e.command ? Yr[e.command] : void 0;
                o += M || " " + e.value;
              } else
                e.command && (e.command === "\\mathop" ? o += ee("math", e.body) : e.command === "\\operatorname" ? o += Pc(e.body) : o += e.command.startsWith("\\") ? " " + e.command.slice(1) : " " + e.command);
            }
            break;
          case "enclose":
            m = ee("math", e.body), o += " crossed out " + m + ". End crossed out.";
            break;
        }
        if (!h && !e.hasEmptyBranch("superscript")) {
          let y = ee(r, e.superscript);
          y = y.trim();
          let w = y.replace(/<[^>]*>/g, "");
          if (Ci(e.superscript)) {
            if (r === "math") {
              let k = Ec(e.superscript);
              k && (o += '<mark name="' + k + '"/>');
            }
            w === "′" ? o += " prime " : w === "2" ? o += " squared " : w === "3" ? o += " cubed " : Number.isNaN(Number.parseInt(w)) ? o += " to the " + y + "; " : o += ' to the <say-as interpret-as="ordinal">' + w + "</say-as> power; ";
          } else
            Number.isNaN(Number.parseInt(w)) ? o += " raised to the " + y + "; " : o += ' raised to the <say-as interpret-as="ordinal">' + w + "</say-as> power; ";
        }
        if (!h && !e.hasEmptyBranch("subscript")) {
          let y = ee("math", e.subscript);
          y = y.trim(), o += Ci(e.subscript) ? " sub " + y : " subscript " + y + ". End subscript. ";
        }
      }
      return o;
    }
    function $t(r) {
      var t, i;
      if (window.MathfieldElement.textToSpeechRules === "sre" && ("sre" in window || "SRE" in window)) {
        let o = V(r);
        if (o) {
          window.MathfieldElement.textToSpeechMarkup && (window.MathfieldElement.textToSpeechRulesOptions = (t = window.MathfieldElement.textToSpeechRulesOptions) != null ? t : {}, window.MathfieldElement.textToSpeechRulesOptions.markup = window.MathfieldElement.textToSpeechMarkup, window.MathfieldElement.textToSpeechRulesOptions.markup === "ssml" && (window.MathfieldElement.textToSpeechRulesOptions.markup = "ssml_step"), window.MathfieldElement.textToSpeechRulesOptions.rate = window.MathfieldElement.speechEngineRate);
          let a = (i = window.SRE) != null ? i : window.sre.System.getInstance();
          window.MathfieldElement.textToSpeechRulesOptions && a.setupEngine(window.MathfieldElement.textToSpeechRulesOptions);
          let n = "";
          try {
            n = a.toSpeech(o);
          } catch (s) {
            console.error("MathLive 0.90.9: `SRE.toSpeech()` runtime error", s);
          }
          return n;
        }
        return "";
      }
      let e = ee("math", r);
      if (window.MathfieldElement.textToSpeechMarkup === "ssml") {
        let o = "";
        window.MathfieldElement.speechEngineRate && (o = '<prosody rate="' + window.MathfieldElement.speechEngineRate + '">'), e = '<?xml version="1.0"?><speak version="1.1" xmlns="http://www.w3.org/2001/10/synthesis" xml:lang="en-US"><amazon:auto-breaths>' + o + "<p><s>" + e + "</s></p>" + (o ? "</prosody>" : "") + "</amazon:auto-breaths></speak>";
      } else
        window.MathfieldElement.textToSpeechMarkup === "mac" && Xt() === "macos" ? e = e.replace(/<mark([^/]*)\/>/g, "").replace(/<emphasis>/g, "[[emph+]]").replace(/<\/emphasis>/g, "").replace(/<break time="(\d*)ms"\/>/g, "[[slc $1]]").replace(/<say-as[^>]*>/g, "").replace(/<\/say-as>/g, "") : e = e.replace(/<[^>]*>/g, "").replace(/\s{2,}/g, " ");
      return e;
    }
    function je(r, e, t, i) {
      let o = e.split(" ");
      for (let a of o) {
        let n = a.match(/(.*):(.*)/);
        if (n) {
          let s = i != null ? i : {};
          n[2] === "active" ? s.passive = false : s[n[2]] = true, r.addEventListener(n[1], t, s);
        } else
          r.addEventListener(a, t, i);
      }
    }
    function Ti(r, e, t, i) {
      let o = e.split(" ");
      for (let a of o) {
        let n = a.match(/(.*):(.*)/);
        if (n) {
          let s = i != null ? i : {};
          n[2] === "active" ? s.passive = false : s[n[2]] = true, r.removeEventListener(n[1], t, s);
        } else
          r.removeEventListener(a, t, i);
      }
    }
    function xo(r) {
      var t;
      Wi();
      let e = document.getElementById(r);
      return e ? e.dataset.refcount = Number(Number.parseInt((t = e.getAttribute("data-refcount")) != null ? t : "0") + 1).toString() : (e = document.createElement("div"), e.setAttribute("aria-hidden", "true"), e.dataset.refcount = "1", e.id = r, document.body.append(e)), e;
    }
    function vo(r) {
      var t;
      if (!r)
        return;
      let e = Number.parseInt((t = r.getAttribute("data-refcount")) != null ? t : "0");
      e <= 1 ? r.remove() : r.dataset.refcount = Number(e - 1).toString();
    }
    function qt(r) {
      var e;
      return ((e = r.element) == null ? void 0 : e.mathfield) === r;
    }
    function Kc(r) {
      var e, t;
      return (t = (e = r.querySelector(".ML__caret")) != null ? e : r.querySelector(".ML__text-caret")) != null ? t : r.querySelector(".ML__latex-caret");
    }
    function Lr(r) {
      let e = Kc(r);
      if (!e)
        return null;
      let t = e.getBoundingClientRect();
      return { x: t.right, y: t.bottom, height: t.height };
    }
    function Dc(r) {
      var t;
      if (!r.parent)
        return "root";
      let e = (t = r.parent.id) != null ? t : "";
      return e += typeof r.treeBranch == "string" ? "-" + r.treeBranch : `-${r.treeBranch[0]}/${r.treeBranch[0]}`, e;
    }
    function ba(r, e) {
      if (!e)
        return null;
      let t = r.field.getBoundingClientRect(), i = e.right - e.left, o = e.bottom - e.top, a = Math.ceil(e.left - t.left + r.field.scrollLeft), n = Math.ceil(e.top - t.top);
      return { left: a, right: a + i, top: n, bottom: n + o };
    }
    function cs(r) {
      let e = r.getBoundingClientRect(), t = parseInt(getComputedStyle(r).marginRight), i = { top: e.top - 1, bottom: e.bottom, left: e.left, right: e.right - 1 + t };
      if (r.children.length === 0 || r.tagName.toUpperCase() === "SVG")
        return i;
      for (let o of r.children)
        if (o.nodeType === 1 && "atomId" in o.dataset && !o.classList.contains("pstrut")) {
          let a = cs(o);
          i.left = Math.min(i.left, a.left), i.right = Math.max(i.right, a.right), i.top = Math.min(i.top, a.top), i.bottom = Math.max(i.bottom, a.bottom);
        }
      return i;
    }
    function mr(r, e) {
      var o, a;
      if (!e.id)
        return null;
      let t = (a = (o = r.atomBoundsCache) == null ? void 0 : o.get(e.id)) != null ? a : null;
      if (t !== null)
        return t;
      let i = r.field.querySelector(`[data-atom-id="${e.id}"]`);
      return t = i ? cs(i) : null, r.atomBoundsCache && (t ? r.atomBoundsCache.set(e.id, t) : r.atomBoundsCache.delete(e.id)), t != null ? t : null;
    }
    function Bc(r, e, t) {
      let i = /* @__PURE__ */ new Map();
      for (let o of r.model.getAtoms(e, { includeChildren: true })) {
        if (t != null && t.excludeAtomsWithBackground && o.style.backgroundColor)
          break;
        let a = ba(r, mr(r, o));
        if (a) {
          let n = Dc(o);
          if (i.has(n)) {
            let s = i.get(n);
            i.set(n, { left: Math.min(s.left, a.left), right: Math.max(s.right, a.right), top: Math.min(s.top, a.top), bottom: Math.max(s.bottom, a.bottom) });
          } else
            i.set(n, a);
        }
      }
      return [...i.values()];
    }
    function wo(r, e) {
      return r.model.selection.ranges.reduce((t, i) => t.concat(...Bc(r, i, e)), []);
    }
    function Qr(r, e) {
      return r === "*" || e === "none" ? true : e === "same-origin" ? !window.origin || r === window.origin : typeof e == "function" ? e(r) : false;
    }
    function xa(r) {
      let e = 0, t = 0, i = r.offsetWidth, o = r.offsetHeight;
      for (; r instanceof HTMLElement; )
        e += r.offsetTop, t += r.offsetLeft, r = r.offsetParent;
      return new DOMRect(t, e, i, o);
    }
    function Xe(r) {
      let e = 0;
      for (let t = 0; t < r.length; t++)
        e = Math.imul(31, e) + r.charCodeAt(t) | 0;
      return Math.abs(e);
    }
    function Ze(r, e, t) {
      var a, n;
      if (!e)
        return null;
      let i = (a = r == null ? void 0 : r.getRootNode()) != null ? a : document == null ? void 0 : document.head;
      if (!i)
        return null;
      i === document && (i = document.head);
      let o = i.querySelector(`style[data-id="${t}"]`);
      if (o) {
        let s = Number.parseFloat((n = o.getAttribute("data-refcount")) != null ? n : "0");
        o.dataset.refcount = Number(s + 1).toString();
      } else {
        let s = document.createElement("style");
        s.dataset.id = t, s.dataset.refcount = "1", s.append(document.createTextNode(e)), i.appendChild(s);
      }
      return { release: () => {
        var l;
        let s = i.querySelector(`style[data-id="${t}"]`);
        if (s) {
          let c = Number.parseFloat((l = s.getAttribute("data-refcount")) != null ? l : "0");
          c === 1 ? s.remove() : s.dataset.refcount = Number(c - 1).toString();
        }
      } };
    }
    function wa(r) {
      let e = r.split("+"), t = { shift: false, alt: false, cmd: false, win: false, meta: false, ctrl: false, key: e.pop() };
      return e.includes("shift") && (t.shift = true), e.includes("alt") && (t.alt = true), e.includes("ctrl") && (t.ctrl = true), e.includes("cmd") && (t.cmd = true), e.includes("win") && (t.win = true), e.includes("meta") && (t.meta = true), t;
    }
    function Pi(r) {
      let e = "";
      return r.shift && (e += "shift+"), r.alt && (e += "alt+"), r.ctrl && (e += "ctrl+"), r.cmd && (e += "cmd+"), r.win && (e += "win+"), r.meta && (e += "meta+"), e + r.key;
    }
    var ka = va() === "apple" ? { id: "apple.en-intl", displayName: "English (international)", virtualLayout: "qwerty", platform: "apple", locale: "en", score: 0, mapping: { KeyA: ["a", "A", "å", "Å"], KeyB: ["b", "B", "∫", "ı"], KeyC: ["c", "C", "ç", "Ç"], KeyD: ["d", "D", "∂", "Î"], KeyE: ["e", "E", "´", "´"], KeyF: ["f", "F", "ƒ", "Ï"], KeyG: ["g", "G", "©", "˝"], KeyH: ["h", "H", "˙", "Ó"], KeyI: ["i", "I", "ˆ", "ˆ"], KeyJ: ["j", "J", "∆", "Ô"], KeyK: ["k", "K", "˚", ""], KeyL: ["l", "L", "¬", "Ò"], KeyM: ["m", "M", "µ", "Â"], KeyN: ["n", "N", "˜", "˜"], KeyO: ["o", "O", "ø", "Ø"], KeyP: ["p", "P", "π", "∏"], KeyQ: ["q", "Q", "œ", "Œ"], KeyR: ["r", "R", "®", "‰"], KeyS: ["s", "S", "ß", "Í"], KeyT: ["t", "T", "†", "ˇ"], KeyU: ["u", "U", "¨", "¨"], KeyV: ["v", "V", "√", "◊"], KeyW: ["w", "W", "∑", "„"], KeyX: ["x", "X", "≈", "˛"], KeyY: ["y", "Y", "¥", "Á"], KeyZ: ["z", "Z", "Ω", "¸"], Digit1: ["1", "!", "¡", "⁄"], Digit2: ["2", "@", "™", "€"], Digit3: ["3", "#", "£", "‹"], Digit4: ["4", "$", "¢", "›"], Digit5: ["5", "%", "∞", "ﬁ"], Digit6: ["6", "^", "§", "ﬂ"], Digit7: ["7", "&", "¶", "‡"], Digit8: ["8", "*", "•", "°"], Digit9: ["9", "(", "ª", "·"], Digit0: ["0", ")", "º", "‚"], Space: [" ", " ", " ", " "], Minus: ["-", "_", "–", "—"], Equal: ["=", "+", "≠", "±"], BracketLeft: ["[", "{", "“", "”"], BracketRight: ["]", "}", "‘", "’"], Backslash: ["\\", "|", "«", "»"], Semicolon: [";", ":", "…", "Ú"], Quote: ["'", '"', "æ", "Æ"], Backquote: ["`", "˜", "`", "`"], Comma: [",", "<", "≤", "¯"], Period: [".", ">", "≥", "˘"], Slash: ["/", "?", "÷", "¿"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], Numpad1: ["1", "1", "1", "1"], Numpad2: ["2", "2", "2", "2"], Numpad3: ["3", "3", "3", "3"], Numpad4: ["4", "4", "4", "4"], Numpad5: ["5", "5", "5", "5"], Numpad6: ["6", "6", "6", "6"], Numpad7: ["7", "7", "7", "7"], Numpad8: ["8", "8", "8", "8"], Numpad9: ["9", "9", "9", "9"], Numpad0: ["0", "0", "0", "0"], NumpadDecimal: [".", ".", ".", "."], IntlBackslash: ["§", "±", "§", "±"], NumpadEqual: ["=", "=", "=", "="], AudioVolumeUp: ["", "=", "", "="] } } : va() === "windows" ? { id: "windows.en-intl", displayName: "English (international)", platform: "windows", virtualLayout: "qwerty", locale: "en", score: 0, mapping: { KeyA: ["a", "A", "á", "Á"], KeyB: ["b", "B", "", ""], KeyC: ["c", "C", "©", "¢"], KeyD: ["d", "D", "ð", "Ð"], KeyE: ["e", "E", "é", "É"], KeyF: ["f", "F", "", ""], KeyG: ["g", "G", "", ""], KeyH: ["h", "H", "", ""], KeyI: ["i", "I", "í", "Í"], KeyJ: ["j", "J", "", ""], KeyK: ["k", "K", "", ""], KeyL: ["l", "L", "ø", "Ø"], KeyM: ["m", "M", "µ", ""], KeyN: ["n", "N", "ñ", "Ñ"], KeyO: ["o", "O", "ó", "Ó"], KeyP: ["p", "P", "ö", "Ö"], KeyQ: ["q", "Q", "ä", "Ä"], KeyR: ["r", "R", "®", ""], KeyS: ["s", "S", "ß", "§"], KeyT: ["t", "T", "þ", "Þ"], KeyU: ["u", "U", "ú", "Ú"], KeyV: ["v", "V", "", ""], KeyW: ["w", "W", "å", "Å"], KeyX: ["x", "X", "", ""], KeyY: ["y", "Y", "ü", "Ü"], KeyZ: ["z", "Z", "æ", "Æ"], Digit1: ["1", "!", "¡", "¹"], Digit2: ["2", "@", "²", ""], Digit3: ["3", "#", "³", ""], Digit4: ["4", "$", "¤", "£"], Digit5: ["5", "%", "€", ""], Digit6: ["6", "^", "¼", ""], Digit7: ["7", "&", "½", ""], Digit8: ["8", "*", "¾", ""], Digit9: ["9", "(", "‘", ""], Digit0: ["0", ")", "’", ""], Space: [" ", " ", "", ""], Minus: ["-", "_", "¥", ""], Equal: ["=", "+", "×", "÷"], BracketLeft: ["[", "{", "«", ""], BracketRight: ["]", "}", "»", ""], Backslash: ["\\", "|", "¬", "¦"], Semicolon: [";", ":", "¶", "°"], Quote: ["'", '"', "´", "¨"], Backquote: ["`", "~", "", ""], Comma: [",", "<", "ç", "Ç"], Period: [".", ">", "", ""], Slash: ["/", "?", "¿", ""], NumpadDivide: ["/", "/", "", ""], NumpadMultiply: ["*", "*", "", ""], NumpadSubtract: ["-", "-", "", ""], NumpadAdd: ["+", "+", "", ""], IntlBackslash: ["\\", "|", "", ""] } } : { id: "linux.en", displayName: "English", platform: "linux", virtualLayout: "qwerty", locale: "en", score: 0, mapping: { KeyA: ["a", "A", "a", "A"], KeyB: ["b", "B", "b", "B"], KeyC: ["c", "C", "c", "C"], KeyD: ["d", "D", "d", "D"], KeyE: ["e", "E", "e", "E"], KeyF: ["f", "F", "f", "F"], KeyG: ["g", "G", "g", "G"], KeyH: ["h", "H", "h", "H"], KeyI: ["i", "I", "i", "I"], KeyJ: ["j", "J", "j", "J"], KeyK: ["k", "K", "k", "K"], KeyL: ["l", "L", "l", "L"], KeyM: ["m", "M", "m", "M"], KeyN: ["n", "N", "n", "N"], KeyO: ["o", "O", "o", "O"], KeyP: ["p", "P", "p", "P"], KeyQ: ["q", "Q", "q", "Q"], KeyR: ["r", "R", "r", "R"], KeyS: ["s", "S", "s", "S"], KeyT: ["t", "T", "t", "T"], KeyU: ["u", "U", "u", "U"], KeyV: ["v", "V", "v", "V"], KeyW: ["w", "W", "w", "W"], KeyX: ["x", "X", "x", "X"], KeyY: ["y", "Y", "y", "Y"], KeyZ: ["z", "Z", "z", "Z"], Digit1: ["1", "!", "1", "!"], Digit2: ["2", "@", "2", "@"], Digit3: ["3", "#", "3", "#"], Digit4: ["4", "$", "4", "$"], Digit5: ["5", "%", "5", "%"], Digit6: ["6", "^", "6", "^"], Digit7: ["7", "&", "7", "&"], Digit8: ["8", "*", "8", "*"], Digit9: ["9", "(", "9", "("], Digit0: ["0", ")", "0", ")"], Space: [" ", " ", " ", " "], Minus: ["-", "_", "-", "_"], Equal: ["=", "+", "=", "+"], BracketLeft: ["[", "{", "[", "{"], BracketRight: ["]", "}", "]", "}"], Backslash: ["\\", "|", "\\", "|"], Semicolon: [";", ":", ";", ":"], Quote: ["'", '"', "'", '"'], Backquote: ["`", "~", "`", "~"], Comma: [",", "<", ",", "<"], Period: [".", ">", ".", ">"], Slash: ["/", "?", "/", "?"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], Numpad1: ["1", "1", "1", "1"], Numpad2: ["2", "2", "2", "2"], Numpad3: ["3", "3", "3", "3"], Numpad4: ["4", "4", "4", "4"], Numpad5: ["5", "5", "5", "5"], Numpad6: ["6", "6", "6", "6"], Numpad7: ["7", "7", "7", "7"], Numpad8: ["8", "8", "8", "8"], Numpad9: ["9", "9", "9", "9"], Numpad0: ["0", "0", "0", "0"], NumpadDecimal: ["", ".", "", "."], IntlBackslash: ["<", ">", "|", "¦"], NumpadEqual: ["=", "=", "=", "="], NumpadComma: [".", ".", ".", "."], NumpadParenLeft: ["(", "(", "(", "("], NumpadParenRight: [")", ")", ")", ")"] } }, Oc = { enter: "[Enter]", escape: "[Escape]", backspace: "[Backspace]", tab: "[Tab]", space: "[Space]", pausebreak: "[Pause]", insert: "[Insert]", home: "[Home]", pageup: "[PageUp]", delete: "[Delete]", end: "[End]", pagedown: "[PageDown]", right: "[ArrowRight]", left: "[ArrowLeft]", down: "[ArrowDown]", up: "[ArrowUp]", numpad0: "[Numpad0]", numpad1: "[Numpad1]", numpad2: "[Numpad2]", numpad3: "[Numpad3]", numpad4: "[Numpad4]", numpad5: "[Numpad5]", numpad6: "[Numpad6]", numpad7: "[Numpad7]", numpad8: "[Numpad8]", numpad9: "[Numpad9]", numpad_divide: "[NumpadDivide]", numpad_multiply: "[NumpadMultiply]", numpad_subtract: "[NumpadSubtract]", numpad_add: "[NumpadAdd]", numpad_decimal: "[NumpadDecimal]", numpad_separator: "[NumpadComma]", capslock: "[Capslock]", f1: "[F1]", f2: "[F2]", f3: "[F3]", f4: "[F4]", f5: "[F5]", f6: "[F6]", f7: "[F7]", f8: "[F8]", f9: "[F9]", f10: "[F10]", f11: "[F11]", f12: "[F12]", f13: "[F13]", f14: "[F14]", f15: "[F15]", f16: "[F16]", f17: "[F17]", f18: "[F18]", f19: "[F19]" }, Ei = [];
    function va() {
      switch (Xt()) {
        case "macos":
        case "ios":
          return "apple";
        case "windows":
          return "windows";
      }
      return "linux";
    }
    function Kt(r) {
      (!r.platform || r.platform === va()) && Ei.push(r);
    }
    function us(r, e) {
      var i;
      let t = { shift: false, alt: false, cmd: false, win: false, meta: false, ctrl: false, key: "" };
      if (!r)
        return t;
      for (let [o, a] of Object.entries(e.mapping)) {
        if (a[0] === r)
          return t.key = `[${o}]`, t;
        if (a[1] === r)
          return t.shift = true, t.key = `[${o}]`, t;
        if (a[2] === r)
          return t.alt = true, t.key = `[${o}]`, t;
        if (a[3] === r)
          return t.shift = true, t.alt = true, t.key = `[${o}]`, t;
      }
      return t.key = (i = Oc[r]) != null ? i : "", t;
    }
    function ds(r) {
      if (r.code)
        return r;
      let e = Object.entries(pr().mapping), t = false, i = false, o = "";
      for (let a = 0; a < 4; a++) {
        for (let [n, s] of e)
          if (s[a] === r.key) {
            o = n, a === 3 ? (t = true, i = true) : a === 2 ? t = true : a === 1 && (i = true);
            break;
          }
        if (o)
          break;
      }
      return new KeyboardEvent(r.type, E(b({}, r), { altKey: t, shiftKey: i, code: o }));
    }
    function ms(r) {
      var t, i;
      if (!r || r.key === "Unidentified" || r.key === "Dead")
        return;
      let e = r.shiftKey && r.altKey ? 3 : r.altKey ? 2 : r.shiftKey ? 1 : 0;
      for (let o of Ei)
        ((t = o.mapping[r.code]) == null ? void 0 : t[e]) === r.key ? o.score += 1 : (i = o.mapping[r.code]) != null && i[e] && (o.score = 0);
      Ei.sort((o, a) => a.score - o.score);
    }
    function pr() {
      return Ei[0];
    }
    Kt(ka);
    Kt({ id: "apple.french", locale: "fr", displayName: "French", platform: "apple", virtualLayout: "azerty", score: 0, mapping: { KeyA: ["q", "Q", "‡", "Ω"], KeyB: ["b", "B", "ß", "∫"], KeyC: ["c", "C", "©", "¢"], KeyD: ["d", "D", "∂", "∆"], KeyE: ["e", "E", "ê", "Ê"], KeyF: ["f", "F", "ƒ", "·"], KeyG: ["g", "G", "ﬁ", "ﬂ"], KeyH: ["h", "H", "Ì", "Î"], KeyI: ["i", "I", "î", "ï"], KeyJ: ["j", "J", "Ï", "Í"], KeyK: ["k", "K", "È", "Ë"], KeyL: ["l", "L", "¬", "|"], KeyM: [",", "?", "∞", "¿"], KeyN: ["n", "N", "~", "ı"], KeyO: ["o", "O", "œ", "Œ"], KeyP: ["p", "P", "π", "∏"], KeyQ: ["a", "A", "æ", "Æ"], KeyR: ["r", "R", "®", "‚"], KeyS: ["s", "S", "Ò", "∑"], KeyT: ["t", "T", "†", "™"], KeyU: ["u", "U", "º", "ª"], KeyV: ["v", "V", "◊", "√"], KeyW: ["z", "Z", "Â", "Å"], KeyX: ["x", "X", "≈", "⁄"], KeyY: ["y", "Y", "Ú", "Ÿ"], KeyZ: ["w", "W", "‹", "›"], Digit1: ["&", "1", "", "´"], Digit2: ["é", "2", "ë", "„"], Digit3: ['"', "3", "“", "”"], Digit4: ["'", "4", "‘", "’"], Digit5: ["(", "5", "{", "["], Digit6: ["§", "6", "¶", "å"], Digit7: ["è", "7", "«", "»"], Digit8: ["!", "8", "¡", "Û"], Digit9: ["ç", "9", "Ç", "Á"], Digit0: ["à", "0", "ø", "Ø"], Space: [" ", " ", " ", " "], Minus: [")", "°", "}", "]"], Equal: ["-", "_", "—", "–"], BracketLeft: ["^", "¨", "ô", "Ô"], BracketRight: ["$", "*", "€", "¥"], Backslash: ["`", "£", "@", "#"], Semicolon: ["m", "M", "µ", "Ó"], Quote: ["ù", "%", "Ù", "‰"], Backquote: ["<", ">", "≤", "≥"], Comma: [";", ".", "…", "•"], Period: [":", "/", "÷", "\\"], Slash: ["=", "+", "≠", "±"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], NumpadDecimal: [",", ".", ",", "."], IntlBackslash: ["@", "#", "•", "Ÿ"], NumpadEqual: ["=", "=", "=", "="] } });
    Kt({ id: "apple.spanish", locale: "es", displayName: "Spanish ISO", platform: "apple", virtualLayout: "qwerty", score: 0, mapping: { KeyA: ["a", "A", "å", "Å"], KeyB: ["b", "B", "ß", ""], KeyC: ["c", "C", "©", " "], KeyD: ["d", "D", "∂", "∆"], KeyE: ["e", "E", "€", "€"], KeyF: ["f", "F", "ƒ", "ﬁ"], KeyG: ["g", "G", "", "ﬂ"], KeyH: ["h", "H", "™", " "], KeyI: ["i", "I", " ", " "], KeyJ: ["j", "J", "¶", "¯"], KeyK: ["k", "K", "§", "ˇ"], KeyL: ["l", "L", " ", "˘"], KeyM: ["m", "M", "µ", "˚"], KeyN: ["n", "N", " ", "˙"], KeyO: ["o", "O", "ø", "Ø"], KeyP: ["p", "P", "π", "∏"], KeyQ: ["q", "Q", "œ", "Œ"], KeyR: ["r", "R", "®", " "], KeyS: ["s", "S", "∫", " "], KeyT: ["t", "T", "†", "‡"], KeyU: ["u", "U", " ", " "], KeyV: ["v", "V", "√", "◊"], KeyW: ["w", "W", "æ", "Æ"], KeyX: ["x", "X", "∑", "›"], KeyY: ["y", "Y", "¥", " "], KeyZ: ["z", "Z", "Ω", "‹"], Digit1: ["1", "!", "|", "ı"], Digit2: ["2", '"', "@", "˝"], Digit3: ["3", "·", "#", "•"], Digit4: ["4", "$", "¢", "£"], Digit5: ["5", "%", "∞", "‰"], Digit6: ["6", "&", "¬", " "], Digit7: ["7", "/", "÷", "⁄"], Digit8: ["8", "(", "“", "‘"], Digit9: ["9", ")", "”", "’"], Digit0: ["0", "=", "≠", "≈"], Space: [" ", " ", " ", " "], Minus: ["'", "?", "´", "¸"], Equal: ["¡", "¿", "‚", "˛"], BracketLeft: ["`", "^", "[", "ˆ"], BracketRight: ["+", "*", "]", "±"], Backslash: ["ç", "Ç", "}", "»"], Semicolon: ["ñ", "Ñ", "~", "˜"], Quote: ["´", "¨", "{", "«"], Backquote: ["<", ">", "≤", "≥"], Comma: [",", ";", "„", ""], Period: [".", ":", "…", "…"], Slash: ["-", "_", "–", "—"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], Numpad1: ["1", "1", "1", "1"], Numpad2: ["2", "2", "2", "2"], Numpad3: ["3", "3", "3", "3"], Numpad4: ["4", "4", "4", "4"], Numpad5: ["5", "5", "5", "5"], Numpad6: ["6", "6", "6", "6"], Numpad7: ["7", "7", "7", "7"], Numpad8: ["8", "8", "8", "8"], Numpad9: ["9", "9", "9", "9"], Numpad0: ["0", "0", "0", "0"], NumpadDecimal: [",", ",", ",", ","], IntlBackslash: ["º", "ª", "\\", "°"] } });
    Kt({ id: "windows.spanish", locale: "es", displayName: "Spanish", platform: "windows", virtualLayout: "qwerty", score: 0, mapping: { KeyA: ["a", "A", "", ""], KeyB: ["b", "B", "", ""], KeyC: ["c", "C", "", ""], KeyD: ["d", "D", "", ""], KeyE: ["e", "E", "€", ""], KeyF: ["f", "F", "", ""], KeyG: ["g", "G", "", ""], KeyH: ["h", "H", "", ""], KeyI: ["i", "I", "", ""], KeyJ: ["j", "J", "", ""], KeyK: ["k", "K", "", ""], KeyL: ["l", "L", "", ""], KeyM: ["m", "M", "", ""], KeyN: ["n", "N", "", ""], KeyO: ["o", "O", "", ""], KeyP: ["p", "P", "", ""], KeyQ: ["q", "Q", "", ""], KeyR: ["r", "R", "", ""], KeyS: ["s", "S", "", ""], KeyT: ["t", "T", "", ""], KeyU: ["u", "U", "", ""], KeyV: ["v", "V", "", ""], KeyW: ["w", "W", "", ""], KeyX: ["x", "X", "", ""], KeyY: ["y", "Y", "", ""], KeyZ: ["z", "Z", "", ""], Digit1: ["1", "!", "|", ""], Digit2: ["2", '"', "@", ""], Digit3: ["3", "·", "#", ""], Digit4: ["4", "$", "~", ""], Digit5: ["5", "%", "€", ""], Digit6: ["6", "&", "¬", ""], Digit7: ["7", "/", "", ""], Digit8: ["8", "(", "", ""], Digit9: ["9", ")", "", ""], Digit0: ["0", "=", "", ""], Space: [" ", " ", "", ""], Minus: ["'", "?", "", ""], Equal: ["¡", "¿", "", ""], BracketLeft: ["`", "^", "[", ""], BracketRight: ["+", "*", "]", ""], Backslash: ["ç", "Ç", "}", ""], Semicolon: ["ñ", "Ñ", "", ""], Quote: ["´", "¨", "{", ""], Backquote: ["º", "ª", "\\", ""], Comma: [",", ";", "", ""], Period: [".", ":", "", ""], Slash: ["-", "_", "", ""], NumpadDivide: ["/", "/", "", ""], NumpadMultiply: ["*", "*", "", ""], NumpadSubtract: ["-", "-", "", ""], NumpadAdd: ["+", "+", "", ""], IntlBackslash: ["<", ">", "", ""] } });
    Kt({ id: "linux.spanish", locale: "es", displayName: "Spanish", platform: "linux", virtualLayout: "qwerty", score: 0, mapping: { KeyA: ["a", "A", "æ", "Æ"], KeyB: ["b", "B", "”", "’"], KeyC: ["c", "C", "¢", "©"], KeyD: ["d", "D", "ð", "Ð"], KeyE: ["e", "E", "€", "¢"], KeyF: ["f", "F", "đ", "ª"], KeyG: ["g", "G", "ŋ", "Ŋ"], KeyH: ["h", "H", "ħ", "Ħ"], KeyI: ["i", "I", "→", "ı"], KeyJ: ["j", "J", "̉", "̛"], KeyK: ["k", "K", "ĸ", "&"], KeyL: ["l", "L", "ł", "Ł"], KeyM: ["m", "M", "µ", "º"], KeyN: ["n", "N", "n", "N"], KeyO: ["o", "O", "ø", "Ø"], KeyP: ["p", "P", "þ", "Þ"], KeyQ: ["q", "Q", "@", "Ω"], KeyR: ["r", "R", "¶", "®"], KeyS: ["s", "S", "ß", "§"], KeyT: ["t", "T", "ŧ", "Ŧ"], KeyU: ["u", "U", "↓", "↑"], KeyV: ["v", "V", "“", "‘"], KeyW: ["w", "W", "ł", "Ł"], KeyX: ["x", "X", "»", ">"], KeyY: ["y", "Y", "←", "¥"], KeyZ: ["z", "Z", "«", "<"], Digit1: ["1", "!", "|", "¡"], Digit2: ["2", '"', "@", "⅛"], Digit3: ["3", "·", "#", "£"], Digit4: ["4", "$", "~", "$"], Digit5: ["5", "%", "½", "⅜"], Digit6: ["6", "&", "¬", "⅝"], Digit7: ["7", "/", "{", "⅞"], Digit8: ["8", "(", "[", "™"], Digit9: ["9", ")", "]", "±"], Digit0: ["0", "=", "}", "°"], Enter: ["\r", "\r", "\r", "\r"], Escape: ["\x1B", "\x1B", "\x1B", "\x1B"], Backspace: ["\b", "\b", "\b", "\b"], Tab: ["	", "", "	", ""], Space: [" ", " ", " ", " "], Minus: ["'", "?", "\\", "¿"], Equal: ["¡", "¿", "̃", "~"], BracketLeft: ["̀", "̂", "[", "̊"], BracketRight: ["+", "*", "]", "̄"], Backslash: ["ç", "Ç", "}", "̆"], Semicolon: ["ñ", "Ñ", "~", "̋"], Quote: ["́", "̈", "{", "{"], Backquote: ["º", "ª", "\\", "\\"], Comma: [",", ";", "─", "×"], Period: [".", ":", "·", "÷"], Slash: ["-", "_", "̣", "̇"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], NumpadEnter: ["\r", "\r", "\r", "\r"], Numpad1: ["", "1", "", "1"], Numpad2: ["", "2", "", "2"], Numpad3: ["", "3", "", "3"], Numpad4: ["", "4", "", "4"], Numpad5: ["", "5", "", "5"], Numpad6: ["", "6", "", "6"], Numpad7: ["", "7", "", "7"], Numpad8: ["", "8", "", "8"], Numpad9: ["", "9", "", "9"], Numpad0: ["", "0", "", "0"], NumpadDecimal: ["", ".", "", "."], IntlBackslash: ["<", ">", "|", "¦"], NumpadEqual: ["=", "=", "=", "="], NumpadComma: [".", ".", ".", "."], NumpadParenLeft: ["(", "(", "(", "("], NumpadParenRight: [")", ")", ")", ")"] } });
    Kt({ id: "linux.french", locale: "fr", displayName: "French", virtualLayout: "azerty", platform: "linux", score: 0, mapping: { KeyA: ["q", "Q", "@", "Ω"], KeyB: ["b", "B", "”", "’"], KeyC: ["c", "C", "¢", "©"], KeyD: ["d", "D", "ð", "Ð"], KeyE: ["e", "E", "€", "¢"], KeyF: ["f", "F", "đ", "ª"], KeyG: ["g", "G", "ŋ", "Ŋ"], KeyH: ["h", "H", "ħ", "Ħ"], KeyI: ["i", "I", "→", "ı"], KeyJ: ["j", "J", "̉", "̛"], KeyK: ["k", "K", "ĸ", "&"], KeyL: ["l", "L", "ł", "Ł"], KeyM: [",", "?", "́", "̋"], KeyN: ["n", "N", "n", "N"], KeyO: ["o", "O", "ø", "Ø"], KeyP: ["p", "P", "þ", "Þ"], KeyQ: ["a", "A", "æ", "Æ"], KeyR: ["r", "R", "¶", "®"], KeyS: ["s", "S", "ß", "§"], KeyT: ["t", "T", "ŧ", "Ŧ"], KeyU: ["u", "U", "↓", "↑"], KeyV: ["v", "V", "“", "‘"], KeyW: ["z", "Z", "«", "<"], KeyX: ["x", "X", "»", ">"], KeyY: ["y", "Y", "←", "¥"], KeyZ: ["w", "W", "ł", "Ł"], Digit1: ["&", "1", "¹", "¡"], Digit2: ["é", "2", "~", "⅛"], Digit3: ['"', "3", "#", "£"], Digit4: ["'", "4", "{", "$"], Digit5: ["(", "5", "[", "⅜"], Digit6: ["-", "6", "|", "⅝"], Digit7: ["è", "7", "`", "⅞"], Digit8: ["_", "8", "\\", "™"], Digit9: ["ç", "9", "^", "±"], Digit0: ["à", "0", "@", "°"], Enter: ["\r", "\r", "\r", "\r"], Escape: ["\x1B", "\x1B", "\x1B", "\x1B"], Backspace: ["\b", "\b", "\b", "\b"], Tab: ["	", "", "	", ""], Space: [" ", " ", " ", " "], Minus: [")", "°", "]", "¿"], Equal: ["=", "+", "}", "̨"], BracketLeft: ["̂", "̈", "̈", "̊"], BracketRight: ["$", "£", "¤", "̄"], Backslash: ["*", "µ", "̀", "̆"], Semicolon: ["m", "M", "µ", "º"], Quote: ["ù", "%", "̂", "̌"], Backquote: ["²", "~", "¬", "¬"], Comma: [";", ".", "─", "×"], Period: [":", "/", "·", "÷"], Slash: ["!", "§", "̣", "̇"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], NumpadDecimal: ["", ".", "", "."], IntlBackslash: ["<", ">", "|", "¦"] } });
    Kt({ id: "windows.french", locale: "fr", displayName: "French", virtualLayout: "azerty", platform: "windows", score: 0, mapping: { KeyA: ["q", "Q", "", ""], KeyB: ["b", "B", "", ""], KeyC: ["c", "C", "", ""], KeyD: ["d", "D", "", ""], KeyE: ["e", "E", "€", ""], KeyF: ["f", "F", "", ""], KeyG: ["g", "G", "", ""], KeyH: ["h", "H", "", ""], KeyI: ["i", "I", "", ""], KeyJ: ["j", "J", "", ""], KeyK: ["k", "K", "", ""], KeyL: ["l", "L", "", ""], KeyM: [",", "?", "", ""], KeyN: ["n", "N", "", ""], KeyO: ["o", "O", "", ""], KeyP: ["p", "P", "", ""], KeyQ: ["a", "A", "", ""], KeyR: ["r", "R", "", ""], KeyS: ["s", "S", "", ""], KeyT: ["t", "T", "", ""], KeyU: ["u", "U", "", ""], KeyV: ["v", "V", "", ""], KeyW: ["z", "Z", "", ""], KeyX: ["x", "X", "", ""], KeyY: ["y", "Y", "", ""], KeyZ: ["w", "W", "", ""], Digit1: ["&", "1", "", ""], Digit2: ["é", "2", "~", ""], Digit3: ['"', "3", "#", ""], Digit4: ["'", "4", "{", ""], Digit5: ["(", "5", "[", ""], Digit6: ["-", "6", "|", ""], Digit7: ["è", "7", "`", ""], Digit8: ["_", "8", "\\", ""], Digit9: ["ç", "9", "^", ""], Digit0: ["à", "0", "@", ""], Space: [" ", " ", "", ""], Minus: [")", "°", "]", ""], Equal: ["=", "+", "}", ""], BracketLeft: ["^", "¨", "", ""], BracketRight: ["$", "£", "¤", ""], Backslash: ["*", "µ", "", ""], Semicolon: ["m", "M", "", ""], Quote: ["ù", "%", "", ""], Backquote: ["²", "", "", ""], Comma: [";", ".", "", ""], Period: [":", "/", "", ""], Slash: ["!", "§", "", ""], NumpadDivide: ["/", "/", "", ""], NumpadMultiply: ["*", "*", "", ""], NumpadSubtract: ["-", "-", "", ""], NumpadAdd: ["+", "+", "", ""], IntlBackslash: ["<", ">", "", ""] } });
    Kt({ id: "windows.german", locale: "de", displayName: "German", platform: "windows", virtualLayout: "qwertz", score: 0, mapping: { KeyA: ["a", "A", "", ""], KeyB: ["b", "B", "", ""], KeyC: ["c", "C", "", ""], KeyD: ["d", "D", "", ""], KeyE: ["e", "E", "€", ""], KeyF: ["f", "F", "", ""], KeyG: ["g", "G", "", ""], KeyH: ["h", "H", "", ""], KeyI: ["i", "I", "", ""], KeyJ: ["j", "J", "", ""], KeyK: ["k", "K", "", ""], KeyL: ["l", "L", "", ""], KeyM: ["m", "M", "µ", ""], KeyN: ["n", "N", "", ""], KeyO: ["o", "O", "", ""], KeyP: ["p", "P", "", ""], KeyQ: ["q", "Q", "@", ""], KeyR: ["r", "R", "", ""], KeyS: ["s", "S", "", ""], KeyT: ["t", "T", "", ""], KeyU: ["u", "U", "", ""], KeyV: ["v", "V", "", ""], KeyW: ["w", "W", "", ""], KeyX: ["x", "X", "", ""], KeyY: ["z", "Z", "", ""], KeyZ: ["y", "Y", "", ""], Digit1: ["1", "!", "", ""], Digit2: ["2", '"', "²", ""], Digit3: ["3", "§", "³", ""], Digit4: ["4", "$", "", ""], Digit5: ["5", "%", "", ""], Digit6: ["6", "&", "", ""], Digit7: ["7", "/", "{", ""], Digit8: ["8", "(", "[", ""], Digit9: ["9", ")", "]", ""], Digit0: ["0", "=", "}", ""], Space: [" ", " ", "", ""], Minus: ["ß", "?", "\\", "ẞ"], Equal: ["´", "`", "", ""], BracketLeft: ["ü", "Ü", "", ""], BracketRight: ["+", "*", "~", ""], Backslash: ["#", "'", "", ""], Semicolon: ["ö", "Ö", "", ""], Quote: ["ä", "Ä", "", ""], Backquote: ["^", "°", "", ""], Comma: [",", ";", "", ""], Period: [".", ":", "", ""], Slash: ["-", "_", "", ""], NumpadDivide: ["/", "/", "", ""], NumpadMultiply: ["*", "*", "", ""], NumpadSubtract: ["-", "-", "", ""], NumpadAdd: ["+", "+", "", ""], IntlBackslash: ["<", ">", "|", ""] } });
    Kt({ id: "apple.german", locale: "de", displayName: "German", virtualLayout: "qwertz", platform: "apple", score: 0, mapping: { KeyA: ["a", "A", "å", "Å"], KeyB: ["b", "B", "∫", "‹"], KeyC: ["c", "C", "ç", "Ç"], KeyD: ["d", "D", "∂", "™"], KeyE: ["e", "E", "€", "‰"], KeyF: ["f", "F", "ƒ", "Ï"], KeyG: ["g", "G", "©", "Ì"], KeyH: ["h", "H", "ª", "Ó"], KeyI: ["i", "I", "⁄", "Û"], KeyJ: ["j", "J", "º", "ı"], KeyK: ["k", "K", "∆", "ˆ"], KeyL: ["l", "L", "@", "ﬂ"], KeyM: ["m", "M", "µ", "˘"], KeyN: ["n", "N", "~", "›"], KeyO: ["o", "O", "ø", "Ø"], KeyP: ["p", "P", "π", "∏"], KeyQ: ["q", "Q", "«", "»"], KeyR: ["r", "R", "®", "¸"], KeyS: ["s", "S", "‚", "Í"], KeyT: ["t", "T", "†", "˝"], KeyU: ["u", "U", "¨", "Á"], KeyV: ["v", "V", "√", "◊"], KeyW: ["w", "W", "∑", "„"], KeyX: ["x", "X", "≈", "Ù"], KeyY: ["z", "Z", "Ω", "ˇ"], KeyZ: ["y", "Y", "¥", "‡"], Digit1: ["1", "!", "¡", "¬"], Digit2: ["2", '"', "“", "”"], Digit3: ["3", "§", "¶", "#"], Digit4: ["4", "$", "¢", "£"], Digit5: ["5", "%", "[", "ﬁ"], Digit6: ["6", "&", "]", "^"], Digit7: ["7", "/", "|", "\\"], Digit8: ["8", "(", "{", "˜"], Digit9: ["9", ")", "}", "·"], Digit0: ["0", "=", "≠", "¯"], Space: [" ", " ", " ", " "], Minus: ["ß", "?", "¿", "˙"], Equal: ["´", "`", "'", "˚"], BracketLeft: ["ü", "Ü", "•", "°"], BracketRight: ["+", "*", "±", ""], Backslash: ["#", "'", "‘", "’"], Semicolon: ["ö", "Ö", "œ", "Œ"], Quote: ["ä", "Ä", "æ", "Æ"], Backquote: ["<", ">", "≤", "≥"], Comma: [",", ";", "∞", "˛"], Period: [".", ":", "…", "÷"], Slash: ["-", "_", "–", "—"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], NumpadDecimal: [",", ",", ".", "."], IntlBackslash: ["^", "°", "„", "“"], NumpadEqual: ["=", "=", "=", "="] } });
    Kt({ id: "dvorak", locale: "en", displayName: "Dvorak", virtualLayout: "dvorak", platform: "", score: 0, mapping: { KeyA: ["a", "A", "å", "Å"], KeyB: ["x", "X", "≈", "˛"], KeyC: ["j", "J", "∆", "Ô"], KeyD: ["e", "E", "´", "´"], KeyE: [".", ">", "≥", "˘"], KeyF: ["u", "U", "¨", "¨"], KeyG: ["i", "I", "ˆ", "ˆ"], KeyH: ["d", "D", "∂", "Î"], KeyI: ["c", "C", "ç", "Ç"], KeyJ: ["h", "H", "˙", "Ó"], KeyK: ["t", "T", "†", "ˇ"], KeyL: ["n", "N", "˜", "˜"], KeyM: ["m", "M", "µ", "Â"], KeyN: ["b", "B", "∫", "ı"], KeyO: ["r", "R", "®", "‰"], KeyP: ["l", "L", "¬", "Ò"], KeyQ: ["'", '"', "æ", "Æ"], KeyR: ["p", "P", "π", "∏"], KeyS: ["o", "O", "ø", "Ø"], KeyT: ["y", "Y", "¥", "Á"], KeyU: ["g", "G", "©", "˝"], KeyV: ["k", "K", "˚", ""], KeyW: [",", "<", "≤", "¯"], KeyX: ["q", "Q", "œ", "Œ"], KeyY: ["f", "F", "ƒ", "Ï"], KeyZ: [";", ":", "…", "Ú"], Digit1: ["1", "!", "¡", "⁄"], Digit2: ["2", "@", "™", "€"], Digit3: ["3", "#", "£", "‹"], Digit4: ["4", "$", "¢", "›"], Digit5: ["5", "%", "∞", "ﬁ"], Digit6: ["6", "^", "§", "ﬂ"], Digit7: ["7", "&", "¶", "‡"], Digit8: ["8", "*", "•", "°"], Digit9: ["9", "(", "ª", "·"], Digit0: ["0", ")", "º", "‚"], Space: [" ", " ", " ", " "], Minus: ["[", "{", "“", "”"], Equal: ["]", "}", "‘", "’"], BracketLeft: ["/", "?", "÷", "¿"], BracketRight: ["=", "+", "≠", "±"], Backslash: ["\\", "|", "«", "»"], Semicolon: ["s", "S", "ß", "Í"], Quote: ["-", "_", "–", "—"], Backquote: ["`", "~", "`", "`"], Comma: ["w", "W", "∑", "„"], Period: ["v", "V", "√", "◊"], Slash: ["z", "Z", "Ω", "¸"], NumpadDivide: ["/", "/", "/", "/"], NumpadMultiply: ["*", "*", "*", "*"], NumpadSubtract: ["-", "-", "-", "-"], NumpadAdd: ["+", "+", "+", "+"], Numpad1: ["1", "1", "1", "1"], Numpad2: ["2", "2", "2", "2"], Numpad3: ["3", "3", "3", "3"], Numpad4: ["4", "4", "4", "4"], Numpad5: ["5", "5", "5", "5"], Numpad6: ["6", "6", "6", "6"], Numpad7: ["7", "7", "7", "7"], Numpad8: ["8", "8", "8", "8"], Numpad9: ["9", "9", "9", "9"], Numpad0: ["0", "0", "0", "0"], NumpadDecimal: [".", ".", ".", "."], IntlBackslash: ["§", "±", "§", "±"], NumpadEqual: ["=", "=", "=", "="], AudioVolumeUp: ["", "=", "", "="] } });
    function zc(r) {
      if (fe()) {
        let e = Xt(), t = r.startsWith("!"), i = r.endsWith(e);
        if (t && !i || !t && i)
          return true;
      }
      return r === "!other" ? false : r === "other";
    }
    function fs(r, e, t) {
      if (r.length === 0)
        return "";
      let i = Pi(wa(t));
      for (let o = r.length - 1; o >= 0; o--)
        if (r[o].key === i && (!r[o].ifMode || r[o].ifMode === e))
          return r[o].command;
      return "";
    }
    function hs(r) {
      let e = r;
      return Y(e) && (e = e.length > 0 ? e[0] + "(" + e.slice(1).join("") + ")" : ""), e;
    }
    function gs(r, e) {
      let t = [];
      if (typeof e == "string") {
        let a = rs[e];
        Y(a) ? t = a.slice() : a && t.push(a);
      }
      let i = hs(e), o = new RegExp("^" + i.replace("\\", "\\\\").replace("|", "\\|").replace("*", "\\*").replace("$", "\\$").replace("^", "\\^") + "([^*a-zA-Z]|$)");
      for (let a of r)
        o.test(hs(a.command)) && t.push(a.key);
      return t.map(Ki);
    }
    function Ki(r) {
      var o;
      let e = /macos|ios|/.test(Xt()), t = r.split("+"), i = "";
      for (let a of t)
        !e && i && (i += '<span class="ML__shortcut-join">+</span>'), a.startsWith("[Key") ? i += a.slice(4, 5) : a.startsWith("Key") ? i += a.slice(3, 4) : a.startsWith("[Digit") ? i += a.slice(6, 7) : a.startsWith("Digit") ? i += a.slice(5, 6) : i += (o = { cmd: "⌘", meta: e ? "⌘" : "command", shift: e ? "⇧" : "shift", alt: e ? "⌥" : "alt", ctrl: e ? "⌃" : "control", "\n": e ? "⏎" : "return", "[return]": e ? "⏎" : "return", "[enter]": e ? "⌤" : "enter", "[tab]": e ? "⇥" : "tab", "[escape]": "esc", "[backspace]": e ? "⌫" : "backspace", "[delete]": e ? "⌦" : "del", "[pageup]": e ? "⇞" : "page up", "[pagedown]": e ? "⇟" : "page down", "[home]": e ? "⤒" : "home", "[end]": e ? "⤓" : "end", "[space]": "space", "[equal]": "=", "[minus]": "-", "[comma]": ",", "[slash]": "/", "[backslash]": "\\", "[bracketleft]": "[", "[bracketright]": "]", semicolon: ";", period: ".", comma: ",", minus: "-", equal: "=", quote: "'", bracketLeft: "[", bracketRight: "]", backslash: "\\", intlbackslash: "\\", backquote: "`", slash: "/", numpadmultiply: "* &#128290;", numpaddivide: "/ &#128290;", numpadsubtract: "- &#128290;", numpadadd: "+ &#128290;", numpaddecimal: ". &#128290;", numpadcomma: ", &#128290;", help: "help", left: "⇠", up: "⇡", right: "⇢", down: "⇣", "[arrowleft]": "⇠", "[arrowup]": "⇡", "[arrowright]": "⇢", "[arrowdown]": "⇣", "[digit0]": "0", "[digit1]": "1", "[digit2]": "2", "[digit3]": "3", "[digit4]": "4", "[digit5]": "5", "[digit6]": "6", "[digit7]": "7", "[digit8]": "8", "[digit9]": "9" }[a.toLowerCase()]) != null ? o : a.toUpperCase();
      return i;
    }
    function Rc(r, e) {
      if (r.ifPlatform && !/^!?(macos|windows|android|ios|chromeos|other)$/.test(r.ifPlatform))
        throw new Error(`Unexpected platform "${r.ifPlatform}" for keybinding ${r.key}`);
      if (r.ifLayout !== void 0 && (e.score === 0 || !r.ifLayout.includes(e.id)))
        return;
      let t = wa(r.key), i = r.ifPlatform;
      if (t.cmd) {
        if (i && i !== "macos" && i !== "ios")
          throw new Error('Unexpected "cmd" modifier with platform "' + i + `"
"cmd" modifier can only be used with macOS or iOS platform.`);
        i || (i = Xt() === "ios" ? "ios" : "macos"), t.win = false, t.cmd = false, t.meta = true;
      }
      if (t.win) {
        if (i && i !== "windows")
          throw new Error('Unexpected "win" modifier with platform "' + i + `"
"win" modifier can only be used with Windows platform.`);
        i = "windows", t.win = false, t.cmd = false, t.meta = true;
      }
      if (i && !zc(i))
        return;
      if (/^\[.+\]$/.test(t.key))
        return E(b({}, r), { ifPlatform: i, key: Pi(t) });
      let o = us(t.key, e);
      if (!o)
        throw new Error('Invalid keybinding key "' + r.key + '"');
      if (o.shift && t.shift || o.alt && t.alt)
        throw new Error(`The keybinding ${r.key} (${Sa(r.command)}) is conflicting with the key combination ${Pi(o)} using the ${e.displayName} keyboard layout`);
      return o.shift = o.shift || t.shift, o.alt = o.alt || t.alt, o.meta = t.meta, o.ctrl = t.ctrl, E(b({}, r), { ifPlatform: i, key: Pi(o) });
    }
    function Sa(r) {
      if (Array.isArray(r)) {
        let e = [...r];
        return e.shift() + "(" + e.map((t) => typeof t == "string" ? `"${t}"` : t.toString()).join(", ") + ")";
      }
      return r;
    }
    function ys(r, e) {
      let t = [], i = [];
      for (let o of r)
        try {
          let a = Rc(o, e);
          if (a) {
            let n = t.filter((s) => s.key === a.key && s.ifMode === a.ifMode);
            if (n.length > 0)
              throw new Error(`Ambiguous key binding ${o.key} (${Sa(o.command)}) matches ${n[0].key} (${Sa(n[0].command)}) with the ${e.displayName} keyboard layout`);
            t.push(a);
          }
        } catch (a) {
          a instanceof Error && i.push(a.message);
        }
      return [t, i];
    }
    var _a = `/* The element that display info while in latex mode */
#mathlive-popover-panel {
  visibility: hidden;
  background-color: rgba(97, 97, 97, 0.95);
  color: #fff;
  text-align: center;
  border-radius: 8px;
  position: fixed;
  z-index: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
  transition: all 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  /* The 'tip' of the popover panel */
}
#mathlive-popover-panel::after {
  content: '';
  position: absolute;
  top: -5px;
  left: calc(50% - 3px);
  width: 0;
  height: 0;
  border-left: 5px solid transparent;
  border-right: 5px solid transparent;
  font-size: 1rem;
  border-bottom: 5px solid rgba(97, 97, 97, 0.9);
}
#mathlive-popover-panel.is-visible {
  visibility: inherit;
  animation: ML__fade-in cubic-bezier(0, 0, 0.2, 1) 0.15s;
}
@keyframes ML__fade-in {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}
/* The wrapper class for the entire content of the popover panel */
#mathlive-popover-panel ul {
  display: flex;
  flex-flow: column;
  list-style: none;
  margin: 0;
  padding: 0;
  align-items: flex-start;
  justify-content: center;
}
#mathlive-popover-panel li {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  margin: 8px;
  padding: 8px;
  width: calc(100% - 16px - 16px);
  column-gap: 1em;
  border-radius: 8px;
  cursor: pointer;
  /* Since the content can be clicked on, provide feedback on hover */
}
#mathlive-popover-panel li a {
  color: #5ea6fd;
  padding-top: 0.3em;
  margin-top: 0.4em;
  display: block;
}
#mathlive-popover-panel li a:hover {
  color: #5ea6fd;
  text-decoration: underline;
}
#mathlive-popover-panel li:hover,
#mathlive-popover-panel li.is-pressed,
#mathlive-popover-panel li.is-active {
  background: rgba(255, 255, 255, 0.1);
}
/* The command inside a popover (inside a #mathlive-popover-panel) */
.ML__popover__command {
  font-size: 1.6rem;
  font-family: KaTeX_Main;
}
.ML__popover__latex {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;
  align-self: center;
}
/* The keyboard shortcuts for a symbol as displayed in the popover */
.ML__popover__keybinding {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 0.8em;
  opacity: 0.7;
}
/* Style for the character that joins the modifiers of a keyboard shortcut 
(usually a "+" sign)*/
.ML__shortcut-join {
  opacity: 0.5;
}
`;
    var Ie = `.ML__sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  margin: -1px;
  padding: 0;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  clip-path: inset(50%);
  white-space: nowrap;
  border: 0;
}
.ML__is-inline {
  display: inline-block;
}
.ML__base {
  visibility: inherit;
  display: inline-block;
  position: relative;
  cursor: text;
  padding: 0;
  margin: 0;
  box-sizing: content-box;
  border: 0;
  outline: 0;
  vertical-align: baseline;
  font-weight: inherit;
  font-family: inherit;
  font-style: inherit;
  text-decoration: none;
  width: min-content;
}
.ML__strut,
.ML__strut--bottom {
  display: inline-block;
  min-height: 0.5em;
}
.ML__small-delim {
  font-family: KaTeX_Main;
}
/* Text mode */
.ML__text {
  font-family: var(--text-font-family, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif);
  white-space: pre;
}
/* Use cmr for 'math upright' */
.ML__cmr {
  font-family: KaTeX_Main;
  font-style: normal;
}
.ML__mathit {
  font-family: KaTeX_Math;
  /* The KaTeX_Math font is italic by default, so the font-style below is only 
     useful when a fallback font is used
  */
  font-style: italic;
}
.ML__mathbf {
  font-family: KaTeX_Main;
  font-weight: bold;
}
/* Lowercase greek symbols should stick to math font when \\mathbf is applied 
   to match TeX idiosyncratic behavior */
.lcGreek.ML__mathbf {
  font-family: KaTeX_Math;
  font-weight: normal;
}
.ML__mathbfit {
  font-family: KaTeX_Math;
  font-weight: bold;
  font-style: italic;
}
.ML__ams {
  font-family: KaTeX_AMS;
}
/* Blackboard */
.ML__bb {
  font-family: KaTeX_AMS;
}
.ML__cal {
  font-family: KaTeX_Caligraphic;
}
.ML__frak {
  font-family: KaTeX_Fraktur;
}
.ML__tt {
  font-family: KaTeX_Typewriter;
}
.ML__script {
  font-family: KaTeX_Script;
}
.ML__sans {
  font-family: KaTeX_SansSerif;
}
.ML__series_ul {
  font-weight: 100;
}
.ML__series_el {
  font-weight: 100;
}
.ML__series_l {
  font-weight: 200;
}
.ML__series_sl {
  font-weight: 300;
}
.ML__series_sb {
  font-weight: 500;
}
.ML__bold,
.ML__boldsymbol {
  font-weight: 700;
}
.ML__series_eb {
  font-weight: 800;
}
.ML__series_ub {
  font-weight: 900;
}
.ML__series_uc {
  font-stretch: ultra-condensed;
}
.ML__series_ec {
  font-stretch: extra-condensed;
}
.ML__series_c {
  font-stretch: condensed;
}
.ML__series_sc {
  font-stretch: semi-condensed;
}
.ML__series_sx {
  font-stretch: semi-expanded;
}
.ML__series_x {
  font-stretch: expanded;
}
.ML__series_ex {
  font-stretch: extra-expanded;
}
.ML__series_ux {
  font-stretch: ultra-expanded;
}
.ML__it {
  font-style: italic;
}
.ML__shape_ol {
  -webkit-text-stroke: 1px black;
  text-stroke: 1px black;
  color: transparent;
}
.ML__shape_sc {
  font-variant: small-caps;
}
.ML__shape_sl {
  font-style: oblique;
}
/* First level emphasis */
.ML__emph {
  color: #bc2612;
}
/* Second level emphasis */
.ML__emph .ML__emph {
  color: #0c7f99;
}
.ML__highlight {
  color: #007cb2;
  background: #edd1b0;
}
.ML__center {
  text-align: center;
}
.ML__label_padding {
  padding: 0 0.5em;
}
.ML__frac-line {
  width: 100%;
  min-height: 1px;
}
.ML__frac-line:after {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  /* There's a bug since Chrome 62 where 
      sub-pixel border lines don't draw at some zoom 
      levels (110%, 90%). 
      Setting the min-height used to work around it, but that workaround
      broke in Chrome 84 or so.
      Setting the background (and the min-height) seems to work for now.
      */
  background: currentColor;
  box-sizing: content-box;
  /* Vuetify sets the box-sizing to inherit 
            causes the fraction line to not draw at all sizes (see #26) */
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt {
  display: inline-block;
}
.ML__sqrt-sign {
  display: inline-block;
  font-family: KaTeX_Main;
  position: relative;
}
.ML__sqrt-line {
  display: inline-block;
  height: 0.04em;
  width: 100%;
}
.ML__sqrt-line:before {
  content: '';
  display: block;
  margin-top: -0.04em;
  min-height: 0.04em;
  /* Ensure the line is visible when printing even if "turn off background images" is on*/
  -webkit-print-color-adjust: exact;
  print-color-adjust: exact;
  background: currentColor;
  /* On some versions of Firefox on Windows, the line fails to 
            draw at some zoom levels, but setting the transform triggers
            the hardware accelerated path, which works */
  transform: translate(0, 0);
}
.ML__sqrt-line:after {
  border-bottom-width: 1px;
  content: ' ';
  display: block;
  margin-top: -0.1em;
}
.ML__sqrt-index {
  margin-left: 0.27777778em;
  margin-right: -0.55555556em;
}
.ML__delim-size1 {
  font-family: KaTeX_Size1;
}
.ML__delim-size2 {
  font-family: KaTeX_Size2;
}
.ML__delim-size3 {
  font-family: KaTeX_Size3;
}
.ML__delim-size4 {
  font-family: KaTeX_Size4;
}
.ML__delim-mult .delim-size1 > span {
  font-family: KaTeX_Size1;
}
.ML__delim-mult .delim-size4 > span {
  font-family: KaTeX_Size4;
}
.ML__accent-body > span {
  font-family: KaTeX_Main;
  width: 0;
}
.ML__accent-vec > span {
  position: relative;
  left: 0.24em;
}
.ML__mathlive {
  display: inline-block;
  direction: ltr;
  text-align: left;
  text-indent: 0;
  text-rendering: auto;
  font-family: KaTeX_Main, 'Times New Roman', serif;
  font-style: normal;
  font-size-adjust: none;
  font-stretch: normal;
  font-variant-caps: normal;
  letter-spacing: normal;
  line-height: 1.2;
  word-wrap: normal;
  word-spacing: normal;
  white-space: nowrap;
  text-shadow: none;
  -webkit-user-select: none;
  user-select: none;
  width: min-content;
}
.ML__mathlive .style-wrap {
  position: relative;
}
.ML__mathlive .mfrac,
.ML__mathlive .left-right {
  display: inline-block;
}
.ML__mathlive .vlist-t {
  display: inline-table;
  table-layout: fixed;
  border-collapse: collapse;
}
.ML__mathlive .vlist-r {
  display: table-row;
}
.ML__mathlive .vlist {
  display: table-cell;
  vertical-align: bottom;
  position: relative;
}
.ML__mathlive .vlist > span {
  display: block;
  height: 0;
  position: relative;
}
.ML__mathlive .vlist > span > span {
  display: inline-block;
}
.ML__mathlive .vlist > span > .pstrut {
  overflow: hidden;
  width: 0;
}
.ML__mathlive .vlist-t2 {
  margin-right: -2px;
}
.ML__mathlive .vlist-s {
  display: table-cell;
  vertical-align: bottom;
  font-size: 1px;
  width: 2px;
  min-width: 2px;
}
.ML__mathlive .msubsup {
  text-align: left;
}
.ML__mathlive .negativethinspace {
  display: inline-block;
  margin-left: -0.16667em;
  height: 0.71em;
}
.ML__mathlive .thinspace {
  display: inline-block;
  width: 0.16667em;
  height: 0.71em;
}
.ML__mathlive .mediumspace {
  display: inline-block;
  width: 0.22222em;
  height: 0.71em;
}
.ML__mathlive .thickspace {
  display: inline-block;
  width: 0.27778em;
  height: 0.71em;
}
.ML__mathlive .enspace {
  display: inline-block;
  width: 0.5em;
  height: 0.71em;
}
.ML__mathlive .quad {
  display: inline-block;
  width: 1em;
  height: 0.71em;
}
.ML__mathlive .qquad {
  display: inline-block;
  width: 2em;
  height: 0.71em;
}
.ML__mathlive .llap,
.ML__mathlive .rlap {
  width: 0;
  position: relative;
  display: inline-block;
}
.ML__mathlive .llap > .inner,
.ML__mathlive .rlap > .inner {
  position: absolute;
}
.ML__mathlive .llap > .fix,
.ML__mathlive .rlap > .fix {
  display: inline-block;
}
.ML__mathlive .llap > .inner {
  right: 0;
}
.ML__mathlive .rlap > .inner {
  left: 0;
}
.ML__mathlive .rule {
  display: inline-block;
  border: solid 0;
  position: relative;
  box-sizing: border-box;
}
.ML__mathlive .overline .overline-line,
.ML__mathlive .underline .underline-line {
  width: 100%;
}
.ML__mathlive .overline .overline-line:before,
.ML__mathlive .underline .underline-line:before {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  content: '';
  display: block;
}
.ML__mathlive .overline .overline-line:after,
.ML__mathlive .underline .underline-line:after {
  border-bottom-style: solid;
  border-bottom-width: 0.04em;
  min-height: thin;
  /* There's a bug since Chrome 62 where 
            sub-pixel border lines don't draw at some zoom 
            levels (110%, 90%). Setting the min-height seems to work around it.
            */
  content: '';
  display: block;
  margin-top: -1px;
}
.ML__mathlive .stretchy {
  display: block;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .stretchy:before,
.ML__mathlive .stretchy:after {
  content: '';
}
.ML__mathlive .stretchy svg {
  display: block;
  position: absolute;
  width: 100%;
  height: inherit;
  fill: currentColor;
  stroke: currentColor;
  fill-rule: nonzero;
  fill-opacity: 1;
  stroke-width: 1;
  stroke-linecap: butt;
  stroke-linejoin: miter;
  stroke-miterlimit: 4;
  stroke-dasharray: none;
  stroke-dashoffset: 0;
  stroke-opacity: 1;
}
.ML__mathlive .slice-1-of-2 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-2 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 50.2%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-3 {
  display: inline-flex;
  position: absolute;
  left: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-2-of-3 {
  display: inline-flex;
  position: absolute;
  left: 25%;
  width: 50%;
  overflow: hidden;
}
.ML__mathlive .slice-3-of-3 {
  display: inline-flex;
  position: absolute;
  right: 0;
  width: 25.1%;
  overflow: hidden;
}
.ML__mathlive .slice-1-of-1 {
  display: inline-flex;
  position: absolute;
  width: 100%;
  left: 0;
  overflow: hidden;
}
.ML__mathlive .nulldelimiter {
  width: 0.12em;
  display: inline-block;
}
.ML__mathlive .op-group {
  display: inline-block;
}
.ML__mathlive .op-symbol {
  position: relative;
}
.ML__mathlive .op-symbol.small-op {
  font-family: KaTeX_Size1;
}
.ML__mathlive .op-symbol.large-op {
  font-family: KaTeX_Size2;
}
.ML__mathlive .accent > .vlist > span {
  text-align: center;
}
.ML__mathlive .mtable .vertical-separator {
  display: inline-block;
  min-width: 1px;
  box-sizing: border-box;
}
.ML__mathlive .mtable .arraycolsep {
  display: inline-block;
}
.ML__mathlive .mtable .col-align-m > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-c > .vlist-t {
  text-align: center;
}
.ML__mathlive .mtable .col-align-l > .vlist-t {
  text-align: left;
}
.ML__mathlive .mtable .col-align-r > .vlist-t {
  text-align: right;
}
.ML__error {
  display: inline-block;
  background-image: radial-gradient(ellipse at center, hsl(341, 100%, 40%), rgba(0, 0, 0, 0) 70%);
  background-color: hsla(341, 100%, 40%, 0.1);
  background-repeat: repeat-x;
  background-size: 3px 3px;
  padding-bottom: 3px;
  background-position: 0 100%;
}
.ML__error > .ML__error {
  background: transparent;
  padding: 0;
}
.ML__composition {
  background: #fff1c2;
  color: black;
  text-decoration: underline var(--caret-color-computed, var(--ML__caret-color));
}
.ML__placeholder {
  color: var(--placeholder-color, var(--ML__placeholder-color));
  opacity: var(--placeholder-opacity, 0.4);
  padding-left: 0.4ex;
  padding-right: 0.4ex;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
}
.ML__notation {
  position: absolute;
  box-sizing: border-box;
}
.ML__container {
  min-height: auto !important;
}
.ML__prompt {
  border-radius: 2px;
}
.ML__editablePromptBox {
  outline: 1px solid #acacac;
  border-radius: 2px;
  z-index: -1;
}
.ML__focusedPromptBox {
  outline: highlight auto 1px;
}
.ML__lockedPromptBox {
  background-color: rgba(142, 142, 141, 0.4);
  z-index: -1;
}
.ML__correctPromptBox {
  outline: 1px solid var(--correct-color, var(--ML__correct-color));
  box-shadow: 0 0 5px var(--correct-color, var(--ML__correct-color));
}
.ML__incorrectPromptBox {
  outline: 1px solid var(--incorrect-color, var(--ML__incorrect-color));
  box-shadow: 0 0 5px var(--incorrect-color, var(--ML__incorrect-color));
}
`;
    function Vt(r) {
      return { value: r.model.getValue(), selectionIsCollapsed: r.model.selectionIsCollapsed, canUndo: r.canUndo(), canRedo: r.canRedo() };
    }
    var ko = "mathlive#virtual-keyboard-message";
    function Di(r) {
      var t;
      return !(r.type !== "message" || ((t = r.data) == null ? void 0 : t.type) !== ko);
    }
    var ei = class {
      constructor() {
        this.targetOrigin = window.origin;
        this.originValidator = "none";
        window.addEventListener("message", this), this.sendMessage("proxy-created"), this.listeners = {};
      }
      static get singleton() {
        return this._singleton || (this._singleton = new ei()), this._singleton;
      }
      set alphabeticLayout(e) {
        this.sendMessage("update-setting", { alphabeticLayout: e });
      }
      set layouts(e) {
        this.sendMessage("update-setting", { layouts: e });
      }
      set actionToolbar(e) {
        this.sendMessage("update-setting", { actionToolbar: e });
      }
      set container(e) {
        throw new Error("Container inside an iframe cannot be changed");
      }
      show() {
        this.sendMessage("show");
      }
      hide() {
        this.sendMessage("hide");
      }
      get visible() {
        return this._boundingRect.height > 0;
      }
      set visible(e) {
        e ? this.show() : this.hide();
      }
      get boundingRect() {
        return this._boundingRect;
      }
      executeCommand(e) {
        return this.sendMessage("execute-command", { command: e }), true;
      }
      updateToolbar(e) {
        this.sendMessage("update-toolbar", e);
      }
      connect() {
        this.sendMessage("connect");
      }
      disconnect() {
        this.sendMessage("disconnect");
      }
      addEventListener(e, t, i) {
        this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set()), this.listeners[e].has(t) || this.listeners[e].add(t);
      }
      dispatchEvent(e) {
        return !this.listeners[e.type] || this.listeners[e.type].size === 0 ? true : (this.listeners[e.type].forEach((t) => {
          typeof t == "function" ? t(e) : t == null || t.handleEvent(e);
        }), !e.defaultPrevented);
      }
      removeEventListener(e, t, i) {
        this.listeners[e] && this.listeners[e].delete(t);
      }
      handleEvent(e) {
        if (Di(e)) {
          if (!Qr(e.origin, this.originValidator))
            throw new DOMException(`Message from unknown origin (${e.origin}) cannot be handled`, "SecurityError");
          let { action: t } = e.data;
          if (t === "execute-command") {
            let { command: i } = e.data;
            hr(i) === "virtual-keyboard" && this.executeCommand(i);
            return;
          }
          if (t === "synchronize-proxy") {
            this._boundingRect = e.data.boundingRect;
            return;
          }
          if (t === "geometry-changed") {
            this._boundingRect = e.data.boundingRect, this.dispatchEvent(new Event("geometrychange"));
            return;
          }
        }
      }
      sendMessage(e, t = {}) {
        if (!window.top)
          throw new DOMException("A frame does not have access to the top window and can‘t communicate with the keyboard. Review virtualKeyboardTargetOrigin and originValidator on the mathfield embedded in an iframe", "SecurityError");
        window.top.postMessage(b({ type: ko, action: e }, t), this.targetOrigin);
      }
    };
    function ti(r, e, t) {
      t.default && (r.dataset.command = JSON.stringify(t.default)), t.alt && (r.dataset.commandAlt = JSON.stringify(t.alt)), t.shift && (r.dataset.commandShift = JSON.stringify(t.shift)), t.pressed && (r.dataset.commandPressed = JSON.stringify(t.pressed)), t.pressAndHold && (r.dataset.commandPressAndHold = JSON.stringify(t.pressAndHold));
      let i;
      je(r, "pointerdown:passive", (o) => {
        if (o.buttons !== 1)
          return;
        o.stopPropagation(), r.classList.add("is-pressed");
        let a = o.target;
        a.hasPointerCapture(o.pointerId) && a.releasePointerCapture(o.pointerId);
        let n = r.getAttribute("data-command-pressed");
        n && e(JSON.parse(n));
        let s = r.getAttribute("data-command-press-and-hold");
        s && (i && clearTimeout(i), i = setTimeout(() => {
          r.classList.contains("is-pressed") && (r.classList.remove("is-pressed"), r.classList.add("is-active"), e(JSON.parse(s)));
        }, 300));
      }), je(r, "pointerenter", (o) => {
        let a = o.target;
        a.hasPointerCapture(o.pointerId) && a.releasePointerCapture(o.pointerId), o.buttons === 1 && r.classList.add("is-pressed");
      }), je(r, "pointercancel", () => r.classList.remove("is-pressed")), je(r, "pointerleave", () => r.classList.remove("is-pressed")), je(r, "pointerup", (o) => {
        r.classList.remove("is-pressed"), r.classList.add("is-active"), setTimeout(() => r.classList.remove("is-active"), 150);
        let a = null;
        !a && o.altKey && (a = r.getAttribute("data-command-alt")), !a && o.shiftKey && (a = r.getAttribute("data-command-shift")), a || (a = r.getAttribute("data-command")), a && e(JSON.parse(a)), o.stopPropagation(), o.preventDefault();
      });
    }
    var Ma = `@layer ML_keyboard {
  :where(:root) {
    --keyboard-height: 0;
    --keyboard-accent-color: #0b579d;
    --keyboard-background: #cacfd7;
    --keyboard-border: #ddd;
    --keyboard-padding-horizontal: 0px;
    --keyboard-padding-top: 5px;
    --keyboard-padding-bottom: 0px;
    --keyboard-toolbar-text: #2c2e2f;
    --keyboard-toolbar-text-active: var(--keyboard-accent-color);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #eee;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: white;
    --keycap-background-hover: #f5f5f7;
    --keycap-background-active: white;
    --keycap-border: #e5e6e9;
    --keycap-border-bottom: #8d8f92;
    --keycap-text: #000;
    --keycap-text-active: #fff;
    --keycap-text-hover: #fff;
    --keycap-secondary-text: #000;
    --keycap-modifier-background: #b9bfc8;
    --keycap-modifier-background-hover: #a0a9b6;
    --keycap-modifier-text: #060707;
    --keycap-modifier-border: #c5c9d0;
    --keycap-modifier-border-bottom: #989da6;
    --keycap-height: 62px;
    --keycap-font-size: clamp(16px, 4cqw, 24px);
    --keycap-small-font-size: calc(var(--keycap-font-size) * 0.8);
    --keycap-extra-small-font-size: calc(var(--keycap-font-size) / 1.42);
    --variant-panel-background: #fff;
    --variant-keycap-text: var(--keycap-text, #000);
    --variant-keycap-text-active: #fff;
    --variant-keycap-background-active: var(--keyboard-accent-color);
    --variant-keycap-length: 70px;
    --variant-keycap-font-size: 30px;
    --variant-keycap-aside-font-size: 12px;
  }
  body > .ML__keyboard {
    position: fixed;
    --keyboard-padding-bottom: calc(var(--keyboard-padding-bottom) + env(safe-area-inset-bottom, 0));
  }
  body > .ML__keyboard.is-visible > .MLK__backdrop {
    box-shadow: 0 -5px 6px rgba(0, 0, 0, 0.08);
    border-top: 1px solid var(--keyboard-border);
    transition: 0.28s cubic-bezier(0, 0, 0.2, 1);
    transition-property: transform, opacity;
    transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
  }
  .ML__keyboard {
    position: relative;
    overflow: hidden;
    top: 0;
    left: 0;
    height: 100%;
    width: 100%;
    z-index: var(--keyboard-zindex, 105);
    pointer-events: none;
  }
  .MLK__backdrop {
    position: absolute;
    bottom: calc(-1 * var(--keyboard-height));
    width: 100%;
    height: var(--keyboard-height);
    box-sizing: border-box;
    padding-top: var(--keyboard-padding-top);
    padding-bottom: var(--keyboard-padding-bottom);
    padding-left: var(--keyboard-padding-horizontal);
    padding-right: var(--keyboard-padding-horizontal);
    opacity: 0;
    visibility: hidden;
    transform: translate(0, 0);
    background: var(--keyboard-background);
  }
  .ML__keyboard.is-visible > .MLK__backdrop {
    transform: translate(0, calc(-1 * var(--keyboard-height)));
    opacity: 1;
    visibility: visible;
  }
  .MLK__plate {
    position: absolute;
    bottom: 0;
    left: var(--keyboard-padding-horizontal);
    width: calc(100% - 2 * var(--keyboard-padding-horizontal));
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    container-type: inline-size;
    touch-action: none;
    -webkit-user-select: none;
    user-select: none;
    pointer-events: all;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-size: 16px;
    /* Size of toolbar labels */
    font-weight: 400;
    text-shadow: none;
  }
  .MLK__tex {
    font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__tex-math {
    font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__layer {
    display: none;
    outline: none;
  }
  .MLK__layer.is-visible {
    display: flex;
    flex-flow: column;
  }
  /* Keyboard layouts are made or rows of keys... */
  .MLK__rows {
    border: 0;
    border-collapse: separate;
    clear: both;
    margin: auto;
    display: flex;
    flex-flow: column;
    align-items: center;
    overflow-x: auto;
    touch-action: none;
    /* Keycap with (incl. margin) */
    --max-width: 102px;
    --margin: 6px;
    /* For the alignment of the text on some modifiers (e.g. shift) */
    /* Extra spacing between two adjacent keys */
  }
  .MLK__rows .small {
    font-size: 12px;
  }
  .MLK__rows .tex {
    font-family: KaTeX_Math, KaTeX_Main, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__rows .tex-math {
    font-family: KaTeX_Math, 'Cambria Math', 'Asana Math', OpenSymbol, Symbola, STIX, Times, serif !important;
  }
  .MLK__rows .big-op {
    font-size: calc(1.25 * var(--keycap-font-size, 20px));
  }
  .MLK__rows .small {
    font-size: var(--keycap-small-font-size, 16px);
  }
  .MLK__rows .bottom {
    justify-content: flex-end;
  }
  .MLK__rows .left {
    align-items: flex-start;
    padding-left: 12px;
  }
  .MLK__rows .right {
    align-items: flex-end;
    padding-right: 12px;
  }
  .MLK__rows .w0 {
    width: 0;
  }
  .MLK__rows .w5 {
    width: calc(min(var(--max-width), 10cqw) / 2 - var(--margin));
  }
  .MLK__rows .w15 {
    width: calc(15 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .w20 {
    width: calc(20 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .w50 {
    width: calc(50 * min(var(--max-width), 10cqw) / 10 - var(--margin));
  }
  .MLK__rows .MLK__keycap.w50 {
    font-size: 80%;
    padding-top: 10px;
    font-weight: 100;
  }
  .MLK__rows .separator {
    background: transparent;
    border: none;
    pointer-events: none;
  }
  .MLK__rows .horizontal-rule {
    width: 100%;
    border-top: 1px solid var(--keycap-modifier-border-bottom);
  }
  .MLK__rows .ghost {
    background: transparent;
    border: none;
  }
  .MLK__rows .bigfnbutton {
    font-size: var(--keycap-extra-small-font-size, 14px);
  }
  .MLK__rows .modifier,
  .MLK__rows .action {
    color: var(--keycap-modifier-text);
    background: var(--keycap-modifier-background);
    border-color: var(--keycap-modifier-border);
    border-bottom-color: var(--keycap-modifier-border-bottom);
    font-size: 65%;
    font-weight: 100;
  }
  .MLK__rows .modifier:hover,
  .MLK__rows .action:hover {
    background: var(--keycap-modifier-background-hover);
  }
  .MLK__rows .modifier.selected,
  .MLK__rows .action.selected {
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__rows .modifier.selected:hover,
  .MLK__rows .action.selected:hover,
  .MLK__rows .modifier.selected:active,
  .MLK__rows .action.selected:active,
  .MLK__rows .modifier.selected.is-pressed,
  .MLK__rows .action.selected.is-pressed,
  .MLK__rows .modifier.selected.is-active,
  .MLK__rows .action.selected.is-active {
    color: white;
  }
  .MLK__rows .action.font-glyph,
  .MLK__rows .modifier.font-glyph {
    font-size: 2em;
  }
  .MLK__rows .warning {
    height: 25px;
    width: 25px;
    min-height: 25px;
    min-width: 25px;
    background: #cd0030;
    color: white;
    border-radius: 100%;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: -2px;
  }
  .MLK__rows .warning svg.svg-glyph {
    width: 16px;
    height: 16px;
  }
  .MLK__rows > ul {
    display: flex;
    flex-flow: row;
    width: 100%;
    list-style: none;
    margin: 0 0 var(--margin) 0;
    padding: 0;
  }
  .MLK__rows li {
    display: flex;
    flex-flow: column;
    align-items: center;
    justify-content: center;
    margin-right: var(--margin);
    width: calc(min(var(--max-width), 10cqw) - var(--margin));
    height: var(--keycap-height, 62px);
    box-sizing: border-box;
    padding: 0;
    vertical-align: top;
    text-align: center;
    float: left;
    color: var(--keycap-text);
    fill: currentColor;
    font-size: var(--keycap-font-size, 20px);
    background: var(--keycap-background);
    border: 1px solid var(--keycap-border);
    border-bottom-color: var(--keycap-border-bottom);
    border-radius: 5px;
    cursor: pointer;
    touch-action: none;
    /* Last key should be flush against the border */
    /* Keys with a variants panel */
    position: relative;
    overflow: hidden;
    -webkit-user-select: none;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
  }
  .MLK__rows li.horizontal-rule {
    margin-top: 1px;
    height: 3px;
  }
  .MLK__rows li:hover {
    background: var(--keycap-background-hover);
  }
  .MLK__rows li .ML__mathlive {
    pointer-events: none;
    touch-action: none;
  }
  .MLK__rows li:last-child {
    margin-right: 0;
  }
  .MLK__rows li svg.svg-glyph {
    margin: 8px 0;
    width: 20px;
    height: 20px;
  }
  .MLK__rows li svg.svg-glyph-lg {
    margin: 8px 0;
    width: 24px;
    height: 24px;
  }
  .MLK__rows li.MLK__tex-math {
    font-size: 25px;
  }
  .MLK__rows li.is-pressed {
    background: var(--keycap-background-active);
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__rows li.MLK__keycap.is-active,
  .MLK__rows li.action.is-active,
  .MLK__rows li.MLK__keycap.is-pressed,
  .MLK__rows li.action.is-pressed {
    z-index: calc(var(--keyboard-zindex, 105) - 5);
    background: var(--keyboard-accent-color);
    color: #fff;
  }
  .MLK__rows li.modifier.is-active {
    background: var(--keyboard-toolbar-text-active);
    color: var(--keycap-text-active);
  }
  .MLK__rows li small {
    color: var(--keycap-secondary-text);
  }
  .MLK__rows li aside {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-size: 10px;
    line-height: 10px;
    color: var(--keycap-secondary-text);
  }
  /* Add an attribute 'data-tooltip' to display a tooltip on hover.
Note there are a different set of tooltip rules for the keyboard toggle
(it's in a different CSS tree) */
  .MLK__tooltip {
    position: relative;
  }
  .MLK__tooltip::after {
    position: absolute;
    display: inline-table;
    content: attr(data-tooltip);
    top: inherit;
    bottom: 100%;
    width: max-content;
    max-width: 200px;
    padding: 8px 8px;
    background: #616161;
    color: #fff;
    text-align: center;
    z-index: 2;
    box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
    border-radius: 2px;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    font-weight: 400;
    font-size: 12px;
    transition: all 0.15s cubic-bezier(0.4, 0, 1, 1) 1s;
    opacity: 0;
    transform: scale(0.5);
  }
  .MLK__tooltip:hover {
    position: relative;
  }
  .MLK__tooltip:hover::after {
    opacity: 1;
    transform: scale(1);
  }
  .MLK__toolbar {
    align-self: center;
    display: flex;
    flex-flow: row;
    justify-content: space-between;
    width: 100%;
    max-width: 996px;
    min-height: 32px;
    /* Icons for undo/redo, etc. */
  }
  .MLK__toolbar svg {
    height: 20px;
    width: 20px;
  }
  .MLK__toolbar > .left {
    position: relative;
    display: flex;
    justify-content: flex-start;
    flex-flow: row;
  }
  .MLK__toolbar > .right {
    display: flex;
    justify-content: flex-end;
    flex-flow: row;
  }
  .MLK__toolbar > div > div {
    /* "button" in the toolbar */
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--keyboard-toolbar-text);
    fill: currentColor;
    background: var(--keyboard-toolbar-background);
    font-size: 125%;
    padding: 4px 15px;
    cursor: pointer;
    width: max-content;
    min-width: 42px;
    min-height: 22px;
    border: none;
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 8px;
    padding-top: 8px;
    margin-top: 7px;
    margin-bottom: 8px;
    margin-left: 4px;
    margin-right: 4px;
    border-radius: 8px;
    box-shadow: none;
    border-bottom: 2px solid transparent;
  }
  .MLK__toolbar > div > div:not(.disabled):not(.selected):hover {
    background: var(--keyboard-toolbar-background-hover);
  }
  .MLK__toolbar > div > div.disabled svg,
  .MLK__toolbar > div > div.disabled:hover svg,
  .MLK__toolbar > div > div.disabled.is-pressed svg {
    color: var(--keyboard-toolbar-text);
    opacity: 0.2;
  }
  .MLK__toolbar > div > div:hover,
  .MLK__toolbar > div > div:active,
  .MLK__toolbar > div > div.is-pressed,
  .MLK__toolbar > div > div.is-active {
    color: var(--keyboard-toolbar-text-active);
  }
  .MLK__toolbar > div > div.selected {
    color: var(--keyboard-toolbar-text-active);
    background: var(--keyboard-toolbar-background-selected);
    border-radius: 0;
    border-bottom-color: var(--keyboard-toolbar-text-active);
    padding-bottom: 4px;
    margin-bottom: 12px;
  }
  /* This is the element that displays variants on press+hold */
  .MLK__variant-panel {
    visibility: hidden;
    position: fixed;
    bottom: auto;
    top: 0;
    box-sizing: content-box;
    transform: none;
    z-index: calc(var(--keyboard-zindex, 105) + 1);
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-content: center;
    touch-action: none;
    max-width: 286px;
    background: var(--variant-panel-background);
    text-align: center;
    border-radius: 6px;
    padding: 6px;
    box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
    transition: none;
  }
  .MLK__variant-panel.is-visible {
    visibility: visible;
  }
  .MLK__variant-panel.compact {
    --variant-keycap-length: 50px;
    --variant-keycap-font-size: 24px;
    --variant-keycap-aside-font-size: 10px;
  }
  .MLK__variant-panel ul {
    list-style: none;
    margin: 3px;
    padding: 0;
    display: flex;
    flex-flow: row wrap-reverse;
    justify-content: center;
  }
  .MLK__variant-panel li {
    display: flex;
    flex-flow: column;
    align-items: center;
    justify-content: center;
    font-size: var(--variant-keycap-font-size);
    height: var(--variant-keycap-length);
    width: var(--variant-keycap-length);
    box-sizing: border-box;
    margin: 0;
    background: transparent;
    border: 1px solid transparent;
    border-radius: 5px;
    pointer-events: all;
    cursor: pointer;
    color: var(--variant-keycap-text);
    fill: currentColor;
  }
  @media (max-height: 412px) {
    .MLK__variant-panel li {
      font-size: 24px;
      height: 50px;
      width: 50px;
    }
  }
  .MLK__variant-panel li .ML__mathlive {
    pointer-events: none;
  }
  .MLK__variant-panel li:hover,
  .MLK__variant-panel li.is-pressed,
  .MLK__variant-panel li.is-active {
    background: var(--variant-keycap-background-active);
    color: var(--variant-keycap-text-active);
  }
  .MLK__variant-panel li.small {
    font-size: var(--keycap-small-font-size, 16px);
  }
  .MLK__variant-panel li.small-button {
    width: 42px;
    height: 42px;
    margin: 2px;
    background: #fbfbfb;
  }
  .MLK__variant-panel li.small-button:hover {
    background: var(--variant-keycap-background-active);
  }
  .MLK__variant-panel li.box > div,
  .MLK__variant-panel li.box > span {
    border: 1px dashed rgba(0, 0, 0, 0.24);
  }
  .MLK__variant-panel li .warning {
    min-height: 60px;
    min-width: 60px;
    background: #cd0030;
    color: white;
    padding: 5px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 5px;
  }
  .MLK__variant-panel li .warning:hover,
  .MLK__variant-panel li .warning.is-pressed,
  .MLK__variant-panel li .warning.is-active {
    background: red;
  }
  .MLK__variant-panel li .warning svg.svg-glyph {
    width: 50px;
    height: 50px;
  }
  .MLK__variant-panel li aside {
    font-size: var(--variant-keycap-aside-font-size);
    line-height: 12px;
    opacity: 0.78;
    padding-top: 2px;
  }
  /* @xs breakpoint: iPhone 5 */
  @container (max-width: 414px) {
    .MLK__variant-panel {
      max-width: 320px;
    }
    .MLK__toolbar > div > div {
      font-size: 100%;
      padding: 0;
      margin-left: 2px;
      margin-right: 2px;
    }
    .MLK__rows > ul {
      height: 42px;
    }
    .MLK__rows > ul > li {
      width: calc(10cqw - 2px);
      height: 42px;
      margin-right: 2px;
    }
    .MLK__rows .w5 {
      width: calc(5cqw - 2px);
    }
    .MLK__rows .w15 {
      width: calc(15cqw - 2px);
    }
    .MLK__rows .w20 {
      width: calc(20cqw - 2px);
    }
    .MLK__rows .w50 {
      width: calc(50cqw - 2px);
    }
    .MLK__rows .separator {
      width: 2px;
      min-width: 2px;
    }
    .MLK__rows .modifier,
    .MLK__rows .action {
      font-size: 65%;
    }
  }
  @container (max-width: 744px) {
    .MLK__toolbar > div > div {
      padding-left: 0;
      padding-right: 0;
    }
    .MLK__tooltip::after {
      padding: 8px 16px;
      font-size: 16px;
    }
    .MLK__rows .warning {
      height: 16px;
      width: 16px;
      min-height: 16px;
      min-width: 16px;
    }
    .MLK__rows .warning svg.svg-glyph {
      width: 14px;
      height: 14px;
    }
    .MLK__rows .action.font-glyph,
    .MLK__rows .modifier.font-glyph {
      font-size: 16px;
    }
    .MLK__rows .fnbutton {
      font-size: 16px;
    }
    .MLK__rows .bigfnbutton {
      font-size: calc(var(--keycap-extra-small-font-size, 14px) / 1.55);
    }
    .MLK__rows .small {
      font-size: 13px;
    }
    .MLK__rows aside {
      display: none;
    }
  }
  /* Medium breakpoint: larger phones */
  @container (max-width: 768px) {
    .ML__keyboard {
      --keycap-height: 42px;
    }
    .MLK__rows > ul > small {
      font-size: 14px;
    }
  }
  @container (max-width: 1444px) {
    .MLK__rows .if-wide {
      display: none;
    }
  }
  @media (prefers-color-scheme: dark) {
    .ML__keyboard {
      --keyboard-accent-color: hsl(212, 100%, 50%);
      --keyboard-background: #151515;
      --keyboard-border: transparent;
      --keyboard-toolbar-text: #e3e4e8;
      --keyboard-toolbar-text-active: hsl(212, 100%, 60%);
      --keyboard-toolbar-background: transparent;
      --keyboard-toolbar-background-hover: #303030;
      --keyboard-toolbar-background-selected: transparent;
      --keycap-background: #1f2022;
      --keycap-background-hover: #2f3032;
      --keycap-background-active: #2f3032;
      --keycap-border: transparent;
      --keycap-border-bottom: transparent;
      --keycap-text: #e3e4e8;
      --keycap-text-active: #000;
      --keycap-secondary-text: #e7ebee;
      --keycap-modifier-background: #3d4144;
      --keycap-modifier-background-hover: #4d5154;
      --keycap-modifier-text: #e7ebee;
      --keycap-modifier-border: transparent;
      --keycap-modifier-border-bottom: transparent;
      --variant-panel-background: #303030;
      --variant-keycap-text: var(--keycap-text);
      --variant-keycap-text-active: #fff;
    }
  }
  /* Same as the media query, but with a class */
  [theme='dark'] .ML__keyboard {
    --keyboard-accent-color: hsl(212, 100%, 50%);
    --keyboard-background: #151515;
    --keyboard-border: transparent;
    --keyboard-toolbar-text: #e3e4e8;
    --keyboard-toolbar-text-active: hsl(212, 100%, 60%);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #303030;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: #1f2022;
    --keycap-background-hover: #2f3032;
    --keycap-background-active: #2f3032;
    --keycap-border: transparent;
    --keycap-border-bottom: transparent;
    --keycap-text: #e3e4e8;
    --keycap-text-active: #000;
    --keycap-secondary-text: #e7ebee;
    --keycap-modifier-background: #3d4144;
    --keycap-modifier-background-hover: #4d5154;
    --keycap-modifier-text: #e7ebee;
    --keycap-modifier-border: transparent;
    --keycap-modifier-border-bottom: transparent;
    --variant-panel-background: #303030;
    --variant-keycap-text: var(--keycap-text);
    --variant-keycap-text-active: #fff;
  }
  [theme='light'] .ML__keyboard {
    --keyboard-accent-color: #0b579d;
    --keyboard-background: #cacfd7;
    --keyboard-border: #ddd;
    --keyboard-toolbar-text: #2c2e2f;
    --keyboard-toolbar-text-active: var(--keyboard-accent-color);
    --keyboard-toolbar-background: transparent;
    --keyboard-toolbar-background-hover: #eee;
    --keyboard-toolbar-background-selected: transparent;
    --keycap-background: white;
    --keycap-background-hover: #f5f5f7;
    --keycap-background-active: white;
    --keycap-border: #e5e6e9;
    --keycap-border-bottom: #8d8f92;
    --keycap-text: #000;
    --keycap-text-active: #fff;
    --keycap-text-hover: #fff;
    --keycap-secondary-text: #000;
    --keycap-modifier-background: #a0a9b6;
    --keycap-modifier-background-hover: #949ead;
    --keycap-modifier-text: #060707;
    --keycap-modifier-border: #c5c9d0;
    --keycap-modifier-border-bottom: #989da6;
    --variant-panel-background: #fff;
    --variant-keycap-text: var(--keycap-text, #000);
    --variant-keycap-text-active: #fff;
    --variant-keycap-background-active: var(--keyboard-accent-color);
  }
}
`;
    function $c() {
      return "";
    }
    var Bi = null, bs, xs, Aa = ((xs = (bs = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : bs.currentScript) == null ? void 0 : xs.src) || $c();
    async function So(r) {
      if (/^(?:[a-z+]+:)?\/\//i.test(r))
        return new URL(r).href;
      if (Bi === null)
        try {
          let e = await fetch(Aa, { method: "HEAD" });
          e.status === 200 && (Bi = e.url);
        } catch (e) {
          console.error(`Invalid URL "${r}" (relative to "${Aa}")`);
        }
      return new URL(r, Bi != null ? Bi : Aa).href;
    }
    function qc(r, e, t = {}) {
      return new FontFace(r, `url(${e}.woff2) format('woff2')`, t);
    }
    var $e = "not-loaded";
    async function vs() {
      return $e = "not-loaded", Tr();
    }
    async function Tr() {
      var e;
      if ($e !== "not-loaded")
        return;
      if ($e = "loading", (e = getComputedStyle(document.documentElement).getPropertyValue("--ML__static-fonts")) != null ? e : false) {
        $e = "ready";
        return;
      }
      if (document.body.classList.remove("ML__fonts-did-not-load"), "fonts" in document) {
        let t = ["KaTeX_Main", "KaTeX_Math", "KaTeX_AMS", "KaTeX_Caligraphic", "KaTeX_Fraktur", "KaTeX_SansSerif", "KaTeX_Script", "KaTeX_Typewriter", "KaTeX_Size1", "KaTeX_Size2", "KaTeX_Size3", "KaTeX_Size4"], i = Array.from(document.fonts).map((n) => n.family);
        if (t.every((n) => i.includes(n))) {
          $e = "ready";
          return;
        }
        if (!window.MathfieldElement.fontsDirectory) {
          $e = "not-loaded";
          return;
        }
        let o = await So(window.MathfieldElement.fontsDirectory);
        if (!o) {
          document.body.classList.add("ML__fonts-did-not-load"), $e = "error";
          return;
        }
        let a = [["KaTeX_Main-Regular"], ["KaTeX_Main-BoldItalic", { style: "italic", weight: "bold" }], ["KaTeX_Main-Bold", { weight: "bold" }], ["KaTeX_Main-Italic", { style: "italic" }], ["KaTeX_Math-Italic", { style: "italic" }], ["KaTeX_Math-BoldItalic", { style: "italic", weight: "bold" }], ["KaTeX_AMS-Regular"], ["KaTeX_Caligraphic-Regular"], ["KaTeX_Caligraphic-Bold", { weight: "bold" }], ["KaTeX_Fraktur-Regular"], ["KaTeX_Fraktur-Bold", { weight: "bold" }], ["KaTeX_SansSerif-Regular", { style: "italic" }], ["KaTeX_SansSerif-Bold", { weight: "bold" }], ["KaTeX_SansSerif-Italic", { style: "italic" }], ["KaTeX_Script-Regular"], ["KaTeX_Typewriter-Regular"], ["KaTeX_Size1-Regular"], ["KaTeX_Size2-Regular"], ["KaTeX_Size3-Regular"], ["KaTeX_Size4-Regular"]].map((n) => qc(n[0].replace(/-[a-zA-Z]+$/, ""), o + "/" + n[0], n[1]));
        try {
          (await Promise.all(a.map((s) => {
            try {
              return s.load();
            } catch (l) {
            }
          }))).forEach((s) => document.fonts.add(s)), $e = "ready";
          return;
        } catch (n) {
          console.error(`MathLive 0.90.9: The math fonts could not be loaded from "${o}"`, { cause: n }), document.body.classList.add("ML__fonts-did-not-load");
        }
        $e = "error";
      }
    }
    var ws = { numeric: { label: "123", classes: "MLK__tex-math", tooltip: "keyboard.tooltip.numeric", layers: ["numeric"] }, alphabetic: { label: "abc", classes: "MLK__tex-math", tooltip: "keyboard.tooltip.alphabetic", layers: ["lower-alphabetic", "upper-alphabetic"] }, greek: { label: "&alpha;&beta;&gamma;", classes: "MLK__tex-math", tooltip: "keyboard.tooltip.greek", layers: ["lower-greek", "upper-greek"] }, functions: { label: "f&thinsp;()", classes: "MLK__tex-math", tooltip: "keyboard.tooltip.functions", layers: ["functions"] }, symbols: { label: "&infin;≠∈", classes: "MLK__tex-math", tooltip: "keyboard.tooltip.symbols", layers: ["symbols"] } }, _o = { "\\varphi ": ["&Phi;", "\\Phi "], "\\varsigma ": ["&Sigma;", "\\Sigma "], "\\epsilon ": ["&#x0190;", '\\char"0190'], "\\rho ": ["&#x3A1", '\\char"3A1'], "\\tau ": ["&#x3A4;", '\\char"3A4'], "\\upsilon ": ["&Upsilon;", "\\Upsilon "], "\\theta ": ["&Theta;", "\\Theta "], "\\iota ": ["&Iota;", '\\char"399'], "\\omicron ": ["&#x039F;", '\\char"39F'], "\\pi ": ["&Pi;", "\\Pi "], "\\alpha ": ["&Alpha;", '\\char"391'], "\\sigma ": ["&Sigma;", "\\Sigma "], "\\delta ": ["&Delta;", "\\Delta "], "\\phi ": ["&#x03a6;", "\\Phi "], "\\gamma ": ["&Gamma;", "\\Gamma "], "\\eta ": ["&Eta;", '\\char"397'], "\\xi ": ["&Xi;", "\\Xi "], "\\kappa ": ["&Kappa;", '\\char"39A'], "\\lambda ": ["&Lambda;", "\\Lambda "], "\\zeta ": ["&Zeta;", '\\char"396'], "\\chi ": ["&Chi;", '\\char"3A7'], "\\psi ": ["&Psi;", "\\Psi "], "\\omega ": ["&Omega;", "\\Omega "], "\\beta ": ["&Beta;", '\\char"392'], "\\nu ": ["&Nu;", '\\char"39D'], "\\mu ": ["&Mu;", '\\char"39C'] }, La = { numeric: `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='x-var'><i>x</i></li>
    <li class='MLK__keycap MLK__tex' data-variants='n-var'><i>n</i></li>
    <li class='separator w5'></li>
    <row name='numpad-1'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='\\exponentialE' data-variants='ee'>e</li>
    <li class='MLK__keycap MLK__tex' data-latex='\\imaginaryI' data-variants='ii'>i</li>
    <li class='MLK__keycap MLK__tex' data-latex='\\pi' data-variants='numeric-pi'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-key='<' data-variants='<'>&lt;</li>
    <li class='MLK__keycap MLK__tex' data-key='>' data-variants='>'>&gt;</li>
    <li class='separator w5'></li>
    <row name='numpad-2'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-latex='#@^{2}' data-latex='x^2'></li>
    <li class='MLK__keycap MLK__tex' data-variants='^' data-insert='#@^{#?}' data-latex='x^\\placeholder'></li>
    <li class='MLK__keycap MLK__tex small' data-insert='\\sqrt{#0}' data-latex='\\sqrt{#0}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap MLK__tex' data-variants='(' >(</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' >)</li>
    <li class='separator w5'></li>
    <row name='numpad-3'/>
    <li class='separator w5'></li>
    <li class='MLK__keycap small' data-variants='int' data-latex='\\int_0^\\infty'></li>
    <li class='MLK__keycap' data-latex='\\forall' data-variants='logic' ></li>
    <li class='action font-glyph bottom right' data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  </ul>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'></span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span></li>
    <li class='separator w5'></li>
    <row name='numpad-4'/>
    <li class='separator w5'></li>
    <arrows/>
  </ul>
</div>
    `, "lower-alphabetic": `
<div class='MLK__rows'>
  <ul>
    <row name='numpad-1' class='if-wide'/>
    <row name='lower-1' shift-layer='upper-alphabetic'/>
  </ul>
  <ul>
    <row name='numpad-2' class='if-wide'/>
    <row name='lower-2'  shift-layer='upper-alphabetic''/>
  </ul>
  <ul>
    <row name='numpad-3' class='if-wide'/>
    <row name='lower-3'  shift-layer='upper-alphabetic''/>
  </ul>
  <ul>
    <row name='numpad-4' class='if-wide'/>
    <li class='MLK__keycap' >;</li>
    <li class='MLK__keycap' >,</li>
    <li class='MLK__keycap w50' data-key=' ' data-variants='space'>&nbsp;</li>
    <arrows/>
  </ul>
</div>`, "upper-alphabetic": `<div class='MLK__rows'>
<ul>
  <row name='numpad-1' class='if-wide'/>
  <row name='upper-1'  shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-2' class='if-wide'/>
  <row name='upper-2' shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-3' class='if-wide'/>
  <row name='upper-3' shift-layer='lower-alphabetic'/>
</ul>
<ul>
  <row name='numpad-4' class='if-wide'/>
  <li class='MLK__keycap' >;</li>
  <li class='MLK__keycap' data-variants='.'>;</li>
  <li class='MLK__keycap w50' data-key=' '>&nbsp;</li>
  <arrows/>
</ul>
</div>`, symbols: `
<div class='MLK__rows'>
  <ul>
    <row name='numpad-1' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\lbrace '>{</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rbrace '>}</li>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex small' data-variants='xleftarrows' data-latex='\\leftarrow' ></li>
    <li class='MLK__keycap MLK__tex small' data-variants='xrightarrows' data-latex='\\rightarrow' ></li>
    <li class='MLK__keycap MLK__tex' data-variants='overline' data-latex='\\overline{#@}' data-aside='overline'></li>
    <li class='MLK__keycap MLK__tex' data-variants='underline' data-latex='\\underline{#@}' data-aside='underline'></li>
    <li class='MLK__keycap w15' data-insert='\\ulcorner#0\\urcorner '><span><sup>&#x250c;</sup><span><span style='color:#ddd'>o</span><sup>&#x2510;</sup></span><aside>ceil</aside></li>
    <li class='MLK__keycap MLK__tex' data-variants='nabla' data-insert='\\nabla '>&#x2207;<aside>nabla</aside></li>
    <li class='MLK__keycap MLK__tex' data-variants='infinity' data-insert='\\infty '>&#x221e;</li>

  </ul>
  <ul>
    <row name='numpad-2' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\lbrack '>[</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rbrack '>]</li>
    <li class='separator w5'></li>

    <li class='MLK__keycap MLK__tex' data-variants='in' data-insert='\\in '>&#x2208;</li>
    <li class='MLK__keycap MLK__tex' data-variants='!in' data-insert='\\notin '>&#x2209;</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Re '>&#x211c;<aside>Real</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Im '>&#x2111;<aside>Imaginary</aside></li>
    <li class='MLK__keycap w15' data-insert='\\llcorner#0\\lrcorner '><span><sub>&#x2514;</sub><span style='color:#ddd'>o</span><sub>&#x2518;</sub></span><aside>floor</aside></li>

    <li class='MLK__keycap MLK__tex' data-insert='\\partial '>&#x2202;<aside>partial<br>derivative</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\emptyset '>&#x2205;<aside>empty set</aside></li>

  </ul>
  <ul>
    <row name='numpad-3' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-variants='(' data-insert='\\langle '>&#x27e8;</li>
    <li class='MLK__keycap MLK__tex' data-variants=')' data-insert='\\rangle '>&#x27e9;</li>
    <li class='separator w5'></li>
    <li class='MLK__keycap MLK__tex' data-variants='subset' data-insert='\\subset '>&#x2282;</li>
    <li class='MLK__keycap MLK__tex' data-variants='superset' data-insert='\\supset '>&#x2283;</li>

    <li class='MLK__keycap MLK__tex' data-variants='accents' data-insert='\\vec{#@}' data-latex='\\vec{#?}' data-aside='vector'></li>
    <li class='MLK__keycap MLK__tex' data-variants='absnorm' data-insert='\\left| #0 \\right|' data-latex='\\left| #? \\right|' data-aside='abs'></li>

    <li class='MLK__keycap MLK__tex' data-key='!' data-variants='!'>!<aside>factorial</aside></li>
    <li class='MLK__keycap' data-latex='^{\\prime} '><span><sup><span><span style='color:#ddd'>o</span>&#x2032</sup></span><aside>prime</aside></li>

    <li class='action font-glyph bottom right w15'
        data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
        data-shifted-command='"deleteAll"'
        data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
    ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>
  </ul>
  <ul>
    <row name='numpad-4' class='if-wide'/>
    <li class='MLK__keycap MLK__tex' data-insert=','>,</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\cdot '>&#x22c5;<aside>centered dot</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\colon '>:<aside>colon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\circ '>&#x2218;<aside>circle</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\approx '>&#x2248;<aside>approx.</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\ne '>&#x2260;</li>
    <li class='MLK__keycap MLK__tex' data-insert='\\pm '>&#x00b1;</li>
    <arrows/>
  </ul>
</div>`, "lower-greek": `
<div class='MLK__rows'>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\varphi '><i>&#x03c6;</i><aside>phi var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varsigma '><i>&#x03c2;</i><aside>sigma var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\epsilon '><i>&#x03f5;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\rho '><i>&rho;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\tau '><i>&tau;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\upsilon '><i>&upsilon;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\theta '><i>&theta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\iota '><i>&iota;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\omicron '>&omicron;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\pi '><i>&pi;</i></li>
  </ul>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\alpha ' data-shifted='&Alpha;' data-shifted-command='["insert","\\\\char\\"391"]'><i>&alpha;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\sigma '><i>&sigma;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\delta '><i>&delta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\phi '><i>&#x03d5;</i></i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\gamma '><i>&gamma;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\eta '><i>&eta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\xi '><i>&xi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\kappa '><i>&kappa;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\lambda '><i>&lambda;</i></li>
  </ul>
  <ul><li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='upper-greek'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\zeta '><i>&zeta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\chi '><i>&chi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\psi '><i>&psi;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\omega '><i>&omega;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\beta '><i>&beta;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\nu '><i>&nu;</i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\mu '><i>&mu;</i></li>
      <li class='action font-glyph bottom right w15'
          data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
          data-shifted-command='"deleteAll"'
          data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
      ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>
  </ul>
  <ul>
      <li class='MLK__keycap ' data-key=' '>&nbsp;</li>
      <li class='MLK__keycap'>,</li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varepsilon '><i>&#x03b5;</i><aside>epsilon var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\vartheta '><i>&#x03d1;</i><aside>theta var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varkappa '><i>&#x3f0;</i><aside>kappa var.</aside></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varpi '><i>&#x03d6;<aside>pi var.</aside></i></li>
      <li class='MLK__keycap MLK__tex' data-insert='\\varrho '><i>&#x03f1;</i><aside>rho var.</aside></li>
      <arrows/>
  </ul>
</div>`, "upper-greek": `
<div class='MLK__rows'>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\Phi '>&Phi;<aside>phi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"0190'>&#x0190;<aside>epsilon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A1'>&#x3A1;<aside>rho</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A4'>&#x3A4;<aside>tau</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Upsilon '>&Upsilon;<aside>upsilon</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Theta '>&Theta;<aside>theta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"399'>&Iota;<aside>iota</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39F'>&#x039F;<aside>omicron</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Pi '>&Pi;<aside>pi</aside></li></ul>
  <ul><li class='MLK__keycap MLK__tex' data-insert='\\char"391'>&#x391;<aside>alpha</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Sigma '>&Sigma;<aside>sigma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Delta '>&Delta;<aside>delta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Phi '>&#x03a6;<aside>phi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Gamma '>&Gamma;<aside>gamma</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"397'>&Eta;<aside>eta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Xi '>&Xi;<aside>xi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39A'>&Kappa;<aside>kappa</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Lambda '>&Lambda;<aside>lambda</aside></li></ul>
  <ul><li class='shift modifier font-glyph bottom left selected w15 layer-switch' data-layer='lower-greek'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"396'>&Zeta;<aside>zeta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"3A7'>&Chi;<aside>chi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Psi '>&Psi;<aside>psi</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\Omega '>&Omega;<aside>omega</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"392'>&Beta;<aside>beta</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39D'>&Nu;<aside>nu</aside></li>
    <li class='MLK__keycap MLK__tex' data-insert='\\char"39C'>&Mu;<aside>mu</aside></li>
    <li class='action font-glyph bottom right w15' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
<ul>
    <li class='separator'>&nbsp;</li>
    <li class='MLK__keycap'>.</li>
    <li class='MLK__keycap w50' data-key=' '>&nbsp;</li>
    <arrows/>
  </ul>
</div>`, functions: `
<div class='MLK__rows'>
  <ul>
    <li class='fnbutton' data-insert='\\sin'></li>
    <li class='fnbutton' data-insert='\\sin^{-1}'></li>
    <li class='fnbutton' data-insert='\\ln'></li>
    <li class='fnbutton' data-insert='\\exponentialE^{#?}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{lcm}(#?)' data-latex='\\operatorname{lcm}()'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{ceil}(#?)' data-latex='\\operatorname{ceil}()'></li>
    <li class='bigfnbutton' data-insert='\\lim_{n\\to\\infty}'></li>
    <li class='bigfnbutton' data-insert='\\int'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{abs}(#?)' data-latex='\\operatorname{abs}()'></li>
  </ul>
  <ul>
    <li class='fnbutton' data-latex='\\cos'></li>
    <li class='fnbutton' data-latex='\\cos^{-1}'></li>
    <li class='fnbutton' data-latex='\\log'></li>
    <li class='fnbutton' data-latex='10^{#?}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{gcd}(#?)' data-latex='\\operatorname{gcd}()'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{floor}(#?)' data-latex='\\operatorname{floor}()'></li>
    <li class='bigfnbutton' data-latex='\\sum_{n\\mathop=0}^{\\infty}'></li>
    <li class='bigfnbutton' data-latex='\\int_{0}^{\\infty}'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{sign}(#?)' data-latex='\\operatorname{sign}()'></li>
  </ul>
  <ul>
    <li class='fnbutton' data-latex='\\tan'></li>
    <li class='fnbutton' data-latex='\\tan^{-1}'></li>
    <li class='fnbutton' data-latex='\\log_{#?}'></li>
    <li class='fnbutton' data-latex='\\sqrt[#?]{#0}'></li>
    <li class='bigfnbutton' data-insert='#0 \\mod' data-latex='\\mod'></li>
    <li class='bigfnbutton' data-insert='\\operatorname{round}(#?) ' data-latex='\\operatorname{round}()'></li>
    <li class='bigfnbutton' data-insert='\\prod_{n\\mathop=0}^{\\infty}' data-latex='{ \\prod_{n=0}^{\\infty}}'></li>
    <li class='bigfnbutton' data-insert='\\frac{\\differentialD #0}{\\differentialD x}'></li>
    <li class='action font-glyph bottom right' data-command='["performWithFeedback","deleteBackward"]'><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li></ul>
  <ul>
    <li class='fnbutton'>(</li>
    <li class='fnbutton'>)</li>
    <li class='fnbutton' data-insert='^{#?}' data-latex='x^{#?}'></li>
    <li class='fnbutton' data-insert='_{#?}' data-latex='x_{#?}'></li>
    <li class='MLK__keycap w20 ' data-key=' '>&nbsp;</li>
    <arrows/>
  </ul>
</div>`, style: `
<div class='MLK__rows'>
  <ul>
    <li class='MLK__keycap' data-variants='foreground-color' data-command='["applyStyle",{"color":"red"}]'><span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428'></span></li>
    <li class='MLK__keycap' data-variants='background-color' data-command='["applyStyle",{"backgroundColor":"yellow"}]'><span style='border-radius: 50%;width:22px;height:22px; background:#fff590'></span></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"3"}]' data-latex='\\scriptsize\\text{small}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"5"}]' data-latex='\\scriptsize\\text{normal}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"size":"9"}]' data-latex='\\huge\\text{big}'></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-latex='\\langle' data-command='["insert", "\\\\langle", {"smartFence":true}]'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"l"}]' data-latex='\\fontseries{l}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"m"}]' data-latex='\\fontseries{m}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"b"}]' data-latex='\\fontseries{b}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"bx"}]' data-latex='\\fontseries{bx}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"sb"}]' data-latex='\\fontseries{sb}\\text{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"series":"c"}]' data-latex='\\fontseries{c}\\text{Ab}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"up"}]' data-latex='\\textup{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"it"}]' data-latex='\\textit{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"sl"}]' data-latex='\\textsl{Ab}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"shape":"sc"}]' data-latex='\\textsc{Ab}'></li>
    <li class='separator w5'></li>
    <li class='MLK__keycap' data-insert='\\emph{#@} ' data-latex='\\text{\\emph{emph}}'></li>
  </ul>
  <ul>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmr"}]' data-latex='\\textrm{Az}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmtt"}]' data-latex='\\texttt{Az}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cmss"}]' data-latex='\\textsf{Az}'></li>

    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"bb"}]'  data-latex='\\mathbb{AZ}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"scr"}]'  data-latex='\\mathscr{AZ}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"cal"}]' data-latex='\\mathcal{A1}'></li>
    <li class='MLK__keycap' data-command='["applyStyle",{"fontFamily":"frak"}]' data-latex='\\mathfrak{Az}'></li>
  </ul>
</div>` };
    var Dt = class {
      constructor(e) {
        var t, i;
        this.preventOverlayClose = (t = e == null ? void 0 : e.preventOverlayClose) != null ? t : false, this.translucent = (i = e == null ? void 0 : e.translucent) != null ? i : false, this.state = "closed";
      }
      get element() {
        if (this._element)
          return this._element;
        let e = document.createElement("div");
        return e.setAttribute("role", "presentation"), e.style.position = "fixed", e.style.contain = "content", e.style.top = "0", e.style.left = "0", e.style.right = "0", e.style.bottom = "0", e.style.zIndex = "var(--scrim-zindex, 10099)", e.style.outline = "none", this.translucent ? (e.style.background = "rgba(255, 255, 255, .2)", e.style.backdropFilter = "contrast(40%)") : e.style.background = "transparent", this._element = e, e;
      }
      open(e) {
        var a;
        if (this.state !== "closed")
          return;
        this.state = "opening", this.savedActiveElement = ks();
        let { element: t } = this;
        ((a = e == null ? void 0 : e.root) != null ? a : document.body).appendChild(t), t.addEventListener("click", this), document.addEventListener("touchmove", this, false), document.addEventListener("scroll", this, false);
        let i = window.innerWidth - document.documentElement.clientWidth;
        this.savedMarginRight = document.body.style.marginRight, this.savedOverflow = document.body.style.overflow, document.body.style.overflow = "hidden";
        let o = Number.parseFloat(getComputedStyle(document.body).marginRight);
        document.body.style.marginRight = `${o + i}px`, e != null && e.child && t.append(e.child), this.state = "open";
      }
      close() {
        var t, i, o, a;
        if (this.state !== "open")
          return;
        this.state = "closing", typeof this.onClose == "function" && this.onClose();
        let { element: e } = this;
        e.removeEventListener("click", this), document.removeEventListener("touchmove", this, false), document.removeEventListener("scroll", this, false), e.remove(), document.body.style.overflow = (t = this.savedOverflow) != null ? t : "", document.body.style.marginRight = (i = this.savedMarginRight) != null ? i : "", ks() !== this.savedActiveElement && ((a = (o = this.savedActiveElement) == null ? void 0 : o.focus) == null || a.call(o)), e.innerHTML = "", this.state = "closed";
      }
      handleEvent(e) {
        this.preventOverlayClose || (e.target === this._element && e.type === "click" ? (this.close(), e.preventDefault(), e.stopPropagation()) : e.target === document && (e.type === "touchmove" || e.type === "scroll") && (this.close(), e.preventDefault(), e.stopPropagation()));
      }
    };
    function ks() {
      var e;
      let r = document.activeElement;
      for (; (e = r == null ? void 0 : r.shadowRoot) != null && e.activeElement; )
        r = r.shadowRoot.activeElement;
      return r;
    }
    var Mo = { "0-extended": ["\\emptyset", "\\varnothing", "\\infty", { latex: "#?_0", insert: "#@_0" }, "\\circ", "\\bigcirc", "\\bullet"], 0: ["\\varnothing", "\\infty"], 1: ["\\frac{1}{#0}", "\\times 10^{#?}"], 2: ["\\frac{1}{2}", "#@^2", "\\exponentialE"], 3: ["\\frac{1}{3}", "#@^3", "\\pi"], 4: ["\\frac{1}{4}", "#@^4"], 5: ["\\frac{1}{5}", "#@^5"], 6: ["\\frac{1}{6}", "#@^6"], 7: ["\\frac{1}{7}", "#@^7"], 8: ["\\frac{1}{8}", "#@^8"], 9: ["\\frac{1}{9}", "#@^9"], ".": [".", ",", ";", "\\colon", { latex: ":", aside: "ratio" }, { latex: "\\cdotp", aside: "center dot", class: "box" }, { latex: "\\cdots", aside: "center ellipsis", class: "box" }, { latex: "\\ldotp", aside: "low dot", class: "box" }, { latex: "\\ldots", aside: "low ellipsis", class: "box" }, { latex: "\\vdots", aside: "", class: "box" }, { latex: "\\ddots", aside: "", class: "box" }, "\\odot", "\\oslash", "\\circledcirc"], "*": ["\\cdot", "\\ast", "\\star", { latex: "\\prod_{#0}^{#0}", class: "small" }], "*-extended": ["\\cdot", "\\ast", "\\star", "\\bigstar", "\\ltimes", "\\rtimes", "\\rightthreetimes", "\\leftthreetimes", "\\intercal", "\\prod", { latex: "\\prod_{n\\mathop=0}^{\\infty}", class: "small" }], "+-extended": ["\\pm", "\\mp", "\\sum", { latex: "\\sum_{n\\mathop=0}^{\\infty}", class: "small" }, "\\dotplus", "\\oplus"], "+": [{ latex: "\\sum_{#0}^{#0}", class: "small" }], "--extended": ["\\pm", "\\mp", "\\ominus", "\\vert #0  \\vert"], "-": ["\\pm"], "/-extended": ["\\divideontimes", "/", "\\div", "\\%"], "/": ["/", "\\div", "\\%"], "(": ["\\lbrack", "\\langle", "\\lfloor", "\\lceil", "\\lbrace"], ")": ["\\rbrack", "\\rangle", "\\rfloor", "\\rceil", "\\rbrace"], "(-extended": ["\\left( #0\\right)", "\\left[ #0\\right]", "\\left\\{ #0\\right\\}", "\\left\\langle #0\\right\\rangle", "\\lfloor", "\\llcorner", "(", "\\lbrack", "\\lvert", "\\lVert", "\\lgroup", "\\langle", "\\lceil", "\\ulcorner", "\\lmoustache", "\\lbrace"], ")-extended": ["\\rfloor", "\\lrcorner", ")", "\\rbrack", "\\rvert", "\\rVert", "\\rgroup", "\\rangle", "\\rceil", "\\urcorner", "\\rmoustache", "\\rbrace"], "=": ["\\neq", "\\equiv", "\\varpropto", "\\thickapprox", "\\lt", "\\gt", "\\le", "\\ge"], "=-extended": ["\\cong", "\\asymp", "\\equiv", "\\differencedelta", "\\varpropto", "\\thickapprox", "\\approxeq", "\\thicksim", "\\backsim", "\\eqsim", "\\simeq", "\\Bumpeq", "\\bumpeq", "\\doteq", "\\Doteq", "\\fallingdotseq", "\\risingdotseq", "\\coloneq", "\\eqcirc", "\\circeq", "\\triangleq", "\\between"], "!=": ["\\neq", "\\ncong", "", "\\nsim"], "<": ["\\leq", "\\leqq", "\\lneqq", "\\ll", "\\lessgtr", "\\nless", "\\nleq", "\\lesssim", "\\precsim", "\\prec", "\\nprec", "\\preccurlyeq", "\\lessdot"], ">": ["\\geq", "\\geqq", "\\gneqq", "\\gg", "\\gtrless", "\\ngtr", "\\ngeq", "\\gtrsim", "\\succsim", "\\succ", "\\nsucc", "\\succcurlyeq", "\\gtrdot"], in: ["\\owns"], "!in": ["\\backepsilon"], subset: ["\\subseteq", "\\nsubset", "\\nsubseteq"], superset: ["\\supseteq", "\\nsupset", "\\nsupseteq"], infinity: ["\\aleph_0", "\\aleph_1", "\\omega", "\\mathfrak{m}"], "numeric-pi": ["\\prod", "\\theta", "\\rho", "\\sin", "\\cos", "\\tan"], ee: ["\\times 10^{#?}", "\\ln", "\\log_{10}", "\\log"], "^": ["_{#?}"], int: [{ latex: "\\int_{#?}^{#?}", class: "small" }, { latex: "\\int", class: "small" }, { latex: "\\smallint", class: "small" }, { latex: "\\iint", class: "small" }, { latex: "\\iiint", class: "small" }, { latex: "\\oint", class: "small" }, { latex: "\\dfrac{\\rd}{\\rd x}", class: "small" }, { latex: "\\frac{\\partial}{\\partial x}", class: "small" }, "\\capitalDifferentialD", "\\rd", "\\partial"], nabla: ["\\nabla\\times", "\\nabla\\cdot", "\\nabla^{2}"], "!": ["!!", "\\Gamma", "\\Pi"], accents: ["\\bar{#@}", "\\vec{#@}", "\\hat{#@}", "\\check{#@}", "\\dot{#@}", "\\ddot{#@}", "\\mathring{#@}", "\\breve{#@}", "\\acute{#@}", "\\tilde{#@}", "\\grave{#@}"], underline: ["\\underbrace{#@}", "\\underlinesegment{#@}", "\\underleftrightarrow{#@}", "\\underrightarrow{#@}", "\\underleftarrow{#@}", "\\undergroup{#@}"], overline: ["\\overbrace{#@}", "\\overlinesegment{#@}", "\\overleftrightarrow{#@}", "\\overrightarrow{#@}", "\\overleftarrow{#@}", "\\overgroup{#@}"], xleftarrows: ["\\xlongequal{#@}", "\\xleftrightarrow{#@}", "\\xLeftrightarrow{#@}", "\\xleftrightharpoons{#@}", "\\xLeftarrow{#@}", "\\xleftharpoonup{#@}", "\\xleftharpoondown{#@}", "\\xtwoheadleftarrow{#@}", "\\xhookleftarrow{#@}", "\\xtofrom{#@}", "\\xleftequilibrium{#@}", "\\xrightleftarrows{#@}"], xrightarrows: ["\\xrightarrow{#@}", "\\xlongequal{#@}", "\\xleftrightarrow{#@}", "\\xLeftrightarrow{#@}", "\\xleftrightharpoons{#@}", "\\xRightarrow{#@}", "\\xrightharpoonup{#@}", "\\xrightharpoondown{#@}", "\\xtwoheadrightarrow{#@}", "\\xrightleftharpoons{#@}", "\\xhookrightarrow{#@}", "\\xmapsto{#@}", "\\xrightequilibrium{#@}", "\\xrightleftarrows{#@}"], A: [{ latex: "\\aleph", aside: "aleph" }, { latex: "\\forall", aside: "for all" }], a: [{ latex: "\\aleph", aside: "aleph" }, { latex: "\\forall", aside: "for all" }], b: [{ latex: "\\beth", aside: "beth" }], B: [{ latex: "\\beth", aside: "beth" }], c: [{ latex: "\\C", aside: "set of complex numbers" }], d: [{ latex: "\\daleth", aside: "daleth" }], D: [{ latex: "\\daleth", aside: "daleth" }], e: [{ latex: "\\exponentialE", aside: "exponential e" }, { latex: "\\exists", aside: "there is" }, { latex: "\\nexists", aside: "there isn’t" }], g: [{ latex: "\\gimel", aside: "gimel" }], G: [{ latex: "\\gimel", aside: "gimel" }], h: [{ latex: "\\hbar", aside: "h bar" }, { latex: "\\hslash", aside: "h slash" }], i: [{ latex: "\\imaginaryI", aside: "imaginary i" }], j: [{ latex: "\\imaginaryJ", aside: "imaginary j" }], l: [{ latex: "\\ell", aside: "ell" }], n: [{ latex: "\\mathbb{N}", aside: "set of natural numbers" }], p: [{ latex: "\\mathbb{P}", aside: "set of primes" }], q: [{ latex: "\\mathbb{Q}", aside: "set of rational numbers" }], r: [{ latex: "\\mathbb{R}", aside: "set of real numbers" }], z: [{ latex: "\\mathbb{Z}", aside: "set of integers" }], "x-var": ["y", "z", "t", "r", { latex: "f(#?)", class: "small" }, { latex: "g(#?)", class: "small" }, "x^2", "x^n", "x_n", "x_{n+1}", "x_i", "x_{i+1}"], "n-var": ["i", "j", "p", "k", "a", "u"], ii: ["\\Re", "\\Im", "\\imaginaryJ", "\\Vert #0 \\Vert"], logic: [{ latex: "\\exists", aside: "there is" }, { latex: "\\nexists", aside: "there isn’t" }, { latex: "\\ni", aside: "such that" }, { latex: "\\Colon", aside: "such that" }, { latex: "\\implies", aside: "implies" }, { latex: "\\impliedby", aside: "implied by" }, { latex: "\\iff", aside: "if and only if" }, { latex: "\\land", aside: "and" }, { latex: "\\lor", aside: "or" }, { latex: "\\oplus", aside: "xor" }, { latex: "\\lnot", aside: "not" }, { latex: "\\downarrow", aside: "nor" }, { latex: "\\uparrow", aside: "nand" }, { latex: "\\curlywedge", aside: "nor" }, { latex: "\\bar\\curlywedge", aside: "nand" }, { latex: "\\therefore", aside: "therefore" }, { latex: "\\because", aside: "because" }, { latex: "^\\biconditional", aside: "biconditional" }, "\\leftrightarrow", "\\Leftrightarrow", "\\to", "\\models", "\\vdash", "\\gets", "\\dashv", "\\roundimplies"], "set-operators": ["\\cap", "\\cup", "\\setminus", "\\smallsetminus", "\\complement"], "set-relations": ["\\in", "\\notin", "\\ni", "\\owns", "\\subset", "\\supset", "\\subseteq", "\\supseteq", "\\subsetneq", "\\supsetneq", "\\varsubsetneq", "\\subsetneqq", "\\nsubset", "\\nsupset", "\\nsubseteq", "\\nsupseteq"], space: [{ latex: '\\char"203A\\!\\char"2039', insert: "\\!", aside: "negative thin space<br>⁻³⧸₁₈ em" }, { latex: '\\unicode{"203A}\\,\\unicode{"2039}', insert: "\\,", aside: "thin space<br>³⧸₁₈ em" }, { latex: '\\unicode{"203A}\\:\\unicode{"2039}', insert: "\\:", aside: "medium space<br>⁴⧸₁₈ em" }, { latex: '\\unicode{"203A}\\;\\unicode{"2039}', insert: "\\;", aside: "thick space<br>⁵⧸₁₈ em" }, { latex: '\\unicode{"203A}\\ \\unicode{"2039}', insert: "\\ ", aside: "⅓ em" }, { latex: '\\unicode{"203A}\\enspace\\unicode{"2039}', insert: "\\enspace", aside: "½ em" }, { latex: '\\unicode{"203A}\\quad\\unicode{"2039}', insert: "\\quad", aside: "1 em" }, { latex: '\\unicode{"203A}\\qquad\\unicode{"2039}', insert: "\\qquad", aside: "2 em" }], delete: [{ label: '<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>', command: "deleteAll" }], "->|": [] };
    function Ss(r, e) {
      var s, l;
      let t = Hc(e), i = document.createElement("div");
      i.setAttribute("aria-hidden", "true"), i.className = "ML__keyboard MLK__variant-panel", t.length >= 14 ? i.style.width = "236px" : t.length >= 7 ? i.style.width = "286px" : t.length === 4 || t.length === 2 ? i.style.width = "146px" : t.length === 1 ? i.style.width = "86px" : i.style.width = "146px", i.style.height = "auto";
      let o = "";
      for (let c of t)
        o += "<li", typeof c == "string" ? o += ` data-latex="${c.replace(/"/g, "&quot;")}"'>${ri(c)}</li>` : (c.latex && (o += ' data-latex="' + c.latex.replace(/"/g, "&quot;") + '"'), c.insert && (o += ' data-insert="' + c.insert.replace(/"/g, "&quot;") + '"'), c.command && (o += ` data-command='${(typeof c.command == "string" ? '"' + c.command + '"' : JSON.stringify(c.command)).replace(/"/g, "&quot;")}'`), c.aside && (o += ` data-aside="${c.aside.replace(/"/g, "&quot;")}"`), c.class && (o += ` data-classes="${c.class}"`), o += ">", o += (l = c.label) != null ? l : ri((s = c.latex) != null ? s : ""), o += "</li>");
      i.innerHTML = Ao.createHTML(`<ul>${o}</ul>`);
      let a = qe.singleton;
      Dt.scrim || (Dt.scrim = new Dt()), Dt.scrim.open({ root: a.container, child: i }), Ca(a, [...i.querySelectorAll("li")], "performVariant");
      let n = r == null ? void 0 : r.getBoundingClientRect();
      if (n) {
        n.top - i.clientHeight < 0 && (i.style.width = "auto", t.length <= 6 ? i.style.height = "56px" : t.length <= 12 ? i.style.height = "108px" : t.length <= 18 ? i.style.height = "205px" : i.classList.add("compact"));
        let c = Math.max(0, Math.min(window.innerWidth - i.offsetWidth, (n.left + n.right - i.offsetWidth) / 2)), u = n.top - i.clientHeight + 5;
        i.style.transform = `translate(${c}px, ${u}px)`, i.classList.add("is-visible");
      }
      return false;
    }
    function Er() {
      var e;
      let r = document.querySelector(".MLK__variant-panel");
      return r && (r.classList.remove("is-visible"), r.innerHTML = ""), (e = Dt.scrim) == null || e.close(), false;
    }
    function Vc(r) {
      if (r === "foreground-color") {
        let e = [];
        for (let t of Object.keys(hi))
          e.push({ class: "small-button", label: '<span style="border-radius:50%;width:32px;height:32px; box-sizing: border-box; border: 3px solid ' + hi[t] + '"></span>', command: ["applyStyle", { color: t }] });
        return e;
      }
      if (r === "background-color") {
        let e = [];
        for (let t of Object.keys(pi))
          e.push({ class: "small-button", label: '<span style="border-radius:50%;width:32px;height:32px; background:' + pi[t] + '"></span>', command: ["applyStyle", { backgroundColor: t }] });
        return e;
      }
    }
    function Hc(r) {
      var e;
      return Mo[r] || (Mo[r] = (e = Vc(r)) != null ? e : []), Mo[r];
    }
    function _s(r, e) {
      Mo[r] = e;
    }
    function ai() {
      Er();
      let r = qe.singleton.element.querySelectorAll(".MLK__layer.is-visible .MLK__keycap, .MLK__layer.is-visible .action");
      if (r)
        for (let e of r) {
          e.classList.remove("is-active"), e.classList.remove("is-pressed");
          let t = e.getAttribute("data-unshifted-content");
          t && (e.innerHTML = re.createHTML(t), e.dataset.unshiftedContent = "");
          let i = e.getAttribute("data-unshifted-command");
          i && (e.dataset.command = i, e.dataset.unshiftedCommand = "");
        }
      return false;
    }
    function Gc(r) {
      return typeof r == "string" ? r : Object.entries(r).map(([e, t]) => `${e}:${t} !important`).join(";");
    }
    function Jc(r) {
      return Object.keys(r).map((e) => `${e} {${Gc(r[e])}}`).join("");
    }
    function ri(r, e) {
      if (!r)
        return "";
      r = r.replace(/(^|[^\\])#@/g, "$1#?");
      let t = Tt(), i = new g("root", t);
      i.body = pe(r, t, { parseMode: "math", args: e != null ? e : () => "\\placeholder{}" });
      let o = new P({ registers: t.registers }, { fontSize: nt }, "displaystyle"), a = Yt(Mt(new v(i.render(o), { classes: "ML__base" }), o));
      return _t(a, { classes: "ML__mathlive" }).toMarkup();
    }
    function Oi(r) {
      if (Array.isArray(r))
        return r.map((t) => Oi(t)).flat();
      if (typeof r == "string" && La[r])
        return Oi({ markup: La[r], id: r });
      let e;
      return typeof r == "string" ? e = { markup: r } : e = r, e.id || (e.id = "ML__layer_" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36)), [e];
    }
    function Ea(r) {
      if (typeof r == "string")
        return Ea(ws[r]);
      if ("rows" in r && Array.isArray(r.rows)) {
        let t = false, i = false;
        for (let o of r.rows.flat()) {
          let a = typeof o == "string" ? o : o.label;
          a === "[shift]" && (t = true), ["[undo]", "[redo]", "[cut]", "[copy]", "[paste]"].includes(a) && (i = true);
        }
        return (!("displayShiftedKeycaps" in r) || r.displayShiftedKeycaps === void 0) && (r.displayShiftedKeycaps = t), (!("displayEditToolbar" in r) || r.displayEditToolbar === void 0) && (r.displayEditToolbar = !i), E(b({}, r), { layers: Oi({ rows: r.rows }), rows: void 0 });
      }
      if ("markup" in r && typeof r.markup == "string")
        return E(b({}, r), { layers: Oi(r.markup) });
      let e = b({}, r);
      return "layers" in r && (e.layers = Oi(r.layers)), (!("displayEditToolbar" in r) || r.displayEditToolbar === void 0) && (e.displayEditToolbar = true), e;
    }
    function Wc(r, e) {
      var i, o;
      let t = '<div class="left">';
      if (r.layouts.length > 1)
        for (let [a, n] of r.layouts.entries()) {
          let s = n, l = [a === e ? "selected" : "layer-switch"];
          s.tooltip && l.push("MLK__tooltip"), s.classes && l.push(...s.classes.split(" ")), t += `<div class="${l.join(" ")}"`, s.tooltip && (t += " data-tooltip='" + ((i = kt(s.tooltip)) != null ? i : s.tooltip) + "' "), a !== e && (t += `data-layer="${s.layers[0].id}"`), t += `>${(o = s.label) != null ? o : "untitled"}</div>`;
        }
      return t += "</div>", t;
    }
    function Ms(r, e) {
      let t = "";
      if (r.actionToolbar === "none")
        return "";
      let o = [];
      e.selectionIsCollapsed ? o.push("undo", "redo", "pasteFromClipboard") : o.push("cutToClipboard", "copyToClipboard", "pasteFromClipboard");
      let a = { undo: `<div class='action ${e.canUndo === false ? "disabled" : ""}'
          data-command='"undo"'
          data-tooltip='${kt("tooltip.undo")}'>
          <svg><use xlink:href='#svg-undo' /></svg>
      </div>`, redo: `<div class='action ${e.canRedo === false ? "disabled" : ""}'
          data-command='"redo"'
          data-tooltip='${kt("tooltip.redo")}'>
          <svg><use xlink:href='#svg-redo' /></svg>
      </div>`, cutToClipboard: `
        <div class='action'
            data-command='"cutToClipboard"'
            data-tooltip='${kt("tooltip.cut to clipboard")}'>
            <svg><use xlink:href='#svg-cut' /></svg>
        </div>
    `, copyToClipboard: `
        <div class='action'
            data-command='"copyToClipboard"'
            data-tooltip='${kt("tooltip.copy to clipboard")}'>
            <svg><use xlink:href='#svg-copy' /></svg>
        </div>
    `, pasteFromClipboard: `
        <div class='action'
            data-command='"pasteFromClipboard"'
            data-tooltip='${kt("tooltip.paste from clipboard")}'>
            <svg><use xlink:href='#svg-paste' /></svg>
        </div>
    ` };
      return t += o.map((n) => a[n]).join(""), t;
    }
    function Ca(r, e, t) {
      var i, o;
      for (let a of e) {
        let n = a.innerHTML;
        n || (a.getAttribute("data-label") ? n = a.getAttribute("data-label").replace(/&quot;/g, '"') : a.getAttribute("data-latex") ? n = ri(a.getAttribute("data-latex").replace(/&quot;/g, '"')) : a.getAttribute("data-insert") && (n = ri(a.getAttribute("data-insert").replace(/&quot;/g, '"'))), a.getAttribute("data-aside") && (n += `<aside>${a.getAttribute("data-aside").replace(/&quot;/g, '"')}</aside>`), n && (a.innerHTML = re.createHTML(n))), a.getAttribute("data-classes") && a.classList.add(a.getAttribute("data-classes"));
        let s = (i = a.getAttribute("data-insert")) == null ? void 0 : i.replace(/&quot;/g, '"');
        s && _o[s] && (a.dataset.shifted = _o[s][0], a.dataset.shiftedCommand = JSON.stringify(["insertAndUnshiftKeyboardLayer", _o[s][1]]));
        let l, c = a.getAttribute("data-command");
        if (c)
          if (/^[a-zA-Z]+$/.test(c))
            l = c;
          else
            try {
              l = JSON.parse(c);
            } catch (u) {
            }
        else
          a.getAttribute("data-insert") ? (a.getAttribute("data-insert"), a.getAttribute("data-latex"), l = ["insert", a.getAttribute("data-insert"), { focus: true, feedback: true, scrollIntoView: true, mode: "math", format: "latex", resetStyle: true }]) : a.getAttribute("data-latex") ? l = ["insert", a.getAttribute("data-latex"), { focus: true, feedback: true, scrollIntoView: true, mode: "math", format: "latex", resetStyle: true }] : (a.getAttribute("data-key"), l = ["typedText", (o = a.getAttribute("data-key")) != null ? o : a.textContent, { focus: true, feedback: true, simulateKeystroke: true }]);
        if (l) {
          t && (l = [t, l]);
          let u = { default: l }, d = a.getAttribute("data-variants");
          d && (u = { default: l, pressAndHold: ["showVariantsPanel", d] }), ti(a, (m) => Array.isArray(m) && m[0] === "showVariantsPanel" ? Ss(a, d) : r.executeCommand(m), u);
        }
      }
    }
    function Uc(r, e) {
      var l, c, u, d;
      let t = { qwerty: { "lower-1": "qwertyuiop", "lower-2": " asdfghjkl ", "lower-3": "^zxcvbnm~", "upper-1": "QWERTYUIOP", "upper-2": " ASDFGHJKL ", "upper-3": "^ZXCVBNM~", "numpad-1": "789/", "numpad-2": "456*", "numpad-3": "123-", "numpad-4": "0.=+" }, azerty: { "lower-1": "azertyuiop", "lower-2": "qsdfghjklm", "lower-3": "^ wxcvbn ~", "upper-1": "AZERTYUIOP", "upper-2": "QSDFGHJKLM", "upper-3": "^ WXCVBN ~" }, qwertz: { "lower-1": "qwertzuiop", "lower-2": " asdfghjkl ", "lower-3": "^yxcvbnm~", "upper-1": "QWERTZUIOP", "upper-2": " ASDFGHJKL", "upper-3": "^YXCVBNM~" }, dvorak: { "lower-1": "^  pyfgcrl ", "lower-2": "aoeuidhtns", "lower-3": "qjkxbmwvz~", "upper-1": "^  PYFGCRL ", "upper-2": "AOEUIDHTNS", "upper-3": "QJKXBMWVZ~" }, colemak: { "lower-1": " qwfpgjluy ", "lower-2": "arstdhneio", "lower-3": "^zxcvbkm~", "upper-1": " QWFPGNLUY ", "upper-2": "ARSTDHNEIO", "upper-3": "^ZXCVBKM~" } }, i = r.alphabeticLayout;
      if (i === "auto") {
        let m = pr();
        m && (i = m.virtualLayout), (!i || i === "auto") && (i = (l = { fr: "azerty", be: "azerty", al: "qwertz", ba: "qwertz", cz: "qwertz", de: "qwertz", hu: "qwertz", sk: "qwertz", ch: "qwertz" }[U.locale.slice(0, 2)]) != null ? l : "qwerty");
      }
      let o = (c = t[i]) != null ? c : t.qwerty, a = e, n;
      a = a.replace(/<arrows\/>/g, `
        <li class='action' data-command='["performWithFeedback","moveToPreviousChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-left" /></svg>'
            data-shifted-command='["performWithFeedback","extendToPreviousChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-left' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","moveToNextChar"]'
            data-shifted='<svg class="svg-glyph"><use xlink:href="#svg-angle-double-right" /></svg>'
            data-shifted-command='["performWithFeedback","extendToNextChar"]'>
            <svg class="svg-glyph"><use xlink:href='#svg-arrow-right' /></svg>
        </li>
        <li class='action' data-command='["performWithFeedback","commit"]'>
        <svg class="svg-glyph"><use xlink:href='#svg-commit' /></svg></li>`);
      let s = a.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
      for (; s; ) {
        n = "";
        let m = s[2].match(/[a-zA-Z][a-zA-Z\d-]*=(['"])(.*?)\1/g), h = {};
        if (m)
          for (let y of m) {
            let w = y.match(/([a-zA-Z][a-zA-Z\d-]*)=(['"])(.*?)\2/);
            w && (h[w[1]] = w[3]);
          }
        let f = o[h.name];
        if (f || (f = t.qwerty[h.name]), !f)
          console.error("MathLive 0.90.9: Unknown roman keyboard row:", h.name);
        else
          for (let y of f) {
            let w = (u = h.class) != null ? u : "";
            w && (w = ` ${w}`), y === "~" ? (n += "<li class='action font-glyph bottom right ", n += f.length - (f.match(/ /g) || []).length / 2 === 10 ? "" : "w15", n += `' data-shifted='<span class="warning"><svg class="svg-glyph"><use xlink:href="#svg-trash" /></svg></span>'
                        data-shifted-command='"deleteAll"'
                        data-variants='delete' data-command='["performWithFeedback","deleteBackward"]'
                        ><svg class="svg-glyph"><use xlink:href="#svg-delete-backward" /></svg></li>`) : y === " " ? n += "<li class='separator w5'></li>" : y === "^" ? n += "<li class='shift modifier font-glyph bottom left w15 layer-switch' data-layer='" + h["shift-layer"] + `'><svg class="svg-glyph"><use xlink:href="#svg-shift" /></svg></li>` : y === "/" ? n += `<li class="MLK__keycap big-op ${w}" data-variants="/" data-insert='\\frac{#@}{#?}'>&divide;</li>` : y === "*" ? n += `<li class="MLK__keycap big-op ${w}" data-variants="*" data-insert='\\times '>&times;</li>` : y === "-" ? n += `<li class="MLK__keycap  big-op ${w}" data-variants="-" data-key='-'>&#x2212;</li>` : y === "." ? n += "<li class='MLK__keycap big-op " + w + `' data-variants='.' data-command='"insertDecimalSeparator"'>` + ((d = r.decimalSeparator) != null ? d : ".") + "</li>" : y === "+" ? n += `<li class="MLK__keycap big-op ${w}" data-variants="+" data-key="+">+</li>` : y === "=" ? n += `<li class="MLK__keycap big-op ${w}" data-variants="=" data-key="=">=</li>` : n += `<li class="MLK__keycap ${w}" data-variants="${y}">${y}</li>`;
          }
        a = a.replace(new RegExp(s[1] + s[2] + s[3]), n), s = a.match(/(<row\s+)(.*)((?:<\/row|\/)>)/);
      }
      return a;
    }
    var ii, oi, Ta;
    function jc() {
      oi || (Ta || (Ta = Xe(Ma).toString(36)), oi = Ze(null, Ma, Ta)), ii || (ii = Ze(null, Ie, Xe(Ie).toString(36)), Tr());
    }
    function As() {
      ii == null || ii.release(), ii = null, oi == null || oi.release(), oi = null;
    }
    var Xc = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">

<symbol id="svg-delete-backward" viewBox="0 0 576 512">
  <path d="M432.1 208.1L385.9 256L432.1 303C442.3 312.4 442.3 327.6 432.1 336.1C423.6 346.3 408.4 346.3 399 336.1L352 289.9L304.1 336.1C295.6 346.3 280.4 346.3 271 336.1C261.7 327.6 261.7 312.4 271 303L318.1 256L271 208.1C261.7 199.6 261.7 184.4 271 175C280.4 165.7 295.6 165.7 304.1 175L352 222.1L399 175C408.4 165.7 423.6 165.7 432.1 175C442.3 184.4 442.3 199.6 432.1 208.1V208.1zM512 64C547.3 64 576 92.65 576 128V384C576 419.3 547.3 448 512 448H205.3C188.3 448 172 441.3 160 429.3L9.372 278.6C3.371 272.6 0 264.5 0 256C0 247.5 3.372 239.4 9.372 233.4L160 82.75C172 70.74 188.3 64 205.3 64L512 64zM528 128C528 119.2 520.8 112 512 112H205.3C201 112 196.9 113.7 193.9 116.7L54.63 256L193.9 395.3C196.9 398.3 201 400 205.3 400H512C520.8 400 528 392.8 528 384V128z"/>
</symbol>

<symbol id="svg-shift" viewBox="0 0 384 512">
  <path d="M2.438 252.3C7.391 264.2 19.06 272 32 272h80v160c0 26.51 21.49 48 48 48h64C250.5 480 272 458.5 272 432v-160H352c12.94 0 24.61-7.797 29.56-19.75c4.953-11.97 2.219-25.72-6.938-34.88l-160-176C208.4 35.13 200.2 32 192 32S175.6 35.13 169.4 41.38l-160 176C.2188 226.5-2.516 240.3 2.438 252.3zM192 86.63L313.4 224H224v208H160V224H70.63L192 86.63z"/>
</symbol>

<symbol id="svg-commit" viewBox="0 0 512 512">
  <path d="M135 432.1l-128-128C2.344 300.3 0 294.2 0 288s2.344-12.28 7.031-16.97l128-128c9.375-9.375 24.56-9.375 33.94 0s9.375 24.56 0 33.94L81.94 264H464v-208C464 42.75 474.8 32 488 32S512 42.75 512 56V288c0 13.25-10.75 24-24 24H81.94l87.03 87.03c9.375 9.375 9.375 24.56 0 33.94S144.4 442.3 135 432.1z"/>
</symbol>

<symbol id="svg-command" viewBox="0 0 640 512">
  <path d="M34.495 36.465l211.051 211.05c4.686 4.686 4.686 12.284 0 16.971L34.495 475.535c-4.686 4.686-12.284 4.686-16.97 0l-7.071-7.07c-4.686-4.686-4.686-12.284 0-16.971L205.947 256 10.454 60.506c-4.686-4.686-4.686-12.284 0-16.971l7.071-7.07c4.686-4.687 12.284-4.687 16.97 0zM640 468v-10c0-6.627-5.373-12-12-12H300c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h328c6.627 0 12-5.373 12-12z"/>
</symbol>

<symbol id="svg-undo" viewBox="0 0 512 512">
  <path d="M20 8h10c6.627 0 12 5.373 12 12v110.625C85.196 57.047 165.239 7.715 256.793 8.001 393.18 8.428 504.213 120.009 504 256.396 503.786 393.181 392.834 504 256 504c-63.926 0-122.202-24.187-166.178-63.908-5.113-4.618-5.354-12.561-.482-17.433l7.069-7.069c4.503-4.503 11.749-4.714 16.482-.454C150.782 449.238 200.935 470 256 470c117.744 0 214-95.331 214-214 0-117.744-95.331-214-214-214-82.862 0-154.737 47.077-190.289 116H180c6.627 0 12 5.373 12 12v10c0 6.627-5.373 12-12 12H20c-6.627 0-12-5.373-12-12V20c0-6.627 5.373-12 12-12z"/>
</symbol>
<symbol id="svg-redo" viewBox="0 0 512 512">
  <path d="M492 8h-10c-6.627 0-12 5.373-12 12v110.625C426.804 57.047 346.761 7.715 255.207 8.001 118.82 8.428 7.787 120.009 8 256.396 8.214 393.181 119.166 504 256 504c63.926 0 122.202-24.187 166.178-63.908 5.113-4.618 5.354-12.561.482-17.433l-7.069-7.069c-4.503-4.503-11.749-4.714-16.482-.454C361.218 449.238 311.065 470 256 470c-117.744 0-214-95.331-214-214 0-117.744 95.331-214 214-214 82.862 0 154.737 47.077 190.289 116H332c-6.627 0-12 5.373-12 12v10c0 6.627 5.373 12 12 12h160c6.627 0 12-5.373 12-12V20c0-6.627-5.373-12-12-12z"/>
</symbol>
<symbol id="svg-arrow-left" viewBox="0 0 320 512">
  <path d="M206.7 464.6l-183.1-191.1C18.22 267.1 16 261.1 16 256s2.219-11.97 6.688-16.59l183.1-191.1c9.152-9.594 24.34-9.906 33.9-.7187c9.625 9.125 9.938 24.37 .7187 33.91L73.24 256l168 175.4c9.219 9.5 8.906 24.78-.7187 33.91C231 474.5 215.8 474.2 206.7 464.6z"/>
</symbol>
<symbol id="svg-arrow-right" viewBox="0 0 320 512">
  <path d="M113.3 47.41l183.1 191.1c4.469 4.625 6.688 10.62 6.688 16.59s-2.219 11.97-6.688 16.59l-183.1 191.1c-9.152 9.594-24.34 9.906-33.9 .7187c-9.625-9.125-9.938-24.38-.7187-33.91l168-175.4L78.71 80.6c-9.219-9.5-8.906-24.78 .7187-33.91C88.99 37.5 104.2 37.82 113.3 47.41z"/>
</symbol>
<symbol id="svg-tab" viewBox="0 0 448 512">
  <path d="M32 217.1c0-8.8 7.2-16 16-16h144v-93.9c0-7.1 8.6-10.7 13.6-5.7l143.5 143.1c6.3 6.3 6.3 16.4 0 22.7L205.6 410.4c-5 5-13.6 1.5-13.6-5.7v-93.9H48c-8.8 0-16-7.2-16-16v-77.7m-32 0v77.7c0 26.5 21.5 48 48 48h112v61.9c0 35.5 43 53.5 68.2 28.3l143.6-143c18.8-18.8 18.8-49.2 0-68L228.2 78.9c-25.1-25.1-68.2-7.3-68.2 28.3v61.9H48c-26.5 0-48 21.6-48 48zM436 64h-8c-6.6 0-12 5.4-12 12v360c0 6.6 5.4 12 12 12h8c6.6 0 12-5.4 12-12V76c0-6.6-5.4-12-12-12z"/>
</symbol>
<symbol id="svg-paste" viewBox="0 0 512 512"><path d="M160 32c11.6 0 21.3 8.2 23.5 19.2C185 58.6 191.6 64 199.2 64H208c8.8 0 16 7.2 16 16V96H96V80c0-8.8 7.2-16 16-16h8.8c7.6 0 14.2-5.4 15.7-12.8C138.7 40.2 148.4 32 160 32zM64 64h2.7C65 69 64 74.4 64 80V96c0 17.7 14.3 32 32 32H224c17.7 0 32-14.3 32-32V80c0-5.6-1-11-2.7-16H256c17.7 0 32 14.3 32 32h32c0-35.3-28.7-64-64-64H210.6c-9-18.9-28.3-32-50.6-32s-41.6 13.1-50.6 32H64C28.7 32 0 60.7 0 96V384c0 35.3 28.7 64 64 64H192V416H64c-17.7 0-32-14.3-32-32V96c0-17.7 14.3-32 32-32zM288 480c-17.7 0-32-14.3-32-32V192c0-17.7 14.3-32 32-32h96v56c0 22.1 17.9 40 40 40h56V448c0 17.7-14.3 32-32 32H288zM416 165.3L474.7 224H424c-4.4 0-8-3.6-8-8V165.3zM448 512c35.3 0 64-28.7 64-64V235.9c0-12.7-5.1-24.9-14.1-33.9l-59.9-59.9c-9-9-21.2-14.1-33.9-14.1H288c-35.3 0-64 28.7-64 64V448c0 35.3 28.7 64 64 64H448z"/></symbol>
<symbol id="svg-cut" viewBox="0 0 512 512"><path d="M485.6 444.2L333.6 314.9C326.9 309.2 326.1 299.1 331.8 292.4C337.5 285.6 347.6 284.8 354.4 290.5L506.4 419.8C513.1 425.5 513.9 435.6 508.2 442.4C502.5 449.1 492.4 449.9 485.6 444.2zM485.7 67.76C492.5 62.07 502.5 62.94 508.2 69.69C513.9 76.45 513.1 86.55 506.3 92.24L208.5 343.1C218.3 359.7 224 379.2 224 400C224 461.9 173.9 512 112 512C50.14 512 0 461.9 0 400C0 338.1 50.14 288 112 288C141.5 288 168.4 299.4 188.4 318.1L262.2 256L188.4 193.9C168.4 212.6 141.5 224 112 224C50.14 224 0 173.9 0 112C0 50.14 50.14 0 112 0C173.9 0 224 50.14 224 112C224 132.8 218.3 152.3 208.5 168.9L287 235.1L485.7 67.76zM32 112C32 156.2 67.82 192 112 192C156.2 192 192 156.2 192 112C192 67.82 156.2 32 112 32C67.82 32 32 67.82 32 112zM112 480C156.2 480 192 444.2 192 400C192 355.8 156.2 320 112 320C67.82 320 32 355.8 32 400C32 444.2 67.82 480 112 480z"/></symbol>
<symbol id="svg-copy" viewBox="0 0 512 512"><path d="M272 416C263.2 416 256 423.2 256 432V448c0 17.67-14.33 32-32 32H64c-17.67 0-32-14.33-32-32V192c0-17.67 14.33-32 32-32h112C184.8 160 192 152.8 192 144C192 135.2 184.8 128 176 128H63.99c-35.35 0-64 28.65-64 64l.0098 256C0 483.3 28.65 512 64 512h160c35.35 0 64-28.65 64-64v-16C288 423.2 280.8 416 272 416zM502.6 86.63l-77.25-77.25C419.4 3.371 411.2 0 402.7 0H288C252.7 0 224 28.65 224 64v256c0 35.35 28.65 64 64 64h160c35.35 0 64-28.65 64-64V109.3C512 100.8 508.6 92.63 502.6 86.63zM416 45.25L466.7 96H416V45.25zM480 320c0 17.67-14.33 32-32 32h-160c-17.67 0-32-14.33-32-32V64c0-17.67 14.33-32 32-32h96l.0026 64c0 17.67 14.33 32 32 32H480V320z"/>
</symbol>
<symbol id="svg-angle-double-right" viewBox="0 0 320 512">
  <path d="M166.9 264.5l-117.8 116c-4.7 4.7-12.3 4.7-17 0l-7.1-7.1c-4.7-4.7-4.7-12.3 0-17L127.3 256 25.1 155.6c-4.7-4.7-4.7-12.3 0-17l7.1-7.1c4.7-4.7 12.3-4.7 17 0l117.8 116c4.6 4.7 4.6 12.3-.1 17zm128-17l-117.8-116c-4.7-4.7-12.3-4.7-17 0l-7.1 7.1c-4.7 4.7-4.7 12.3 0 17L255.3 256 153.1 356.4c-4.7 4.7-4.7 12.3 0 17l7.1 7.1c4.7 4.7 12.3 4.7 17 0l117.8-116c4.6-4.7 4.6-12.3-.1-17z"/>
</symbol>
<symbol id="svg-angle-double-left" viewBox="0 0 320 512">
  <path d="M153.1 247.5l117.8-116c4.7-4.7 12.3-4.7 17 0l7.1 7.1c4.7 4.7 4.7 12.3 0 17L192.7 256l102.2 100.4c4.7 4.7 4.7 12.3 0 17l-7.1 7.1c-4.7 4.7-12.3 4.7-17 0L153 264.5c-4.6-4.7-4.6-12.3.1-17zm-128 17l117.8 116c4.7 4.7 12.3 4.7 17 0l7.1-7.1c4.7-4.7 4.7-12.3 0-17L64.7 256l102.2-100.4c4.7-4.7 4.7-12.3 0-17l-7.1-7.1c-4.7-4.7-12.3-4.7-17 0L25 247.5c-4.6 4.7-4.6 12.3.1 17z"/>
</symbol>
<symbol id="svg-trash" viewBox="0 0 448 512">
  <path d="M336 64l-33.6-44.8C293.3 7.1 279.1 0 264 0h-80c-15.1 0-29.3 7.1-38.4 19.2L112 64H24C10.7 64 0 74.7 0 88v2c0 3.3 2.7 6 6 6h26v368c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V96h26c3.3 0 6-2.7 6-6v-2c0-13.3-10.7-24-24-24h-88zM184 32h80c5 0 9.8 2.4 12.8 6.4L296 64H152l19.2-25.6c3-4 7.8-6.4 12.8-6.4zm200 432c0 8.8-7.2 16-16 16H80c-8.8 0-16-7.2-16-16V96h320v368zm-176-44V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm-80 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12zm160 0V156c0-6.6 5.4-12 12-12h8c6.6 0 12 5.4 12 12v264c0 6.6-5.4 12-12 12h-8c-6.6 0-12-5.4-12-12z"/>
</symbol>
<symbol id="svg-keyboard-down" viewBox="0 0 576 512"><path d="M64 48c-8.8 0-16 7.2-16 16V240c0 8.8 7.2 16 16 16H512c8.8 0 16-7.2 16-16V64c0-8.8-7.2-16-16-16H64zM0 64C0 28.7 28.7 0 64 0H512c35.3 0 64 28.7 64 64V240c0 35.3-28.7 64-64 64H64c-35.3 0-64-28.7-64-64V64zM159 359c9.4-9.4 24.6-9.4 33.9 0l95 95 95-95c9.4-9.4 24.6-9.4 33.9 0s9.4 24.6 0 33.9L305 505c-4.5 4.5-10.6 7-17 7s-12.5-2.5-17-7L159 393c-9.4-9.4-9.4-24.6 0-33.9zm1-167c0-8.8 7.2-16 16-16H400c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V192zM120 88h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H120c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H200c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H280c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16zm64 16c0-8.8 7.2-16 16-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H360c-8.8 0-16-7.2-16-16V104zm96-16h16c8.8 0 16 7.2 16 16v16c0 8.8-7.2 16-16 16H440c-8.8 0-16-7.2-16-16V104c0-8.8 7.2-16 16-16z"/></symbol>
</svg>`;
    function Ls(r) {
      var l;
      jc();
      let e = document.createElement("div");
      e.className = "ML__keyboard";
      let t = document.createElement("div");
      t.className = "MLK__plate", t.innerHTML = re.createHTML(Xc + r.layouts.map((c, u) => Zc(r, c, u)).join(""));
      let i = document.createElement("div");
      i.className = "MLK__backdrop", i.appendChild(t), e.appendChild(i);
      let o = e.querySelectorAll(".ML__edit-toolbar");
      if (o)
        for (let c of o)
          c.addEventListener("click", (u) => {
            var h, f;
            let d = u.target, m = "";
            for (; d && !m; )
              m = (h = d == null ? void 0 : d.getAttribute("data-command")) != null ? h : "", d = (f = d == null ? void 0 : d.parentElement) != null ? f : null;
            m && r.executeCommand(JSON.parse(m));
          });
      let a = e.querySelectorAll(".MLK__keycap, .action, .fnbutton, .bigfnbutton");
      for (let c of a)
        c.id = "ML__k" + Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
      Ca(r, [...a]);
      let n = e.querySelectorAll(".layer-switch");
      for (let c of n)
        c.classList.contains("shift") ? ti(c, (u) => r.executeCommand(u), { pressed: "shiftKeyboardLayer", default: ["switchKeyboardLayer", c.getAttribute("data-layer")] }) : ti(c, (u) => r.executeCommand(u), { default: ["switchKeyboardLayer", c.getAttribute("data-layer")] });
      let s = e.querySelectorAll(".MLK__layer");
      s.length > 0;
      for (let c of s)
        c.addEventListener("mousedown", (u) => u.preventDefault());
      return (l = s[0]) == null || l.classList.add("is-visible"), e;
    }
    function Zc(r, e, t) {
      let i = [];
      if (!("layers" in e))
        return "";
      for (let o of e.layers)
        i.push(`<div tabindex="-1" class="MLK__layer" data-layer="${o.id}">`), i.push("<div class='MLK__toolbar' role='toolbar'>"), i.push(Wc(r, t)), e.displayEditToolbar && i.push('<div class="ML__edit-toolbar right"></div>'), i.push("</div>"), i.push(Uc(r, Yc(o, { displayShiftedKeycaps: e.displayShiftedKeycaps }))), i.push("</div>");
      return i.join("");
    }
    function Yc(r, e) {
      var i, o, a;
      if (typeof r == "string")
        return r;
      let t = "";
      if (typeof r.styles == "string" ? t += `<style>${r.styles}</style>` : typeof r.styles == "object" && (t += `<style>${Jc(r.styles)}</style>`), r.backdrop && (t += `<div class='${r.backdrop}'>`), r.container && (t += `<div class='${r.container}'>`), r.rows) {
        t += "<div class='MLK__rows'>";
        for (let n of r.rows) {
          t += "<ul>";
          for (let s of n) {
            t += "<li", s = Qc(s, e);
            let l = (i = s.class) != null ? i : "";
            if (s.layer && !/layer-switch/.test(l) && (l += " layer-switch"), l && !/separator/.test(l) && (l += " MLK__keycap"), !/\bw[0-9]+\b/.test(l) && s.width && (l += (o = { 0: " w0", 0.5: " w5", 1.5: " w15", 2: " w20", 5: " w50" }[s.width]) != null ? o : ""), t += ` class="${l || "MLK__keycap"}"`, s.key && (t += ` data-key="${s.key}"`), s.tooltip && (t += ` data-tooltip="${s.tooltip}"`), s.command && (typeof s.command == "string" ? t += ` data-command='"${s.command}"'` : (t += " data-command='", t += JSON.stringify(s.command), t += "'")), s.insert && (t += ` data-insert="${s.insert}"`), s.latex && (t += ` data-latex="${s.latex}"`), s.aside && (t += ` data-aside="${s.aside}"`), s.variants)
              if (typeof s.variants != "string") {
                let c = Date.now().toString(36).slice(-2) + Math.floor(Math.random() * 1e5).toString(36);
                _s(c, s.variants), t += ` data-variants="${c}"`;
              } else
                t += ` data-variants="${s.variants}"`;
            s.shifted && (t += ` data-shifted="${s.shifted}"`), s.shiftedCommand && (t += ` data-shifted-command="${s.shiftedCommand}"`), s.layer && (t += ` data-layer="${s.layer}"`), t += `>${s.label || ri((a = s.latex) != null ? a : "")}</li>`;
          }
          t += "</ul>";
        }
        t += "</div>";
      } else
        r.markup && (t += r.markup);
      return r.container && (t += "</div>"), r.backdrop && (t += "</div>"), t;
    }
    var Lo = { "[left]": { class: "action", command: ["performWithFeedback", "moveToPreviousChar"], shifted: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-left /></svg>", shiftedCommand: ["performWithFeedback", "extendToPreviousChar"], label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-left /></svg>" }, "[right]": { class: "action", command: ["performWithFeedback", "moveToNextChar"], shifted: "<svg class=svg-glyph><use xlink:href=#svg-angle-double-right /></svg>", shiftedCommand: ["performWithFeedback", "extendToNextChar"], label: "<svg class=svg-glyph><use xlink:href=#svg-arrow-right /></svg>" }, "[return]": { class: "action", command: ["performWithFeedback", "commit"], width: 1.5, label: "<svg class=svg-glyph><use xlink:href=#svg-commit /></svg>" }, "[hr]": { class: "separator horizontal-rule" }, "[hide-keyboard]": { class: "action", command: ["performWithFeedback", "hideVirtualKeyboard"], width: 1.5, label: "<svg class=svg-glyph-lg><use xlink:href=#svg-keyboard-down /></svg>" }, "[.]": { class: "big-op", variants: ".", command: "insertDecimalSeparator" }, "[+]": { class: "big-op", variants: "+", latex: "+", label: "+" }, "[-]": { class: "big-op", variants: "-", latex: "-", label: "&#x2212;" }, "[/]": { class: "big-op", variants: "/", latex: "\\frac{#@}{#?}", label: "&divide;" }, "[*]": { class: "big-op", variants: "*", latex: "\\times", label: "&times;" }, "[=]": { class: "big-op", variants: "=", latex: "=", label: "=" }, "[backspace]": { class: "action font-glyph bottom right", width: 1.5, command: ["performWithFeedback", "deleteBackward"], label: "<svg class=svg-glyph><use xlink:href=#svg-delete-backward /></svg>", shifted: "<span class=warning><svg class=svg-glyph><use xlink:href=#svg-trash /></svg></span", shiftedCommand: "deleteAll", variants: "delete" }, "[undo]": { class: "ghost", command: "undo", label: "<svg class=svg-glyph><use xlink:href=#svg-undo /></svg>", tooltip: kt("tooltip.undo") }, "[redo]": { class: "ghost", command: "redo", label: "<svg class=svg-glyph><use xlink:href=#svg-redo /></svg>" }, "[(]": { variants: "(", latex: "(" }, "[)]": { variants: ")", latex: ")" }, "[0]": { variants: "0", latex: "0", label: "0" }, "[1]": { variants: "1", latex: "1", label: "1" }, "[2]": { variants: "2", latex: "2", label: "2" }, "[3]": { variants: "3", latex: "3", label: "3" }, "[4]": { variants: "4", latex: "4", label: "4" }, "[5]": { variants: "5", latex: "5", label: "5" }, "[6]": { variants: "6", latex: "6", label: "6" }, "[7]": { variants: "7", latex: "7", label: "7" }, "[8]": { variants: "8", latex: "8", label: "8" }, "[9]": { variants: "9", latex: "9", label: "9" }, "[separator-5]": { class: "separator", width: 0.5 }, "[separator]": { class: "separator" }, "[separator-10]": { class: "separator" }, "[separator-15]": { class: "separator", width: 1.5 }, "[separator-20]": { class: "separator", width: 2 }, "[separator-50]": { class: "separator", width: 5 }, "[shift]": { class: "shift modifier font-glyph bottom left layer-switch", width: 1.5, label: "<svg class=svg-glyph><use xlink:href=#svg-shift /></svg>" }, "[foreground-color]": { variants: "foreground-color", command: ["applyStyle", { color: "red" }], label: "<span style='border-radius: 50%;width:22px;height:22px; border: 3px solid #cc2428; box-sizing: border-box'>" }, "[background-color]": { variants: "background-color", command: ["applyStyle", { backgroundColor: "yellow" }], label: "<span style='border-radius: 50%;width:22px;height:22px; background:#fff590; box-sizing: border-box'></span>" } };
    function Qc(r, e = {}) {
      var t;
      if (typeof r == "string") {
        if (!Lo[r])
          return { latex: r };
        r = { label: r };
      }
      if ("label" in r && r.label && Lo[r.label]) {
        let i = E(b(b({}, Lo[r.label]), r), { label: Lo[r.label].label });
        return i.command === "insertDecimalSeparator" && (i.label = (t = re.decimalSeparator) != null ? t : "."), e.displayShiftedKeycaps || (delete i.shifted, delete i.shiftedCommand), i;
      }
      return r;
    }
    var qe = class {
      constructor() {
        this.originalContainerBottomPadding = null;
        var e, t, i;
        this.targetOrigin = window.origin, this.originValidator = "none", this._alphabeticLayout = "auto", this.layouts = ["default"], this._actionToolbar = "default", this._container = (t = (e = window.document) == null ? void 0 : e.body) != null ? t : null, this._visible = false, this._dirty = true, this.observer = new ResizeObserver((o) => {
          var n, s;
          let a = this.boundingRect.height;
          if (this.container === document.body) {
            (n = this._element) == null || n.style.setProperty("--keyboard-height", `calc(${a}px + env(safe-area-inset-bottom, 0))`);
            let l = a - 1;
            this.container.style.paddingBottom = this.originalContainerBottomPadding ? `calc(${this.originalContainerBottomPadding} + ${l}px)` : `${l}px`;
          } else
            (s = this._element) == null || s.style.setProperty("--keyboard-height", `${a}px`);
          this.dispatchEvent(new Event("geometrychange")), this.sendMessage("geometry-changed", { boundingRect: this.boundingRect });
        }), this.listeners = {}, (i = window.top) == null || i.addEventListener("message", this), document.body.addEventListener("focusin", (o) => {
          var n;
          let a = o.target;
          if (a != null && a.isConnected && ((n = a.tagName) == null ? void 0 : n.toLowerCase()) === "math-field" && fn()) {
            let s = a;
            s.mathVirtualKeyboardPolicy === "auto" && !s.readOnly && this.show();
          }
        }), document.addEventListener("focusout", () => {
          setTimeout(() => {
            var n, s, l;
            let o = document.activeElement, a = false;
            for (; o; ) {
              if (((n = o.tagName) == null ? void 0 : n.toLowerCase()) === "math-field") {
                a = true;
                break;
              }
              o = (l = (s = o.shadowRoot) == null ? void 0 : s.activeElement) != null ? l : null;
            }
            a || this.hide();
          }, 300);
        });
      }
      get alphabeticLayout() {
        return this._alphabeticLayout;
      }
      set alphabeticLayout(e) {
        this._alphabeticLayout = e, this.rebuild();
      }
      get layouts() {
        return this._layouts;
      }
      set layouts(e) {
        let t = Array.isArray(e) ? [...e] : [e], i = t.findIndex((o) => o === "default");
        i >= 0 && t.splice(i, 1, "numeric", "functions", "symbols", "alphabetic", "greek"), this._layouts = t.map((o) => Ea(o)), this.rebuild();
      }
      get actionToolbar() {
        return this._actionToolbar;
      }
      set actionToolbar(e) {
        this._actionToolbar = e, this.rebuild();
      }
      get container() {
        return this._container;
      }
      set container(e) {
        this._container = e, this.rebuild();
      }
      static get singleton() {
        return this._singleton || (this._singleton = new qe()), this._singleton;
      }
      addEventListener(e, t, i) {
        this.listeners[e] || (this.listeners[e] = /* @__PURE__ */ new Set()), this.listeners[e].has(t) || this.listeners[e].add(t);
      }
      dispatchEvent(e) {
        return !this.listeners[e.type] || this.listeners[e.type].size === 0 ? true : (this.listeners[e.type].forEach((t) => {
          typeof t == "function" ? t(e) : t == null || t.handleEvent(e);
        }), !e.defaultPrevented);
      }
      removeEventListener(e, t, i) {
        this.listeners[e] && this.listeners[e].delete(t);
      }
      get element() {
        return this._element;
      }
      set element(e) {
        var t;
        this._element !== e && ((t = this._element) == null || t.remove(), this._element = e);
      }
      get visible() {
        return this._visible;
      }
      set visible(e) {
        e ? this.show() : this.hide();
      }
      get boundingRect() {
        var t;
        if (!this._visible)
          return new DOMRect();
        let e = (t = this._element) == null ? void 0 : t.getElementsByClassName("MLK__plate")[0];
        return e ? e.getBoundingClientRect() : new DOMRect();
      }
      rebuild() {
        var i;
        if (this._dirty || !this._element)
          return;
        this._dirty = true;
        let e = "", t = this._element.querySelector(".MLK__layer.is-visible");
        t && (e = (i = t.getAttribute("data-layer")) != null ? i : ""), requestAnimationFrame(() => {
          var o;
          if (this._dirty = false, this._element && (this._element.remove(), this._element = void 0), this.visible) {
            this.buildAndAttachElement();
            let a = this.element.querySelector(`.MLK__layer[data-layer="${e}"]`);
            a && ((o = this.element.querySelector(".MLK__layer.is-visible")) == null || o.classList.remove("is-visible"), a.classList.add("is-visible")), this.element.classList.add("is-visible");
          }
        });
      }
      show() {
        if (this._visible)
          return;
        let e = this.container;
        if (e && this.stateWillChange(true)) {
          if (this._element || this.buildAndAttachElement(), !this._visible) {
            let t = this._element.getElementsByClassName("MLK__plate")[0];
            if (t && this.observer.observe(t), e === window.document.body) {
              let i = e.style.paddingBottom;
              this.originalContainerBottomPadding = i;
              let o = t.offsetHeight - 1;
              e.style.paddingBottom = i ? `calc(${i} + ${o}px)` : `${o}px`;
            }
            window.addEventListener("mouseup", this), window.addEventListener("blur", this);
          }
          requestAnimationFrame(() => {
            var t;
            (t = this._element) == null || t.classList.add("is-visible"), this.focus(), this._visible = true, this.stateChanged();
          });
        }
      }
      hide() {
        var t;
        let e = this.container;
        if (e && this._visible && this.stateWillChange(false)) {
          if (this._element) {
            let i = this._element.getElementsByClassName("MLK__plate")[0];
            i && this.observer.unobserve(i), window.removeEventListener("mouseup", this), window.removeEventListener("blur", this), Er(), this._visible = false, As(), (t = this._element) == null || t.remove(), this._element = void 0, this.originalContainerBottomPadding !== null && (e.style.paddingBottom = this.originalContainerBottomPadding);
          }
          this._visible = false, this.stateChanged();
        }
      }
      get height() {
        var e, t;
        return (t = (e = this.element) == null ? void 0 : e.offsetHeight) != null ? t : 0;
      }
      buildAndAttachElement() {
        var e;
        this.element, this.element = Ls(this), je(this.element, "mousedown", () => this.focus()), (e = this.container) == null || e.appendChild(this.element);
      }
      handleEvent(e) {
        if (Di(e)) {
          if (!Qr(e.origin, this.originValidator))
            throw new DOMException(`Message from unknown origin (${e.origin}) cannot be handled`, "SecurityError");
          let { action: t } = e.data;
          if (t === "execute-command") {
            let { command: i } = e.data;
            if (this.connectedMathfieldWindow = e.source, hr(i) !== "virtual-keyboard" && window === window.parent)
              return;
            this.executeCommand(i);
            return;
          }
          if (t === "connect") {
            this.connectedMathfieldWindow = e.source;
            return;
          }
          if (t === "disconnect") {
            this.connectedMathfieldWindow = void 0;
            return;
          }
          if (t === "show") {
            this.connectedMathfieldWindow = e.source, this.show();
            return;
          }
          if (t === "hide") {
            this.connectedMathfieldWindow = e.source, this.hide();
            return;
          }
          if (t === "update-setting") {
            e.data.alphabeticLayout && (this.alphabeticLayout = e.data.alphabeticLayout), e.data.layouts && (this.layouts = e.data.layouts), e.data.actionToolbar && (this.actionToolbar = e.data.actionToolbar);
            return;
          }
          if (t === "proxy-created") {
            this.sendMessage("synchronize-proxy", { boundingRect: this.boundingRect, alphabeticLayout: this._alphabeticLayout, layouts: this._layouts, actionToolbar: this._actionToolbar });
            return;
          }
        }
        if (this._element)
          switch (e.type) {
            case "mouseup":
            case "blur":
              document.body.style.userSelect = "", ai();
              break;
          }
      }
      sendMessage(e, t = {}) {
        var i;
        (i = this.connectedMathfieldWindow) == null || i.postMessage(b({ type: ko, action: e }, t), this.targetOrigin);
      }
      stateWillChange(e) {
        return this.dispatchEvent(new CustomEvent("before-virtual-keyboard-toggle", { detail: { visible: e }, bubbles: true, cancelable: true, composed: true }));
      }
      stateChanged() {
        this.dispatchEvent(new Event("virtual-keyboard-toggle")), this.sendMessage("geometry-changed", { boundingRect: this.boundingRect });
      }
      focus() {
        this.sendMessage("focus");
      }
      blur() {
        this.sendMessage("blur");
      }
      updateToolbar(e) {
        var i;
        let t = (i = this._element) == null ? void 0 : i.querySelectorAll(".ML__edit-toolbar");
        if (t)
          for (let o of t)
            o.innerHTML = Ms(this, e);
      }
      connect() {
        this.connectedMathfieldWindow = window;
      }
      disconnect() {
        this.connectedMathfieldWindow = void 0;
      }
      executeCommand(e) {
        let t, i = [];
        return Y(e) ? (t = e[0], i = e.slice(1)) : t = e, t = t.replace(/-\w/g, (o) => o[1].toUpperCase()), hr(e) === "virtual-keyboard" ? Ht[t].fn(...i) : (this.sendMessage("execute-command", { command: e }), false);
      }
      dispose() {
        window.removeEventListener("mouseup", this), window.removeEventListener("blur", this), window.removeEventListener("message", this);
      }
    };
    if (fe() && !("mathVirtualKeyboard" in window))
      if (window === window.top) {
        let r = qe.singleton;
        Object.defineProperty(window, "mathVirtualKeyboard", { get: () => r });
      } else
        Object.defineProperty(window, "mathVirtualKeyboard", { get: () => ei.singleton });
    function Co(r) {
      var e;
      typeof ((e = r.listeners) == null ? void 0 : e.onSelectionDidChange) == "function" && !r.suppressChangeNotifications && (r.suppressChangeNotifications = true, r.listeners.onSelectionDidChange(r), r.suppressChangeNotifications = false), window.mathVirtualKeyboard.updateToolbar(Vt(r.mathfield));
    }
    function H(r, e = {}) {
      var i;
      if (r.suppressChangeNotifications || !r.mathfield.host)
        return true;
      r.suppressChangeNotifications = true;
      let t = r.mathfield.host.dispatchEvent(new InputEvent("beforeinput", E(b({}, e), { data: e.data ? e.data : (i = e.inputType) != null ? i : "", cancelable: true, bubbles: true, composed: true })));
      return r.suppressChangeNotifications = false, t;
    }
    function J(r, e) {
      var t;
      r.suppressChangeNotifications || !r.mathfield.host || (r.suppressChangeNotifications = true, r.mathfield.host.dispatchEvent(new InputEvent("input", E(b({}, e), { data: e.data ? e.data : (t = e.inputType) != null ? t : "", bubbles: true, composed: true }))), r.suppressChangeNotifications = false);
    }
    var Pa = class extends Z {
      constructor() {
        super("latex");
      }
      createAtom(e, t, i) {
        return new ae(e, t);
      }
      onPaste(e, t) {
        var o;
        if (!t)
          return false;
        let i = typeof t == "string" ? t : (o = t.getData("text/x-latex")) != null ? o : t.getData("text/plain");
        return i && H(e.model, { inputType: "insertFromPaste", data: i }) ? (e.snapshot(), this.insert(e.model, i) && (J(e.model, { inputType: "insertFromPaste" }), te(e)), true) : false;
      }
      insert(e, t, i) {
        if (!H(e, { data: t, inputType: "insertText" }))
          return false;
        i || (i = {}), i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder");
        let { suppressChangeNotifications: o } = e;
        i.suppressChangeNotifications && (e.suppressChangeNotifications = true);
        let a = e.suppressChangeNotifications;
        e.suppressChangeNotifications = true, i.insertionMode === "replaceSelection" && !e.selectionIsCollapsed ? e.deleteAtoms(xe(e.selection)) : i.insertionMode === "replaceAll" ? (e.root.setChildren([], "body"), e.position = 0) : i.insertionMode === "insertBefore" ? e.collapseSelection("backward") : i.insertionMode === "insertAfter" && e.collapseSelection("forward");
        let n = [];
        for (let c of t)
          Rn.test(c) && n.push(new ae(c, e.mathfield));
        let s = e.at(e.position);
        if (s instanceof We && (s = s.lastChild), !(s.parent instanceof We)) {
          let c = new We("", e.mathfield);
          s.parent.addChildAfter(c, s), s = c.firstChild;
        }
        let l = s.parent.addChildrenAfter(n, s);
        return e.suppressChangeNotifications = a, i.selectionMode === "before" || (i.selectionMode === "item" ? e.setSelection(e.anchor, e.offsetOf(l)) : l && (e.position = e.offsetOf(l))), J(e, { data: t, inputType: "insertText" }), e.suppressChangeNotifications = o, true;
      }
    };
    function Cs(r) {
      return r.atoms.find((e) => e instanceof We);
    }
    function Pr(r) {
      var t, i;
      let e = r.atoms.find((o) => o instanceof We);
      return e ? (i = (t = e.body) == null ? void 0 : t.filter((o) => o instanceof ae)) != null ? i : [] : [];
    }
    function To(r, e) {
      var s;
      let t = 0, i = false, o = Number.isFinite(e == null ? void 0 : e.before) ? (s = e == null ? void 0 : e.before) != null ? s : 0 : r.lastOffset;
      for (; t <= o && !i; ) {
        let l = r.at(t);
        i = l instanceof ae && l.isSuggestion, i || t++;
      }
      if (!i)
        return [void 0, void 0];
      let a = t, n = false;
      for (; a <= o && !n; ) {
        let l = r.at(a);
        n = !(l instanceof ae && l.isSuggestion), n || a++;
      }
      return [t - 1, a - 1];
    }
    new Pa();
    function zi(r) {
      let e = Pr(r.model).filter((t) => t.isSuggestion);
      if (e.length !== 0) {
        r.model.position = r.model.offsetOf(e[0].leftSibling);
        for (let t of e)
          t.parent.removeChild(t);
      }
    }
    function si(r, e) {
      var l;
      let { model: t } = r;
      zi(r);
      for (let c of Pr(t))
        c.isError = false;
      if (!t.selectionIsCollapsed) {
        ni(r);
        return;
      }
      let i = [], o = t.at(t.position);
      for (; o && o instanceof ae && /^[a-zA-Z\*]$/.test(o.value); )
        o = o.leftSibling;
      if (o && o instanceof ae && o.value === "\\")
        for (i.push(o), o = o.rightSibling; o && o instanceof ae && /^[a-zA-Z\*]$/.test(o.value); )
          i.push(o), o = o.rightSibling;
      let a = i.map((c) => c.value).join(""), n = a ? In(r, a) : [];
      if (n.length === 0) {
        /^\\[a-zA-Z\*]+$/.test(a) && i.forEach((c) => {
          c.isError = true;
        }), ni(r);
        return;
      }
      r.suggestionIndex = (l = e == null ? void 0 : e.atIndex) != null ? l : 0, r.suggestionIndex < 0 && (r.suggestionIndex = n.length - 1);
      let s = n[r.suggestionIndex % n.length];
      if (s !== a) {
        let c = i[i.length - 1];
        c.parent.addChildrenAfter([...s.slice(a.length - s.length)].map((u) => new ae(u, r, { isSuggestion: true })), c), te(r);
      }
      Ts(r, n);
    }
    function Ka(r) {
      let [e, t] = To(r, { before: r.position });
      if (e === void 0 || t === void 0)
        return false;
      let i = false;
      return r.getAtoms([e, t]).forEach((o) => {
        o.isSuggestion && (o.isSuggestion = false, i = true);
      }), i;
    }
    function yt(r, e = "accept", t) {
      var s, l;
      ni(r);
      let i = Cs(r.model);
      if (!i)
        return false;
      if (e === "accept-suggestion") {
        let c = Pr(r.model).filter((u) => u.isSuggestion);
        if (c.length === 0)
          return false;
        for (let u of c)
          u.isSuggestion = false;
        return r.model.position = r.model.offsetOf(c[c.length - 1]), true;
      }
      let a = Pr(r.model).filter((c) => !c.isSuggestion).map((c) => c.value).join(""), n = i.leftSibling;
      return i.parent.removeChild(i), r.model.position = r.model.offsetOf(n), r.mode = (s = t == null ? void 0 : t.mode) != null ? s : "math", e === "reject" || (Z.insert("math", r.model, a, { selectionMode: (l = t == null ? void 0 : t.selectItem) != null && l ? "item" : "placeholder", format: "latex" }), r.snapshot(), r.model.announce("replacement")), true;
    }
    var Da, Ba = null, Oa = null;
    function eu(r, e) {
      let t = new g("root", r);
      t.body = pe(e, r, { parseMode: "math" });
      let i = new P({ registers: r.registers }, { fontSize: nt }, "displaystyle"), o = Yt(Mt(new v(t.render(i), { classes: "ML__base" }), i));
      return _t(o, { classes: "ML__mathlive" }).toMarkup();
    }
    function Ts(r, e) {
      if (e.length === 0 || r.options.popoverPolicy === "off") {
        ni(r);
        return;
      }
      e = e.slice(0, 10);
      let t = "<ul>";
      for (let o of e) {
        let a = o, n = eu(r, o), s = gs(r.keybindings, a).join("<br>");
        t += `<li role="button" data-command="${a}"><span class="ML__popover__latex">${a}</span><span class="ML__popover__command">${n}</span>`, s && (t += `<span class="ML__popover__keybinding">${s}</span>`), t += "</li>";
      }
      t += "</ul>", r.popover = tu(r, t);
      let i = r.popover.querySelectorAll("ul li");
      for (let o of i)
        o.addEventListener("pointerdown", (a) => a.preventDefault()), o.addEventListener("click", (a) => {
          yt(r, "reject"), Z.insert("math", r.model, o.dataset.command, { selectionMode: "placeholder", format: "latex" }), r.dirty = true, r.scrollIntoView(), r.focus();
        });
      setTimeout(() => {
        let o = Lr(r.field);
        o && Es(r, o), r.popover && (r.popover.classList.add("is-visible"), r.popoverVisible = true);
      }, 32);
    }
    function Ri(r, e) {
      var t;
      if (!(!r.element || r.element.mathfield !== r) && !(!r.popover || !r.popoverVisible)) {
        if (e != null && e.deferred) {
          setTimeout(() => Ri(r), 100);
          return;
        }
        if (((t = r.model.at(r.model.position)) == null ? void 0 : t.type) !== "latex")
          ni(r);
        else {
          let i = Lr(r.field);
          i && Es(r, i);
        }
      }
    }
    function Es(r, e) {
      if (Wi(), !r.popover || !r.popoverVisible)
        return;
      let t = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight, i = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, o = window.innerWidth - document.documentElement.clientWidth, a = window.innerHeight - document.documentElement.clientHeight, n = window.mathVirtualKeyboard.boundingRect.height;
      e.x + r.popover.offsetWidth / 2 > i - o ? r.popover.style.left = `${i - r.popover.offsetWidth - o}px` : e.x - r.popover.offsetWidth / 2 < 0 ? r.popover.style.left = "0" : r.popover.style.left = `${e.x - r.popover.offsetWidth / 2}px`, e.y + r.popover.offsetHeight + 5 > t - a - n ? (r.popover.classList.add("ML__popover--reverse-direction"), r.popover.style.top = `${e.y - e.height - r.popover.offsetHeight - 5}px`) : (r.popover.classList.remove("ML__popover--reverse-direction"), r.popover.style.top = `${e.y + 5}px`);
    }
    function ni(r) {
      r.suggestionIndex = 0, r.popoverVisible = false, r.popover && (r.popover.classList.remove("is-visible"), r.popover.innerHTML = "");
    }
    function tu(r, e) {
      return r.popover ? (r.popover.innerHTML = window.MathfieldElement.createHTML(e), r.popover) : (r.popover = xo("mathlive-popover-panel"), Da === void 0 && (Da = Xe(_a).toString(36)), Ba = Ze(null, _a, Da), Oa = Ze(null, Ie, Xe(Ie).toString(36)), r.popover.innerHTML = window.MathfieldElement.createHTML(e), r.popover);
    }
    function Ps(r) {
      vo(r.popover), Ba && Ba.release(), Oa && Oa.release(), delete r.popover;
    }
    function ru(r) {
      let e = 0;
      for (let t = 0; t < r.length; t++)
        e = e * 31 + r.charCodeAt(t), e = e | 0;
      return Math.abs(e);
    }
    function te(r, e) {
      r.dirty || (r.dirty = true, requestAnimationFrame(() => {
        qt(r) && r.dirty && (r.atomBoundsCache = /* @__PURE__ */ new Map(), Gt(r, e), r.atomBoundsCache = void 0);
      }));
    }
    function iu(r, e) {
      var a;
      e = e != null ? e : {};
      let t = new P({ registers: r.registers, atomIdsSettings: { seed: e.forHighlighting ? ru(g.serialize(r.model.root, { expandMacro: false, defaultMode: r.options.defaultMode })) : "random", groupNumbers: (a = e.forHighlighting) != null ? a : false } }, { fontSize: nt, letterShapeStyle: r.options.letterShapeStyle }, r.options.defaultMode === "inline-math" ? "textstyle" : "displaystyle"), i = r.model.root.render(t);
      return _t(Mt(i, t), { classes: r.hasEditablePrompts ? "ML__mathlive ML__prompting" : "ML__mathlive", attributes: { translate: "no", "aria-hidden": "true" } });
    }
    function za(r, e) {
      let { model: t } = r;
      t.root.caret = "", t.root.isSelected = false, t.root.containsCaret = true;
      for (let a of t.atoms)
        a.caret = "", a.isSelected = false, a.containsCaret = false;
      let i = r.isSelectionEditable && r.hasFocus();
      if (t.selectionIsCollapsed)
        t.at(t.position).caret = i ? r.mode : "";
      else {
        let a = t.getAtoms(t.selection, { includeChildren: true });
        for (let n of a)
          n.isSelected = true;
      }
      if (i) {
        let a = t.at(t.position).parent;
        for (; a; )
          a.containsCaret = true, a = a.parent;
      }
      let o = iu(r, e);
      return window.MathfieldElement.createHTML(o.toMarkup());
    }
    function Gt(r, e) {
      var n;
      if (!qt(r))
        return;
      e != null || (e = {});
      let t = (n = r.element) == null ? void 0 : n.querySelector("[part=virtual-keyboard-toggle]");
      t && (t.style.display = r.hasEditableContent ? "flex" : "none");
      let i = r.field, o = r.isSelectionEditable && r.hasFocus(), a = i.classList.contains("ML__focused");
      a && !o ? i.classList.remove("ML__focused") : !a && o && i.classList.add("ML__focused"), i.innerHTML = za(r, e), r.fieldContent = i.getElementsByClassName("ML__mathlive")[0], Fi(r, e.interactive), r.dirty = false;
    }
    function Fi(r, e) {
      let t = r.field;
      if (!t)
        return;
      for (let s of t.querySelectorAll(".ML__selection, .ML__contains-highlight"))
        s.remove();
      if (!r.hasFocus())
        return;
      !(e != null && e) && $e !== "error" && $e !== "ready" && setTimeout(() => {
        $e === "ready" ? Fi(r) : setTimeout(() => Fi(r), 128);
      }, 32);
      let i = r.model, o = parseFloat(getComputedStyle(t).width), n = t.getBoundingClientRect().width / o;
      if (n = isNaN(n) ? 1 : n, i.selectionIsCollapsed) {
        setTimeout(() => Ri(r), 32);
        let s = i.at(i.position);
        for (; s && !(s.containsCaret && s.displayContainsHighlight); )
          s = s.parent;
        if (s != null && s.containsCaret && s.displayContainsHighlight) {
          let l = ba(r, mr(r, s));
          if (l) {
            l.left /= n, l.right /= n, l.top /= n, l.bottom /= n;
            let c = document.createElement("div");
            c.classList.add("ML__contains-highlight"), c.style.position = "absolute", c.style.left = `${l.left}px`, c.style.top = `${l.top}px`, c.style.width = `${Math.ceil(l.right - l.left)}px`, c.style.height = `${Math.ceil(l.bottom - l.top - 1)}px`, t.insertBefore(c, t.childNodes[0]);
          }
        }
        return;
      }
      for (let s of ou(wo(r, { excludeAtomsWithBackground: true }))) {
        s.left /= n, s.right /= n, s.top /= n, s.bottom /= n;
        let l = document.createElement("div");
        l.classList.add("ML__selection"), l.style.position = "absolute", l.style.left = `${s.left}px`, l.style.top = `${s.top}px`, l.style.width = `${Math.ceil(s.right - s.left)}px`, l.style.height = `${Math.ceil(s.bottom - s.top - 1)}px`, t.insertBefore(l, t.childNodes[0]);
      }
    }
    function ou(r) {
      let e = [];
      for (let t of r) {
        let i = false;
        for (let o of e)
          if (t.left === o.left && t.right === o.right && t.top === o.top && t.bottom === o.bottom) {
            i = true;
            break;
          }
        i || e.push(t);
      }
      r = e, e = [];
      for (let t of r) {
        let i = 0;
        for (let o of r)
          if (t.left >= o.left && t.right <= o.right && t.top >= o.top && t.bottom <= o.bottom && (i += 1, i > 1))
            break;
        i === 1 && e.push(t);
      }
      return e;
    }
    var Ra = 3, Ht = {};
    function he(r, e) {
      e = e != null ? e : { target: "mathfield", canUndo: false };
      for (let t of Object.keys(r))
        Ht[t], Ht[t] = E(b({}, e), { fn: r[t] });
    }
    function hr(r) {
      var t;
      let e;
      return e = Y(r) ? r[0] : r, e = e.replace(/-\w/g, (i) => i[1].toUpperCase()), (t = Ht[e]) == null ? void 0 : t.target;
    }
    function Ks(r, e) {
      var s, l;
      if (!e)
        return false;
      let t, i = [], o = false, a = false;
      Y(e) ? (t = e[0], i = e.slice(1)) : t = e, t = t.replace(/-\w/g, (c) => c[1].toUpperCase());
      let n = (s = Ht[t]) == null ? void 0 : s.target;
      if (n === "model") {
        if (!r.isSelectionEditable && /^(paste|cut|insert|delete|transpose|add)/.test(t))
          return r.model.announce("plonk"), false;
        /^(delete|transpose|add)/.test(t) && t !== "deleteBackward" && r.flushInlineShortcutBuffer(), /^(delete|transpose|add)/.test(t) && r.mode !== "latex" && (r.popUndoStack(), r.snapshot()), r.mode === "latex" && !/^(complete)/.test(t) && zi(r), Ht[t].fn(r.model, ...i), r.mode !== "latex" && /^(delete|transpose|add)/.test(t) && r.snapshot(), r.mode === "latex" && si(r), a = true, o = true;
      } else if (n === "virtual-keyboard")
        a = (l = window.mathVirtualKeyboard.executeCommand(e)) != null ? l : false, o = true;
      else if (Ht[t])
        /^(undo|redo)/.test(t) && r.flushInlineShortcutBuffer(), a = Ht[t].fn(r, ...i), o = true;
      else
        throw new Error(`Unknown command "${t}"`);
      return n !== "virtual-keyboard" && (!r.model.selectionIsCollapsed || /^(transpose|paste|complete|((moveToNextChar|moveToPreviousChar|extend).*))_$/.test(t)) && (r.flushInlineShortcutBuffer(), r.style = {}), a && te(r), o;
    }
    function au(r, e) {
      r.focus(), Ao.keypressVibration && Ui() && navigator.vibrate(Ra), e = e.replace(/-\w/g, (i) => i[1].toUpperCase()), e === "moveToNextPlaceholder" || e === "moveToPreviousPlaceholder" || e === "complete" ? window.MathfieldElement.playSound("return") : e === "deleteBackward" || e === "deleteForward" || e === "deletePreviousWord" || e === "deleteNextWord" || e === "deleteToGroupStart" || e === "deleteToGroupEnd" || e === "deleteToMathFieldStart" || e === "deleteToMathFieldEnd" ? window.MathfieldElement.playSound("delete") : window.MathfieldElement.playSound("keypress");
      let t = r.executeCommand(e);
      return r.scrollIntoView(), t;
    }
    he({ performWithFeedback: (r, e) => au(r, e) });
    function nu(r) {
      return si(r, { atIndex: r.suggestionIndex + 1 }), false;
    }
    function su(r) {
      return si(r, { atIndex: r.suggestionIndex - 1 }), false;
    }
    he({ complete: yt, nextSuggestion: nu, previousSuggestion: su }, { target: "mathfield", category: "autocomplete" });
    function Kr(r, e) {
      return r + $t(e);
    }
    he({ speak: (r, e, t) => lu(r, e, t) }, { target: "mathfield", category: "speech" });
    function lu(r, e, t) {
      var l, c;
      t = t != null ? t : { withHighlighting: false };
      let { model: i } = r;
      function o(u) {
        let d = null;
        switch (u) {
          case "all":
            d = i.root;
            break;
          case "selection":
            d = i.getAtoms(i.selection);
            break;
          case "left": {
            d = i.getAtoms(i.offsetOf(i.at(i.position).leftSibling), i.position);
            break;
          }
          case "right": {
            d = i.getAtoms(i.position, i.offsetOf(i.at(i.position).rightSibling));
            break;
          }
          case "group":
            d = i.getAtoms(i.getSiblingsRange(i.position));
            break;
          case "parent": {
            let { parent: m } = i.at(i.position);
            m && m.type !== "root" ? d = m : d = i.root;
            break;
          }
          default:
            d = i.root;
        }
        return d;
      }
      function a(u) {
        let d = "";
        switch (u) {
          case "all":
            break;
          case "selection":
            d = "no selection";
            break;
          case "left":
            d = "at start";
            break;
          case "right":
            d = "at end";
            break;
          case "group":
            break;
          case "parent":
            d = "no parent";
            break;
          default:
            "" + u;
            break;
        }
        return d;
      }
      let n = o(e);
      if (n === null)
        return (c = (l = window.MathfieldElement).speakHook) == null || c.call(l, a(e)), false;
      (t.withHighlighting || window.MathfieldElement.speechEngine === "amazon") && (window.MathfieldElement.textToSpeechMarkup = window.sre && window.MathfieldElement.textToSpeechRules === "sre" ? "ssml_step" : "ssml");
      let s = $t(n);
      return fe() && t.withHighlighting ? (bt().readAloudMathField = r, Gt(r, { forHighlighting: true }), window.MathfieldElement.readAloudHook && window.MathfieldElement.readAloudHook(r.field, s)) : window.MathfieldElement.speakHook && window.MathfieldElement.speakHook(s), false;
    }
    function Ds(r) {
      var e, t;
      if (fe())
        if (!window.MathfieldElement.speechEngine || window.MathfieldElement.speechEngine === "local") {
          let i = new SpeechSynthesisUtterance(r);
          window.speechSynthesis.speak(i);
        } else if (window.MathfieldElement.speechEngine === "amazon")
          if (!("AWS" in window))
            console.error("MathLive 0.90.9: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk");
          else {
            let i = new window.AWS.Polly({ apiVersion: "2016-06-10" }), o = { OutputFormat: "mp3", VoiceId: (e = window.MathfieldElement.speechEngineVoice) != null ? e : "Joanna", Engine: ["Amy", "Emma", "Brian", "Ivy", "Joanna", "Kendra", "Kimberly", "Salli", "Joey", "Justin", "Matthew"].includes((t = window.MathfieldElement.speechEngineVoice) != null ? t : "Joanna") ? "neural" : "standard", Text: r, TextType: "ssml" };
            i.synthesizeSpeech(o, (a, n) => {
              if (a)
                console.trace(`MathLive 0.90.9: \`polly.synthesizeSpeech()\` error: ${a}`);
              else if (n != null && n.AudioStream) {
                let s = new Uint8Array(n.AudioStream), l = new Blob([s.buffer], { type: "audio/mpeg" }), c = URL.createObjectURL(l);
                new Audio(c).play().catch((d) => console.log(d));
              }
            });
          }
        else
          window.MathfieldElement.speechEngine === "google" && console.error("MathLive 0.90.9: The Google speech engine is not supported yet. Please come again.");
    }
    function Bs(r) {
      let e;
      if (r.parent.type === "prompt")
        r.treeBranch === "body" && (e = "prompt");
      else if (r.treeBranch === "body")
        e = { enclose: "cross out", leftright: "delimiter", surd: "square root", root: "math field", mop: "operator", first: "first" }[r.type];
      else if (r.parent.type === "genfrac") {
        if (r.treeBranch === "above")
          return "numerator";
        if (r.treeBranch === "below")
          return "denominator";
      } else
        r.parent.type === "surd" ? r.treeBranch === "above" && (e = "index") : r.treeBranch === "superscript" ? e = "superscript" : r.treeBranch === "subscript" && (e = "subscript");
      return e != null ? e : "parent";
    }
    function Os(r, e, t, i) {
      let o = "";
      if (e === "plonk")
        window.MathfieldElement.playSound("plonk"), r.flushInlineShortcutBuffer();
      else if (e === "delete")
        o = Kr("deleted: ", i);
      else if (e === "focus" || e.includes("move"))
        o = cu(r.model, t) + (r.model.selectionIsCollapsed ? "" : "selected: ") + uu(r.model);
      else if (e === "replacement")
        o = Kr("", r.model.at(r.model.position));
      else if (e === "line") {
        let a = Kr("", r.model.root);
        r.keyboardDelegate.setAriaLabel(a);
      } else
        o = i ? Kr(e + " ", i) : e;
      if (o) {
        let a = r.ariaLiveText.textContent.includes(" ") ? "   " : "   ";
        r.ariaLiveText.textContent = o + a;
      }
    }
    function cu(r, e) {
      if (Number.isNaN(e))
        return "";
      let t = r.at(e);
      if (!t || t.treeDepth <= r.at(r.position).treeDepth)
        return "";
      let i = "", o = t.parent, a = r.at(r.position).parent;
      for (; o !== r.root && o !== a; )
        i += `out of ${Bs(o)};`, o = o.parent;
      return i;
    }
    function uu(r) {
      if (!r.selectionIsCollapsed)
        return Kr("", r.getAtoms(r.selection));
      let e = "", t = r.at(r.position), i = Bs(t);
      return t.isFirstSibling && (e = (i ? "start of " + i : "unknown") + ": "), t.isLastSibling ? t.isFirstSibling || (e += i ? "end of " + i : "unknown") : e += Kr("", t), e;
    }
    var Ni = class {
      constructor(e, t, i) {
        this.options = e, this._selection = { ranges: [[0, 0]], direction: "none" }, this._anchor = 0, this._position = 0, this.mathfield = i, this.suppressChangeNotifications = false, this.root = new g("root", i, { mode: e.mode }), this.root.body = [], this.setListeners(t);
      }
      get atoms() {
        return this.root.children;
      }
      get selection() {
        return this._selection;
      }
      set selection(e) {
        this.setSelection(e);
      }
      setSelection(e, t) {
        return !this.mathfield.contentEditable && this.mathfield.userSelect === "none" ? false : this.deferNotifications({ selection: true }, () => {
          var l, c, u;
          let i = this.normalizeSelection(e, t);
          if (i === void 0)
            throw new TypeError("Invalid selection");
          if (i.ranges.length === 1 && i.ranges[0][0] === i.ranges[0][1]) {
            let d = i.ranges[0][0];
            return !this.mathfield.dirty && !((l = this.at(d)) != null && l.parentPrompt) && this.mathfield.hasEditablePrompts ? (c = this.at(d - 1)) != null && c.parentPrompt ? (this._anchor = this.normalizeOffset(d - 1), this._position = this._anchor, this._selection = this.normalizeSelection(this._anchor), true) : (u = this.at(d + 1)) != null && u.parentPrompt ? (this._anchor = this.normalizeOffset(d + 1), this._position = this._anchor, this._selection = this.normalizeSelection(this._anchor), true) : (this._anchor = 0, this._position = 0, this._selection = { ranges: [[0, 0]] }, false) : (this._anchor = d, this._position = d, this._selection = i, false);
          }
          let o = xe(i);
          i.direction === "backward" ? [this._position, this._anchor] = o : [this._anchor, this._position] = o;
          let a = this.at(o[0] + 1), n = this.at(o[1]), s = g.commonAncestor(a, n);
          return (s == null ? void 0 : s.type) === "array" && a.parent === s && n.parent === s ? this._selection = { ranges: [o], direction: i.direction } : this._selection = { ranges: [o], direction: i.direction }, this._position >= 0 && this._position <= this.lastOffset, false;
        });
      }
      setPositionHandlingPlaceholder(e) {
        var t, i, o;
        ((t = this.at(e)) == null ? void 0 : t.type) === "placeholder" ? this.setSelection(e - 1, e) : ((o = (i = this.at(e)) == null ? void 0 : i.rightSibling) == null ? void 0 : o.type) === "placeholder" ? this.setSelection(e, e + 1) : this.position = e;
      }
      getState() {
        return { content: this.root.toJson(), selection: this.selection };
      }
      setState(e, t) {
        var a;
        let i = this.suppressChangeNotifications;
        this.suppressChangeNotifications = (a = t == null ? void 0 : t.suppressChangeNotifications) != null ? a : true;
        let o = {};
        (t == null ? void 0 : t.type) === "undo" && (o = { inputType: "historyUndo" }), (t == null ? void 0 : t.type) === "redo" && (o = { inputType: "historyRedo" }), H(this, o) && (this.root = Ue(e.content, this.mathfield), this.selection = e.selection, J(this, o)), this.suppressChangeNotifications = i;
      }
      get position() {
        return this._position;
      }
      set position(e) {
        this.setSelection(e, e);
      }
      get anchor() {
        return this._anchor;
      }
      get selectionIsCollapsed() {
        return this._anchor === this._position;
      }
      get selectionIsPlaceholder() {
        return Math.abs(this._anchor - this._position) === 1 ? this.at(Math.max(this._anchor, this._position)).type === "placeholder" : false;
      }
      collapseSelection(e = "forward") {
        return this._anchor === this._position ? false : (e === "backward" ? this.position = Math.min(this._anchor, this._position) : this.position = Math.max(this._anchor, this._position), true);
      }
      get lastOffset() {
        return this.atoms.length - 1;
      }
      at(e) {
        return this.atoms[e];
      }
      offsetOf(e) {
        return this.atoms.indexOf(e);
      }
      getSiblingsRange(e) {
        let t = this.at(e), { parent: i } = t;
        if (!i)
          return [0, this.lastOffset];
        let o = t.parent.branch(t.treeBranch);
        return [this.offsetOf(o[0]), this.offsetOf(o[o.length - 1])];
      }
      getBranchRange(e, t) {
        let i = this.at(e).branch(t);
        return [this.offsetOf(i[0]), this.offsetOf(i[i.length - 1])];
      }
      getAtoms(e, t, i) {
        let o = i != null ? i : {};
        if (Xr(e)) {
          if (o = t != null ? t : {}, e.ranges.length > 1)
            return e.ranges.reduce((u, d) => [...u, ...this.getAtoms(d, o)], []);
          e = e.ranges[0];
        }
        let a, n;
        if (Pt(e)) {
          if (a = e, !Pt(t))
            return [];
          n = t;
        } else
          [a, n] = e, o = t != null ? t : {};
        if (!Number.isFinite(a))
          return [];
        o.includeChildren === void 0 && (o.includeChildren = false), a < 0 && (a = this.lastOffset - a + 1), n < 0 && (n = this.lastOffset - n + 1);
        let s = Math.min(a, n) + 1, l = Math.max(a, n);
        if (s === 1 && l === this.lastOffset)
          return [this.root];
        let c = [];
        for (let u = s; u <= l; u++) {
          let d = this.atoms[u];
          zs(this, d, s, l) && c.push(d);
        }
        return o.includeChildren || (c = c.filter((u) => {
          let d = false, { parent: m } = u;
          for (; m && !d; )
            d = zs(this, m, s, l), m = m.parent;
          return !d;
        })), c;
      }
      getAllAtoms(e = 0) {
        let t = [], i = this.lastOffset;
        for (let o = e; o <= i; o++)
          t.push(this.atoms[o]);
        for (let o = 0; o < e; o++)
          t.push(this.atoms[o]);
        return t;
      }
      findAtom(e, t = 0, i = "forward") {
        if (i === "forward") {
          let o = this.lastOffset;
          for (let a = t; a <= o; a++)
            if (e(this.atoms[a]))
              return this.atoms[a];
          for (let a = 0; a < t; a++)
            if (e(this.atoms[a]))
              return this.atoms[a];
          return;
        }
        for (let o = t; o >= 0; o--)
          if (e(this.atoms[o]))
            return this.atoms[o];
        for (let o = this.lastOffset; o < t; o--)
          if (e(this.atoms[o]))
            return this.atoms[o];
      }
      extractAtoms(e) {
        let t = this.getAtoms(e);
        t.length === 1 && t[0].type === "root" && (t = t[0].children);
        for (let i of t)
          i.parent.removeChild(i);
        return t;
      }
      deleteAtoms(e) {
        this.extractAtoms(e), this.position = e[0];
      }
      atomToString(e, t) {
        let i = t != null ? t : "latex";
        if (i.startsWith("latex"))
          return Te.serialize([e], { expandMacro: i === "latex-expanded", skipStyles: i === "latex-unstyled", defaultMode: this.mathfield.options.defaultMode });
        if (i === "math-ml")
          return V(e);
        if (i === "spoken")
          return $t(e);
        if (i === "spoken-text") {
          let o = window.MathfieldElement.textToSpeechMarkup;
          window.MathfieldElement.textToSpeechMarkup = "";
          let a = $t(e);
          return window.MathfieldElement.textToSpeechMarkup = o, a;
        }
        if (i === "spoken-ssml" || i === "spoken-ssml-with-highlighting") {
          let o = window.MathfieldElement.textToSpeechMarkup;
          window.MathfieldElement.textToSpeechMarkup = "ssml";
          let a = $t(e);
          return window.MathfieldElement.textToSpeechMarkup = o, a;
        }
        if (i === "math-json") {
          if (!window.MathfieldElement.computeEngine)
            return window[Symbol.for("io.cortexjs.compute-engine")] || console.error(`The CortexJS Compute Engine library is not available.
Load the library, for example with:
import "https://unpkg.com/@cortex-js/compute-engine?module"`), '["Error", "compute-engine-not-available"]';
          try {
            let o = window.MathfieldElement.computeEngine.parse(g.serialize(e, { expandMacro: false, defaultMode: "math" }));
            return JSON.stringify(o.json);
          } catch (o) {
            return JSON.stringify(["Error", `'${o.toString()}'`]);
          }
        }
        return i === "ascii-math" ? ue(e) : (console.error(`MathLive 0.90.9: Unknown format "${i}`), "");
      }
      getValue(e, t, i) {
        if (e === void 0)
          return this.atomToString(this.root, "latex");
        if (typeof e == "string")
          return this.atomToString(this.root, e);
        let o, a;
        if (Pt(e) && Pt(t) ? (o = [this.normalizeRange([e, t])], a = i != null ? i : "latex") : Mr(e) ? (o = [this.normalizeRange(e)], a = t) : Xr(e) ? (o = e.ranges, a = t) : (o = [], a = "latex"), a.startsWith("latex")) {
          let n = { expandMacro: a === "latex-expanded", skipStyles: a === "latex-unstyled", defaultMode: this.mathfield.options.defaultMode };
          return j(o.map((s) => g.serialize(this.getAtoms(s), n)));
        }
        return o.map((n) => this.getAtoms(n).map((s) => this.atomToString(s, a)).join("")).join("");
      }
      extendSelection(e) {
        let t = this._anchor;
        if (e === "forward") {
          let o = this._position;
          do {
            let a = this.at(o + 1);
            if (a != null && a.inCaptureSelection) {
              for (; !a.captureSelection; )
                a = a.parent;
              o = this.offsetOf(a == null ? void 0 : a.lastChild) + 1;
            } else
              o += 1;
          } while (o <= this.lastOffset && this.at(o).isFirstSibling);
          return o === t - 1 && this.at(t).type === "first" && (o = t), this.extendSelectionTo(t, o);
        }
        let i = this._position - 1;
        if (i < 0)
          return false;
        for (; i >= 0 && this.at(i).isLastSibling; ) {
          let o = this.at(i);
          if (o != null && o.inCaptureSelection) {
            for (; !o.captureSelection; )
              o = o.parent;
            i = this.offsetOf(o.firstChild) - 1;
          } else
            i -= 1;
        }
        return i < 0 && (i = 0), i === t + 1 && this.at(i).type === "first" && (t = i), this.extendSelectionTo(t, i);
      }
      extendSelectionTo(e, t) {
        return !this.mathfield.contentEditable && this.mathfield.userSelect === "none" ? false : this.deferNotifications({ selection: true }, () => {
          let i = this.normalizeRange([e, t]), [o, a] = i, { parent: n } = this.at(a);
          if (n && (n.type === "genfrac" || n.type === "msubsup"))
            for (; n !== this.root && Fa(this, n, [o, a]); )
              a = this.offsetOf(n), n = n.parent;
          for (n = this.at(o).parent; n !== this.root && Fa(this, n, [o, a]); )
            o = this.offsetOf(n.leftSibling), n = n.parent;
          if (n = this.at(a).parent, (n == null ? void 0 : n.type) === "genfrac")
            for (; n !== this.root && Fa(this, n, [o, a]); )
              a = this.offsetOf(n), n = n.parent;
          this._position = this.normalizeOffset(t), this._selection = { ranges: [[o, a]], direction: "none" };
        });
      }
      setListeners(e) {
        this.listeners = e;
      }
      announce(e, t, i = []) {
        var a, n;
        ((n = (a = this.mathfield.host) == null ? void 0 : a.dispatchEvent(new CustomEvent("announce", { detail: { command: e, previousPosition: t, atoms: i }, cancelable: true, bubbles: true, composed: true }))) != null ? n : true) && Os(this.mathfield, e, t, i);
      }
      deferNotifications(e, t) {
        let i = this._selection, o = this._anchor, a = this._position, n = this.suppressChangeNotifications;
        this.suppressChangeNotifications = true;
        let s = this.root.changeCounter;
        t();
        let l = this.root.changeCounter !== s, c = o !== this._anchor || a !== this._position || Qn(this._selection, i) === "different";
        return this.suppressChangeNotifications = n, e.content && l && J(this, { inputType: e.type }), e.selection && c && Co(this), l || c;
      }
      normalizeOffset(e) {
        return e > 0 ? e = Math.min(e, this.lastOffset) : e < 0 && (e = this.lastOffset + e + 1), e;
      }
      normalizeRange(e) {
        let [t, i] = e;
        return t = this.normalizeOffset(t), i = this.normalizeOffset(i), t < i ? [t, i] : [i, t];
      }
      normalizeSelection(e, t) {
        var o;
        let i;
        if (Pt(e)) {
          let a = this.normalizeOffset(e);
          if (Pt(t)) {
            let n = this.normalizeOffset(t);
            i = a <= n ? { ranges: [[a, n]], direction: "none" } : { ranges: [[n, a]], direction: "backward" };
          } else
            i = { ranges: [[a, a]], direction: "none" };
        } else if (Mr(e)) {
          let a = this.normalizeOffset(e[0]), n = this.normalizeOffset(e[1]);
          i = a <= n ? { ranges: [[a, n]], direction: "none" } : { ranges: [[n, a]], direction: "backward" };
        } else
          Xr(e) && (i = { ranges: e.ranges.map((a) => this.normalizeRange(a)), direction: (o = e.direction) != null ? o : "none" });
        return i;
      }
    };
    function zs(r, e, t, i) {
      let o = r.offsetOf(e);
      if (o < t || o > i)
        return false;
      if (!e.hasChildren)
        return true;
      let a = r.offsetOf(e.firstChild);
      if (a >= t && a <= i) {
        let n = r.offsetOf(e.lastChild);
        if (n >= t && n <= i)
          return true;
      }
      return false;
    }
    function Fa(r, e, t) {
      if (!(e != null && e.hasChildren))
        return false;
      let [i, o] = t, a = r.offsetOf(e.firstChild), n = r.offsetOf(e.lastChild);
      return a >= i && a <= o && n >= a && n <= o;
    }
    function Eo(r, e) {
      let t = r.at(r.position);
      for (; t && !(Array.isArray(t.treeBranch) && t.parent instanceof X); )
        t = t.parent;
      if (Array.isArray(t == null ? void 0 : t.treeBranch) && (t == null ? void 0 : t.parent) instanceof X) {
        let i = t.parent, o;
        switch (e) {
          case "after row":
            i.addRowAfter(t.treeBranch[0]), o = r.offsetOf(i.getCell(t.treeBranch[0] + 1, 0)[0]);
            break;
          case "after column":
            if (i.maxColumns <= i.colCount) {
              r.announce("plonk");
              return;
            }
            i.addColumnAfter(t.treeBranch[1]), o = r.offsetOf(i.getCell(t.treeBranch[0], t.treeBranch[1] + 1)[0]);
            break;
          case "before row":
            i.addRowBefore(t.treeBranch[0]), o = r.offsetOf(i.getCell(t.treeBranch[0] - 1, 0)[0]);
            break;
          case "before column":
            if (i.maxColumns <= i.colCount) {
              r.announce("plonk");
              return;
            }
            i.addColumnBefore(t.treeBranch[1]), o = r.offsetOf(i.getCell(t.treeBranch[0], t.treeBranch[1] - 1)[0]);
            break;
        }
        r.setSelection(o, o + 1);
      }
    }
    function Na(r) {
      return H(r, { inputType: "insertText" }) ? (Eo(r, "after row"), J(r, { inputType: "insertText" }), true) : false;
    }
    function du(r) {
      return H(r, { inputType: "insertText" }) ? (Eo(r, "before row"), J(r, { inputType: "insertText" }), true) : false;
    }
    function Ia(r) {
      return H(r, { inputType: "insertText" }) ? (Eo(r, "after column"), J(r, { inputType: "insertText" }), true) : false;
    }
    function mu(r) {
      return H(r, { inputType: "insertText" }) ? (Eo(r, "before column"), J(r, { inputType: "insertText" }), true) : false;
    }
    function Rs(r, e) {
      let t = r.at(r.position);
      for (; t && !(Array.isArray(t.treeBranch) && t.parent instanceof X); )
        t = t.parent;
      if (Array.isArray(t == null ? void 0 : t.treeBranch) && (t == null ? void 0 : t.parent) instanceof X) {
        let i = t.parent, o = t.treeBranch, a;
        switch (e) {
          case "row":
            if (i.rowCount > 1) {
              i.removeRow(o[0]);
              let n = i.getCell(Math.max(0, o[0] - 1), o[1]);
              a = r.offsetOf(n[n.length - 1]);
            }
            break;
          case "column":
            if (i.colCount > i.minColumns) {
              i.removeColumn(o[1]);
              let n = i.getCell(o[0], Math.max(0, o[1] - 1));
              a = r.offsetOf(n[n.length - 1]);
            }
            break;
        }
        a && r.setPositionHandlingPlaceholder(a);
      }
    }
    function pu(r) {
      return H(r, { inputType: "deleteContent" }) ? (Rs(r, "row"), J(r, { inputType: "deleteContent" }), true) : false;
    }
    function hu(r) {
      return H(r, { inputType: "deleteContent" }) ? (Rs(r, "column"), J(r, { inputType: "deleteContent" }), true) : false;
    }
    he({ addRowAfter: Na, addColumnAfter: Ia, addRowBefore: du, addColumnBefore: mu, removeRow: pu, removeColumn: hu }, { target: "model", category: "array-edit" });
    function Ii(r, e, t, i) {
      var a, n, s, l, c, u;
      let o = t.parent;
      if (o && t instanceof oe) {
        let d = !i && e === "forward" || i === "body" && e === "backward", m = d ? r.offsetOf(t.firstChild) : r.offsetOf(t.lastChild);
        return d ? t.rightDelim !== "?" && t.rightDelim !== "." ? (t.leftDelim = ".", t.isDirty = true) : (o.addChildrenAfter(t.removeBranch("body"), t), o.removeChild(t), m--) : t.leftDelim !== "?" && t.leftDelim !== "." ? (t.rightDelim = ".", t.isDirty = true) : (o.addChildrenAfter(t.removeBranch("body"), t), o.removeChild(t), m--), r.position = m, true;
      }
      if (o && t.type === "surd") {
        if (e === "forward" && !i || e === "backward" && i === "body") {
          let d = t.leftSibling;
          t.hasChildren && o.addChildrenAfter(t.removeBranch("body"), t), o.removeChild(t), r.position = r.offsetOf(d);
        } else
          e === "forward" && i === "body" ? r.position = r.offsetOf(t) : !i && e === "backward" ? t.hasChildren ? r.position = r.offsetOf(t.lastChild) : (r.position = Math.max(0, r.offsetOf(t) - 1), o.removeChild(t)) : i === "above" && (t.hasEmptyBranch("above") && t.removeBranch("above"), e === "backward" ? r.position = r.offsetOf(t.leftSibling) : r.position = r.offsetOf(t.body[0]));
        return true;
      }
      if (o && (t.type === "box" || t.type === "enclose")) {
        let d = i && e === "backward" || !i && e === "forward" ? t.leftSibling : t.lastChild;
        return o.addChildrenAfter(t.removeBranch("body"), t), o.removeChild(t), r.position = r.offsetOf(d), true;
      }
      if (t.type === "genfrac" || t.type === "overunder") {
        if (!i)
          return t.type === "overunder" && t.hasEmptyBranch("body") || t.type === "genfrac" && t.hasEmptyBranch("below") && t.hasEmptyBranch("above") ? false : (r.position = r.offsetOf(e === "forward" ? t.firstChild : t.lastChild), true);
        let d = t.context.fractionNavigationOrder === "numerator-denominator" ? "above" : "below", m = d === "above" ? "below" : "above";
        if (o && (e === "forward" && i === d || e === "backward" && i === m)) {
          let h = t.removeBranch(d), f = t.removeBranch(m);
          return o.addChildrenAfter([...h, ...f], t), o.removeChild(t), r.position = r.offsetOf(h.length > 0 ? h[h.length - 1] : f[0]), true;
        }
        return e === "backward" ? r.position = r.offsetOf(t.leftSibling) : r.position = r.offsetOf(t), true;
      }
      if (t.isExtensibleSymbol || t.type === "msubsup") {
        if (!i && e === "forward")
          return false;
        if (!i) {
          if (t.subscript || t.superscript) {
            let d = e === "forward" ? (s = (a = t.superscript) == null ? void 0 : a[0]) != null ? s : (n = t.subscript) == null ? void 0 : n[0] : (u = (l = t.subscript) == null ? void 0 : l[0].lastSibling) != null ? u : (c = t.superscript) == null ? void 0 : c[0].lastSibling;
            return d && (r.position = r.offsetOf(d)), true;
          }
          return false;
        }
        if (i && t.hasEmptyBranch(i) && t.removeBranch(i), !t.hasChildren) {
          let d = e === "forward" ? r.offsetOf(t) : Math.max(0, r.offsetOf(t) - 1);
          return t.parent.removeChild(t), r.position = d, true;
        }
        if (i === "superscript")
          if (e === "backward") {
            let d = r.offsetOf(t.firstChild) - 1;
            r.position = d;
          } else
            t.subscript ? r.position = r.offsetOf(t.subscript[0]) : r.position = r.offsetOf(t);
        else
          i === "subscript" && (e === "backward" && t.superscript ? r.position = r.offsetOf(t.superscript[0].lastSibling) : e === "backward" ? r.position = r.offsetOf(t.firstChild) - 1 : r.position = r.offsetOf(t));
        return true;
      }
      if ((o == null ? void 0 : o.type) === "genfrac" && !i && t.type !== "first") {
        let d = r.offsetOf(t.leftSibling);
        return o.removeChild(t), o.hasEmptyBranch("above") && o.hasEmptyBranch("below") ? (d = r.offsetOf(o.leftSibling), o.parent.removeChild(o), r.announce("delete", void 0, [o]), r.position = d, true) : (r.announce("delete", void 0, [t]), r.position = d, true);
      }
      return false;
    }
    function Fs(r) {
      return !r.mathfield.isSelectionEditable || !H(r, { inputType: "deleteContentBackward" }) ? false : r.selectionIsCollapsed ? r.deferNotifications({ content: true, selection: true, type: "deleteContentBackward" }, () => {
        let e = r.at(r.position);
        if (!(e && Ii(r, "backward", e))) {
          if (e != null && e.isFirstSibling) {
            if (Ii(r, "backward", e.parent, e.treeBranch))
              return;
            e = null;
          }
          if (!e) {
            r.announce("plonk");
            return;
          }
          r.position = r.offsetOf(e.leftSibling), e.parent.removeChild(e), r.announce("delete", void 0, [e]);
        }
      }) : mt(r, xe(r.selection), "deleteContentBackward");
    }
    function Ns(r) {
      return !r.mathfield.isSelectionEditable || !H(r, { inputType: "deleteContentForward" }) ? false : r.selectionIsCollapsed ? r.deferNotifications({ content: true, selection: true, type: "deleteContentForward" }, () => {
        var i, o;
        let e = r.at(r.position).rightSibling;
        if (e && Ii(r, "forward", e))
          return;
        if (e) {
          if (r.at(r.position).isLastSibling && Ii(r, "forward", e.parent, e.treeBranch))
            return;
        } else {
          if (e = r.at(r.position), e.isLastSibling && Ii(r, "forward", e.parent, e.treeBranch))
            return;
          e = void 0;
        }
        if (r.position === r.lastOffset || !e) {
          r.announce("plonk");
          return;
        }
        e.parent.removeChild(e);
        let t = (i = r.at(r.position)) == null ? void 0 : i.rightSibling;
        for (; (t == null ? void 0 : t.type) === "msubsup"; )
          t.parent.removeChild(t), t = (o = r.at(r.position)) == null ? void 0 : o.rightSibling;
        r.announce("delete", void 0, [e]);
      }) : mt(r, xe(r.selection), "deleteContentForward");
    }
    function mt(r, e, t) {
      let i = r.getAtoms(e);
      if (i.length > 0 && i[0].parent) {
        let o = i[0].parent.firstChild;
        o.type === "first" && (o = o.rightSibling);
        let a = i[i.length - 1].parent.lastChild, n = i[0];
        n.type === "first" && (n = n.rightSibling);
        let s = i[i.length - 1];
        if (n === o && s === a) {
          let l = i[0].parent;
          l.type !== "root" && l.type !== "prompt" && (e = [r.offsetOf(l.leftSibling), r.offsetOf(l.rightSibling)]);
        }
        if (i.length === 1 && i[0].type === "placeholder" && i[0].parent.type === "genfrac") {
          let l = i[0].parent, c = i[0].treeBranch === "below" ? "above" : "below", u = r.offsetOf(l.leftSibling);
          return r.deferNotifications({ content: true, selection: true, type: t }, () => {
            var m, h;
            let d = l.removeBranch(c);
            if (d.length === 1 && d[0].type === "placeholder")
              (h = l.parent) == null || h.removeChild(l), r.position = Math.max(0, u);
            else {
              let f = l.parent.addChildrenAfter(d, l);
              (m = l.parent) == null || m.removeChild(l), r.position = r.offsetOf(f);
            }
          });
        }
      }
      return r.deferNotifications({ content: true, selection: true, type: t }, () => r.deleteAtoms(e));
    }
    function Is(r, e) {
      let t = r.at(r.position);
      if (t.type === "composition")
        t.value = e;
      else {
        let { caret: i } = t;
        t.caret = "";
        let o = new lr(e, r.mathfield, { mode: t.mode });
        o.caret = i, t.parent.addChildAfter(o, t), r.position += 1;
      }
    }
    function $s(r) {
      let e = r.at(r.position);
      e.type === "composition" && (e.parent.removeChild(e), r.position -= 1);
    }
    function Po(r, e) {
      let t = r.at(e), i;
      if (t) {
        i = t.mode;
        let o = t.parent;
        for (; !i && o; )
          o && (i = o.mode), o = o.parent;
      }
      return i;
    }
    function Bt(r, e) {
      !r || !e || (Y(r) ? r.forEach((t) => Bt(t, e)) : typeof r == "object" && !r.style.color && !r.style.backgroundColor && !r.style.fontFamily && !r.style.fontShape && !r.style.fontSeries && !r.style.fontSize && !r.style.variant && !r.style.variantStyle && (r.applyStyle(e), Bt(r.body, e), Bt(r.above, e), Bt(r.below, e), Bt(r.subscript, e), Bt(r.superscript, e)));
    }
    function $i(r, e, t, i) {
      function o(n, s) {
        for (let l of a)
          if (l.style[n] !== s)
            return false;
        return true;
      }
      if (e = r.normalizeRange(e), e[0] === e[1])
        return false;
      let a = r.getAtoms(e, { includeChildren: true });
      i.operation === "toggle" && (t.color && o("color", t.color) && (t.color = "none", t.verbatimColor = void 0), t.backgroundColor && o("backgroundColor", t.backgroundColor) && (t.backgroundColor = "none", t.verbatimBackgroundColor = void 0), t.fontFamily && o("fontFamily", t.fontFamily) && (t.fontFamily = "none"), t.fontSeries && o("fontSeries", t.fontSeries) && (t.fontSeries = "auto"), t.fontShape && o("fontShape", t.fontShape) && (t.fontShape = "auto"), t.fontSize && o("fontSize", t.fontSize) && (t.fontSize = nt));
      for (let n of a)
        n.applyStyle(t);
      return true;
    }
    var $a = `@keyframes ML__caret-blink {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0;
  }
}
.ML__caret:after {
  content: '';
  border: none;
  border-radius: 2px;
  border-right: 2px solid var(--caret-color, var(--ML__caret-color));
  margin-right: -2px;
  position: relative;
  left: -1px;
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__text-caret:after {
  content: '';
  border: none;
  border-radius: 1px;
  border-right: 1px solid var(--caret-color, var(--ML__caret-color));
  margin-right: -1px;
  position: relative;
  left: 0;
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__latex-caret:after {
  content: '_';
  border: none;
  margin-right: 0;
  margin-right: calc(-1ex - 2px);
  position: relative;
  color: var(--caret-color, var(--ML__caret-color));
  animation: ML__caret-blink 1.05s step-end forwards infinite;
}
.ML__container {
  display: inline-flex;
  flex-flow: row;
  justify-content: space-between;
  align-items: flex-end;
  min-height: 39px;
  /* Need some room for the virtual keyboard toggle */
  width: 100%;
  /* Encourage browsers to consider allocating a hardware accelerated
   layer for this element. */
  isolation: isolate;
  /* Prevent the browser from trying to interpret touch gestures in the field */
  /* "Disabling double-tap to zoom removes the need for browsers to
        delay the generation of click events when the user taps the screen." */
  touch-action: none;
  --ML__selection-background-color: hsl(var(--hue, 212), 97%, 85%);
  --ML__text-highlight-background-color: hsla(var(--hue, 212), 40%, 50%, 0.1);
  --ML__contains-highlight-background-color: hsl(var(--hue, 212), 40%, 95%);
  --ML__selection-color: currentColor;
  --ML__caret-color: hsl(var(--hue, 212), 40%, 49%);
  --ML__smart-fence-color: currentColor;
  --ML__latex-color: var(--primary, hsl(var(--hue, 212), 40%, 50%));
  --ML__correct-color: #10a000;
  --ML__incorrect-color: #a01b00;
  --ML__placeholder-color: hsl(var(--hue, 212), 40%, 49%);
}
/* This is the actual field content (formula) */
.ML__content {
  display: flex;
  align-items: center;
  align-self: center;
  position: relative;
  overflow: hidden;
  padding: 2px 0 2px 1px;
  width: 100%;
}
.ML__virtual-keyboard-toggle {
  box-sizing: border-box;
  display: flex;
  align-self: center;
  align-items: center;
  flex-shrink: 0;
  flex-direction: column;
  justify-content: center;
  width: 34px;
  height: 34px;
  padding: 0;
  margin-right: 4px;
  cursor: pointer;
  /* Avoid some weird blinking with :hover */
  border-radius: 8px;
  border: 1px solid transparent;
  transition: background 0.2s cubic-bezier(0.64, 0.09, 0.08, 1);
  color: var(--primary, hsl(var(--hue, 212), 40%, 50%));
  fill: currentColor;
  background: transparent;
}
.ML__virtual-keyboard-toggle:hover {
  background: hsla(0, 0%, 70%, 0.3);
  color: #333;
  fill: currentColor;
}
.ML__virtual-keyboard-toggle > span {
  display: flex;
  align-self: center;
  align-items: center;
}
/* The invisible element used to capture keyboard events. We're just trying
 really hard to make sure it doesn't show. */
.ML__keyboard-sink {
  display: inline-block;
  resize: none;
  outline: none;
  border: none;
  /* Need these for Microsoft Edge */
  position: fixed;
  clip: rect(0 0 0 0);
  /* Need this to prevent iOS Safari from auto-zooming */
  font-size: 1em;
  font-family: KaTeX_Main;
}
.ML__focused .ML__text {
  background: var(--highlight-text, var(--ML__text-highlight-background-color));
}
/* When using smartFence, the anticipated closing fence is displayed
with this style */
.ML__smart-fence__close {
  opacity: var(--smart-fence-opacity, 0.5);
  color: var(--smart-fence-color, var(--ML__smart-fence-color));
}
.ML__focused .ML__selection {
  background: var(--selection-background-color-focused, var(--selection-background-color, var(--ML__selection-background-color))) !important;
}
.ML__focused .ML__selected,
.ML__focused .ML__selected .ML__contains-caret,
.ML__focused .ML__selected .ML__smart-fence__close,
.ML__focused .ML__selected .ML__placeholder {
  color: var(--selection-color-focused, var(--selection-color, var(--ML__selection-color))) !important;
}
.ML__selection {
  box-sizing: border-box;
  background: var(--selection-background-color, var(--ML__selection-background-color)) !important;
}
.ML__selected,
.ML__selected .ML__contains-caret,
.ML__selected .ML__smart-fence__close,
.ML__selected .ML__placeholder {
  color: var(--selection-color, var(--ML__selection-color));
  opacity: 1;
}
.ML__contains-caret.ML__close,
.ML__contains-caret.ML__open,
.ML__contains-caret > .ML__close,
.ML__contains-caret > .ML__open,
.ML__contains-caret .ML__sqrt-sign,
.ML__contains-caret .ML__sqrt-line {
  color: var(--caret-color, var(--ML__caret-color));
}
.ML__contains-highlight {
  background: var(--contains-highlight-backround-color, var(--ML__contains-highlight));
  box-sizing: border-box;
}
.ML__latex {
  font-family: 'IBM Plex Mono', 'Source Code Pro', Consolas, 'Roboto Mono', Menlo, 'Bitstream Vera Sans Mono', 'DejaVu Sans Mono', Monaco, Courier, monospace;
  font-weight: 400;
  color: var(--latex-color, var(--ML__latex-color));
}
.ML__suggestion {
  opacity: 0.5;
}
.ML__virtual-keyboard-toggle.is-visible.is-pressed:hover {
  background: hsl(var(--hue, 212), 25%, 35%);
  color: #fafafa;
  fill: currentColor;
}
.ML__virtual-keyboard-toggle:focus {
  outline: none;
  border-radius: 8px;
  border: 2px solid var(--primary, hsl(var(--hue, 212), 40%, 50%));
}
.ML__virtual-keyboard-toggle.is-pressed,
.ML__virtual-keyboard-toggle.is-active:hover,
.ML__virtual-keyboard-toggle.is-active {
  background: hsl(var(--hue, 212), 25%, 35%);
  color: #fafafa;
  fill: currentColor;
}
/* This class is used to implement the \`\\mathtip\` and \`\\texttip\` commands
   For UI elements, see \`[data-ML__tooltip]\`
*/
.ML__tooltip-container {
  position: relative;
  transform: scale(0);
}
.ML__tooltip-container .ML__tooltip-content {
  position: fixed;
  display: inline-table;
  visibility: hidden;
  z-index: 2;
  width: max-content;
  max-width: 400px;
  padding: 12px 12px;
  border-radius: 8px;
  background: #616161;
  color: #fff;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  opacity: 0;
  transition: opacity 0.15s cubic-bezier(0.4, 0, 1, 1);
}
.ML__tooltip-container .ML__tooltip-content .ML__text {
  white-space: normal;
}
.ML__tooltip-container .ML__tooltip-content .ML__base {
  display: contents;
}
.ML__tooltip-container:hover .ML__tooltip-content {
  visibility: visible;
  opacity: 1;
  font-size: 0.75em;
  transform: scale(1) translate(0, 3em);
}
/* Add an attribute 'data-ML__tooltip' to automatically show a
   tooltip over a element on hover.
   Use 'data-position="top"' to place the tooltip above the
   element rather than below.
   Use 'data-delay' to delay the triggering of the tooltip.
*/
[data-ML__tooltip] {
  position: relative;
}
[data-ML__tooltip][data-placement='top']::after {
  top: inherit;
  bottom: 100%;
}
[data-ML__tooltip]::after {
  content: attr(data-ML__tooltip);
  position: absolute;
  display: none;
  z-index: 2;
  right: 110%;
  left: calc(100% + 8px);
  width: max-content;
  max-width: 200px;
  padding: 8px 8px;
  border-radius: 2px;
  background: #616161;
  color: #fff;
  box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
  text-align: center;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-weight: 400;
  font-size: 12px;
  /* Phone */
  opacity: 0;
  transform: scale(0.5);
  transition: all 0.15s cubic-bezier(0.4, 0, 1, 1);
}
@media only screen and (max-width: 767px) {
  [data-ML__tooltip]::after {
    padding: 8px 16px;
    font-size: 16px;
  }
}
:not(.tracking) [data-ML__tooltip]:hover {
  position: relative;
}
:not(.tracking) [data-ML__tooltip]:hover::after {
  visibility: visible;
  display: inline-table;
  opacity: 1;
  transform: scale(1);
}
[data-ML__tooltip][data-delay]::after {
  transition-delay: 0s;
}
[data-ML__tooltip][data-delay]:hover::after {
  transition-delay: 1s;
  /* attr(data-delay); Should work. But doesn't. */
}
`;
    var gu = /* @__PURE__ */ new Set(["Backquote", "Digit0", "Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9", "Minus", "Equal", "IntlYen", "KeyQ", "KeyW", "KeyE", "KeyR", "KeyT", "KeyY", "KeyU", "KeyI", "KeyO", "KeyP", "BracketLeft", "BracketRight", "Backslash", "KeyA", "KeyS", "KeyD", "KeyF", "KeyG", "KeyH", "KeyJ", "KeyK", "KeyL", "Semicolon", "Quote", "IntlBackslash", "KeyZ", "KeyX", "KeyC", "KeyV", "KeyB", "KeyN", "KeyM", "Comma", "Period", "Slash", "IntlRo", "Space", "Numpad0", "Numpad1", "Numpad2", "Numpad3", "Numpad4", "Numpad5", "Numpad6", "Numpad7", "Numpad8", "Numpad9", "NumpadAdd", "NumpadComma", "NumpadDecimal", "NumpadDivide", "NumpadEqual", "NumpadHash", "NumpadMultiply", "NumpadParenLeft", "NumpadParenRight", "NumpadStar", "NumpadSubstract"]);
    function Ko(r) {
      return r.ctrlKey || r.metaKey || ["Dead", "Process"].includes(r.key) ? false : r.code === "" ? true : gu.has(r.code);
    }
    function qs(r) {
      r = ds(r);
      let e = [];
      return r.ctrlKey && e.push("ctrl"), r.metaKey && e.push("meta"), r.altKey && e.push("alt"), r.shiftKey && e.push("shift"), e.length === 0 ? "[" + r.code + "]" : (e.push("[" + r.code + "]"), e.join("+"));
    }
    function Vs(r, e, t) {
      let i = null, o = null, a = false, n = false, s = false;
      return r.addEventListener("keydown", (l) => {
        if (a || l.key === "Process" || l.code === "CapsLock" || /(Control|Meta|Alt|Shift)(Left|Right)/.test(l.code)) {
          i = null;
          return;
        }
        i = l, o = null, t.onKeystroke(qs(l), l) ? r.textContent = "" : i = null;
      }, true), r.addEventListener("keypress", (l) => {
        a || (i && o && t.onKeystroke(qs(i), i), o = l);
      }, true), r.addEventListener("compositionstart", (l) => {
        r.textContent = "", a = true, t.onCompositionStart(l.data);
      }, true), r.addEventListener("compositionupdate", (l) => {
        a && t.onCompositionUpdate(l.data);
      }, true), r.addEventListener("compositionend", (l) => {
        r.textContent = "", a && (a = false, t.onCompositionEnd(l.data));
      }, true), r.addEventListener("beforeinput", (l) => l.stopImmediatePropagation()), r.addEventListener("input", (l) => {
        var c;
        if (!a && (r.textContent = "", l.inputType !== "insertCompositionText")) {
          if (l.inputType === "insertFromPaste") {
            l.preventDefault(), l.stopPropagation();
            return;
          }
          t.onInput((c = l.data) != null ? c : ""), l.preventDefault(), l.stopPropagation();
        }
      }), r.addEventListener("paste", (l) => {
        r.focus(), r.textContent = "", t.onPaste(l) || l.preventDefault(), l.stopImmediatePropagation();
      }, true), r.addEventListener("cut", (l) => t.onCut(l), true), r.addEventListener("copy", (l) => t.onCopy(l), true), r.addEventListener("blur", (l) => {
        var u, d, m, h;
        if (((d = (u = l.relatedTarget) == null ? void 0 : u._mathfield) == null ? void 0 : d.element) === e) {
          r.focus(), l.preventDefault(), l.stopPropagation();
          return;
        }
        let c = (m = Dt.scrim) == null ? void 0 : m.state;
        if (c === "open" || c === "opening") {
          l.preventDefault(), l.stopPropagation();
          return;
        }
        if (l.relatedTarget === l.target.getRootNode().host) {
          l.preventDefault(), l.stopPropagation();
          return;
        }
        s || n || (s = true, i = null, o = null, (h = t.onBlur) == null || h.call(t), s = false);
      }, true), r.addEventListener("focus", (l) => {
        var c;
        s || n || (n = true, (c = t.onFocus) == null || c.call(t), n = false);
      }, true), { cancelComposition: () => {
        a && (r.blur(), requestAnimationFrame(() => r.focus()));
      }, blur: () => {
        typeof r.blur == "function" && r.blur();
      }, focus: () => {
        !n && typeof r.focus == "function" && r.focus();
      }, hasFocus: () => yu() === r, setAriaLabel: (l) => r.setAttribute("aria-label", l), setValue: (l) => {
        var c;
        r.textContent = l, r.style.top = "-1000px", (c = window.getSelection()) == null || c.selectAllChildren(r);
      }, moveTo: (l, c) => {
        r.style.top = `${c}px`, r.style.left = `${l}px`;
      } };
    }
    function yu() {
      var e;
      let r = document.activeElement;
      for (; (e = r == null ? void 0 : r.shadowRoot) != null && e.activeElement; )
        r = r.shadowRoot.activeElement;
      return r;
    }
    function li(r) {
      var t;
      if (!r)
        return "";
      let e;
      return r.key === "Unidentified" && r.target && (e = r.target.value), e = (t = e != null ? e : r.key) != null ? t : r.code, /^(Dead|Return|Enter|Tab|Escape|Delete|PageUp|PageDown|Home|End|Help|ArrowLeft|ArrowRight|ArrowUp|ArrowDown)$/.test(e) && (e = ""), e;
    }
    var Do = class {
      constructor(e) {
        this.recording = false;
        this.canCoalesce = false;
        this.model = e, this.reset();
      }
      get maximumDepth() {
        return 1e3;
      }
      reset() {
        this.stack = [], this.index = -1;
      }
      startRecording() {
        this.recording = true;
      }
      canUndo() {
        return this.index > 0;
      }
      canRedo() {
        return this.index !== this.stack.length - 1;
      }
      undo() {
        return this.canUndo() ? (this.model.setState(this.stack[this.index - 1], { suppressChangeNotifications: false, type: "undo" }), this.index -= 1, this.canCoalesce = false, true) : false;
      }
      redo() {
        return this.canRedo() ? (this.index += 1, this.model.setState(this.stack[this.index], { suppressChangeNotifications: false, type: "redo" }), this.canCoalesce = false, true) : false;
      }
      pop() {
        this.canUndo() && (this.index -= 1, this.stack.pop());
      }
      snapshot() {
        return this.recording ? (this.stack.splice(this.index + 1, this.stack.length - this.index - 1), this.stack.push(this.model.getState()), this.index++, this.stack.length > this.maximumDepth && this.stack.shift(), this.canCoalesce = false, true) : false;
      }
      snapshotAndCoalesce() {
        if (!this.recording)
          return false;
        this.canCoalesce && this.pop();
        let e = this.snapshot();
        return this.canCoalesce = true, e;
      }
    };
    function qa(r) {
      let e = r.position, t = r.at(e).parent;
      return !t || t.type === "root" ? (r.announce("plonk"), false) : (r.position = r.offsetOf(t), r.announce("move", e), true);
    }
    function bu(r) {
      let e = 0, t = r.at(r.position), i = false;
      for (; t; )
        (!t.hasEmptyBranch("superscript") || !t.hasEmptyBranch("subscript")) && (e += 1), t.hasEmptyBranch("superscript") ? t.hasEmptyBranch("subscript") || (i = false) : i = true, t = t.parent;
      return i ? e : 0;
    }
    function xu(r) {
      let e = 0, t = r.at(r.position), i = false;
      for (; t; )
        (!t.hasEmptyBranch("superscript") || !t.hasEmptyBranch("subscript")) && (e += 1), t.hasEmptyBranch("superscript") ? t.hasEmptyBranch("subscript") || (i = true) : i = false, t = t.parent;
      return i ? e : 0;
    }
    function Hs(r) {
      var t;
      if (r.collapseSelection(), bu(r) >= r.mathfield.options.scriptDepth[1])
        return r.announce("plonk"), false;
      let e = r.at(r.position);
      return e.subsupPlacement === void 0 && (((t = e.rightSibling) == null ? void 0 : t.type) !== "msubsup" && e.parent.addChildAfter(new ft(r.mathfield, { style: e.computedStyle }), e), e = e.rightSibling), e.createBranch("superscript"), r.setSelection(r.getSiblingsRange(r.offsetOf(e.superscript[0]))), true;
    }
    function Gs(r) {
      var t;
      if (r.collapseSelection(), xu(r) >= r.mathfield.options.scriptDepth[0])
        return r.announce("plonk"), false;
      let e = r.at(r.position);
      return e.subsupPlacement === void 0 && (((t = r.at(r.position + 1)) == null ? void 0 : t.type) !== "msubsup" && e.parent.addChildAfter(new ft(r.mathfield, { style: r.at(r.position).computedStyle }), e), e = r.at(r.position + 1)), e.createBranch("subscript"), r.setSelection(r.getSiblingsRange(r.offsetOf(e.subscript[0]))), true;
    }
    function vu() {
      function r(l) {
        let c = [], u = [];
        return [...l.querySelectorAll(`input, select, textarea, a[href], button,
        [tabindex], audio[controls], video[controls],
        [contenteditable]:not([contenteditable="false"]), details>summary`)].filter(e).forEach((m, h) => {
          let f = i(m);
          f === 0 ? c.push(m) : u.push({ documentOrder: h, tabIndex: f, node: m });
        }), u.sort((m, h) => m.tabIndex === h.tabIndex ? m.documentOrder - h.documentOrder : m.tabIndex - h.tabIndex).map((m) => m.node).concat(c);
      }
      function e(l) {
        return !(!t(l) || o(l) || i(l) < 0);
      }
      function t(l) {
        return !(l.disabled || l.type === "hidden" && l.tagName.toUpperCase() === "INPUT" || s(l));
      }
      function i(l) {
        var u;
        let c = Number.parseInt((u = l.getAttribute("tabindex")) != null ? u : "NaN", 10);
        return Number.isNaN(c) ? l.contentEditable === "true" || (l.nodeName === "AUDIO" || l.nodeName === "VIDEO") && l.getAttribute("tabindex") === null ? 0 : l.tabIndex : c;
      }
      function o(l) {
        return l.tagName.toUpperCase() === "INPUT" && l.type === "radio" && !n(l);
      }
      function a(l, c) {
        for (let u of l)
          if (u.checked && u.form === c)
            return u;
        return null;
      }
      function n(l) {
        var m;
        if (!l.name)
          return true;
        let u = ((m = l.form) != null ? m : l.ownerDocument).querySelectorAll('input[type="radio"][name="' + l.name + '"]'), d = a(u, l.form);
        return !d || d === l;
      }
      function s(l) {
        if (!fe() || l === document.activeElement || l.contains(document.activeElement))
          return false;
        if (getComputedStyle(l).visibility === "hidden")
          return true;
        let c = l.getBoundingClientRect();
        if (c.width === 0 || c.height === 0)
          return true;
        for (; l; ) {
          if (getComputedStyle(l).display === "none")
            return true;
          l = l.parentElement;
        }
        return false;
      }
      return fe() ? r(document.body) : [];
    }
    function Js(r, e, t = true) {
      var l, c;
      let i = e === "forward" ? 1 : -1;
      r.at(r.anchor).type === "placeholder" && xt(r, e);
      let o, a = r.at(r.anchor).parentPrompt;
      a ? e === "forward" ? o = r.offsetOf(a) + 1 : o = r.offsetOf(a.leftSibling) : o = Math.max(r.position + i, 0);
      let n = r.findAtom((u) => u.type === "placeholder" || u.type === "prompt" || !r.mathfield.readOnly && u.treeDepth > 2 && u.isFirstSibling && u.isLastSibling, o, e);
      if (!n || e === "forward" && r.offsetOf(n) < o || e === "backward" && r.offsetOf(n) > o) {
        if (!t || !((c = (l = r.mathfield.host) == null ? void 0 : l.dispatchEvent(new CustomEvent("move-out", { detail: { direction: e }, cancelable: true, bubbles: true, composed: true }))) == null || c))
          return r.announce("plonk"), false;
        let d = vu();
        if (!document.activeElement || d.length <= 1)
          return r.announce("plonk"), false;
        let m = d.indexOf(document.activeElement) + i;
        return m < 0 && (m = d.length - 1), m >= d.length && (m = 0), d[m].focus(), true;
      }
      let s = r.position;
      if (n.type === "prompt")
        r.setSelection(r.offsetOf(n.firstChild), r.offsetOf(n.lastChild));
      else {
        let u = r.offsetOf(n);
        n.type === "placeholder" ? r.setSelection(u - 1, u) : r.position = u;
      }
      return r.announce("move", s), true;
    }
    he({ moveToOpposite: (r) => {
      let e = { superscript: "subscript", subscript: "superscript", above: "below", below: "above" }, t = r.at(r.position), { parent: i } = t;
      if (!i)
        return r.announce("plonk"), false;
      let o = t.treeBranch, a;
      return typeof o == "string" && (a = e[o]), a ? (i.branch(a) || i.createBranch(a), r.setSelection(r.getBranchRange(r.offsetOf(i), a))) : t.subsupPlacement ? Gs(r) : Hs(r);
    }, moveBeforeParent: (r) => {
      let { parent: e } = r.at(r.position);
      return e ? (r.position = r.offsetOf(e), true) : (r.announce("plonk"), false);
    }, moveAfterParent: (r) => qa(r), moveToNextPlaceholder: (r) => Js(r, "forward"), moveToPreviousPlaceholder: (r) => Js(r, "backward"), moveToNextChar: (r) => xt(r, "forward"), moveToPreviousChar: (r) => xt(r, "backward"), moveUp: (r) => xt(r, "upward"), moveDown: (r) => xt(r, "downward"), moveToNextWord: (r) => fr(r, "forward"), moveToPreviousWord: (r) => fr(r, "backward"), moveToGroupStart: (r) => {
      let e = r.offsetOf(r.at(r.position).firstSibling);
      return e === r.position ? (r.announce("plonk"), false) : (r.position = e, true);
    }, moveToGroupEnd: (r) => {
      let e = r.offsetOf(r.at(r.position).lastSibling);
      return e === r.position ? (r.announce("plonk"), false) : (r.position = e, true);
    }, moveToMathfieldStart: (r) => r.position === 0 ? (r.announce("plonk"), false) : (r.position = 0, true), moveToMathfieldEnd: (r) => r.position === r.lastOffset ? (r.announce("plonk"), false) : (r.position = r.lastOffset, true), moveToSuperscript: (r) => Hs(r), moveToSubscript: (r) => Gs(r) }, { target: "model", category: "selection-anchor" });
    function Bo(r, e, t) {
      typeof e == "function" && (t = e, e = 1 / 0), e === void 0 && (e = 1 / 0);
      let i = r.position, o = false, a = "";
      for (; !o; ) {
        let n = r.at(i);
        o = e === 0 || n === void 0 || n.mode !== "math" || !(/mord|textord|mpunct/.test(n.type) || n.type === "mop" && /[a-zA-Z]+/.test(n.value)) || !n.hasEmptyBranch("superscript") || !n.hasEmptyBranch("subscript") || typeof t == "function" && !t(n), o || (n.mode = "text", n.command = n.value, n.verbatimLatex = void 0, a += n.value), i -= 1, e -= 1;
      }
      J(r, { data: a, inputType: "insertText" });
    }
    function Dr(r, e, t) {
      typeof e == "function" && (t = e, e = 1 / 0), e === void 0 && (e = 1 / 0);
      let i = r.position, o = false, a = [];
      for (; !o; ) {
        let n = r.at(i);
        o = e === 0 || !n || n.isFirstSibling || n.mode !== "text" || n.value === " " || t && !t(n), o || (a.push(n.serialize({ defaultMode: "math" })), n.mode = "math"), i -= 1, e -= 1;
      }
      Oo(r), J(r, { data: j(a), inputType: "insertText" });
    }
    function Oo(r) {
      var t;
      let e = r.position - 1;
      for (; e >= 0 && ((t = r.at(e)) == null ? void 0 : t.mode) === "math"; )
        e -= 1;
      if (!(e < 0) && r.at(e).mode === "text" && r.at(e).value === " " && r.at(e - 1).mode === "math") {
        r.at(e - 1).parent.removeChild(r.at(e - 1));
        let i = r.suppressChangeNotifications;
        r.suppressChangeNotifications = true, r.position -= 1, r.suppressChangeNotifications = i, J(r, { inputType: "deleteContent" });
      }
    }
    function wu(r) {
      let e = "", t = r.position, i = false;
      for (; !i; ) {
        let o = r.at(t);
        i = !(o && (o.mode === "text" || o.mode === "math" && /mord|textord|mpunct/.test(o.type))), i || (e = o.value + e), t -= 1;
      }
      return e;
    }
    function Ws(r, e, t) {
      if (r.smartModeSuppressed)
        return false;
      let { model: i } = r;
      if (!i.at(i.position).isLastSibling || !t || !Ko(t))
        return false;
      let o = li(t);
      if (!i.selectionIsCollapsed)
        return !!(r.mode === "text" && /[/_^]/.test(o));
      let a = wu(i) + o;
      if (r.mode === "text") {
        if (e === "Esc" || /[/\\]/.test(o))
          return true;
        if (/[\^_]/.test(o))
          return /(^|\s)[a-zA-Z][^_]$/.test(a) && Dr(i, 1), true;
        let n = { ")": "(", "}": "{", "]": "[" }[o], { parent: s } = i.at(i.position);
        if (n && s instanceof oe && s.leftDelim === n)
          return true;
        if (/(^|[^a-zA-Z])(a|I) $/.test(a))
          return false;
        if (/[$€£₤₺¥¤฿¢₡₧₨₹₩₱]/u.test(o))
          return true;
        if (/(^|[^a-zA-Z'’])[a-zA-Z] $/.test(a))
          return Dr(i, 1), false;
        if (/\D\.[^\d\s]$/.test(a)) {
          Dr(i, 1);
          let l = i.at(i.position);
          return l.value = "⋅", l.style.variant = "normal", l.command = "\\cdot", l.verbatimLatex = void 0, J(i, { data: "\\cdot", inputType: "insertText" }), true;
        }
        if (/(^|\s)[a-zA-Z][^a-zA-Z]$/.test(a) || /\.\d$/.test(a) || /\([\d+\-.]$/.test(a))
          return Dr(i, 1), true;
        if (/\([a-z][,;]$/.test(a))
          return Dr(i, 2), true;
        if (/[\d+\-=><*|]$/.test(o))
          return Oo(i), true;
      } else {
        if (e === "[Space]")
          return Bo(i, void 0, (n) => /[a-z][:,;.]$/.test(n.value)), true;
        if (/[a-zA-Z]{3,}$/.test(a) && !/(dxd|abc|xyz|uvw)$/.test(a))
          return Bo(i, void 0, (n) => /[a-zA-Z]/.test(n.value)), true;
        if (/(^|\W)(if)$/i.test(a))
          return Bo(i, 1), true;
        if (/(\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5){3,}$/u.test(a) && !/(αβγ)$/.test(a))
          return Bo(i, void 0, (n) => /(:|,|;|.|\u0393|\u0394|\u0398|\u039B|\u039E|\u03A0|\u03A3|\u03A5|\u03A6|\u03A8|\u03A9|[\u03B1-\u03C9]|\u03D1|\u03D5|\u03D6|\u03F1|\u03F5)/u.test(n.value)), true;
        if (o === "?" || o === "." && !/[\d-+]\.$/.test(a))
          return true;
      }
      return false;
    }
    var Va = `/* The element that displays the keys as the user type them */
#mathlive-keystroke-caption-panel {
  visibility: hidden;
  /*min-width: 160px;*/
  /*background-color: rgba(97, 97, 200, .95);*/
  background: var(--secondary, hsl(var(--hue, 212), 19%, 26%));
  border-color: var(--secondary-border, hsl(0, 0%, 91%));
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
  text-align: center;
  border-radius: 6px;
  padding: 16px;
  position: absolute;
  z-index: 1;
  display: flex;
  flex-direction: row-reverse;
  justify-content: center;
  --keystroke: white;
  --on-keystroke: #555;
  --keystroke-border: #f7f7f7;
}
@media (prefers-color-scheme: dark) {
  body:not([theme='light']) #mathlive-keystroke-caption-panel {
    --keystroke: hsl(var(--hue, 212), 50%, 30%);
    --on-keystroke: hsl(0, 0%, 98%);
    --keystroke-border: hsl(var(--hue, 212), 50%, 25%);
  }
}
body[theme='dark'] #mathlive-keystroke-caption-panel {
  --keystroke: hsl(var(--hue, 212), 50%, 30%);
  --on-keystroke: hsl(0, 0%, 98%);
  --keystroke-border: hsl(var(--hue, 212), 50%, 25%);
}
#mathlive-keystroke-caption-panel > span {
  min-width: 14px;
  /*height: 8px;*/
  margin: 0 8px 0 0;
  padding: 4px;
  background-color: var(--keystroke);
  color: var(--on-keystroke);
  fill: currentColor;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
  font-size: 1em;
  border-radius: 6px;
  border: 2px solid var(--keystroke-border);
  /*box-shadow: 0 7px 14px rgba(0,0,0,0.25), 0 5px 5px rgba(0,0,0,0.22);*/
}
`;
    var Ha, Ga = null, Ja = null;
    function Us(r, e) {
      if (!r.isSelectionEditable || !r.keystrokeCaptionVisible)
        return;
      let t = Xs(r), i = r.element.getBoundingClientRect();
      t.style.left = `${i.left}px`, t.style.top = `${i.top - 64}px`, t.innerHTML = window.MathfieldElement.createHTML("<span>" + (Ki(e) || e) + "</span>" + t.innerHTML), t.style.visibility = "visible", setTimeout(() => {
        t.childNodes.length > 0 && t.childNodes[t.childNodes.length - 1].remove(), t.childNodes.length === 0 && (t.style.visibility = "hidden");
      }, 3e3);
    }
    function js(r) {
      return r.keystrokeCaptionVisible = !r.keystrokeCaptionVisible, r.keystrokeCaptionVisible ? (r.keystrokeCaption = Xs(r), r.keystrokeCaption.innerHTML = "") : r.keystrokeCaption && (r.keystrokeCaption.style.visibility = "hidden"), false;
    }
    function Xs(r) {
      return r.keystrokeCaption || (r.keystrokeCaption = xo("mathlive-keystroke-caption-panel"), Ha === void 0 && (Ha = Xe(Va).toString(36)), Ga = Ze(null, Va, Ha), Ja = Ze(null, Ie, Xe(Ie).toString(36))), r.keystrokeCaption;
    }
    function Zs(r) {
      vo(r.keystrokeCaption), Ga && Ga.release(), Ja && Ja.release(), delete r.keystrokeCaption;
    }
    var Ua = class extends Z {
      constructor() {
        super("math");
      }
      onPaste(e, t) {
        if (!t || !H(e.model, { data: typeof t == "string" ? t : null, dataTransfer: typeof t == "string" ? null : t, inputType: "insertFromPaste" }))
          return false;
        let i = "", o = "auto", a = typeof t != "string" ? t.getData("application/json+mathlive") : "";
        if (a)
          try {
            let n = JSON.parse(a);
            if (n && Array.isArray(n)) {
              e.snapshot();
              let s = Ue(n, e), { model: l } = e;
              l.selectionIsCollapsed || l.deleteAtoms(xe(l.selection));
              let c = l.at(l.position);
              if (c.parent instanceof X) {
                c.treeBranch;
                let u = [], d = [];
                s[0].type === "first" && s.shift(), s[s.length - 1].type === "first" && s.pop();
                for (let y of s)
                  y.type === "first" && d.length > 0 ? (u.push(d), d = [y]) : d.push(y);
                d.length > 0 && u.push(d);
                let m = Number(c.treeBranch[0]), h = Number(c.treeBranch[1]), f = c.parent.maxColumns;
                for (; c.parent.colCount - h < u.length && c.parent.colCount < f; )
                  c.parent.addColumn();
                c.parent.addChildrenAfter(u[0], c);
                for (let y = 1; y < u.length; y++)
                  h++, h >= f && (h = 0, c.parent.addRowAfter(m), m++), c.parent.setCell(m, h, u[y]);
              } else
                c.parent.addChildrenAfter(s.filter((u) => u.type !== "first"), c);
              return l.position = l.offsetOf(s[s.length - 1]), J(l, { inputType: "insertFromPaste" }), te(e), true;
            }
          } catch (n) {
          }
        if (a = typeof t != "string" ? t.getData("application/json") : "", a && window.MathfieldElement.computeEngine)
          try {
            let n = JSON.parse(a);
            if (typeof n == "object" && "latex" in n && n.latex && (i = n.latex), !i) {
              let s = window.MathfieldElement.computeEngine.box(n);
              s && !s.has("Error") && (i = s.latex);
            }
            i || (o = "latex");
          } catch (n) {
          }
        if (!i && typeof t != "string" && (i = t.getData("application/x-latex"), i && (o = "latex")), i || (i = typeof t == "string" ? t : t.getData("text/plain")), i) {
          e.snapshot();
          let n;
          return [n, i] = fo(i), o === "auto" && n && (o = "latex"), this.insert(e.model, i, { format: o }) && te(e), true;
        }
        return false;
      }
      insert(e, t, i) {
        var w, k;
        let o = typeof t == "string" ? t : (k = (w = window.MathfieldElement.computeEngine) == null ? void 0 : w.box(t).latex) != null ? k : "";
        if (!i.suppressChangeNotifications && !H(e, { data: o, inputType: "insertText" }))
          return false;
        if (i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder"), i.format || (i.format = "auto"), e.mathfield.smartFence) {
          if (e.selectionIsCollapsed && typeof t == "string" && Ro(e, t, i.style))
            return true;
        } else if (i.insertionMode !== "replaceAll") {
          let { parent: S } = e.at(e.position);
          if (S instanceof oe && S.rightDelim === "?" && e.at(e.position).isLastSibling && typeof t == "string" && /^[)}\]|]$/.test(t))
            return S.isDirty = true, S.rightDelim = t, e.position += 1, Co(e), J(e, { data: o, inputType: "insertText" }), true;
        }
        let { suppressChangeNotifications: a } = e;
        i.suppressChangeNotifications && (e.suppressChangeNotifications = true);
        let n = e.suppressChangeNotifications;
        e.suppressChangeNotifications = true;
        let s = {};
        if (s[0] = i.insertionMode === "replaceAll" ? "" : e.getValue(e.selection, "latex-unstyled"), s["?"] = "\\placeholder{}", s["@"] = s["?"], i.insertionMode === "replaceSelection" && !e.selectionIsCollapsed ? e.deleteAtoms(xe(e.selection)) : i.insertionMode === "replaceAll" ? (e.root.setChildren([], "body"), e.position = 0) : i.insertionMode === "insertBefore" ? e.collapseSelection("backward") : i.insertionMode === "insertAfter" && e.collapseSelection("forward"), !e.at(e.position).isLastSibling && e.at(e.position + 1).type === "placeholder" ? e.deleteAtoms([e.position, e.position + 1]) : e.at(e.position).type === "placeholder" && e.deleteAtoms([e.position - 1, e.position]), s[0])
          s["@"] = s[0];
        else if (typeof t == "string" && /(^|[^\\])#@/.test(t)) {
          let S = Mu(e);
          S >= 0 && (s["@"] = e.getValue(S, e.position, "latex-unstyled"), e.deleteAtoms([S, e.position]));
        }
        s[0] || (s[0] = s["?"]);
        let l = false, c = (S) => (l = true, s[S]), [u, d] = Su(e, t, c, i);
        if (!d)
          return false;
        let { parent: m } = e.at(e.position);
        if (u !== "latex" && e.options.removeExtraneousParentheses && m instanceof oe && m.leftDelim === "(" && m.hasEmptyBranch("body") && d.length === 1 && d[0].type === "genfrac") {
          let S = m.parent, T = m.treeBranch;
          S.removeChild(m), S.setChildren(d, T);
        }
        let h = m.hasEmptyBranch("body"), f = e.at(e.position);
        f.parent.addChildrenAfter(d, f), u === "latex" && typeof t == "string" && m.type === "root" && h && !l && (m.verbatimLatex = t), e.suppressChangeNotifications = n;
        let y = d[d.length - 1];
        if (i.selectionMode === "placeholder") {
          let S = d.flatMap((T) => [T, ...T.children]).find((T) => T.type === "placeholder");
          if (S) {
            let T = e.offsetOf(S);
            e.setSelection(T - 1, T), e.announce("move");
          } else
            y && (e.position = e.offsetOf(y));
        } else
          i.selectionMode === "before" || (i.selectionMode === "after" ? y && (e.position = e.offsetOf(y)) : i.selectionMode === "item" && e.setSelection(e.anchor, e.offsetOf(y)));
        return J(e, { data: o, inputType: "insertText" }), e.suppressChangeNotifications = a, true;
      }
    };
    function Su(r, e, t, i) {
      var n;
      let o, a = [];
      if (typeof e != "string" || i.format === "math-json") {
        let s = window.MathfieldElement.computeEngine;
        if (!s)
          return ["math-json", []];
        [o, e] = ["latex", s.box(e).latex], a = pe(e, r.mathfield, { parseMode: "math" });
      } else
        typeof e == "string" && i.format === "ascii-math" ? ([o, e] = _r(e, { format: "ascii-math", inlineShortcuts: r.mathfield.options.inlineShortcuts }), a = pe(e, r.mathfield, { parseMode: "math" }), o !== "latex" && r.options.removeExtraneousParentheses && zo(a)) : (i.format === "auto" || (n = i.format) != null && n.startsWith("latex")) && (i.format === "auto" && ([o, e] = _r(e, { format: "auto", inlineShortcuts: r.mathfield.options.inlineShortcuts })), i.format === "latex" && ([, e] = fo(e)), a = pe(e, r.mathfield, { parseMode: "math", args: t }), i.format !== "latex" && r.options.removeExtraneousParentheses && zo(a));
      return Bt(a, i.style), [o != null ? o : "latex", a];
    }
    function _u(r) {
      if (!r || (r[0].type, r.length > 1))
        return null;
      let e = r[0];
      return e instanceof oe && e.leftDelim === "(" && e.rightDelim === ")" ? e.removeBranch("body") : null;
    }
    function zo(r) {
      if (r) {
        for (let e = 0; r[e]; e++) {
          let t = r[e];
          if (t instanceof oe && t.leftDelim === "(") {
            let i = 0, o = 0, a = 0;
            for (let n = 0; t.body[n]; n++)
              t.body[n].type === "genfrac" && (i++, o = n), a++;
            a === 0 && i === 1 && (r[e] = t.body[o]);
          }
        }
        for (let e of r) {
          for (let t of e.branches)
            if (!e.hasEmptyBranch(t)) {
              zo(e.branch(t));
              let i = _u(e.branch(t));
              i && e.setChildren(i, t);
            }
          if (e instanceof X)
            for (let t of e.cells)
              zo(t);
        }
      }
    }
    function Mu(r) {
      let e = r.at(r.position);
      if (e.mode === "text") {
        for (; !e.isFirstSibling && e.mode === "text"; )
          e = e.leftSibling;
        return r.offsetOf(e);
      }
      let t = e, i = false;
      if (e.type === "mclose") {
        let o = na[e.value];
        for (; !e.isFirstSibling && !(e.type === "mopen" && e.value === o); )
          e = e.leftSibling;
        e.isFirstSibling || (e = e.leftSibling), i = true;
      } else
        e.type === "leftright" && (e = e.leftSibling, i = true);
      if (i)
        for (; !e.isFirstSibling && (e.isFunction || Ys(e)); )
          e = e.leftSibling;
      else {
        let o = [];
        for (; !e.isFirstSibling && (Ys(e) || o.length > 0); )
          e.type === "mclose" && o.unshift(e.value), e.type === "mopen" && o.length > 0 && e.value === na[o[0]] && o.shift(), e = e.leftSibling;
      }
      return t === e ? -1 : r.offsetOf(e);
    }
    function Ys(r) {
      return /^(mord|surd|msubsup|leftright|mop|mclose)$/.test(r.type) ? !(r.isExtensibleSymbol || r.isFunction) : false;
    }
    function Wa(r, e) {
      return r ? ["(", "{", "[", "\\lbrace", "\\lparen", "\\{", "\\lbrack"].includes(r) ? [")", "}", "]", "\\rbrace", "\\rparen", "\\}", "\\rbrack"].includes(e) : tr[r] === e : true;
    }
    function Ro(r, e, t) {
      r.selectionIsCollapsed;
      let i = r.at(r.position), { parent: o } = i;
      if ((e === "{" || e === "\\{") && (e = "\\lbrace"), (e === "}" || e === "\\}") && (e = "\\rbrace"), e === "[" && (e = "\\lbrack"), e === "]" && (e = "\\rbrack"), /\||\\vert|\\Vert|\\mvert|\\mid/.test(e)) {
        let s = o instanceof oe ? o.leftDelim + o.rightDelim : "";
        if (s === "\\lbrace\\rbrace" && (s = "{}"), s === "\\{\\}" && (s = "{}"), s === "\\lparen\\rparen" && (s = "()"), s === "{}")
          return Z.insert("math", r, "\\,\\middle" + e + "\\, ", { format: "latex", style: t }), true;
      }
      let a = tr[e];
      if (a) {
        if (o instanceof oe && o.firstChild === i && (o.leftDelim === "?" || o.leftDelim === "."))
          return o.leftDelim = e, o.isDirty = true, true;
        if (!(o instanceof oe)) {
          let s = i;
          for (; s && !(s.type === "mclose" && s.value === a); )
            s = s.rightSibling;
          if (s) {
            let l = r.extractAtoms([r.offsetOf(i), r.offsetOf(s)]);
            return l.shift(), l.pop(), o.addChildrenAfter([new oe("left...right", l, o.context, { leftDelim: e, rightDelim: a })], i), r.position = r.offsetOf(o.firstChild), J(r, { data: e, inputType: "insertText" }), true;
          }
        }
        if (!(o instanceof oe && o.leftDelim === "|")) {
          if (Z.insert("math", r, `\\left${e}\\right?`, { format: "latex", style: t }), i.lastSibling.type !== "first") {
            let s = r.offsetOf(i.lastSibling), l = r.extractAtoms([r.position, s]);
            r.at(r.position).body = l, r.position -= 1;
          }
          return true;
        }
      }
      let n = "";
      for (let s of Object.keys(tr))
        e === tr[s] && (n = s);
      if (n) {
        let s = i;
        for (; s; ) {
          if (s.type === "mopen" && s.value === n) {
            let m = s.leftSibling, h = r.extractAtoms([r.offsetOf(s.leftSibling), r.offsetOf(i)]);
            h.shift();
            let f = new oe("left...right", h, o.context, { leftDelim: n, rightDelim: e });
            return o.addChildrenAfter([f], m), r.position = r.offsetOf(f), J(r, { data: e, inputType: "insertText" }), true;
          }
          s = s.leftSibling;
        }
        if (o instanceof oe && i.isLastSibling && Wa(o.leftDelim, e))
          return o.isDirty = true, o.rightDelim = e, r.position += 1, J(r, { data: e, inputType: "insertText" }), true;
        let l = r.offsetOf(i.firstSibling), c;
        for (c = r.position; c >= l; c--) {
          let m = r.at(c);
          if (m instanceof oe && m.rightDelim === "?" && Wa(m.leftDelim, e))
            break;
        }
        let u = r.at(c);
        if (c >= l && u instanceof oe)
          return u.rightDelim = e, u.addChildren(r.extractAtoms([c, r.position]), i.treeBranch), r.position = c, J(r, { data: e, inputType: "insertText" }), true;
        if (o instanceof oe && o.rightDelim === "?" && Wa(o.leftDelim, e))
          return o.isDirty = true, o.rightDelim = e, o.parent.addChildren(r.extractAtoms([r.position, r.offsetOf(i.lastSibling)]), o.treeBranch), r.position = r.offsetOf(o), J(r, { data: e, inputType: "insertText" }), true;
        let d = o.parent;
        return d instanceof oe && d.rightDelim === "?" && r.at(r.position).isLastSibling ? (r.position = r.offsetOf(d), Ro(r, e, t)) : false;
      }
      return false;
    }
    new Ua();
    function ja(r, e, t) {
      var u, d, m, h;
      let { model: i } = r;
      ms(t);
      let o = pr();
      if (r.keyboardLayout !== o.id && (r.keyboardLayout = o.id, r._keybindings = void 0), clearTimeout(r.inlineShortcutBufferFlushTimer), r.inlineShortcutBufferFlushTimer = 0, Us(r, e), t.defaultPrevented)
        return r.flushInlineShortcutBuffer(), false;
      let a, n = "", s;
      if (r.isSelectionEditable) {
        if (r.mode === "math")
          if (e === "[Backspace]")
            r.inlineShortcutBuffer.pop(), r.flushInlineShortcutBuffer({ defer: true });
          else if (!Ko(t))
            r.flushInlineShortcutBuffer();
          else {
            let f = li(t), y = [...(d = (u = r.inlineShortcutBuffer[r.inlineShortcutBuffer.length - 1]) == null ? void 0 : u.keystrokes) != null ? d : [], f];
            r.inlineShortcutBuffer.push({ state: i.getState(), keystrokes: y, leftSiblings: Au(r) });
            let w = 0, k = "";
            for (; !a && w < y.length; )
              s = r.inlineShortcutBuffer.length - (y.length - w), k = y.slice(w).join(""), a = Si(r.inlineShortcutBuffer[s].leftSiblings, k, r.options.inlineShortcuts), !a && /^[a-zA-Z][a-zA-Z0-9]+?([_\^][a-zA-Z0-9\*\+\-]+?)?$/.test(k) && (a = r.options.onInlineShortcut(r, k)), w += 1;
            r.flushInlineShortcutBuffer({ defer: true });
          }
        if (r.options.smartMode) {
          let f = r.mode;
          a ? r.mode = "math" : Ws(r, e, t) && (r.mode = { math: "text", text: "math" }[r.mode], n = ""), r.mode !== f && ((m = r.host) != null && m.dispatchEvent(new Event("mode-change", { bubbles: true, composed: true, cancelable: true })) || (r.mode = f));
        }
      }
      if (!a) {
        if (n || (n = fs(r.keybindings, r.mode, e)), !n && (e === "[Enter]" || e === "[Return]")) {
          let f = false;
          return H(i, { inputType: "insertLineBreak" }) && (r.host && (f = !r.host.dispatchEvent(new Event("change", { bubbles: true, composed: true }))), f || t.preventDefault && (t.preventDefault(), t.stopPropagation()), J(i, { inputType: "insertLineBreak" })), f;
        }
        if (!n && r.mode === "math") {
          if (e === "[Space]") {
            if (r.adoptStyle = "none", r.flushInlineShortcutBuffer(), r.options.mathModeSpace)
              return r.snapshot(), Z.insert("math", i, r.options.mathModeSpace, { format: "latex" }), n = "", r.dirty = true, r.scrollIntoView(), t.preventDefault && (t.preventDefault(), t.stopPropagation()), false;
            let f = i.at(i.position + 1), y = i.at(i.position - 1);
            if ((f == null ? void 0 : f.mode) === "text" || (y == null ? void 0 : y.mode) === "text")
              return r.snapshot(), Z.insert("text", i, " "), r.dirty = true, r.scrollIntoView(), true;
          }
          (h = i.at(i.position)) != null && h.isDigit() && window.MathfieldElement.decimalSeparator === "," && li(t) === "," && (n = "insertDecimalSeparator");
        }
      }
      if (!a && !n)
        return true;
      let l = i.at(Math.max(i.position, i.anchor)), { parent: c } = l;
      if (n === "moveAfterParent" && (c == null ? void 0 : c.type) === "leftright" && l.isLastSibling && r.options.smartFence && Ro(i, ".", r.style) && (n = "", te(r)), r.keyboardDelegate.cancelComposition(), n)
        r.executeCommand(n);
      else if (a) {
        let f = b(b({}, i.at(i.position).computedStyle), r.style);
        if (!/^\\({|}|\[|]|@|#|\$|%|&|\^|_|backslash)$/.test(a)) {
          let y = r.mode;
          Z.insert(r.mode, i, li(t), { suppressChangeNotifications: true, style: f }), r.snapshot(), i.setState(r.inlineShortcutBuffer[s].state), r.mode = y;
        }
        i.deferNotifications({ content: true, selection: true, data: a != null ? a : null, type: "insertText" }, () => (Z.insert(r.mode, i, a, { format: "latex", style: f }), Oo(r.model), a.endsWith(" ") && (r.mode = "text", Z.insert("text", i, " ", { style: f })), i.selectionIsCollapsed || r.flushInlineShortcutBuffer(), true)), r.snapshot(), r.dirty = true, i.announce("replacement");
      }
      return r.scrollIntoView(), t.preventDefault && t.preventDefault(), false;
    }
    function qi(r, e, t) {
      var l;
      let { model: i } = r;
      if (!r.isSelectionEditable) {
        i.announce("plonk");
        return;
      }
      if (t = t != null ? t : {}, t.focus && r.focus(), t.feedback && window.MathfieldElement.playSound("keypress"), typeof t.mode == "string" && r.switchMode(t.mode), t.simulateKeystroke) {
        let c = e.charAt(0), u = new KeyboardEvent("keypress", { key: c });
        if (!ja(r, c, u))
          return;
      }
      let o = i.at(i.position), a = o.rightSibling, n = b(b({}, o.computedStyle), r.style);
      i.selectionIsCollapsed || (i.deleteAtoms(xe(i.selection)), r.snapshot());
      let s = Yi(e);
      if (r.mode === "latex")
        i.deferNotifications({ content: true, selection: true, data: e, type: "insertText" }, () => {
          zi(r);
          for (let c of s)
            Z.insert("latex", i, c);
          si(r);
        });
      else if (r.mode === "text")
        for (let c of s)
          Z.insert("text", i, c, { style: n });
      else if (r.mode === "math")
        for (let c of s) {
          let u = { "^": "moveToSuperscript", _: "moveToSubscript", " ": "moveAfterParent" }[c];
          if (c === " " && r.options.mathModeSpace && (u = ["insert", r.options.mathModeSpace]), u)
            r.executeCommand(u);
          else if (/\d/.test(c) && r.options.smartSuperscript && o.treeBranch === "superscript" && ((l = o.parent) == null ? void 0 : l.type) !== "mop" && o.hasNoSiblings)
            Z.insert("math", i, c, { style: n }), qa(i);
          else {
            if (r.adoptStyle !== "none") {
              let d = r.adoptStyle === "left" ? o : a;
              (d == null ? void 0 : d.type) === "mord" && /[a-zA-Z]/.test(d.value) && /[a-zA-Z]/.test(c) && (d.style.variant && (n.variant = d.style.variant), d.style.variantStyle && (n.variantStyle = d.style.variantStyle));
            }
            Z.insert("math", i, c, { style: n });
          }
        }
      r.snapshotAndCoalesce(), r.dirty = true, r.scrollIntoView();
    }
    function Au(r) {
      let e = r.model, t = [], i = e.at(Math.min(e.position, e.anchor));
      for (; i.type !== "first"; )
        t.push(i), i = i.leftSibling;
      return t;
    }
    he({ undo: (r) => (yt(r, "accept"), r.undo(), true), redo: (r) => (yt(r, "accept"), r.redo(), true), scrollIntoView: (r) => (r.scrollIntoView(), true), scrollToStart: (r) => (r.field.scroll(0, 0), true), scrollToEnd: (r) => {
      let e = r.field.getBoundingClientRect();
      return r.field.scroll(e.left - window.scrollX, 0), true;
    }, toggleKeystrokeCaption: js, plonk: (r) => (r.model.announce("plonk"), true), switchMode: (r, e, t, i) => (r.switchMode(e, t, i), true), insert: (r, e, t) => r.insert(e, t), typedText: (r, e, t) => (qi(r, e, t), true), insertDecimalSeparator: (r) => {
      if (r.mode === "math" && window.MathfieldElement.decimalSeparator === ",") {
        let e = r.model;
        if (e.at(Math.max(e.position, e.anchor)).isDigit())
          return r.snapshot(), r.insert("{,}", { format: "latex" }), true;
      }
      return r.insert("."), true;
    }, commit: (r) => {
      var e;
      return H(r.model, { inputType: "insertLineBreak" }) && ((e = r.host) == null || e.dispatchEvent(new Event("change", { bubbles: true, composed: true })), J(r.model, { inputType: "insertLineBreak" })), true;
    } });
    he({ copyToClipboard: (r) => (r.focus(), r.model.selectionIsCollapsed && r.select(), "queryCommandSupported" in document && document.queryCommandSupported("copy") ? document.execCommand("copy") : r.element.querySelector(".ML__keyboard-sink").dispatchEvent(new ClipboardEvent("copy", { bubbles: true, composed: true })), false), cutToClipboard: (r) => (r.focus(), "queryCommandSupported" in document && document.queryCommandSupported("cut") ? document.execCommand("cut") : r.element.querySelector(".ML__keyboard-sink").dispatchEvent(new ClipboardEvent("cut", { bubbles: true, composed: true })), true), pasteFromClipboard: (r) => (r.focus(), "queryCommandSupported" in document && document.queryCommandSupported("paste") ? document.execCommand("paste") : navigator.clipboard.readText().then((e) => {
      e && H(r.model, { inputType: "insertFromPaste", data: e }) ? (r.snapshot(), r.insert(e) && (J(r.model, { inputType: "insertFromPaste" }), te(r))) : r.model.announce("plonk");
    }), true) }, { target: "mathfield", category: "clipboard" });
    function Lu(r, e) {
      r.flushInlineShortcutBuffer();
      let t = Xa(r, e), { model: i } = r;
      return i.selectionIsCollapsed ? (r.style.fontSeries && t.fontSeries === r.style.fontSeries && (t.fontSeries = "auto"), t.fontShape && t.fontShape === r.style.fontShape && (t.fontShape = "auto"), t.color && t.color === r.style.color && (t.color = "none"), t.backgroundColor && t.backgroundColor === r.style.backgroundColor && (t.backgroundColor = "none"), t.fontSize && t.fontSize === r.style.fontSize && (t.fontSize = "auto"), r.style = b(b({}, r.style), t)) : r.model.deferNotifications({ content: true, type: "insertText" }, () => {
        i.selection.ranges.forEach((o) => $i(i, o, t, { operation: "toggle" })), r.snapshot();
      }), true;
    }
    he({ applyStyle: Lu }, { target: "mathfield" });
    function Xa(r, e) {
      var o, a, n, s, l, c;
      let t = {};
      typeof e.color == "string" && (t.verbatimColor = e.color, t.color = (o = r.colorMap(e.color)) != null ? o : "none"), typeof e.backgroundColor == "string" && (t.verbatimBackgroundColor = e.backgroundColor, t.backgroundColor = (a = r.backgroundColorMap(e.backgroundColor)) != null ? a : "none"), typeof e.fontFamily == "string" && (t.fontFamily = e.fontFamily), typeof e.series == "string" && (t.fontSeries = e.series), typeof e.fontSeries == "string" && (t.fontSeries = e.fontSeries.toLowerCase()), t.fontSeries && (t.fontSeries = (n = { bold: "b", medium: "m", normal: "m" }[t.fontSeries]) != null ? n : t.fontSeries), typeof e.shape == "string" && (t.fontShape = e.shape), typeof e.fontShape == "string" && (t.fontShape = e.fontShape.toLowerCase()), t.fontShape && (t.fontShape = (s = { italic: "it", up: "n", upright: "n", normal: "n" }[t.fontShape]) != null ? s : t.fontShape);
      let i = (l = e.size) != null ? l : e.fontSize;
      return typeof i == "number" ? t.fontSize = Math.max(1, Math.min(10, i)) : typeof i == "string" && (t.fontSize = (c = { size1: 1, size2: 2, size3: 3, size4: 4, size5: 5, size6: 6, size7: 7, size8: 8, size9: 9, size10: 10 }[i.toLowerCase()]) != null ? c : { tiny: 1, scriptsize: 2, footnotesize: 3, small: 4, normal: 5, normalsize: 5, large: 6, Large: 7, LARGE: 8, huge: 9, Huge: 10 }[i]), t;
    }
    function Za(r) {
      var e, t, i, o, a, n;
      if (Po(r, r.position) === "text") {
        let s = Math.min(r.anchor, r.position), l = Math.max(r.anchor, r.position), c = false;
        for (; !c && s > 0; ) {
          let u = r.at(s);
          u.mode === "text" && $r.test(u.value) ? s -= 1 : c = true;
        }
        for (c = false; !c && l <= r.lastOffset; ) {
          let u = r.at(l);
          u.mode === "text" && $r.test(u.value) ? l += 1 : c = true;
        }
        if (c && (l -= 1), s >= l)
          return r.setSelection(l - 1, l), true;
        r.setSelection(s, l);
      } else {
        let s = r.at(r.position);
        if (s.isDigit()) {
          let l = Math.min(r.anchor, r.position), c = Math.max(r.anchor, r.position);
          for (; (e = r.at(l)) != null && e.isDigit(); )
            l -= 1;
          for (; (t = r.at(c)) != null && t.isDigit(); )
            c += 1;
          r.setSelection(l, c - 1);
        } else if (s.style.variant || s.style.variantStyle) {
          let l = Math.min(r.anchor, r.position), c = Math.max(r.anchor, r.position), u = (i = r.at(l)) == null ? void 0 : i.style;
          for (; u && u.variant === s.style.variant && u.variantStyle === s.style.variantStyle; )
            l -= 1, u = (o = r.at(l)) == null ? void 0 : o.style;
          for (u = (a = r.at(c)) == null ? void 0 : a.style; u && u.variant === s.style.variant && u.variantStyle === s.style.variantStyle; )
            c += 1, u = (n = r.at(c)) == null ? void 0 : n.style;
          r.setSelection(l, c - 1);
        } else
          r.setSelection(r.offsetOf(s.firstSibling), r.offsetOf(s.lastSibling));
      }
      return true;
    }
    he({ selectGroup: (r) => {
      let e = Za(r);
      return e || r.announce("plonk"), e;
    }, selectAll: (r) => r.setSelection(0, r.lastOffset), extendSelectionForward: (r) => {
      let e = r.extendSelection("forward");
      return e || r.announce("plonk"), e;
    }, extendSelectionBackward: (r) => {
      let e = r.extendSelection("backward");
      return e || r.announce("plonk"), e;
    }, extendToNextWord: (r) => fr(r, "forward", { extend: true }), extendToPreviousWord: (r) => fr(r, "backward", { extend: true }), extendSelectionUpward: (r) => xt(r, "upward", { extend: true }), extendSelectionDownward: (r) => xt(r, "downward", { extend: true }), extendToNextBoundary: (r) => fr(r, "forward", { extend: true }), extendToPreviousBoundary: (r) => fr(r, "backward", { extend: true }), extendToGroupStart: (r) => {
      let e = r.setSelection(r.anchor, r.offsetOf(r.at(r.position).firstSibling));
      return e || r.announce("plonk"), e;
    }, extendToGroupEnd: (r) => {
      let e = r.setSelection(r.anchor, r.offsetOf(r.at(r.position).lastSibling));
      return e || r.announce("plonk"), e;
    }, extendToMathFieldStart: (r) => {
      let e = r.setSelection(r.anchor, 0);
      return e || r.announce("plonk"), e;
    }, extendToMathFieldEnd: (r) => {
      let e = r.setSelection(r.anchor, r.lastOffset);
      return e || r.announce("plonk"), e;
    } }, { target: "model", category: "selection-extend" });
    var Br = null, Vi = 0;
    function Qs(r) {
      return r instanceof PointerEvent;
    }
    function Ya(r, e) {
      var k;
      r.atomBoundsCache = /* @__PURE__ */ new Map();
      let t = r, i, o = false, n = "none";
      if (e.buttons > 1)
        return;
      let s = false, l = false, c = e.clientX, u = e.clientY, d = Date.now(), m = t.field, h = setInterval(() => {
        s ? m.scroll({ top: 0, left: m.scrollLeft - 16 }) : l && m.scroll({ top: 0, left: m.scrollLeft + 16 });
      }, 32);
      function f(S) {
        "PointerEvent" in window ? (Ti(m, "pointermove", y), Ti(m, "pointerup pointercancel", f), S instanceof PointerEvent && m.releasePointerCapture(S.pointerId)) : (Ti(window, "mousemove", y), Ti(window, "mouseup blur", f)), o = false, clearInterval(h), r.element.classList.remove("tracking"), S && S.preventDefault();
      }
      function y(S) {
        if (!t.hasFocus()) {
          f(null);
          return;
        }
        let T = S.clientX, C = S.clientY, K = Qs(S) && S.pointerType === "touch" ? 20 : 5;
        if (Date.now() < d + 500 && Math.abs(c - T) < K && Math.abs(u - C) < K) {
          S.preventDefault(), S.stopPropagation();
          return;
        }
        let M = m.getBoundingClientRect();
        l = T > M.right, s = T < M.left;
        let R = i;
        Qs(S) && (S.isPrimary || (R = Or(t, S.clientX, S.clientY, { bias: 0 })));
        let F = Or(t, T, C, { bias: T <= c ? T === c ? 0 : -1 : 1 });
        R >= 0 && F >= 0 && (t.model.extendSelectionTo(R, F), te(r)), S.preventDefault(), S.stopPropagation();
      }
      Br && Math.abs(Br.x - c) < 5 && Math.abs(Br.y - u) < 5 && Date.now() < Br.time + 500 ? (Vi += 1, Br.time = d) : (Br = { x: c, y: u, time: d }, Vi = 1);
      let w = m.getBoundingClientRect();
      if (c >= w.left && c <= w.right && u >= w.top && u <= w.bottom) {
        if (r.hasFocus() || (n = "none", r.focus({ scrollIntoView: false })), r.flushInlineShortcutBuffer(), r.smartModeSuppressed = false, r.adoptStyle = "left", i = Or(r, c, u, { bias: 0 }), i >= 0) {
          if (r.element.classList.add("tracking"), e.shiftKey) {
            let S = r.model.selectionIsCollapsed;
            r.model.extendSelectionTo(r.model.anchor, i), Ka(r.model) || S ? n = "all" : n = "selection";
          } else
            r.model.at(i).type === "placeholder" ? (r.model.setSelection(i - 1, i), n = "selection") : ((k = r.model.at(i).rightSibling) == null ? void 0 : k.type) === "placeholder" ? (r.model.setSelection(i, i + 1), n = "selection") : (r.model.position = i, Ka(r.model) ? n = "all" : n = "selection");
          r.style = {}, e.detail === 3 || Vi > 2 ? (f(e), (e.detail === 3 || Vi === 3) && (r.model.selection = { ranges: [[0, r.model.lastOffset]] }, n = "all")) : o || (o = true, "PointerEvent" in window ? (je(m, "pointermove", y), je(m, "pointerup pointercancel", f), e instanceof PointerEvent && m.setPointerCapture(e.pointerId)) : (je(window, "blur", f), je(window, "mousemove", y), je(window, "mouseup", f)), (e.detail === 2 || Vi === 2) && (Za(r.model), n = "all"));
        }
      } else
        Br = null;
      n !== "none" && (r.model.selectionIsCollapsed && (n = "all"), te(r)), e.preventDefault();
    }
    function Cu(r, e, t) {
      if (r >= t.left && r <= t.right && e >= t.top && e <= t.bottom)
        return 0;
      let i = r - (t.left + t.right) / 2, o = e - (t.top + t.bottom) / 2;
      return i * i + o * o;
    }
    function el(r, e, t, i, o) {
      if (!t.id)
        return [1 / 0, null];
      if (e.has(t.id))
        return e.get(t.id);
      let a = mr(r, t);
      if (!a)
        return [1 / 0, null];
      let n = [1 / 0, null];
      if (t.hasChildren && !t.captureSelection && i >= a.left && i <= a.right)
        for (let s of t.children) {
          let l = el(r, e, s, i, o);
          l[0] <= n[0] && (n = l);
        }
      return n[1] || (n = [Cu(i, o, a), t]), e.set(t.id, n), n;
    }
    function Tu(r, e, t) {
      let [, i] = el(r, /* @__PURE__ */ new Map(), r.model.root, e, t);
      return i;
    }
    function Or(r, e, t, i) {
      var c, u;
      let o = (c = r.fieldContent) == null ? void 0 : c.getBoundingClientRect();
      if (!o)
        return 0;
      if (e > o.right || t > o.bottom + 8)
        return r.model.lastOffset;
      if (e < o.left || t < o.top - 8)
        return 0;
      i = i != null ? i : {}, i.bias = (u = i.bias) != null ? u : 0;
      let a = Tu(r, e, t), n = [], s = a;
      for (; s; )
        n.unshift(s), s = s.parent;
      for (let d of n)
        if (d.captureSelection) {
          a = d;
          break;
        }
      let l = r.model.offsetOf(a);
      if (l < 0)
        return -1;
      if (a.leftSibling)
        if (i.bias === 0 && a.type !== "placeholder") {
          let d = mr(r, a);
          d && e < (d.left + d.right) / 2 && (l = r.model.offsetOf(a.leftSibling));
        } else
          i.bias < 0 && (l = r.model.offsetOf(a.leftSibling));
      return l;
    }
    var Qa = class extends Z {
      constructor() {
        super("text");
      }
      onPaste(e, t) {
        if (!t)
          return false;
        let i = typeof t == "string" ? t : t.getData("text/plain");
        return i && H(e.model, { inputType: "insertFromPaste", data: i }) ? (e.snapshot(), this.insert(e.model, i) && (J(e.model, { inputType: "insertFromPaste" }), te(e)), true) : false;
      }
      insert(e, t, i = {}) {
        if (!H(e, { data: t, inputType: "insertText" }))
          return false;
        i.insertionMode || (i.insertionMode = "replaceSelection"), i.selectionMode || (i.selectionMode = "placeholder"), i.format || (i.format = "auto");
        let { suppressChangeNotifications: o } = e;
        i.suppressChangeNotifications && (e.suppressChangeNotifications = true);
        let a = e.suppressChangeNotifications;
        e.suppressChangeNotifications = true, i.insertionMode === "replaceSelection" && !e.selectionIsCollapsed ? e.deleteAtoms(xe(e.selection)) : i.insertionMode === "replaceAll" ? (e.root.setChildren([], "body"), e.position = 0) : i.insertionMode === "insertBefore" ? e.collapseSelection("backward") : i.insertionMode === "insertAfter" && e.collapseSelection("forward");
        let n = Eu(t, e.mathfield);
        if (Bt(n, i.style), !n)
          return false;
        let s = e.at(e.position), l = s.parent.addChildrenAfter(n, s);
        return e.suppressChangeNotifications = a, i.selectionMode === "before" || (i.selectionMode === "item" ? e.setSelection(e.anchor, e.offsetOf(l)) : l && (e.position = e.offsetOf(l))), J(e, { data: t, inputType: "insertText" }), e.suppressChangeNotifications = o, true;
      }
    };
    function Eu(r, e) {
      return r = r.replace(/\\/g, "\\textbackslash "), r = r.replace(/#/g, "\\#"), r = r.replace(/\$/g, "\\$"), r = r.replace(/%/g, "\\%"), r = r.replace(/&/g, "\\&"), r = r.replace(/_/g, "\\_"), r = r.replace(/{/g, "\\textbraceleft "), r = r.replace(/}/g, "\\textbraceright "), r = r.replace(/\^/g, "\\textasciicircum "), r = r.replace(/~/g, "\\textasciitilde "), r = r.replace(/£/g, "\\textsterling "), pe(r, e, { parseMode: "text" });
    }
    new Qa();
    var en, tn, Pu = '<svg style="width: 21px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path d="M528 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h480c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm16 336c0 8.823-7.177 16-16 16H48c-8.823 0-16-7.177-16-16V112c0-8.823 7.177-16 16-16h480c8.823 0 16 7.177 16 16v288zM168 268v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-336 80v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm384 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zM120 188v-24c0-6.627-5.373-12-12-12H84c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm96 0v-24c0-6.627-5.373-12-12-12h-24c-6.627 0-12 5.373-12 12v24c0 6.627 5.373 12 12 12h24c6.627 0 12-5.373 12-12zm-96 152v-8c0-6.627-5.373-12-12-12H180c-6.627 0-12 5.373-12 12v8c0 6.627 5.373 12 12 12h216c6.627 0 12-5.373 12-12z"/></svg>', Fo = class {
      constructor(e, t) {
        this.focusBlurInProgress = false;
        this.stylesheets = [];
        var a;
        this.options = Ur(E(b({}, jr()), { registers: po(this) }), t), t.eventSink && (this.host = t.eventSink), this.element = e, e.mathfield = this, en || (en = Xe(Ie).toString(36)), this.stylesheets.push(Ze(e, Ie, en)), tn || (tn = Xe($a).toString(36)), this.stylesheets.push(Ze(e, $a, tn)), this.blurred = true, this.keystrokeCaptionVisible = false, this.popoverVisible = false, this.suggestionIndex = 0, this.inlineShortcutBuffer = [], this.inlineShortcutBufferFlushTimer = 0, this.mode = yo(this.options), this.smartModeSuppressed = false, this.style = {}, this.adoptStyle = "left", this.options.defaultMode === "inline-math" ? this.element.classList.add("ML__is-inline") : this.element.classList.remove("ML__is-inline"), this.dirty = false, this.model = new Ni({ mode: yo(this.options), macros: this.options.macros, removeExtraneousParentheses: this.options.removeExtraneousParentheses }, { onSelectionDidChange: () => this._onSelectionDidChange() }, this), this.undoManager = new Do(this.model);
        let i = (a = t.value) != null ? a : this.element.textContent;
        i && (i = i.trim()), i && Z.insert("math", this.model, i, { insertionMode: "replaceAll", selectionMode: "after", format: "latex", suppressChangeNotifications: true });
        let o = [];
        if (o.push("<span contenteditable=true aria-multiline=false part=keyboard-sink class=ML__keyboard-sink autocapitalize=off autocomplete=off autocorrect=off spellcheck=false inputmode=none tabindex=0></span>"), o.push('<span part=container class=ML__container aria-hidden=true  style="visibility:hidden">'), o.push("<span part=content class=ML__content>"), o.push(za(this)), o.push("</span>"), o.push(`<div part=virtual-keyboard-toggle class=ML__virtual-keyboard-toggle role=button ${this.hasEditableContent ? "" : 'style="display:none;"'}data-ML__tooltip="${kt("tooltip.toggle virtual keyboard")}">`), o.push(Pu), o.push("</div>"), o.push("</span>"), o.push("<span class=ML__sr-only>"), o.push("<span role=status aria-live=assertive aria-atomic=true></span>"), o.push("</span>"), this.element.innerHTML = window.MathfieldElement.createHTML(o.join("")), !this.element.children) {
          console.error("%cMathLive 0.90.9: Something went wrong and the mathfield could not be created.%c\nIf you are using Vue, this may be because you are using the runtime-only build of Vue. Make sure to include `runtimeCompiler: true` in your Vue configuration. There may a warning from Vue in the log above.", "color:red;font-family:system-ui;font-size:1.2rem;font-weight:bold", "color:inherit;font-family:system-ui;font-size:inherit;font-weight:inherit");
          return;
        }
        this.field = this.element.querySelector("[part=content]"), this.field.addEventListener("click", (n) => n.stopImmediatePropagation(), { capture: false }), this.field.addEventListener("wheel", this, { passive: false }), "PointerEvent" in window ? this.field.addEventListener("pointerdown", this) : this.field.addEventListener("mousedown", this), ti(this.element.querySelector("[part=virtual-keyboard-toggle]"), (n) => this.executeCommand(n), { default: "toggleVirtualKeyboard", shift: "toggleVirtualKeyboardShift" }), this.ariaLiveText = this.element.querySelector("[role=status]"), this.keyboardDelegate = Vs(this.element.querySelector(".ML__keyboard-sink"), this.element, { onFocus: () => this.onFocus(), onBlur: () => this.onBlur(), onInput: (n) => qi(this, n), onKeystroke: (n, s) => ja(this, n, s), onCompositionStart: (n) => this.onCompositionStart(n), onCompositionUpdate: (n) => this.onCompositionUpdate(n), onCompositionEnd: (n) => this.onCompositionEnd(n), onCut: (n) => {
          if (!this.isSelectionEditable) {
            this.model.announce("plonk");
            return;
          }
          H(this.model, { inputType: "deleteByCut" }) && (this.snapshot(), Z.onCopy(this, n), mt(this.model, xe(this.model.selection), "deleteByCut"), te(this));
        }, onCopy: (n) => Z.onCopy(this, n), onPaste: (n) => {
          let s = this.isSelectionEditable;
          return s && (s = Z.onPaste(this.model.at(this.model.position).mode, this, n.clipboardData)), s || this.model.announce("plonk"), n.preventDefault(), n.stopPropagation(), s;
        } }), window.addEventListener("resize", this), window === window.top && window.addEventListener("blur", () => {
          qt(this) && this.hasFocus() && window.addEventListener("focus", (n) => {
            n.target === window && qt(this) && this.focus();
          }, { once: true });
        }, { capture: true }), this.undoManager.startRecording(), this.undoManager.snapshot(), $e !== "ready" && document.fonts.ready.then(() => Fi(this)), e.querySelector(".ML__container").style.removeProperty("visibility");
      }
      connectToVirtualKeyboard() {
        this.connectedToVirtualKeyboard || (this.connectedToVirtualKeyboard = true, window.addEventListener("message", this), window.mathVirtualKeyboard.connect(), window.mathVirtualKeyboard.updateToolbar(Vt(this)));
      }
      disconnectFromVirtualKeyboard() {
        this.connectedToVirtualKeyboard && (window.removeEventListener("message", this), window.mathVirtualKeyboard.disconnect(), this.connectedToVirtualKeyboard = false);
      }
      get colorMap() {
        return (e) => {
          var i;
          let t;
          return typeof ((i = this.options) == null ? void 0 : i.colorMap) == "function" && (t = this.options.colorMap(e)), t || (t = br(e)), t;
        };
      }
      get backgroundColorMap() {
        return (e) => {
          var i;
          let t;
          return typeof ((i = this.options) == null ? void 0 : i.backgroundColorMap) == "function" && (t = this.options.backgroundColorMap(e)), !t && typeof this.options.colorMap == "function" && (t = this.options.colorMap(e)), t || (t = Rr(e)), t;
        };
      }
      get fractionNavigationOrder() {
        return window.MathfieldElement.fractionNavigationOrder;
      }
      get placeholderSymbol() {
        var e, t;
        return (t = (e = this.options) == null ? void 0 : e.placeholderSymbol) != null ? t : "▢";
      }
      get smartFence() {
        var e, t;
        return (t = (e = this.options) == null ? void 0 : e.smartFence) != null ? t : false;
      }
      get readOnly() {
        var e, t;
        return (t = (e = this.options) == null ? void 0 : e.readOnly) != null ? t : false;
      }
      get disabled() {
        var e, t;
        return (t = (e = this.host) == null ? void 0 : e.disabled) != null ? t : false;
      }
      get contentEditable() {
        var e;
        return ((e = this.host) == null ? void 0 : e.getAttribute("contenteditable")) !== "false";
      }
      get userSelect() {
        if (!this.host)
          return "";
        let e = getComputedStyle(this.host);
        return e.getPropertyValue("user-select") || e.getPropertyValue("-webkit-user-select");
      }
      get hasEditableContent() {
        return this.disabled || !this.contentEditable ? false : !this.readOnly || this.hasEditablePrompts;
      }
      get hasEditablePrompts() {
        return this.readOnly && !this.disabled && this.contentEditable && this.model.findAtom((e) => e.type === "prompt" && !e.locked) !== void 0;
      }
      get isSelectionEditable() {
        if (this.disabled || !this.contentEditable)
          return false;
        if (!this.readOnly)
          return true;
        let e = this.model.at(this.model.anchor), t = this.model.at(this.model.position), i = g.commonAncestor(e, t);
        return !!(i != null && i.parentPrompt);
      }
      get letterShapeStyle() {
        var e, t;
        return (t = (e = this.options) == null ? void 0 : e.letterShapeStyle) != null ? t : "tex";
      }
      get registers() {
        var e, t;
        return (t = (e = this.options) == null ? void 0 : e.registers) != null ? t : {};
      }
      getDefinition(e, t = "math") {
        return xi(e, t);
      }
      getMacro(e) {
        return oo(e, this.options.macros);
      }
      get keybindings() {
        var i, o;
        if (this._keybindings)
          return this._keybindings;
        let [e, t] = ys(this.options.keybindings, (i = pr()) != null ? i : ka);
        return ((o = pr()) == null ? void 0 : o.score) > 0 && (this._keybindings = e, t.length > 0 && console.error("MathLive 0.90.9: Invalid keybindings for current keyboard layout", t)), e;
      }
      setOptions(e) {
        this.options = Ur(this.options, e), this.model.setListeners({ onSelectionDidChange: (i) => this._onSelectionDidChange() }), this.model.options.macros = this.options.macros, this._keybindings = void 0, this.options.defaultMode === "inline-math" ? this.element.classList.add("ML__is-inline") : this.element.classList.remove("ML__is-inline"), this.options.readOnly && this.hasFocus() && window.mathVirtualKeyboard.visible && this.executeCommand("hideVirtualKeyboard");
        let t = g.serialize(this.model.root, { expandMacro: false, defaultMode: this.options.defaultMode });
        ("macros" in e || this.model.getValue() !== t) && Z.insert("math", this.model, t, { insertionMode: "replaceAll", selectionMode: "after", format: "latex", suppressChangeNotifications: true }), te(this);
      }
      getOptions(e) {
        return Et(this.options, e);
      }
      getOption(e) {
        return Et(this.options, e);
      }
      handleEvent(e) {
        var t;
        if (qt(this)) {
          if (Di(e)) {
            if (!Qr(e.origin, (t = this.options.originValidator) != null ? t : "none"))
              throw new DOMException(`Message from unknown origin (${e.origin}) cannot be handled`, "SecurityError");
            let { action: i } = e.data;
            if (i === "execute-command") {
              let o = e.data.command;
              if (hr(o) === "virtual-keyboard")
                return;
              this.executeCommand(o);
            } else
              i === "update-state" || (i === "focus" ? this.focus() : i === "blur" && this.blur());
            return;
          }
          switch (e.type) {
            case "focus":
              this.onFocus();
              break;
            case "blur":
              this.onBlur();
              break;
            case "mousedown":
              Ya(this, e);
              break;
            case "pointerdown":
              Ya(this, e);
              break;
            case "resize":
              this.resizeTimer && cancelAnimationFrame(this.resizeTimer), this.resizeTimer = requestAnimationFrame(() => qt(this) && this.onResize());
              break;
            case "wheel":
              this.onWheel(e);
              break;
            default:
              console.warn("Unexpected event type", e.type);
          }
        }
      }
      dispose() {
        if (!qt(this))
          return;
        this.disconnectFromVirtualKeyboard();
        let e = this.element;
        delete this.element, delete e.mathfield, e.innerHTML = this.model.getValue(), e.removeEventListener("pointerdown", this), e.removeEventListener("mousedown", this), e.removeEventListener("focus", this), e.removeEventListener("blur", this), window.removeEventListener("resize", this), window.removeEventListener("blur", this, { capture: true }), delete this.ariaLiveText, delete this.field, delete this.fieldContent, Ps(this), Zs(this), this.stylesheets.forEach((t) => t == null ? void 0 : t.release());
      }
      flushInlineShortcutBuffer(e) {
        if (e != null || (e = { defer: false }), !e.defer) {
          this.inlineShortcutBuffer = [], clearTimeout(this.inlineShortcutBufferFlushTimer), this.inlineShortcutBufferFlushTimer = 0;
          return;
        }
        this.options.inlineShortcutTimeout > 0 && (clearTimeout(this.inlineShortcutBufferFlushTimer), this.inlineShortcutBufferFlushTimer = setTimeout(() => this.flushInlineShortcutBuffer(), this.options.inlineShortcutTimeout));
      }
      executeCommand(e) {
        return hr(e) === "virtual-keyboard" ? (this.focus({ scrollIntoView: false }), window.mathVirtualKeyboard.executeCommand(e), requestAnimationFrame(() => window.mathVirtualKeyboard.updateToolbar(Vt(this))), false) : Ks(this, e);
      }
      get errors() {
        return co(this.model.getValue(), this);
      }
      getValue(e, t, i) {
        return this.model.getValue(e, t, i);
      }
      setValue(e, t) {
        var o;
        t = t != null ? t : { mode: "math" }, t.insertionMode === void 0 && (t.insertionMode = "replaceAll"), (t.format === void 0 || t.format === "auto") && (t.format = "latex");
        let i = "math";
        (t.mode === void 0 || t.mode === "auto") && (i = (o = Po(this.model, this.model.position)) != null ? o : "math"), Z.insert(i, this.model, e, t) && (this.undoManager.snapshot(), te(this));
      }
      get expression() {
        let e = window.MathfieldElement.computeEngine;
        return e ? e.box(e.parse(this.model.getValue())) : (console.error("MathLive 0.90.9:  no compute engine available. Make sure the Compute Engine library is loaded."), null);
      }
      scrollIntoView() {
        var i;
        if (!this.element)
          return;
        (i = this.host) == null || i.scrollIntoView({ block: "nearest", inline: "nearest" }), this.dirty && Gt(this, { interactive: true });
        let e = this.field.getBoundingClientRect(), t = null;
        if (this.model.selectionIsCollapsed)
          t = Lr(this.field);
        else {
          let o = wo(this);
          if (o.length > 0) {
            let a = -1 / 0, n = -1 / 0;
            for (let s of o)
              s.right > a && (a = s.right), s.top < n && (n = s.top);
            t = { x: a + e.left - this.field.scrollLeft, y: n + e.top - this.field.scrollTop, height: 0 };
          }
        }
        if (this.host && t) {
          let o = this.host.getBoundingClientRect(), a = t.y, n = this.host.scrollTop;
          a < o.top ? n = a - o.top + this.host.scrollTop : a > o.bottom && (n = a - o.bottom + this.host.scrollTop + t.height), this.host.scroll({ top: n, left: 0 });
        }
        if (t) {
          let o = t.x - window.scrollX, a = this.field.scrollLeft;
          o < e.left ? a = o - e.left + this.field.scrollLeft - 20 : o > e.right && (a = o - e.right + this.field.scrollLeft + 20), this.field.scroll({ top: this.field.scrollTop, left: a });
        }
      }
      insert(e, t) {
        if (typeof e != "string" || e.length === 0 && ((t == null ? void 0 : t.insertionMode) === "insertBefore" || (t == null ? void 0 : t.insertionMode) === "insertAfter") || e.length === 0 && this.model.selectionIsCollapsed)
          return false;
        if (this.flushInlineShortcutBuffer(), t = t != null ? t : { mode: "math" }, t.focus && this.focus(), t.feedback && (re.keypressVibration && Ui() && navigator.vibrate(Ra), window.MathfieldElement.playSound("keypress")), t.scrollIntoView && this.scrollIntoView(), e === "\\\\")
          Na(this.model);
        else if (e === "&")
          Ia(this.model);
        else {
          let i = this.style;
          Z.insert(this.mode, this.model, e, b({ style: this.model.at(this.model.position).computedStyle }, t)), t.resetStyle && (this.style = i);
        }
        return this.undoManager.snapshot(), te(this), true;
      }
      switchMode(e, t = "", i = "") {
        var n;
        if (this.mode === e || this.readOnly || !this.contentEditable || this.disabled || !((n = this.host) != null && n.dispatchEvent(new Event("mode-change", { bubbles: true, composed: true, cancelable: true }))))
          return;
        let o = this.mode, { model: a } = this;
        a.deferNotifications({ content: !!i || !!t, selection: true, type: "insertText" }, () => {
          let s = false;
          if (this.flushInlineShortcutBuffer(), this.smartModeSuppressed = /text|math/.test(this.mode) && /text|math/.test(e), t && e !== "latex") {
            let l = pe(t, this, { parseMode: e });
            a.collapseSelection("forward");
            let c = a.at(a.position);
            a.position = a.offsetOf(c.parent.addChildrenAfter(l, c)), s = true;
          }
          if (this.mode = e, e === "latex") {
            let l = a.selectionIsCollapsed;
            yt(this, "accept");
            let c, u = a.at(a.position);
            if (l)
              c = "\\";
            else {
              let m = xe(a.selection);
              c = this.model.getValue(m, "latex");
              let h = this.model.extractAtoms(m);
              h.length === 1 && h[0] instanceof ie && (c = t, l = true), u = a.at(m[0]);
            }
            let d = new We(c, this);
            u.parent.addChildAfter(d, u), l ? a.position = a.offsetOf(d.lastChild) : a.setSelection(a.offsetOf(d.firstChild), a.offsetOf(d.lastChild));
          } else
            Pr(a).forEach((l) => {
              l.isError = false;
            });
          if (i) {
            let l = pe(i, this, { parseMode: o });
            a.collapseSelection("forward");
            let c = a.at(a.position);
            a.position = a.offsetOf(c.parent.addChildrenAfter(l, c)), s = true;
          }
          return te(this), s;
        }), this.mode = e;
      }
      hasFocus() {
        return !this.blurred;
      }
      focus(e) {
        var t;
        this.hasFocus() || (this.keyboardDelegate.focus(), this.connectToVirtualKeyboard(), this.model.announce("line")), ((t = e == null ? void 0 : e.scrollIntoView) == null || t) && this.scrollIntoView();
      }
      blur() {
        this.disconnectFromVirtualKeyboard(), this.hasFocus() && this.keyboardDelegate.blur();
      }
      select() {
        this.model.selection = { ranges: [[0, this.model.lastOffset]] };
      }
      applyStyle(e, t = {}) {
        var n, s;
        let i = { operation: "set", suppressChangeNotifications: false };
        Mr(t) ? i.range = t : (i.range = t.range, i.suppressChangeNotifications = (n = t.suppressChangeNotifications) != null ? n : false);
        let o = Xa(this, e), a = (s = i.operation) != null ? s : "set";
        this.model.deferNotifications({ content: !i.suppressChangeNotifications, type: "insertText" }, () => {
          if (i.range === void 0)
            for (let l of this.model.selection.ranges)
              $i(this.model, l, o, { operation: a });
          else
            $i(this.model, i.range, o, { operation: a });
        }), te(this);
      }
      getCaretPoint() {
        let e = Lr(this.field);
        return e ? { x: e.x, y: e.y } : null;
      }
      setCaretPoint(e, t) {
        let i = Or(this, e, t, { bias: 0 });
        if (i < 0)
          return false;
        let o = this.model.position;
        return this.model.position = i, this.model.announce("move", o), te(this), true;
      }
      getPrompt(e) {
        let t = this.model.findAtom((i) => i.type === "prompt" && i.placeholderId === e);
        return t;
      }
      getPromptValue(e, t) {
        let i = this.getPrompt(e);
        if (!i)
          return console.error(`MathLive 0.90.9: unknown prompt ${e}`), "";
        let o = this.model.offsetOf(i.firstChild), a = this.model.offsetOf(i.lastChild);
        return this.model.getValue(o, a, t);
      }
      getPrompts(e) {
        return this.model.getAllAtoms().filter((t) => t.type !== "prompt" ? false : e ? !(e.id && t.placeholderId !== e.id || e.locked && t.locked !== e.locked || e.correctness === "undefined" && t.correctness || e.correctness && t.correctness !== e.correctness) : true).map((t) => t.placeholderId);
      }
      setPromptValue(e, t, i) {
        if (t !== void 0) {
          let o = this.getPrompt(e);
          if (!o) {
            console.error(`MathLive 0.90.9: unknown prompt ${e}`);
            return;
          }
          let a = this.model.getBranchRange(this.model.offsetOf(o), "body");
          this.model.setSelection(a), this.insert(t, E(b({}, i), { insertionMode: "replaceSelection" }));
        }
        i != null && i.suppressChangeNotifications && (this.valueOnFocus = this.getValue()), te(this);
      }
      setPromptState(e, t, i) {
        let o = this.getPrompt(e);
        if (!o) {
          console.error(`MathLive 0.90.9: unknown prompt ${e}`);
          return;
        }
        t === "undefined" ? o.correctness = void 0 : typeof t == "string" && (o.correctness = t), typeof i == "boolean" && (o.locked = i, o.captureSelection = i), te(this);
      }
      getPromptState(e) {
        let t = this.getPrompt(e);
        return t ? [t.correctness, t.locked] : (console.error(`MathLive 0.90.9: unknown prompt ${e}`), [void 0, true]);
      }
      canUndo() {
        return this.undoManager.canUndo();
      }
      canRedo() {
        return this.undoManager.canRedo();
      }
      popUndoStack() {
        this.undoManager.pop();
      }
      snapshot() {
        var e;
        this.undoManager.snapshot() && (window.mathVirtualKeyboard.updateToolbar(Vt(this)), (e = this.host) == null || e.dispatchEvent(new CustomEvent("undo-state-change", { bubbles: true, composed: true, detail: { type: "snapshot" } })));
      }
      snapshotAndCoalesce() {
        var e;
        this.undoManager.snapshotAndCoalesce() && (window.mathVirtualKeyboard.updateToolbar(Vt(this)), (e = this.host) == null || e.dispatchEvent(new CustomEvent("undo-state-change", { bubbles: true, composed: true, detail: { type: "snapshot" } })));
      }
      undo() {
        var e;
        this.undoManager.undo() && (window.mathVirtualKeyboard.updateToolbar(Vt(this)), (e = this.host) == null || e.dispatchEvent(new CustomEvent("undo-state-change", { bubbles: true, composed: true, detail: { type: "undo" } })));
      }
      redo() {
        var e;
        this.undoManager.redo() && (window.mathVirtualKeyboard.updateToolbar(Vt(this)), (e = this.host) == null || e.dispatchEvent(new CustomEvent("undo-state-change", { bubbles: true, composed: true, detail: { type: "undo" } })));
      }
      resetUndo() {
        var e;
        (e = this.undoManager) == null || e.reset();
      }
      _onSelectionDidChange() {
        var t, i;
        let e = this.model;
        this.keyboardDelegate.setValue(this.model.getValue(this.model.selection, "latex-expanded"));
        {
          let o = e.at(e.position), a = (t = o.mode) != null ? t : yo(this.options);
          this.mode !== a && (this.mode === "latex" ? (yt(this, "accept", { mode: a }), e.position = e.offsetOf(o)) : this.switchMode(a));
        }
        (i = this.host) == null || i.dispatchEvent(new Event("selection-change", { bubbles: true, composed: true }));
      }
      onFocus() {
        this.focusBlurInProgress || !this.blurred || (this.focusBlurInProgress = true, this.blurred = false, this.keyboardDelegate.focus(), Gt(this, { interactive: true }), this.valueOnFocus = this.model.getValue(), this.hasEditablePrompts && !this.model.at(this.model.anchor).parentPrompt && this.executeCommand("moveToNextPlaceholder"), this.focusBlurInProgress = false);
      }
      onBlur() {
        var e, t, i;
        this.focusBlurInProgress || this.blurred || (this.focusBlurInProgress = true, this.blurred = true, this.ariaLiveText.textContent = "", yt(this, "accept"), this.model.getValue() !== this.valueOnFocus && ((e = this.host) == null || e.dispatchEvent(new Event("change", { bubbles: true, composed: true }))), this.disconnectFromVirtualKeyboard(), (t = this.host) == null || t.dispatchEvent(new Event("blur", { bubbles: false, composed: true })), (i = this.host) == null || i.dispatchEvent(new UIEvent("focusout", { bubbles: true, composed: true })), te(this), this.focusBlurInProgress = false);
      }
      onCompositionStart(e) {
        this.model.deleteAtoms(xe(this.model.selection));
        let t = Lr(this.field);
        t && requestAnimationFrame(() => {
          Gt(this), this.keyboardDelegate.moveTo(t.x, t.y - t.height);
        });
      }
      onCompositionUpdate(e) {
        Is(this.model, e), te(this);
      }
      onCompositionEnd(e) {
        $s(this.model), qi(this, e, { simulateKeystroke: true });
      }
      onResize() {
        Ri(this);
      }
      onWheel(e) {
        let t = 5 * e.deltaX;
        if (!Number.isFinite(t) || t === 0)
          return;
        let i = this.field;
        t < 0 && i.scrollLeft === 0 || t > 0 && i.offsetWidth + i.scrollLeft >= i.scrollWidth || (i.scrollBy({ top: 0, left: t }), e.preventDefault(), e.stopPropagation());
      }
      getHTMLElement(e) {
        var i;
        let t = e;
        for (; !t.id && t.hasChildren; )
          t = e.children[0];
        if (t.id)
          return (i = this.fieldContent) == null ? void 0 : i.querySelector(`[data-atom-id="${t.id}"]`);
        throw new TypeError("Could not get an ID from atom");
      }
    };
    function Io(r, e, t) {
      if (r.at(e).mode !== "text")
        return e;
      let i = t === "backward" ? -1 : 1, o;
      if ($r.test(r.at(e).value)) {
        let a = e, n;
        do
          n = r.at(a).mode === "text" && $r.test(r.at(a).value), a += i;
        while (r.at(a) && n);
        o = r.at(a) ? a - 2 * i : a - i;
      } else if (/\s/.test(r.at(e).value)) {
        let a = e;
        for (; r.at(a) && r.at(a).mode === "text" && /\s/.test(r.at(a).value); )
          a += i;
        if (!r.at(a))
          o = a - i;
        else {
          let n = true;
          do
            n = r.at(a).mode === "text" && !/\s/.test(r.at(a).value), a += i;
          while (r.at(a) && n);
          o = r.at(a) ? a - 2 * i : a - i;
        }
      } else {
        let a = e;
        for (; r.at(a) && r.at(a).mode === "text" && !/\s/.test(r.at(a).value); )
          a += i;
        o = r.at(a) ? a : a - i;
        let n = true;
        for (; r.at(a) && n; )
          n = r.at(a).mode === "text" && /\s/.test(r.at(a).value), n && (o = a), a += i;
        o = r.at(a) ? a - 2 * i : a - i;
      }
      return o - (i > 0 ? 0 : 1);
    }
    function fr(r, e, t) {
      var n, s, l, c, u, d, m;
      let i = r.position;
      (n = t == null ? void 0 : t.extend) != null && n || r.collapseSelection(e);
      let o = r.at(r.position);
      if (e === "forward" && (o.type === "msubsup" ? (o = o.rightSibling, o || (o = r.at(r.position + 1))) : o = r.at(r.position + 1)), !o)
        return r.announce("plonk"), false;
      let a = r.offsetOf(o);
      if (o instanceof Je)
        a = Io(r, a, e);
      else if (o instanceof ae)
        if (o.isSuggestion)
          for (; o && o instanceof ae; )
            o.isSuggestion = false, a = r.offsetOf(o), o = o.rightSibling;
        else if (e === "forward") {
          if (o = o.rightSibling, !o || !(o instanceof ae))
            return r.announce("plonk"), false;
          for (; o && o instanceof ae && /[a-zA-Z\*]/.test(o.value); )
            a = r.offsetOf(o), o = o.rightSibling;
        } else {
          if (o = o.leftSibling, !o || !(o instanceof ae))
            return r.announce("plonk"), false;
          for (; o && o instanceof ae && /[a-zA-Z\*]/.test(o.value); )
            a = r.offsetOf(o), o = o.leftSibling;
        }
      else if (e === "forward" && o.type === "mopen") {
        let h = 0;
        do
          o.type === "mopen" ? h += 1 : o.type === "mclose" && (h -= 1), o = o.rightSibling;
        while (!o.isLastSibling && h !== 0);
        a = r.offsetOf(o.leftSibling);
      } else if (e === "backward" && o.type === "mclose") {
        let h = 0;
        do
          o.type === "mopen" ? h += 1 : o.type === "mclose" && (h -= 1), o = o.leftSibling;
        while (!o.isFirstSibling && h !== 0);
        a = r.offsetOf(o);
      } else if (e === "backward")
        if (o.type === "first")
          for (; a > 0 && o.type === "first"; )
            a -= 1, o = r.at(a);
        else {
          let h = o.type;
          o.type === "msubsup" && (a = r.offsetOf(r.at(a).leftSibling)), a -= 1;
          let f = (s = r.at(a)) == null ? void 0 : s.type;
          for (; a >= 0 && f === h; )
            ((l = r.at(a)) == null ? void 0 : l.type) === "msubsup" ? a = r.offsetOf(r.at(a).leftSibling) : a -= 1, f = r.at(a).type;
        }
      else {
        let { type: h } = o, f = (c = r.at(a)) == null ? void 0 : c.type, { lastOffset: y } = r;
        for (; a <= y && (f === h || f === "msubsup"); ) {
          for (; ((u = r.at(a).rightSibling) == null ? void 0 : u.type) === "msubsup"; )
            a = r.offsetOf(r.at(a).rightSibling);
          a += 1, f = (d = r.at(a)) == null ? void 0 : d.type;
        }
        a -= 1;
      }
      if ((m = t == null ? void 0 : t.extend) != null && m) {
        if (!r.setSelection(r.anchor, a))
          return r.announce("plonk"), false;
      } else {
        if (a === r.position)
          return r.announce("plonk"), false;
        r.position = a;
      }
      return r.announce("move", i), true;
    }
    function xt(r, e, t) {
      var a, n, s, l, c, u;
      if (t = t != null ? t : { extend: false }, r.mathfield.adoptStyle = e === "backward" ? "right" : "left", e !== "forward") {
        let [d, m] = To(r);
        d !== void 0 && m !== void 0 && r.deleteAtoms([d, m]);
      }
      if (e === "upward")
        return Du(r, t);
      if (e === "downward")
        return Bu(r, t);
      let i = r.position;
      if (t.extend)
        return r.extendSelection(e);
      if (r.selectionIsPlaceholder)
        return r.collapseSelection(e), xt(r, e);
      let o = () => {
        var m, h;
        let d = true;
        return r.suppressChangeNotifications || (d = (h = (m = r.mathfield.host) == null ? void 0 : m.dispatchEvent(new CustomEvent("move-out", { detail: { direction: e }, cancelable: true, bubbles: true, composed: true }))) != null ? h : true), d && r.announce("plonk"), d;
      };
      if (!r.collapseSelection(e)) {
        let d = r.position + (e === "forward" ? 1 : -1), m = r.at(d);
        if (d >= 0 && d <= r.lastOffset) {
          if (e === "forward")
            if (r.mathfield.hasEditablePrompts && !r.at(d).parentPrompt) {
              let y = r.getAtoms(d, -1).map((w) => [w, ...w.children]).flat().filter((w) => w.type === "prompt" && !w.captureSelection)[0];
              if (!y)
                return o();
              d = r.offsetOf(y) - 1;
            } else if (m.inCaptureSelection) {
              for (; !m.captureSelection; )
                m = m.parent;
              d = r.offsetOf(m);
            } else if (!m.isFirstSibling && m.isLastSibling && ((a = m.parent) != null && a.skipBoundary))
              if (d + 1 === r.lastOffset)
                d = d + 1;
              else
                return r.position = d, xt(r, "forward", t);
            else
              (n = m.parent) != null && n.skipBoundary && ((s = m.rightSibling) != null && s.isLastSibling) ? d += 2 : (l = m.parent) != null && l.skipBoundary && m.type === "first" ? d += 1 : m instanceof ae && m.isSuggestion && (m.isSuggestion = false);
          else if (e === "backward")
            if (r.mathfield.hasEditablePrompts && !r.at(d).parentPrompt) {
              let f = r.getAtoms(0, d).map((w) => [w, ...w.children]).flat().filter((w) => w.type === "prompt" && !w.captureSelection), y = f[f.length - 1];
              if (!y)
                return o();
              d = r.offsetOf(y) - 1;
            } else if ((c = m.parent) != null && c.inCaptureSelection) {
              for (; !m.captureSelection; )
                m = m.parent;
              d = Math.max(0, r.offsetOf(m.leftSibling));
            } else
              (m.skipBoundary || (u = m.parent) != null && u.skipBoundary && m.type === "first") && (d = Math.max(0, r.position - 2));
        }
        if (d < 0 || d > r.lastOffset)
          return o();
        r.setPositionHandlingPlaceholder(d);
      }
      return r.announce("move", i), true;
    }
    function Ku(r, e, t) {
      let i = 1 / 0, o = 0;
      for (; o < e.length; o++) {
        let a = xa(r.getHTMLElement(e[o])).right, n = Math.abs(t - a);
        if (n <= i)
          i = n;
        else
          break;
      }
      return e[o - 1];
    }
    function No(r, e, t, i, o) {
      let a = t.filter((l) => !r.mathfield.hasEditableContent || l.type === "prompt" && !l.captureSelection), n = xa(r.mathfield.getHTMLElement(e)).right, s = r.offsetOf(Ku(r.mathfield, a, n)) - (r.mathfield.hasEditableContent ? 1 : 0);
      if (i) {
        let [l, c] = r.selection.ranges[0], u;
        s < (o === "up" ? l : c) ? u = { ranges: [[s, c]], direction: "backward" } : u = { ranges: [[l, s]], direction: "forward" }, r.setSelection(u);
      } else
        r.setPositionHandlingPlaceholder(s);
      r.announce(`move ${o}`);
    }
    function Du(r, e) {
      var n, s;
      let t = (n = e == null ? void 0 : e.extend) != null ? n : false;
      t || r.collapseSelection("backward");
      let i = () => {
        var c, u;
        let l = true;
        return r.suppressChangeNotifications || (l = (u = (c = r.mathfield.host) == null ? void 0 : c.dispatchEvent(new CustomEvent("move-out", { detail: { direction: "upward" }, cancelable: true, bubbles: true, composed: true }))) != null ? u : true), r.announce(l ? "plonk" : "line"), l;
      }, o = r.at(r.position), a = o;
      for (; a && a.treeBranch !== "below" && !(Array.isArray(a.treeBranch) && a.parent instanceof X); )
        a = a.parent;
      if (Array.isArray(a == null ? void 0 : a.treeBranch) && a.parent instanceof X) {
        let l = a.parent;
        if (a.treeBranch[0] < 1)
          return i();
        let c = a.treeBranch[0] - 1, u = l.array[c][a.treeBranch[1]];
        if (!u.some((m) => m.type === "prompt" && !m.captureSelection) && r.mathfield.hasEditableContent)
          return i();
        No(r, o, u, t, "up");
      } else if (a) {
        let l = (s = a.parent.branch("above")) != null ? s : a.parent.createBranch("above");
        if (!l.some((u) => u.type === "prompt" && u.placeholderId) && r.mathfield.hasEditableContent)
          return i();
        No(r, o, l, t, "up");
      } else
        return i();
      return true;
    }
    function Bu(r, e) {
      var n, s;
      let t = (n = e == null ? void 0 : e.extend) != null ? n : false;
      t || r.collapseSelection("forward");
      let i = () => {
        var c, u;
        let l = true;
        return r.suppressChangeNotifications || (l = (u = (c = r.mathfield.host) == null ? void 0 : c.dispatchEvent(new CustomEvent("move-out", { detail: { direction: "downward" }, cancelable: true, bubbles: true, composed: true }))) != null ? u : true), r.announce(l ? "plonk" : "line"), l;
      }, o = r.at(r.position), a = o;
      for (; a && a.treeBranch !== "above" && !(Array.isArray(a.treeBranch) && a.parent instanceof X); )
        a = a.parent;
      if (Array.isArray(a == null ? void 0 : a.treeBranch) && a.parent instanceof X) {
        let l = a.parent;
        if (a.treeBranch[0] + 1 > l.array.length - 1)
          return i();
        let c = a.treeBranch[0] + 1, u = l.array[c][a.treeBranch[1]];
        if (!u.some((m) => m.type === "prompt" && !m.captureSelection) && r.mathfield.hasEditableContent)
          return i();
        No(r, o, u, t, "down");
      } else if (a) {
        let l = (s = a.parent.branch("below")) != null ? s : a.parent.createBranch("below");
        if (!l.some((u) => u.type === "prompt") && r.mathfield.hasEditableContent)
          return i();
        No(r, o, l, t, "down");
      } else
        return i();
      return true;
    }
    he({ deleteAll: (r) => H(r, { inputType: "deleteContent" }) && mt(r, [0, -1], "deleteContent"), deleteForward: (r) => Ns(r), deleteBackward: (r) => Fs(r), deleteNextWord: (r) => H(r, { inputType: "deleteWordForward" }) && mt(r, [r.anchor, Io(r, r.position, "forward")], "deleteWordForward"), deletePreviousWord: (r) => H(r, { inputType: "deleteWordBackward" }) && mt(r, [r.anchor, Io(r, r.position, "backward")], "deleteWordBackward"), deleteToGroupStart: (r) => H(r, { inputType: "deleteSoftLineBackward" }) && mt(r, [r.anchor, r.offsetOf(r.at(r.position).firstSibling)], "deleteSoftLineBackward"), deleteToGroupEnd: (r) => H(r, { inputType: "deleteSoftLineForward" }) && mt(r, [r.anchor, r.offsetOf(r.at(r.position).lastSibling)], "deleteSoftLineForward"), deleteToMathFieldStart: (r) => H(r, { inputType: "deleteHardLineBackward" }) && mt(r, [r.anchor, 0], "deleteHardLineBackward"), deleteToMathFieldEnd: (r) => H(r, { inputType: "deleteHardLineForward" }) && mt(r, [r.anchor, -1], "deleteHardLineForward") }, { target: "model", category: "delete" });
    function tl(r) {
      if (r && (r.classList.remove("ML__highlight"), r.children))
        for (let e of r.children)
          tl(e);
    }
    function rn(r, e) {
      var t;
      r && (!e || ((t = r.dataset) == null ? void 0 : t.atomId) === e ? (r.classList.add("ML__highlight"), r.children && r.children.length > 0 && [...r.children].forEach((i) => {
        i instanceof HTMLElement && rn(i);
      })) : (r.classList.remove("ML__highlight"), r.children && r.children.length > 0 && [...r.children].forEach((i) => {
        i instanceof HTMLElement && rn(i, e);
      })));
    }
    function rl(r, e) {
      var o;
      if (!fe())
        return;
      if (window.MathfieldElement.speechEngine !== "amazon") {
        console.error("MathLive 0.90.9: Use Amazon TTS Engine for synchronized highlighting"), typeof window.MathfieldElement.speakHook == "function" && window.MathfieldElement.speakHook(e);
        return;
      }
      if (!window.AWS) {
        console.error("MathLive 0.90.9: AWS SDK not loaded. See https://www.npmjs.com/package/aws-sdk");
        return;
      }
      let t = new window.AWS.Polly({ apiVersion: "2016-06-10" }), i = { OutputFormat: "json", VoiceId: (o = window.MathfieldElement.speechEngineVoice) != null ? o : "Joanna", Engine: "standard", Text: e, TextType: "ssml", SpeechMarkTypes: ["ssml"] };
      bt().readAloudElement = r, t.synthesizeSpeech(i, (a, n) => {
        if (a) {
          console.trace(`MathLive 0.90.9: \`polly.synthesizeSpeech()\` error: ${a}`);
          return;
        }
        if (!(n != null && n.AudioStream))
          return;
        let s = new TextDecoder("utf-8").decode(new Uint8Array(n.AudioStream));
        bt().readAloudMarks = s.split(`
`).map((l) => l ? JSON.parse(l) : {}), bt().readAloudTokens = [];
        for (let l of bt().readAloudMarks)
          l.value && bt().readAloudTokens.push(l.value);
        bt().readAloudCurrentMark = "", i.OutputFormat = "mp3", i.SpeechMarkTypes = [], t.synthesizeSpeech(i, (l, c) => {
          if (l) {
            console.trace(`MathLive 0.90.9: \`polly.synthesizeSpeech("${e}") error:${l}`);
            return;
          }
          if (!(c != null && c.AudioStream))
            return;
          let u = new Uint8Array(c.AudioStream), d = new Blob([u.buffer], { type: "audio/mpeg" }), m = URL.createObjectURL(d), h = bt();
          h.readAloudAudio ? h.readAloudAudio.pause() : (h.readAloudAudio = new Audio(), h.readAloudAudio.addEventListener("ended", () => {
            let f = h.readAloudMathField;
            h.readAloudStatus = "ended", document.body.dispatchEvent(new Event("read-aloud-status-change", { bubbles: true, composed: true })), f ? (Gt(f), h.readAloudElement = null, h.readAloudMathField = null, h.readAloudTokens = [], h.readAloudMarks = [], h.readAloudCurrentMark = "") : tl(h.readAloudElement);
          }), h.readAloudAudio.addEventListener("timeupdate", () => {
            let f = "", y = h.readAloudAudio.currentTime * 1e3 + 100;
            for (let w of h.readAloudMarks)
              w.time < y && (f = w.value);
            h.readAloudCurrentMark !== f && (h.readAloudCurrentToken = f, f && f === h.readAloudFinalToken ? h.readAloudAudio.pause() : (h.readAloudCurrentMark = f, rn(h.readAloudElement, h.readAloudCurrentMark)));
          })), h.readAloudAudio.src = m, h.readAloudStatus = "playing", document.body.dispatchEvent(new Event("read-aloud-status-change", { bubbles: true, composed: true })), h.readAloudAudio.play();
        });
      });
    }
    fe() || console.error('MathLive 0.90.9: this version of the MathLive library is for use in the browser. A subset of the API is available on the server side in the "mathlive-ssr" library. If using server side rendering (with React for example) you may want to do a dynamic import of the MathLive library inside a `useEffect()` call.');
    var on = fe() ? document.createElement("template") : null;
    on && (on.innerHTML = `<style>
  :host { display: inline-block; background-color: field; color: fieldtext; border-width: 1px; border-style: solid; border-color: #acacac; border-radius: 2px; padding:4px; pointer-events: none;}
  :host([hidden]) { display: none; }
  :host([disabled]), :host([disabled]:focus), :host([disabled]:focus-within) { outline: none; opacity:  .5; }
  :host(:focus), :host(:focus-within) {
    outline: Highlight auto 1px;    /* For Firefox */
    outline: -webkit-focus-ring-color auto 1px;
  }
  </style>
  <span style="pointer-events:auto"></span><slot style="display:none"></slot>`);
    var W = /* @__PURE__ */ new WeakMap(), Ou = 0.5, gr = { letterShapeStyle: "mf.letterShapeStyle = ...", horizontalSpacingScale: 'Removed. Use `"thinmuskip"`, `"medmuskip"`, and `"thickmuskip"` registers ', macros: "mf.macros = ...", registers: "mf.registers = ...", backgroundColorMap: "mf.backgroundColorMap = ...", colorMap: "mf.colorMap = ...", enablePopover: "mf.popoverPolicy = ...", mathModeSpace: "mf.mathModeSpace = ...", placeholderSymbol: "mf.placeholderSymbol = ...", readOnly: "mf.readOnly = ...", removeExtraneousParentheses: "mf.removeExtraneousParentheses = ...", scriptDepth: "mf.scriptDepth = ...", smartFence: "mf.smartFence = ...", smartMode: "mf.smartMode = ...", smartSuperscript: "mf.smartSuperscript = ...", inlineShortcutTimeout: "mf.inlineShortcutTimeout = ...", inlineShortcuts: "mf.inlineShortcuts = ...", keybindings: "mf.keybindings = ...", virtualKeyboardMode: "mf.mathVirtualKeyboardPolicy = ...", customVirtualKeyboardLayers: "mathVirtualKeyboard.layers = ...", customVirtualKeyboards: "mathVirtualKeyboard.layouts = ...", keypressSound: "mathVirtualKeyboard.keypressSound = ...", keypressVibration: "mathVirtualKeyboard.keypressVibration = ...", plonkSound: "mathVirtualKeyboard.plonkSound = ...", virtualKeyboardContainer: "mathVirtualKeyboard.container = ...", virtualKeyboardLayout: "mathVirtualKeyboard.alphabeticLayout = ...", virtualKeyboardTheme: "No longer supported", virtualKeyboardToggleGlyph: "No longer supported", virtualKeyboardToolbar: "mathVirtualKeyboard.actionToolbar = ...", virtualKeyboards: "Use `mathVirtualKeyboard.layouts`", speechEngine: "`MathfieldElement.speechEngine`", speechEngineRate: "`MathfieldElement.speechEngineRate`", speechEngineVoice: "`MathfieldElement.speechEngineVoice`", textToSpeechMarkup: "`MathfieldElement.textToSpeechMarkup`", textToSpeechRules: "`MathfieldElement.textToSpeechRules`", textToSpeechRulesOptions: "`MathfieldElement.textToSpeechRulesOptions`", readAloudHook: "`MathfieldElement.readAloudHook`", speakHook: "`MathfieldElement.speakHook`", computeEngine: "`MathfieldElement.computeEngine`", fontsDirectory: "`MathfieldElement.fontsDirectory`", soundsDirectory: "`MathfieldElement.soundsDirectory`", createHTML: "`MathfieldElement.createHTML`", onExport: "`MathfieldElement.onExport`", onInlineShortcut: "`MathfieldElement.onInlineShortcut`", locale: "MathfieldElement.locale = ...", strings: "MathfieldElement.strings = ...", decimalSeparator: "MathfieldElement.decimalSeparator = ...", fractionNavigationOrder: "MathfieldElement.fractionNavigationOrder = ..." }, yr = class extends HTMLElement {
      constructor(t) {
        super();
        if (t) {
          let o = [];
          for (let a of Object.keys(t))
            if (gr[a])
              if (gr[a].startsWith("mf."))
                if (gr[a].startsWith(`mf.${a}`))
                  o.push(`Option \`${a}\` cannot be used as a constructor option. Use ${gr[a]}`);
                else {
                  let n = gr[a].match(/([a-zA-Z]+) =/);
                  o.push(`Option \`${a}\` has been renamed \`${n[1]}\``);
                }
              else
                o.push(`Option \`${a}\` cannot be used as a constructor option. Use ${gr[a]}`);
            else
              o.push(`Unexpected option \`${a}\``);
          if (o.length > 0) {
            console.group("%cMathLive 0.90.9: %cInvalid Options", "color:#12b; font-size: 1.1rem", "color:#db1111; font-size: 1.1rem"), console.warn("Some of the options passed to `new MathFieldElement(...)` are invalid. \n          See https://cortexjs.io/mathlive/changelog/ for details.");
            for (let a of o)
              console.warn(a);
            console.groupEnd();
          }
        }
        ci() && (this._internals = this.attachInternals(), this._internals.role = "math", this._internals.ariaLabel = "math input field", this._internals.ariaMultiLine = "false"), this.attachShadow({ mode: "open", delegatesFocus: true }), this.shadowRoot.append(on.content.cloneNode(true));
        let i = this.shadowRoot.querySelector("slot:not([name])");
        this._slotValue = i.assignedNodes().map((o) => o.nodeType === 3 ? o.textContent : "").join("").trim(), t && this._setOptions(t);
      }
      static get formAssociated() {
        return ci();
      }
      static get optionsAttributes() {
        return { "default-mode": "string", "letter-shape-style": "string", "popover-policy": "string", "math-mode-space": "string", "read-only": "boolean", "remove-extraneous-parentheses": "on/off", "smart-fence": "on/off", "smart-mode": "on/off", "smart-superscript": "on/off", "inline-shortcut-timeout": "string", "script-depth": "string", "virtual-keyboard-target-origin": "string", "math-virtual-keyboard-policy": "string" };
      }
      static get observedAttributes() {
        return [...Object.keys(this.optionsAttributes), "contenteditable", "disabled", "readonly", "read-only"];
      }
      static get fontsDirectory() {
        return this._fontsDirectory;
      }
      static set fontsDirectory(t) {
        this._fontsDirectory = t, vs();
      }
      static get soundsDirectory() {
        return this._soundsDirectory;
      }
      static set soundsDirectory(t) {
        this._soundsDirectory = t, this.audioBuffers = {};
      }
      static get keypressSound() {
        return this._keypressSound;
      }
      static set keypressSound(t) {
        var i, o, a;
        this.audioBuffers = {}, t === null ? this._keypressSound = { spacebar: null, return: null, delete: null, default: null } : typeof t == "string" ? this._keypressSound = { spacebar: t, return: t, delete: t, default: t } : typeof t == "object" && "default" in t && (this._keypressSound = { spacebar: (i = t.spacebar) != null ? i : t.default, return: (o = t.return) != null ? o : t.default, delete: (a = t.delete) != null ? a : t.default, default: t.default });
      }
      static get plonkSound() {
        return this._plonkSound;
      }
      static set plonkSound(t) {
        this.audioBuffers = {}, this._plonkSound = t;
      }
      static get audioContext() {
        return this._audioContext || (this._audioContext = new AudioContext()), this._audioContext;
      }
      static get speechEngine() {
        return this._speechEngine;
      }
      static set speechEngine(t) {
        this._speechEngine = t;
      }
      static get speechEngineRate() {
        return this._speechEngineRate;
      }
      static set speechEngineRate(t) {
        this._speechEngineRate = t;
      }
      static get speechEngineVoice() {
        return this._speechEngineVoice;
      }
      static set speechEngineVoice(t) {
        this._speechEngineVoice = t;
      }
      static get textToSpeechMarkup() {
        return this._textToSpeechMarkup;
      }
      static set textToSpeechMarkup(t) {
        this._textToSpeechMarkup = t;
      }
      static get textToSpeechRules() {
        return this._textToSpeechRules;
      }
      static set textToSpeechRules(t) {
        this._textToSpeechRules = t;
      }
      static get textToSpeechRulesOptions() {
        return this._textToSpeechRulesOptions;
      }
      static set textToSpeechRulesOptions(t) {
        this._textToSpeechRulesOptions = t;
      }
      static get locale() {
        return U.locale;
      }
      static set locale(t) {
        t === "auto" && (t = navigator.language.slice(0, 5)), U.locale = t;
      }
      static get decimalSeparator() {
        return this._decimalSeparator;
      }
      static set decimalSeparator(t) {
        this._decimalSeparator = t, this._computeEngine && (this._computeEngine.latexOptions.decimalMarker = this.decimalSeparator === "," ? "{,}" : ".");
      }
      static get strings() {
        return U.strings;
      }
      static set strings(t) {
        U.merge(t);
      }
      static get computeEngine() {
        var t, i;
        if (this._computeEngine === void 0) {
          let o = (t = window[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : t.ComputeEngine;
          o ? this._computeEngine = new o() : console.error(`MathLive 0.90.9: The CortexJS Compute Engine library is not available.
          
          Load the library, for example with:
          
          import "https://unpkg.com/@cortex-js/compute-engine?module"`), this._computeEngine && this.decimalSeparator === "," && (this._computeEngine.latexOptions.decimalMarker = "{,}");
        }
        return (i = this._computeEngine) != null ? i : null;
      }
      static set computeEngine(t) {
        this._computeEngine = t;
      }
      static async loadSound(t) {
        delete this.audioBuffers[t];
        let i = "";
        switch (t) {
          case "keypress":
            i = this._keypressSound.default;
            break;
          case "return":
            i = this._keypressSound.return;
            break;
          case "spacebar":
            i = this._keypressSound.spacebar;
            break;
          case "delete":
            i = this._keypressSound.delete;
            break;
          case "plonk":
            i = this.plonkSound;
            break;
        }
        if (typeof i != "string")
          return;
        i = i.trim();
        let o = this.soundsDirectory;
        if (o == null || o === "null" || i === "none" || i === "null")
          return;
        let n = await (await fetch(await So(`${o}/${i}`))).arrayBuffer(), s = await this.audioContext.decodeAudioData(n);
        this.audioBuffers[t] = s;
      }
      static async playSound(t) {
        if (this.audioBuffers[t] || await this.loadSound(t), !this.audioBuffers[t])
          return;
        let i = this.audioContext.createBufferSource();
        i.buffer = this.audioBuffers[t];
        let o = this.audioContext.createGain();
        o.gain.value = Ou, i.connect(o).connect(this.audioContext.destination), i.start();
      }
      onPointerDown() {
        window.addEventListener("pointerup", (t) => {
          var i;
          t.target === this && !((i = this._mathfield) != null && i.disabled) && this.dispatchEvent(new MouseEvent("click", { altKey: t.altKey, button: t.button, buttons: t.buttons, clientX: t.clientX, clientY: t.clientY, ctrlKey: t.ctrlKey, metaKey: t.metaKey, movementX: t.movementX, movementY: t.movementY, relatedTarget: t.relatedTarget, screenX: t.screenX, screenY: t.screenY, shiftKey: t.shiftKey }));
        }, { once: true });
      }
      getPromptValue(t) {
        var i, o;
        return (o = (i = this._mathfield) == null ? void 0 : i.getPromptValue(t)) != null ? o : "";
      }
      getPrompts(t) {
        var i, o;
        return (o = (i = this._mathfield) == null ? void 0 : i.getPrompts(t)) != null ? o : [];
      }
      addEventListener(t, i, o) {
        return super.addEventListener(t, i, o);
      }
      removeEventListener(t, i, o) {
        super.removeEventListener(t, i, o);
      }
      get form() {
        var t;
        return (t = this._internals) == null ? void 0 : t.form;
      }
      get name() {
        var t;
        return (t = this.getAttribute("name")) != null ? t : "";
      }
      get type() {
        return this.localName;
      }
      get mode() {
        var t, i;
        return (i = (t = this._mathfield) == null ? void 0 : t.mode) != null ? i : "math";
      }
      set mode(t) {
        this._mathfield && (this._mathfield.mode = t);
      }
      get expression() {
        if (this._mathfield)
          return window[Symbol.for("io.cortexjs.compute-engine")] || console.error(`MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`), this._mathfield.expression;
      }
      set expression(t) {
        var o, a;
        if (!this._mathfield)
          return;
        let i = (a = (o = yr.computeEngine) == null ? void 0 : o.box(t).latex) != null ? a : null;
        i !== null && this._mathfield.setValue(i), window[Symbol.for("io.cortexjs.compute-engine")] || console.error(`MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`);
      }
      get errors() {
        var t, i;
        return (i = (t = this._mathfield) == null ? void 0 : t.errors) != null ? i : [];
      }
      _getOptions(t) {
        return this._mathfield ? Et(this._mathfield.options, t) : W.has(this) ? Et(Ur(jr(), W.get(this).options), t) : null;
      }
      getOptions(t) {
        return console.warn("%cMathLive 0.90.9: %cDeprecated Usage%c\n      `mf.getOptions()` is deprecated. Read the property directly on the mathfield instead.\n      See https://cortexjs.io/mathlive/changelog/ for details.", "color:#12b; font-size: 1.1rem", "color:#db1111; font-size: 1.1rem", "color: inherit, font-size: 1rem"), this._mathfield ? Et(this._mathfield.options, t) : W.has(this) ? Et(Ur(jr(), W.get(this).options), t) : null;
      }
      reflectAttributes() {
        let t = jr(), i = this._getOptions();
        Object.keys(yr.optionsAttributes).forEach((o) => {
          let a = Ot(o);
          yr.optionsAttributes[o] === "on/off" ? t[a] !== i[a] ? this.setAttribute(o, i[a] ? "on" : "off") : this.removeAttribute(o) : t[a] !== i[a] && (yr.optionsAttributes[o] === "boolean" ? i[a] ? this.setAttribute(o, "") : this.removeAttribute(o) : (typeof i[a] == "string" || typeof i[a] == "number") && this.setAttribute(o, i[a].toString()));
        });
      }
      getOption(t) {
        return console.warn("%cMathLive 0.90.9: %cDeprecated Usage%c\n      `mf.getOption()` is deprecated. Read the property directly on the mathfield instead.\n      See https://cortexjs.io/mathlive/changelog/ for details.", "color:#12b; font-size: 1.1rem", "color:#db1111; font-size: 1.1rem", "color: inherit, font-size: 1rem"), this._getOptions([t])[t];
      }
      _getOption(t) {
        return this._getOptions([t])[t];
      }
      _setOptions(t) {
        if (this._mathfield)
          this._mathfield.setOptions(t);
        else if (W.has(this)) {
          let i = b(b({}, W.get(this).options), t);
          W.set(this, E(b({}, W.get(this)), { selection: { ranges: i.readOnly ? [[0, 0]] : [[0, -1]] }, options: i }));
        } else
          W.set(this, { value: void 0, selection: { ranges: [[0, 0]] }, options: t });
        this.reflectAttributes();
      }
      setOptions(t) {
        console.group("%cMathLive 0.90.9: %cDeprecated Usage", "color:#12b; font-size: 1.1rem", "color:#db1111; font-size: 1.1rem"), console.warn(" `mf.setOptions()` is deprecated. Set the property directly on the mathfield instead.\n      See https://cortexjs.io/mathlive/changelog/ for details.");
        for (let i of Object.keys(t))
          gr[i] && console.warn(`\`mf.setOptions({${i}:...})\` -> ${gr[i]}`);
        console.groupEnd(), this._setOptions(t);
      }
      executeCommand(t) {
        var i, o;
        return (o = (i = this._mathfield) == null ? void 0 : i.executeCommand(t)) != null ? o : false;
      }
      getValue(t, i, o) {
        var a, n;
        if (this._mathfield)
          return this._mathfield.model.getValue(t, i, o);
        if (W.has(this)) {
          let s, l, c;
          if (Xr(t) ? ([s, l] = t.ranges[0], c = i) : Mr(t) ? ([s, l] = t, c = i) : Pt(t) && Pt(i) ? (s = t, l = i, c = o) : (s = 0, l = -1, c = t), (c === void 0 || c === "latex") && s === 0 && l === -1)
            return (n = (a = W.get(this).value) != null ? a : this.textContent) != null ? n : "";
        }
        return "";
      }
      setValue(t, i) {
        if (this._mathfield && t !== void 0) {
          i || (i = { suppressChangeNotifications: true }), this._mathfield.setValue(t, i);
          return;
        }
        if (W.has(this)) {
          let a = W.get(this).options;
          W.set(this, { value: t, selection: { ranges: a.readOnly ? [[0, 0]] : [[0, -1]], direction: "forward" }, options: a });
          return;
        }
        let o = $o(this);
        W.set(this, { value: t, selection: { ranges: o.readOnly ? [[0, 0]] : [[0, -1]], direction: "forward" }, options: o });
      }
      hasFocus() {
        var t, i;
        return (i = (t = this._mathfield) == null ? void 0 : t.hasFocus()) != null ? i : false;
      }
      focus() {
        var t;
        (t = this._mathfield) == null || t.focus();
      }
      blur() {
        var t;
        (t = this._mathfield) == null || t.blur();
      }
      select() {
        var t;
        (t = this._mathfield) == null || t.select();
      }
      insert(t, i) {
        var o, a;
        return (a = (o = this._mathfield) == null ? void 0 : o.insert(t, i)) != null ? a : false;
      }
      applyStyle(t, i) {
        var o;
        return (o = this._mathfield) == null ? void 0 : o.applyStyle(t, i);
      }
      get caretPoint() {
        var t, i;
        return (i = (t = this._mathfield) == null ? void 0 : t.getCaretPoint()) != null ? i : null;
      }
      set caretPoint(t) {
        var i;
        t && ((i = this._mathfield) == null || i.setCaretPoint(t.x, t.y));
      }
      setCaretPoint(t, i) {
        var o, a;
        return (a = (o = this._mathfield) == null ? void 0 : o.setCaretPoint(t, i)) != null ? a : false;
      }
      offsetFromPoint(t, i, o) {
        return this._mathfield ? Or(this._mathfield, t, i, o) : -1;
      }
      hitboxFromOffset(t) {
        if (!this._mathfield)
          return null;
        let i = this._mathfield.model.at(t);
        if (!i)
          return null;
        let o = mr(this._mathfield, i);
        return o ? new DOMRect(o.left, o.top, o.right - o.left, o.bottom - o.top) : null;
      }
      resetUndo() {
        var t;
        (t = this._mathfield) == null || t.resetUndo();
      }
      canUndo() {
        return this._mathfield ? this._mathfield.canUndo() : false;
      }
      canRedo() {
        return this._mathfield ? this._mathfield.canRedo() : false;
      }
      connectedCallback() {
        var o, a, n;
        requestAnimationFrame(() => void Tr()), this.shadowRoot.host.addEventListener("pointerdown", () => this.onPointerDown(), true), this.shadowRoot.host.addEventListener("focus", () => {
          var s;
          return (s = this._mathfield) == null ? void 0 : s.focus();
        }, true), this.shadowRoot.host.addEventListener("blur", () => {
          var s;
          return (s = this._mathfield) == null ? void 0 : s.blur();
        }, true), ci() || (this.hasAttribute("role") || this.setAttribute("role", "math"), this.hasAttribute("aria-label") || this.setAttribute("aria-label", "math input field"), this.setAttribute("aria-multiline", "false")), this.hasAttribute("contenteditable") || this.setAttribute("contenteditable", "true"), this.hasAttribute("tabindex") || this.setAttribute("tabindex", "0");
        let t = this.shadowRoot.querySelector("slot:not([name])"), i = "";
        if (this.hasAttribute("value") ? i = (o = this.getAttribute("value")) != null ? o : "" : i = (a = t == null ? void 0 : t.assignedNodes().map((s) => s.nodeType === 3 ? s.textContent : "").join("").trim()) != null ? a : "", this._mathfield = new Fo(this.shadowRoot.querySelector(":host > span"), E(b({}, W.has(this) ? W.get(this).options : $o(this)), { eventSink: this, value: i })), !W.has(this)) {
          this.upgradeProperty("disabled"), this.upgradeProperty("readonly");
          for (let s of Object.keys(yr.optionsAttributes))
            this.upgradeProperty(Ot(s));
        }
        if (!((n = this._mathfield) != null && n.model)) {
          this._mathfield = null;
          return;
        }
        W.has(this) && this._mathfield.model.deferNotifications({ content: false, selection: false }, () => {
          let s = W.get(this).value;
          s !== void 0 && this._mathfield.setValue(s), this._mathfield.model.selection = W.get(this).selection, W.delete(this);
        }), t.addEventListener("slotchange", (s) => {
          if (s.target !== t)
            return;
          let l = t.assignedNodes().map((c) => c.nodeType === 3 ? c.textContent : "").join("").trim();
          l !== this._slotValue && (this._mathfield ? this._mathfield.setValue(l) : this.value = l);
        }), this.dispatchEvent(new Event("mount", { cancelable: false, bubbles: true, composed: true }));
      }
      disconnectedCallback() {
        if (this.dispatchEvent(new Event("unmount", { cancelable: false, bubbles: true, composed: true })), !this._mathfield)
          return;
        let t = Et(this._mathfield.options, Object.keys(yr.optionsAttributes).map((i) => Ot(i)));
        W.set(this, { value: this._mathfield.getValue(), selection: this._mathfield.model.selection, options: t }), this._mathfield.dispose(), this._mathfield = null;
      }
      upgradeProperty(t) {
        if (this.hasOwnProperty(t)) {
          let i = this[t];
          delete this[t], (t === "readonly" || t === "read-only") && (t = "readOnly"), this[t] = i;
        }
      }
      attributeChangedCallback(t, i, o) {
        if (i === o)
          return;
        let a = o !== null;
        switch (t) {
          case "contenteditable":
            this._mathfield && te(this._mathfield);
            break;
          case "disabled":
            this.disabled = a;
            break;
          case "read-only":
          case "readonly":
            this.readOnly = a;
            break;
        }
      }
      get readonly() {
        return this.hasAttribute("readonly") || this.hasAttribute("read-only");
      }
      set readonly(t) {
        let i = !!t;
        i ? (this.setAttribute("readonly", ""), ci() ? this._internals.ariaReadOnly = "true" : this.setAttribute("aria-readonly", "true"), this.setAttribute("aria-readonly", "true")) : (ci() ? this._internals.ariaReadOnly = "false" : this.removeAttribute("aria-readonly"), this.removeAttribute("readonly"), this.removeAttribute("read-only")), this._setOptions({ readOnly: i });
      }
      get disabled() {
        return this.hasAttribute("disabled");
      }
      set disabled(t) {
        var o;
        let i = !!t;
        i ? this.setAttribute("disabled", "") : this.removeAttribute("disabled"), ci() ? this._internals.ariaDisabled = i ? "true" : "false" : this.setAttribute("aria-disabled", i ? "true" : "false"), i && ((o = this._mathfield) != null && o.hasFocus) && window.mathVirtualKeyboard.visible && this._mathfield.executeCommand("hideVirtualKeyboard");
      }
      get value() {
        return this.getValue();
      }
      set value(t) {
        this.setValue(t);
      }
      get defaultMode() {
        return this._getOption("defaultMode");
      }
      set defaultMode(t) {
        this._setOptions({ defaultMode: t });
      }
      get macros() {
        return this._getOption("macros");
      }
      set macros(t) {
        this._setOptions({ macros: t });
      }
      get registers() {
        return this._getOption("registers");
      }
      set registers(t) {
        this._setOptions({ registers: t });
      }
      get colorMap() {
        return this._getOption("colorMap");
      }
      set colorMap(t) {
        this._setOptions({ colorMap: t });
      }
      get backgroundColorMap() {
        return this._getOption("backgroundColorMap");
      }
      set backgroundColorMap(t) {
        this._setOptions({ backgroundColorMap: t });
      }
      get letterShapeStyle() {
        return this._getOption("letterShapeStyle");
      }
      set letterShapeStyle(t) {
        this._setOptions({ letterShapeStyle: t });
      }
      get smartMode() {
        return this._getOption("smartMode");
      }
      set smartMode(t) {
        this._setOptions({ smartMode: t });
      }
      get smartFence() {
        return this._getOption("smartFence");
      }
      set smartFence(t) {
        this._setOptions({ smartFence: t });
      }
      get smartSuperscript() {
        return this._getOption("smartSuperscript");
      }
      set smartSuperscript(t) {
        this._setOptions({ smartSuperscript: t });
      }
      get scriptDepth() {
        return this._getOption("scriptDepth");
      }
      set scriptDepth(t) {
        this._setOptions({ scriptDepth: t });
      }
      get removeExtraneousParentheses() {
        return this._getOption("removeExtraneousParentheses");
      }
      set removeExtraneousParentheses(t) {
        this._setOptions({ removeExtraneousParentheses: t });
      }
      get mathModeSpace() {
        return this._getOption("mathModeSpace");
      }
      set mathModeSpace(t) {
        this._setOptions({ mathModeSpace: t });
      }
      get placeholderSymbol() {
        return this._getOption("placeholderSymbol");
      }
      set placeholderSymbol(t) {
        this._setOptions({ placeholderSymbol: t });
      }
      get popoverPolicy() {
        return this._getOption("popoverPolicy");
      }
      set popoverPolicy(t) {
        this._setOptions({ popoverPolicy: t });
      }
      get mathVirtualKeyboardPolicy() {
        return this._getOption("mathVirtualKeyboardPolicy");
      }
      set mathVirtualKeyboardPolicy(t) {
        this._setOptions({ mathVirtualKeyboardPolicy: t });
      }
      get inlineShortcuts() {
        return this._getOption("inlineShortcuts");
      }
      set inlineShortcuts(t) {
        this._setOptions({ inlineShortcuts: t });
      }
      get inlineShortcutTimeout() {
        return this._getOption("inlineShortcutTimeout");
      }
      set inlineShortcutTimeout(t) {
        this._setOptions({ inlineShortcutTimeout: t });
      }
      get keybindings() {
        return this._getOption("keybindings");
      }
      set keybindings(t) {
        this._setOptions({ keybindings: t });
      }
      get onInlineShortcut() {
        return this._getOption("onInlineShortcut");
      }
      set onInlineShortcut(t) {
        this._setOptions({ onInlineShortcut: t });
      }
      get onExport() {
        return this._getOption("onExport");
      }
      set onExport(t) {
        this._setOptions({ onExport: t });
      }
      get readOnly() {
        return this._getOption("readOnly");
      }
      set readOnly(t) {
        this._setOptions({ readOnly: t });
      }
      setPromptState(t, i, o) {
        var a;
        (a = this._mathfield) == null || a.setPromptState(t, i, o);
      }
      getPromptState(t) {
        var i, o;
        return (o = (i = this._mathfield) == null ? void 0 : i.getPromptState(t)) != null ? o : [void 0, true];
      }
      setPromptContent(t, i, o) {
        var a;
        (a = this._mathfield) == null || a.setPromptValue(t, i, o);
      }
      get virtualKeyboardTargetOrigin() {
        return this._getOption("virtualKeyboardTargetOrigin");
      }
      set virtualKeyboardTargetOrigin(t) {
        this._setOptions({ virtualKeyboardTargetOrigin: t });
      }
      get selection() {
        return this._mathfield ? this._mathfield.model.selection : W.has(this) ? W.get(this).selection : { ranges: [[0, 0]], direction: "forward" };
      }
      set selection(t) {
        if (typeof t == "number" && (t = { ranges: [[t, t]] }), this._mathfield) {
          this._mathfield.model.selection = t;
          return;
        }
        if (W.has(this)) {
          W.set(this, E(b({}, W.get(this)), { selection: t }));
          return;
        }
        W.set(this, { value: void 0, selection: t, options: $o(this) });
      }
      get selectionIsCollapsed() {
        let t = this.selection;
        return t.ranges.length === 1 && t.ranges[0][0] === t.ranges[0][1];
      }
      get position() {
        return this._mathfield ? this._mathfield.model.position : W.has(this) ? W.get(this).selection.ranges[0][0] : 0;
      }
      set position(t) {
        if (this._mathfield && (this._mathfield.model.position = t), W.has(this)) {
          W.set(this, E(b({}, W.get(this)), { selection: { ranges: [[t, t]] } }));
          return;
        }
        W.set(this, { value: void 0, selection: { ranges: [[t, t]] }, options: $o(this) });
      }
      getOffsetDepth(t) {
        var i;
        return this._mathfield ? ((i = this._mathfield.model.at(t)) == null ? void 0 : i.treeDepth) - 2 : 0;
      }
      get lastOffset() {
        var t, i;
        return (i = (t = this._mathfield) == null ? void 0 : t.model.lastOffset) != null ? i : -1;
      }
    }, re = yr;
    re.version = "0.90.9", re._fontsDirectory = "./fonts", re._soundsDirectory = "./sounds", re.keypressVibration = true, re._keypressSound = { spacebar: "keypress-spacebar.wav", return: "keypress-return.wav", delete: "keypress-delete.wav", default: "keypress-standard.wav" }, re._plonkSound = "plonk.wav", re.audioBuffers = {}, re.createHTML = (t) => t, re._speechEngineRate = "100%", re._speechEngineVoice = "Joanna", re._textToSpeechMarkup = "", re._textToSpeechRules = "mathlive", re._textToSpeechRulesOptions = {}, re.speakHook = Ds, re.readAloudHook = rl, re._decimalSeparator = ".", re.fractionNavigationOrder = "numerator-denominator";
    function Ot(r) {
      return r.toLowerCase().replace(/[^a-zA-Z\d]+(.)/g, (e, t) => t.toUpperCase());
    }
    function $o(r) {
      let e = {}, t = re.optionsAttributes;
      return Object.keys(t).forEach((i) => {
        if (r.hasAttribute(i)) {
          let o = r.getAttribute(i);
          t[i] === "boolean" ? e[Ot(i)] = true : t[i] === "on/off" ? o === "on" ? e[Ot(i)] = true : o === "off" ? e[Ot(i)] = false : e[Ot(i)] = void 0 : t[i] === "number" ? e[Ot(i)] = Number.parseFloat(o != null ? o : "0") : e[Ot(i)] = o;
        } else
          t[i] === "boolean" && (e[Ot(i)] = false);
      }), e;
    }
    function ci() {
      return !(!("ElementInternals" in window) || !HTMLElement.prototype.attachInternals || !("role" in window.ElementInternals.prototype));
    }
    var Ao = re, il, ol, nl;
    if (fe() && !((il = window.customElements) != null && il.get("math-field"))) {
      window[ol = Symbol.for("io.cortexjs.mathlive")] != null || (window[ol] = {});
      let r = window[Symbol.for("io.cortexjs.mathlive")];
      r.version = "0.90.9", window.MathfieldElement = re, (nl = window.customElements) == null || nl.define("math-field", re);
    }
    function an(r, e) {
      var s;
      e = e != null ? e : {}, e.mathstyle = (s = e.mathstyle) != null ? s : "displaystyle";
      let t = Tt(), i = new g("root", t);
      i.body = pe(r, t, { parseMode: "math", mathstyle: e.mathstyle });
      let o = new P({ registers: t.registers, renderPlaceholder: () => new v(160, { maxFontSize: 1 }) }, { fontSize: nt, letterShapeStyle: t.letterShapeStyle }, e.mathstyle), a = i.render(o);
      return a ? (Mt(a, o), Yt(a), _t(a, { classes: "ML__mathlive" }).toMarkup()) : "";
    }
    function zu(r) {
      return co(r, Tt());
    }
    function nn(r, e = {}) {
      return V(pe(r, Tt(), { parseMode: "math", args: () => "", mathstyle: "displaystyle" }), e);
    }
    function sn(r) {
      let e = pe(r, Tt(), { parseMode: "math", mathstyle: "displaystyle" });
      return $t(e);
    }
    var Hi;
    function ln(r) {
      var e, t;
      if (!Hi) {
        let i = (e = globalThis[Symbol.for("io.cortexjs.compute-engine")]) == null ? void 0 : e.ComputeEngine;
        i ? Hi = new i() : console.error(`MathLive 0.90.9: The CortexJS Compute Engine library is not available.
        
        Load the library, for example with:
        
        import "https://unpkg.com/@cortex-js/compute-engine?module"`);
      }
      return (t = Hi == null ? void 0 : Hi.box(r).latex) != null ? t : "";
    }
    function Ru(r, e = "math") {
      let t = Tt(), i = new g("root", t);
      return i.body = pe(r, t, { parseMode: e }), ue(i);
    }
    function Fu(r) {
      return _r(r, { format: "ascii-math" })[1];
    }
    function Nu(r, e, t) {
      let i = t, o = 0, a = r.length;
      for (; i < e.length; ) {
        let n = e[i];
        if (o <= 0 && e.slice(i, i + a) === r)
          return i;
        n === "\\" ? i++ : n === "{" ? o++ : n === "}" && o--, i++;
      }
      return -1;
    }
    function qo(r, e, t, i, o = "latex") {
      let a = [];
      for (let n of r)
        if (n.type === "text") {
          let s = n.data, l = true, c = 0, u;
          u = s.indexOf(e), u !== -1 && (c = u, c > 0 && a.push({ type: "text", data: s.slice(0, c) }), l = false);
          let d = false;
          for (; !d; ) {
            if (l) {
              if (u = s.indexOf(e, c), u === -1) {
                d = true;
                break;
              }
              c !== u && a.push({ type: "text", data: s.slice(c, u) }), c = u;
            } else {
              if (u = Nu(t, s, c + e.length), u === -1) {
                d = true;
                break;
              }
              let m = s.slice(c + e.length, u);
              o === "ascii-math" && ([, m] = _r(m, { format: "ascii-math" })), a.push({ type: "math", data: m, rawData: s.slice(c, u + t.length), mathstyle: i }), c = u + t.length;
            }
            l = !l;
          }
          c < s.length && a.push({ type: "text", data: s.slice(c) });
        } else
          a.push(n);
      return a;
    }
    function sl(r, e, t) {
      let i = [{ type: "text", data: r }];
      return e != null && e.inline && e.inline.forEach(([o, a]) => {
        i = qo(i, o, a, "textstyle");
      }), e != null && e.display && e.display.forEach(([o, a]) => {
        i = qo(i, o, a, "displaystyle");
      }), t != null && t.inline && t.inline.forEach(([o, a]) => {
        i = qo(i, o, a, "textstyle", "ascii-math");
      }), t != null && t.display && t.display.forEach(([o, a]) => {
        i = qo(i, o, a, "displaystyle", "ascii-math");
      }), i;
    }
    function Iu(r, e) {
      let t = document.createElement("span");
      try {
        let i = "<math xmlns='http://www.w3.org/1998/Math/MathML'>" + e.renderToMathML(r) + "</math>";
        t.innerHTML = window.MathfieldElement.createHTML(i);
      } catch (i) {
        console.error(`MathLive 0.90.9:  Could not convert "${r}"' to MathML with ${i}`), t.textContent = r;
      }
      return t.className = "ML__sr-only", t;
    }
    function $u(r, e, t, i) {
      try {
        let o = e.renderToMarkup(r, { mathstyle: t, format: "html" }), a = document.createElement(t === "displaystyle" ? "div" : "span");
        return a.setAttribute("aria-hidden", "true"), a.innerHTML = window.MathfieldElement.createHTML(o), a;
      } catch (o) {
        if (console.error("Could not parse'" + r + "' with ", o), i)
          return document.createTextNode(r);
      }
      return null;
    }
    function ui(r, e, t, i) {
      var n;
      let o = $u(r, t, e || "displaystyle", i), a = (n = t.renderAccessibleContent) != null ? n : "";
      if (o && /\b(mathml|speakable-text)\b/i.test(a)) {
        let s = document.createElement("span");
        if (/\bmathml\b/i.test(a) && t.renderToMathML && s.append(Iu(r, t)), /\bspeakable-text\b/i.test(a) && t.renderToSpeakableText) {
          let l = document.createElement("span"), c = t.renderToSpeakableText(r);
          l.innerHTML = window.MathfieldElement.createHTML(c), l.className = "ML__sr-only", s.append(l);
        }
        return s.append(o), s;
      }
      return o;
    }
    function qu(r, e) {
      var i, o, a;
      let t = null;
      if ((i = e.TeX) != null && i.processEnvironments && /^\s*\\begin/.test(r)) {
        t = document.createDocumentFragment();
        let n = ui(r, "", e, true);
        n && t.appendChild(n);
      } else {
        if (!r.trim())
          return null;
        let n = sl(r, (o = e.TeX) == null ? void 0 : o.delimiters, (a = e.asciiMath) == null ? void 0 : a.delimiters);
        if (n.length === 1 && n[0].type === "text")
          return null;
        t = document.createDocumentFragment();
        for (let s of n)
          if (s.type === "text")
            t.appendChild(document.createTextNode(s.data));
          else {
            let l = ui(s.data, s.mathstyle === "textstyle" ? "textstyle" : "displaystyle", e, true);
            l && t.appendChild(l);
          }
      }
      return t;
    }
    function ll(r, e) {
      var t, i, o, a, n, s, l, c, u, d, m, h, f, y, w, k;
      if (r.childNodes.length === 1 && r.childNodes[0].nodeType === 3) {
        let S = (t = r.childNodes[0].textContent) != null ? t : "";
        if ((i = e.TeX) != null && i.processEnvironments && /^\s*\\begin/.test(S)) {
          r.textContent = "";
          let C = ui(S, "", e, true);
          C && r.append(C);
          return;
        }
        let T = sl(S, (o = e.TeX) == null ? void 0 : o.delimiters, (a = e.asciiMath) == null ? void 0 : a.delimiters);
        if (T.length === 1 && T[0].type === "math") {
          r.textContent = "";
          let C = ui(T[0].data, T[0].mathstyle === "textstyle" ? "textstyle" : "displaystyle", e, true);
          C && r.append(C);
          return;
        }
        if (T.length === 1 && T[0].type === "text")
          return;
      }
      for (let S = r.childNodes.length - 1; S >= 0; S--) {
        let T = r.childNodes[S];
        if (T.nodeType === 3) {
          let C = qu((n = T.textContent) != null ? n : "", e);
          C && (S += C.childNodes.length - 1, T.replaceWith(C));
        } else if (T.nodeType === 1) {
          let C = T, K = T.nodeName.toLowerCase();
          if (K === "script") {
            let M = T, R;
            if ((s = e.processScriptTypePattern) != null && s.test(M.type))
              R = (l = M.textContent) != null ? l : "";
            else if ((c = e.processMathJSONScriptTypePattern) != null && c.test(M.type))
              try {
                R = (d = e.serializeToLatex) == null ? void 0 : d.call(e, JSON.parse((u = M.textContent) != null ? u : ""));
              } catch (F) {
                console.error(F);
              }
            if (R) {
              let F = "displaystyle";
              for (let Pe of M.type.split(";")) {
                let [vt, Jt] = Pe.toLowerCase().split("=");
                vt.trim() === "mode" && (F = Jt.trim() === "display" ? "displaystyle" : "textstyle");
              }
              let Le = ui(R, F, e, true);
              Le && M.parentNode.replaceChild(Le, M);
            }
          } else if (((h = (m = e.processClassPattern) == null ? void 0 : m.test(C.className)) != null ? h : false) || !((y = (f = e.skipTags) == null ? void 0 : f.includes(K)) != null && y || (k = (w = e.ignoreClassPattern) == null ? void 0 : w.test(C.className)) != null && k))
            if (r.childNodes.length === 1 && r.childNodes[0].nodeType === 3) {
              let R = r.textContent;
              r.textContent = "";
              let F = ui(R != null ? R : "", "displaystyle", e, true);
              F && r.append(F);
            } else
              ll(C, e);
        }
      }
    }
    var Vu = { skipTags: ["math-field", "noscript", "style", "textarea", "pre", "code", "annotation", "annotation-xml"], processScriptType: "math/tex", processMathJSONScriptType: "math/json", ignoreClass: "tex2jax_ignore", processClass: "tex2jax_process", renderAccessibleContent: "mathml", asciiMath: { delimiters: { display: [["`", "`"]] } }, TeX: { processEnvironments: true, delimiters: { inline: [["\\(", "\\)"]], display: [["$$", "$$"], ["\\[", "\\]"]] } } };
    function cn(r, e) {
      var t, i, o, a;
      try {
        let n = b(b({}, Vu), e);
        n.ignoreClassPattern = new RegExp((t = n.ignoreClass) != null ? t : ""), n.processClassPattern = new RegExp((i = n.processClass) != null ? i : ""), n.processScriptTypePattern = new RegExp((o = n.processScriptType) != null ? o : ""), n.processMathJSONScriptTypePattern = new RegExp((a = n.processMathJSONScriptType) != null ? a : ""), requestAnimationFrame(() => void Tr()), Ze(null, Ie, Xe(Ie).toString(36)), ll(r, n);
      } catch (n) {
        n instanceof Error ? console.error("renderMathInElement(): " + n.message) : console.error("renderMathInElement(): Could not render math for element", r);
      }
    }
    var Hu = { FUNCTIONS: st, MATH_SYMBOLS: lt, TEXT_SYMBOLS: At, ENVIRONMENTS: io, DEFAULT_KEYBINDINGS: go, getKeybindingMarkup: Ki }, zr = Hu;
    var Gu = 0, cl = 200;
    var D = 1200, Ju = 2e3, de = 3e3, Ee = 4e3;
    function A(r, e, t = de, i = "$0") {
      for (let o of e)
        lt[o] && (lt[o].frequency = t, lt[o].category = r, lt[o].template = i.replace(/\$0/g, o)), st[o] && (st[o] = E(b({}, st[o]), { frequency: t, category: r, template: i.replace(/\$0/g, o) }));
    }
    A("Trigonometry", ["\\cos", "\\sin", "\\tan"], Ee);
    A("Trigonometry", ["\\arccos", "\\arcsin", "\\arctan", "\\arctg", "\\arcctg", "\\arcsec", "\\arccsc", "\\arsinh", "\\arcosh", "\\artanh", "\\arcsech", "\\arccsch", "\\arg", "\\ch", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\lg", "\\lb", "\\sec", "\\sinh", "\\sh", "\\tanh", "\\tg", "\\th"], Ju);
    A("Functions", ["\\ln", "\\log", "\\exp", "\\lim"], Ee);
    A("Functions", ["\\dim", "\\ker", "\\deg", "\\det", "\\mod", "\\min", "\\max"], de);
    A("Functions", ["\\hom"], D);
    A("Decoration", ["\\rule"], cl, "$0{2em}{1em}");
    A("Decoration", ["\\color", "\\textcolor"], cl, "{$0{m0}A}{$0{m1}B}{$0{m2}C }{$0{m3}a}{$0{m4}b}{$0{m5}c}{$0{m6}8}");
    A("Decoration", ["\\overline", "\\underline"], de, "$0{\\placeholder{}}");
    A("Decoration", ["\\enclose"], D, '\\enclose{updiagonalstrike,roundedbox}[1px solid red, mathbackground="#fbc0bd"]{x=0}');
    A("Decoration", ["\\fcolorbox"], D, '\\fcolorbox{#cd0030}{#ffd400}{\\unicode{"2B1A}}');
    A("Decoration", ["\\colorbox"], D, '\\colorbox{#fbc0bd}{\\unicode{"2B1A}}');
    A("Decoration", ["\\boxed", "\\cancel", "\\bcancel", "\\xcancel"], D, "$0{\\placeholder{}}");
    A("Decoration", ["\\bbox"], D, '\\bbox[#ffd400, solid 2px #ffd400]{\\unicode{"2B1A}}');
    A("Styling", ["\\mathbb"], Ee, "$0{Don Knuth}");
    A("Styling", ["\\textbf", "\\textup", "\\textit", "\\textrm", "\\textsf", "\\texttt", "\\textnormal", "\\textmd", "\\textsl", "\\textsc", "\\mathsf", "\\mathtt", "\\mathrm", "\\mathfrak", "\\mathcal", "\\mathscr", "\\mathbf", "\\mathmd", "\\mathit", "\\text", "\\mbox", "\\Bbb", "\\bold", "\\bm", "\\boldsymbol"], de, "$0{Don Knuth}");
    A("Styling", ["\\frak", "\\tt", "\\bf", "\\it", "\\rmfamily", "\\sffamily", "\\ttfamily", "\\class", "\\cssId", "\\htmlData", "\\htmlStyle"], D, "{$0 Don Knuth}");
    A("Styling", ["\\bfseries", "\\mdseries", "\\upshape", "\\slshape", "\\scshape"], D, "\\text{$0 Don Knuth}");
    A("Styling", ["\\class", "\\cssId"], D, "$0{testIdentifier}{Don Knuth}");
    A("Styling", ["\\fontseries"], D, "\\text{$0{b}Don Knuth}");
    A("Styling", ["\\fontfamily"], D, "\\text{$0{cmtt}Don Knuth}");
    A("Styling", ["\\fontshape"], D, "\\text{$0{sc}Don Knuth}");
    A("Styling", ["\\selectfont"], D, "\\text{$0}");
    A("Styling", ["\\emph"], D, "Don$0{Knuth}");
    A("Styling", ["\\em"], D, "Don{$0 Knuth}");
    A("Layout", ["\\mathop", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathord", "\\mathinner", "\\operatorname", "\\operatorname*"], D, "x=$0{arg}=0");
    A("Layout", ["\\middle"], D, "\\left\\{x$0|x>0\\right\\}");
    A("Layout", ["\\overset", "\\underset", "\\stackrel", "\\stackbin"], D, "$0{arg}{x=0}");
    A("Layout", ["\\rlap", "\\mathrlap"], D, "$0{/}0");
    A("Layout", ["\\llap", "\\mathllap"], D, "o$0{/}");
    A("Fractions", ["\\frac"], Ee, "$0{\\placeholder{}}{\\placeholder{}}");
    A("Fractions", ["\\binom", "\\dfrac", "\\tfrac", "\\dbinom", "\\tbinom", "\\pdiff", "\\cfrac"], D, "$0{\\placeholder{}}{\\placeholder{}}");
    A("Fractions", ["\\over", "\\atop", "\\choose"], D, '\\unicode{"2B1A} $0 \\unicode{"2B1A}');
    A("Fractions", ["\\overwithdelims", "\\atopwithdelims"], D, '{\\unicode{"2B1A} $0{\\lbrace}{\\rbrace} \\unicode{"2B1A}}');
    A("Extensible Operators", ["\\sum", "\\prod", "\\bigcap", "\\bigcup", "\\int"], Ee);
    A("Extensible Operators", ["\\bigoplus", "\\smallint", "\\iint", "\\oint"], de);
    A("Extensible Operators", ["\\bigwedge", "\\bigvee", "\\coprod", "\\bigsqcup", "\\bigotimes", "\\bigodot", "\\biguplus", "\\intop", "\\sqcup", "\\sqcap", "\\uplus", "\\wr", "\\Cap", "\\Cup", "\\doublecap", "\\doublecup", "\\amalg", "\\iiint", "\\oiint", "\\oiiint", "\\intclockwise", "\\varointclockwise", "\\ointctrclockwise", "\\intctrclockwise"], D);
    A("Accents", ["\\vec"], Ee);
    A("Accents", ["\\bar", "\\ddot", "\\acute", "\\tilde", "\\check"], de, "$0{\\placeholder{}}");
    A("Accents", ["\\^", "\\`", "\\'"], D, "$0{e}");
    A("Accents", ["\\c"], D, "$0{c}");
    A("Accents", ["\\~"], D, "$0{n}");
    A("Accents", ["\\mathring", "\\hat", "\\dot", "\\breve", "\\grave"], D, "$0{\\placeholder{}}");
    A("Extensible Symbols", ["\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftharpoon", "\\overrightharpoon", "\\overleftrightarrow", "\\overbrace", "\\overlinesegment", "\\overgroup", "\\widehat", "\\widecheck", "\\widetilde"], de, "$0{ABC}");
    A("Extensible Symbols", ["\\underrightarrow", "\\underleftarrow", "\\underleftrightarrow", "\\underbrace", "\\underlinesegment", "\\undergroup", "\\utilde"], de, "$0{ABC}");
    A("Sizing", ["\\tiny", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"], D, "$0{x=0}");
    A("Sizing", ["\\big", "\\Big", "\\bigg", "\\Bigg"], D, "$0($0)");
    A("Sizing", ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl"], D, "$0(");
    A("Sizing", ["\\bigr", "\\Bigr", "\\biggr", "\\Biggr"], D, "$0)");
    A("Sizing", ["\\bigm", "\\Bigm", "\\biggm", "\\Biggm"], D, "$0|");
    A("Letterlike Symbols", ["\\nabla", "\\partial", "\\N", "\\R", "\\Q", "\\C", "\\Z", "\\exponentialE", "\\forall", "\\exists", "\\nexists"], Ee);
    A("Letterlike Symbols", ["\\doubleStruckCapitalP", "\\P", "\\ell", "\\hbar", "\\hslash", "\\imath", "\\jmath", "\\imaginaryI", "\\imaginaryJ", "\\differentialD", "\\rd", "\\capitalDifferentialD", "\\doubleStruckCapitalN", "\\doubleStruckCapitalR", "\\doubleStruckCapitalQ", "\\doubleStruckCapitalC", "\\doubleStruckCapitalZ", "\\rD", "\\differencedelta", "\\mid", "@", "\\Re", "\\Im", "\\$", "\\%", "\\And", "\\degree"], de);
    A("Letterlike Symbols", ["\\top", "\\bot", "\\scriptCapitalE", "\\scriptCapitalH", "\\scriptCapitalL", "\\gothicCapitalC", "\\gothicCapitalH", "\\gothicCapitalI", "\\gothicCapitalR", "\\Bbbk", "\\Finv", "\\Game", "\\wp", "\\eth", "\\mho", "\\pounds", "\\yen", "\\euro"], D);
    A("Crosses", ["\\dagger", "\\dag"], Ee);
    A("Crosses", ["\\ddag", "\\ddagger", "\\maltese", "\\textdagger", "\\textdaggerdbl"], D);
    A("Various", ["\\checkmark", "\\diagup", "\\diagdown", "\\angle", "\\measuredangle", "\\sphericalangle", "\\prime", "\\doubleprime", "\\backprime", "\\backdoubleprime", "\\sharp", "\\flat", "\\natural", "\\&", "\\#", "\\clubsuit", "\\spadesuit", "\\diamondsuit", "\\heartsuit", "\\backslash", "\\infty", "/", "\\_", "\\/", "|", "'"], D);
    A("Various", ["\\unicode"], D, '$0{"2B1A}');
    A("Arrows", ["\\longrightarrow", "\\rightarrow", "\\Longrightarrow", "\\Rightarrow"], Ee);
    A("Arrows", ["\\longmapsto", "\\mapsto", "\\Longleftrightarrow", "\\rightleftarrows", "\\leftarrow", "\\curvearrowleft", "\\uparrow", "\\downarrow", "\\hookrightarrow", "\\rightharpoonup", "\\rightleftharpoons"], de);
    A("Arrows", ["\\Leftarrow", "\\longleftrightarrow", "\\longleftarrow", "\\Longleftarrow", "\\searrow", "\\nearrow", "\\swarrow", "\\nwarrow", "\\Uparrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "\\hookleftarrow", "\\leftharpoonup", "\\leftharpoondown", "\\rightharpoondown", "\\leftrightarrows", "\\dashrightarrow", "\\dashleftarrow", "\\leftleftarrows", "\\Lleftarrow", "\\twoheadleftarrow", "\\leftarrowtail", "\\looparrowleft", "\\leftrightharpoons", "\\circlearrowleft", "\\Lsh", "\\upuparrows", "\\downharpoonleft", "\\multimap", "\\leftrightsquigarrow", "\\twoheadrightarrow", "\\rightarrowtail", "\\looparrowright", "\\curvearrowright", "\\circlearrowright", "\\Rsh", "\\downdownarrows", "\\upharpoonright", "\\downharpoonright", "\\rightsquigarrow", "\\leadsto", "\\Rrightarrow", "\\restriction"], D);
    A("Arrows", ["\\upharpoonleft", "\\rightrightarrows"], Gu);
    A("Negated Arrows", ["\\nrightarrow", "\\nRightarrow", "\\nleftrightarrow", "\\nLeftrightarrow", "\\nleftarrow", "\\nLeftarrow"], D);
    A("Extensible Symbols", ["\\xrightarrow", "\\xleftarrow", "\\xRightarrow", "\\xLeftarrow", "\\xleftharpoonup", "\\xleftharpoondown", "\\xrightharpoonup", "\\xrightharpoondown", "\\xlongequal", "\\xtwoheadleftarrow", "\\xtwoheadrightarrow", "\\xleftrightarrow", "\\xLeftrightarrow", "\\xrightleftharpoons", "\\xleftrightharpoons", "\\xhookleftarrow", "\\xhookrightarrow", "\\xmapsto", "\\xtofrom", "\\xrightleftarrows", "\\xrightequilibrium", "\\xleftequilibrium"], D, "$0[below]{above}=0");
    A("Negated Relations", ["\\nless", "\\nleqslant", "\\lneq", "\\lneqq", "\\nleqq", "\\unlhd", "\\unrhd", "\\lvertneqq", "\\lnsim", "\\lnapprox", "\\nprec", "\\npreceq", "\\precnsim", "\\precnapprox", "\\nsim", "\\nshortmid", "\\nmid", "\\nvdash", "\\nvDash", "\\ngtr", "\\ngeqslant", "\\ngeqq", "\\gneq", "\\gneqq", "\\gvertneqq", "\\gnsim", "\\nsucc", "\\succnsim", "\\ncong", "\\nshortparallel", "\\nparallel", "\\nVDash", "\\nVdash", "\\precneqq", "\\succneqq", "\\gnapprox", "\\succnapprox", "\\nsucceq"], D);
    A("Hebrew", ["\\aleph", "\\beth", "\\daleth", "\\gimel"], D);
    A("Fences", ["\\lbrace", "\\rbrace", "\\vert", "\\Vert", "\\{", "\\}", "(", ")", "[", "]"], Ee);
    A("Fences", ["\\langle", "\\rangle", "\\lfloor", "\\rfloor", "\\lceil", "\\rceil", "\\mvert", "\\|", "\\mVert"], de);
    A("Fences", ["\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lbrack", "\\rbrack", "\\ulcorner", "\\urcorner", "\\llcorner", "\\lrcorner", "\\lgroup", "\\rgroup", "\\lmoustache", "\\rmoustache"], D);
    A("Relations", ["=", "\\ne", "\\neq", "<", ">", "\\leqslant", "\\geqslant", "\\approx"], Ee);
    A("Relations", ["\\lt", "\\gt", "\\le", "\\ge", "\\leq", "\\geq", "\\gg", "\\cong", "\\equiv", "\\prec", "\\preceq", "\\succ", "\\perp", "\\parallel", "\\propto", "\\smile", "\\frown", "\\sim", "\\gtrsim"], de);
    A("Relations", ["\\coloneq", "\\succeq", "\\approxeq", "\\thickapprox", "\\lessapprox", "\\gtrapprox", "\\precapprox", "\\succapprox", "\\thicksim", "\\succsim", "\\precsim", "\\backsim", "\\eqsim", "\\backsimeq", "\\simeq", "\\lesssim", "\\nleq", "\\ngeq", "\\smallsmile", "\\smallfrown", "\\bowtie", "\\asymp", "\\leqq", "\\eqslantless", "\\ll", "\\lll", "\\lessgtr", "\\lesseqgtr", "\\lesseqqgtr", "\\risingdotseq", "\\fallingdotseq", "\\preccurlyeq", "\\curlyeqprec", "\\vDash", "\\Vvdash", "\\bumpeq", "\\Bumpeq", "\\geqq", "\\eqslantgtr", "\\ggg", "\\gtrless", "\\gtreqless", "\\gtreqqless", "\\succcurlyeq", "\\curlyeqsucc", "\\Vdash", "\\shortmid", "\\shortparallel", "\\between", "\\pitchfork", "\\varpropto", "\\backepsilon", "\\llless", "\\gggtr", "\\lhd", "\\rhd", "\\Join", "\\doteq", "\\doteqdot", "\\Doteq", "\\eqcirc", "\\circeq", "\\lessdot", "\\gtrdot", "\\measeq", "\\eqdef", "\\questeq"], D);
    A("Logic", ["\\leftrightarrow", "\\Leftrightarrow", "\\to"], Ee);
    A("Logic", ["\\models", "\\vdash"], de);
    A("Logic", ["\\therefore", "\\because", "\\implies", "\\gets", "\\dashv", "\\impliedby", "\\biconditional", "\\roundimplies"], D);
    A("Operators", ["+", "-", "*", "\\cdot"], Ee);
    A("Operators", ["\\sqrt"], Ee, "$0{\\placeholder{}}");
    A("Operators", ["\\pm", "\\mp", "\\times", "\\div", "\\surd"], de);
    A("Operators", ["\\ltimes", "\\rtimes", "\\leftthreetimes", "\\rightthreetimes", "\\intercal", "\\dotplus", "\\centerdot", "\\doublebarwedge", "\\divideontimes", "\\divides"], D);
    A("Logic", ["\\wedge", "\\vee", "\\neg"], Ee);
    A("Logic", ["\\lnot"], de);
    A("Logic", ["\\land", "\\lor", "\\barwedge", "\\veebar", "\\nor", "\\curlywedge", "\\curlyvee"], D);
    A("Greek", ["\\alpha", "\\beta", "\\gamma", "\\delta", "\\epsilon", "\\varepsilon", "\\zeta", "\\eta", "\\theta", "\\vartheta", "\\iota", "\\kappa", "\\varkappa", "\\lambda", "\\mu", "\\nu", "\\xi", "\\pi", "\\varpi", "\\rho", "\\varrho", "\\sigma", "\\varsigma", "\\tau", "\\phi", "\\varphi", "\\upsilon", "\\chi", "\\psi", "\\omega", "\\Gamma", "\\Delta", "\\Theta", "\\Lambda", "\\Xi", "\\Pi", "\\Sigma", "\\Upsilon", "\\Phi", "\\Psi", "\\Omega", "\\digamma", "\\omicron"], de);
    A("Sets", ["\\emptyset", "\\varnothing", "\\cap", "\\cup", "\\in", "\\notin", "\\subset", "\\supset", "\\subseteq", "\\supseteq", "\\sqsubseteq"], Ee);
    A("Sets", ["\\setminus", "\\not", "\\ni", "\\sqsupseteq", "\\nsupseteqq", "\\supsetneq", "\\varsupsetneq", "\\supsetneqq", "\\varsupsetneqq"], de);
    A("Sets", ["\\smallsetminus", "\\complement", "\\owns", "\\subsetneq", "\\varsubsetneq", "\\subsetneqq", "\\varsubsetneqq", "\\nsubset", "\\nsupset", "\\nsubseteq", "\\nsupseteq", "\\nsubseteqq", "\\subseteqq", "\\Subset", "\\sqsubset", "\\supseteqq", "\\Supset", "\\sqsupset"], D);
    A("Spacing", ["\\space", "\\quad", "\\qquad"], de, '\\unicode{"203A}$0\\unicode{"2039}');
    A("Spacing", ["\\!", "\\,", "\\:", "\\;", "\\enskip", "\\enspace"], D, '\\unicode{"203A}$0\\unicode{"2039}');
    A("Spacing", ["\\hspace", "\\hspace*"], D, '\\unicode{"203A}$0{1em}\\unicode{"2039}');
    A("Punctuation", ["\\colon", "\\cdotp", "\\ldots", "\\cdots", "\\ddots", "\\vdots", "?", "!", ":", '"', ",", ".", ";"], de);
    A("Punctuation", ["\\mathellipsis", "\\ldotp", "\\Colon"], D);
    A("Boxes", ["\\square", "\\Box"], de);
    A("Boxes", ["\\blacksquare", "\\boxminus", "\\boxplus", "\\boxtimes", "\\boxdot"], D);
    A("Circles", ["\\circ", "\\bullet", "\\circleddash", "\\oplus", "\\otimes"], de);
    A("Circles", ["\\bigcirc", "\\circledast", "\\ominus", "\\circledcirc", "\\oslash", "\\circledS", "\\circledR", "\\odot"], D);
    A("Triangles", ["\\triangle", "\\triangleq"], de);
    A("Triangles", ["\\bigtriangleup", "\\vartriangle", "\\triangledown", "\\bigtriangledown", "\\triangleleft", "\\vartriangleleft", "\\trianglelefteq", "\\ntriangleleft", "\\ntrianglelefteq", "\\triangleright", "\\vartriangleright", "\\trianglerighteq", "\\ntriangleright", "\\ntrianglerighteq", "\\blacktriangle", "\\blacktriangledown", "\\blacktriangleleft", "\\blacktriangleright"], D);
    A("Shapes", ["\\ast", "\\star"], de);
    A("Shapes", ["\\diamond", "\\Diamond", "\\lozenge", "\\blacklozenge", "\\bigstar"], D);
    function ul(r) {
      var i;
      window.mathVirtualKeyboard.show(), Er(), ai();
      let e = (i = qe.singleton) == null ? void 0 : i.element.querySelectorAll(".MLK__layer"), t = false;
      for (let o of e)
        if (o.dataset.layer === r) {
          t = true;
          break;
        }
      if (t)
        for (let o of e)
          o.dataset.layer === r ? o.classList.add("is-visible") : o.classList.remove("is-visible");
      return qe.singleton.focus(), true;
    }
    function Wu() {
      var e;
      let r = (e = qe.singleton) == null ? void 0 : e.element.querySelectorAll(".MLK__layer.is-visible .MLK__keycap, .MLK__layer.is-visible .action");
      if (r)
        for (let t of r) {
          if (t.dataset.unshiftedContent)
            return false;
          let i = t.getAttribute("data-shifted");
          if (i || /^[a-z]$/.test(t.innerHTML)) {
            t.dataset.unshiftedContent = t.innerHTML, i || (i = t.innerHTML.toUpperCase()), t.innerHTML = window.MathfieldElement.createHTML(i);
            let o = t.getAttribute("data-command");
            if (o) {
              t.dataset.unshiftedCommand = o;
              let a = t.getAttribute("data-shifted-command");
              if (a)
                t.dataset.command = a;
              else {
                let n = JSON.parse(o);
                Y(n) && (n[1] = n[1].toUpperCase()), t.dataset.command = JSON.stringify(n);
              }
            }
          }
        }
      return false;
    }
    he({ shiftKeyboardLayer: Wu }, { target: "virtual-keyboard" });
    function Uu(r) {
      return Er(), window.mathVirtualKeyboard.executeCommand(r);
    }
    function ju(r) {
      return window.mathVirtualKeyboard.executeCommand(["insert", r]), ai(), true;
    }
    he({ performVariant: Uu, switchKeyboardLayer: (r) => ul(r), unshiftKeyboardLayer: () => ai(), insertAndUnshiftKeyboardLayer: ju }, { target: "virtual-keyboard" });
    function Xu() {
      var t, i, o;
      let r = qe.singleton;
      r.alphabeticLayout = { qwerty: "azerty", azerty: "qwertz", qwertz: "dvorak", dvorak: "colemak", colemak: "qwerty" }[r.alphabeticLayout];
      let e = (o = (i = (t = r == null ? void 0 : r.element) == null ? void 0 : t.querySelector(".MLK__layer.is-visible")) == null ? void 0 : i.id) != null ? o : "";
      return r.show(), e && ul(e), false;
    }
    he({ toggleVirtualKeyboardShift: Xu }, { target: "virtual-keyboard" });
    function Zu() {
      let r = window.mathVirtualKeyboard;
      return r.visible ? r.hide() : r.show(), false;
    }
    he({ toggleVirtualKeyboard: Zu, hideVirtualKeyboard: () => (window.mathVirtualKeyboard.hide(), false), showVirtualKeyboard: () => (window.mathVirtualKeyboard.show(), false) }, { target: "virtual-keyboard" });
    function bt() {
      var r;
      return globalThis[r = Symbol.for("io.cortexjs.mathlive")] != null || (globalThis[r] = {}), globalThis[Symbol.for("io.cortexjs.mathlive")];
    }
    function Yu() {
      return console.warn("%cMathLive 0.90.9: %cmakeSharedVirtualKeyboard() is deprecated. \n    Use `window.mathVirtualKeyboard` to access the virtual keyboard instance.\n    See https://cortexjs.io/mathlive/changelog/ for details.", "color:#12b; font-size: 1.1rem", "color:#db1111; font-size: 1.1rem"), window.mathVirtualKeyboard;
    }
    function Qu(r) {
      dl(document.body, r);
    }
    function ed(r) {
      if (typeof r == "string") {
        let e = document.getElementById(r);
        if (e === null)
          throw new Error(`The element with ID "${r}" could not be found.`);
        return e;
      }
      return typeof r == "string" ? null : r;
    }
    function dl(r, e) {
      let t = ed(r);
      if (!t)
        return;
      let i = e != null ? e : {};
      i.renderToMarkup != null || (i.renderToMarkup = an), i.renderToMathML != null || (i.renderToMathML = nn), i.renderToSpeakableText != null || (i.renderToSpeakableText = sn), i.serializeToLatex != null || (i.serializeToLatex = ln), cn(t, i);
    }
    var td = { mathlive: "0.90.9" }, rd = { FUNCTIONS: zr.FUNCTIONS, MATH_SYMBOLS: zr.MATH_SYMBOLS, TEXT_SYMBOLS: zr.TEXT_SYMBOLS, ENVIRONMENTS: zr.ENVIRONMENTS, DEFAULT_KEYBINDINGS: zr.DEFAULT_KEYBINDINGS, getKeybindingMarkup: zr.getKeybindingMarkup };
    return xl(id);
  })();
  Object.assign(exports2, MathLive);
  Object.defineProperty(exports2, "__esModule", { value: true });
});
class CardPlugin extends siyuan.Plugin {
  constructor() {
    initMathLive();
    super();
    __publicField(this, "el");
    __publicField(this, "sheet");
    __publicField(this, "settingConfig");
    this.el = document.createElement("div");
    this.el.classList.add("toolbar__item", "b3-tooltips", "b3-tooltips__se");
    this.el.setAttribute("aria-label", "右键打开菜单");
    this.sheet = document.createElement("div");
    this.settingConfig = null;
  }
  async onload() {
    let localConfig = await this.loadStorage("enhanceConfig.json");
    this.settingConfig = await getSetting(localConfig);
    console.log("数学增强当前配置：\n", settingList.getSetting());
    const AppSheet = createApp(_sfc_main, this.settingConfig);
    AppSheet.mount(this.sheet);
    let base = document.querySelector("head");
    base == null ? void 0 : base.appendChild(this.sheet);
    watch(settingList.setList, () => {
      this.writeConfig();
    });
  }
  async onunload() {
    this.el && this.el.remove();
    this.sheet && this.sheet.remove();
    removeMathLive();
    this.writeConfig();
  }
  async writeConfig() {
    let configText = JSON.stringify(settingList.getSetting());
    await this.writeStorage("enhanceConfig.json", configText);
  }
}
module.exports = CardPlugin;
